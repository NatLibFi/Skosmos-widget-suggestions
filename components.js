/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9669:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(1609);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY2OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQ0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzP2JjM2EiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9669\n");

/***/ }),

/***/ 5448:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar settle = __webpack_require__(6026);\nvar cookies = __webpack_require__(4372);\nvar buildURL = __webpack_require__(5327);\nvar buildFullPath = __webpack_require__(4097);\nvar parseHeaders = __webpack_require__(4109);\nvar isURLSameOrigin = __webpack_require__(7985);\nvar createError = __webpack_require__(5061);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ0OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsSUFBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLElBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxJQUF1QjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUF1QjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxJQUEyQjtBQUN0RCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUE4QjtBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFxQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz9iNTBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG4gICAgdmFyIHJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgY29uZmlnLnRyYW5zaXRpb25hbCAmJiBjb25maWcudHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyAnRVRJTUVET1VUJyA6ICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdERhdGEpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5448\n");

/***/ }),

/***/ 1609:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar bind = __webpack_require__(1849);\nvar Axios = __webpack_require__(321);\nvar mergeConfig = __webpack_require__(7185);\nvar defaults = __webpack_require__(5655);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(5263);\naxios.CancelToken = __webpack_require__(4972);\naxios.isCancel = __webpack_require__(6502);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(8713);\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(6268);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsSUFBZ0I7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLEdBQWM7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsSUFBb0I7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLElBQVk7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLElBQWlCO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLElBQXNCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLElBQW1COztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxJQUFrQjs7QUFFekM7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxJQUF3Qjs7QUFFckQ7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcz9jZWU0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1609\n");

/***/ }),

/***/ 5263:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI2My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzPzdhNzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5263\n");

/***/ }),

/***/ 4972:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(5263);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsSUFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzPzhkZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4972\n");

/***/ }),

/***/ 6502:
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/MmU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6502\n");

/***/ }),

/***/ 321:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar buildURL = __webpack_require__(5327);\nvar InterceptorManager = __webpack_require__(782);\nvar dispatchRequest = __webpack_require__(3572);\nvar mergeConfig = __webpack_require__(7185);\nvar validator = __webpack_require__(4875);\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxJQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyxJQUFxQjtBQUM1Qyx5QkFBeUIsbUJBQU8sQ0FBQyxHQUFzQjtBQUN2RCxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFlO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLElBQXNCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcz8wYTA2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcbnZhciB2YWxpZGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ZhbGlkYXRvcicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///321\n");

/***/ }),

/***/ 782:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxJQUFZOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP2Y2YjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcbiAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICBydW5XaGVuOiBvcHRpb25zID8gb3B0aW9ucy5ydW5XaGVuIDogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///782\n");

/***/ }),

/***/ 4097:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(1793);\nvar combineURLs = __webpack_require__(7303);\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA5Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxJQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzPzgzYjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4097\n");

/***/ }),

/***/ 5061:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(481);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA2MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxHQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/MmQ4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5061\n");

/***/ }),

/***/ 3572:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar transformData = __webpack_require__(8527);\nvar isCancel = __webpack_require__(6502);\nvar defaults = __webpack_require__(5655);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFpQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsSUFBb0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLElBQWE7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcz81MjcwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3572\n");

/***/ }),

/***/ 481:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzPzM4N2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///481\n");

/***/ }),

/***/ 7185:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE4NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanM/NGE3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7185\n");

/***/ }),

/***/ 6026:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(5061);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAyNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxJQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzPzQ2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6026\n");

/***/ }),

/***/ 8527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar defaults = __webpack_require__(5655);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUyNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTtBQUNoQyxlQUFlLG1CQUFPLENBQUMsSUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixXQUFXLGdCQUFnQjtBQUMzQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzP2M0MDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8527\n");

/***/ }),

/***/ 5655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\nvar normalizeHeaderName = __webpack_require__(6016);\nvar enhanceError = __webpack_require__(481);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(5448);\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(5448);\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY1NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBUztBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQyxJQUErQjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxHQUFxQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsSUFBZ0I7QUFDdEMsSUFBSTtBQUNKO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLElBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanM/MjQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHtcbiAgICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxuICB9LFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgKGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPT09ICdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5655\n");

/***/ }),

/***/ 1849:
/***/ (function(module) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanM/MWQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1849\n");

/***/ }),

/***/ 5327:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMyNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcz8zMGI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5327\n");

/***/ }),

/***/ 7303:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMwMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzP2U2ODMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7303\n");

/***/ }),

/***/ 4372:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQyxTQUFTOztBQUVUO0FBQ0EsNERBQTRELHdCQUF3QjtBQUNwRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzPzdhYWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4372\n");

/***/ }),

/***/ 1793:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc5My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzP2Q5MjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1793\n");

/***/ }),

/***/ 6268:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI2OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcz81ZjAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6268\n");

/***/ }),

/***/ 7985:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk4NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcz8zOTM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7985\n");

/***/ }),

/***/ 6016:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAxNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzP2M4YWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6016\n");

/***/ }),

/***/ 4109:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(4867);\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsSUFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2MzNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4109\n");

/***/ }),

/***/ 8713:
/***/ (function(module) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzPzBkZjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8713\n");

/***/ }),

/***/ 4875:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar pkg = __webpack_require__(8593);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsSUFBc0I7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanM/ODQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBwa2cgPSByZXF1aXJlKCcuLy4uLy4uL3BhY2thZ2UuanNvbicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goZnVuY3Rpb24odHlwZSwgaSkge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxudmFyIGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xudmFyIGN1cnJlbnRWZXJBcnIgPSBwa2cudmVyc2lvbi5zcGxpdCgnLicpO1xuXG4vKipcbiAqIENvbXBhcmUgcGFja2FnZSB2ZXJzaW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gdGhhblZlcnNpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uLCB0aGFuVmVyc2lvbikge1xuICB2YXIgcGtnVmVyc2lvbkFyciA9IHRoYW5WZXJzaW9uID8gdGhhblZlcnNpb24uc3BsaXQoJy4nKSA6IGN1cnJlbnRWZXJBcnI7XG4gIHZhciBkZXN0VmVyID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGlmIChwa2dWZXJzaW9uQXJyW2ldID4gZGVzdFZlcltpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwa2dWZXJzaW9uQXJyW2ldIDwgZGVzdFZlcltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvclxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgdmFyIGlzRGVwcmVjYXRlZCA9IHZlcnNpb24gJiYgaXNPbGRlclZlcnNpb24odmVyc2lvbik7XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIHBrZy52ZXJzaW9uICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkIGluICcgKyB2ZXJzaW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVwcmVjYXRlZCAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgdmFyIG9wdCA9IGtleXNbaV07XG4gICAgdmFyIHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPbGRlclZlcnNpb246IGlzT2xkZXJWZXJzaW9uLFxuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4875\n");

/***/ }),

/***/ 4867:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(1849);\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcz9jNTMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbnRlbnQgdmFsdWUgd2l0aG91dCBCT01cbiAqL1xuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xuICBpZiAoY29udGVudC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW0sXG4gIHN0cmlwQk9NOiBzdHJpcEJPTVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4867\n");

/***/ }),

/***/ 5800:
/***/ (function(__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {

"use strict";
eval("\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction shared_esm_bundler_makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ shared_esm_bundler_makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(specialBooleanAttrs)));\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ shared_esm_bundler_makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nfunction includeBooleanAttr(value) {\r\n    return !!value || value === '';\r\n}\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`)));\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownHtmlAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`)));\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nconst isKnownSvgAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));\n\nfunction normalizeStyle(value) {\r\n    if (shared_esm_bundler_isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = shared_esm_bundler_isString(item)\r\n                ? parseStringStyle(item)\r\n                : normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (shared_esm_bundler_isString(value)) {\r\n        return value;\r\n    }\r\n    else if (shared_esm_bundler_isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles || shared_esm_bundler_isString(styles)) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : shared_esm_bundler_hyphenate(key);\r\n        if (shared_esm_bundler_isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (shared_esm_bundler_isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (shared_esm_bundler_isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (shared_esm_bundler_isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nfunction normalizeProps(props) {\r\n    if (!props)\r\n        return null;\r\n    let { class: klass, style } = props;\r\n    if (klass && !shared_esm_bundler_isString(klass)) {\r\n        props.class = normalizeClass(klass);\r\n    }\r\n    if (style) {\r\n        props.style = normalizeStyle(style);\r\n    }\r\n    return props;\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot'));\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view'));\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst shared_esm_bundler_isHTMLTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(HTML_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst shared_esm_bundler_isSVGTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(SVG_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isVoidTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap(VOID_TAGS)));\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.slice(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = shared_esm_bundler_looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction shared_esm_bundler_looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isSymbol(a);\r\n    bValidType = isSymbol(b);\r\n    if (aValidType || bValidType) {\r\n        return a === b;\r\n    }\r\n    aValidType = shared_esm_bundler_isArray(a);\r\n    bValidType = shared_esm_bundler_isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = shared_esm_bundler_isObject(a);\r\n    bValidType = shared_esm_bundler_isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !shared_esm_bundler_looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction shared_esm_bundler_looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => shared_esm_bundler_looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return shared_esm_bundler_isString(val)\r\n        ? val\r\n        : val == null\r\n            ? ''\r\n            : shared_esm_bundler_isArray(val) ||\r\n                (shared_esm_bundler_isObject(val) &&\r\n                    (val.toString === objectToString || !shared_esm_bundler_isFunction(val.toString)))\r\n                ? JSON.stringify(val, replacer, 2)\r\n                : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    // can't use isRef here since @vue/shared has no deps\r\n    if (val && val.__v_isRef) {\r\n        return replacer(_key, val.value);\r\n    }\r\n    else if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (shared_esm_bundler_isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (shared_esm_bundler_isObject(val) && !shared_esm_bundler_isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\nconst shared_esm_bundler_EMPTY_OBJ = ( false)\r\n    ? 0\r\n    : {};\r\nconst EMPTY_ARR = ( false) ? 0 : [];\r\nconst shared_esm_bundler_NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst shared_esm_bundler_NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst shared_esm_bundler_isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst shared_esm_bundler_extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst shared_esm_bundler_hasOwn = (val, key) => shared_esm_bundler_hasOwnProperty.call(val, key);\r\nconst shared_esm_bundler_isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst shared_esm_bundler_isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => toTypeString(val) === '[object Date]';\r\nconst shared_esm_bundler_isFunction = (val) => typeof val === 'function';\r\nconst shared_esm_bundler_isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst shared_esm_bundler_isObject = (val) => val !== null && typeof val === 'object';\r\nconst shared_esm_bundler_isPromise = (val) => {\r\n    return shared_esm_bundler_isObject(val) && shared_esm_bundler_isFunction(val.then) && shared_esm_bundler_isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst shared_esm_bundler_toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => shared_esm_bundler_isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst shared_esm_bundler_isReservedProp = /*#__PURE__*/ shared_esm_bundler_makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst shared_esm_bundler_isBuiltInDirective = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_esm_bundler_makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst shared_esm_bundler_hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst shared_esm_bundler_capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst shared_esm_bundler_toHandlerKey = cacheStringFunction((str) => str ? `on${shared_esm_bundler_capitalize(str)}` : ``);\r\n// compare whether a value has changed, accounting for NaN.\r\nconst shared_esm_bundler_hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst shared_esm_bundler_toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof __webpack_require__.g !== 'undefined'\r\n                            ? __webpack_require__.g\r\n                            : {}));\r\n};\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\r\nfunction genPropsAccessExp(name) {\r\n    return identRE.test(name)\r\n        ? `__props.${name}`\r\n        : `__props[${JSON.stringify(name)}]`;\r\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/reactivity/node_modules/@vue/shared/dist/shared.esm-bundler.js\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction dist_shared_esm_bundler_makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst shared_esm_bundler_PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst shared_esm_bundler_slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst shared_esm_bundler_GLOBALS_WHITE_LISTED = (/* unused pure expression or super */ null && ('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'));\r\nconst shared_esm_bundler_isGloballyWhitelisted = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(shared_esm_bundler_GLOBALS_WHITE_LISTED)));\n\nconst shared_esm_bundler_range = 2;\r\nfunction shared_esm_bundler_generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - shared_esm_bundler_range; j <= i + shared_esm_bundler_range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst shared_esm_bundler_specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst shared_esm_bundler_isSpecialBooleanAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(shared_esm_bundler_specialBooleanAttrs)));\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst shared_esm_bundler_isBooleanAttr = /*#__PURE__*/ dist_shared_esm_bundler_makeMap(shared_esm_bundler_specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nfunction shared_esm_bundler_includeBooleanAttr(value) {\r\n    return !!value || value === '';\r\n}\r\nconst shared_esm_bundler_unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst shared_esm_bundler_attrValidationCache = {};\r\nfunction shared_esm_bundler_isSSRSafeAttrName(name) {\r\n    if (shared_esm_bundler_attrValidationCache.hasOwnProperty(name)) {\r\n        return shared_esm_bundler_attrValidationCache[name];\r\n    }\r\n    const isUnsafe = shared_esm_bundler_unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (shared_esm_bundler_attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst shared_esm_bundler_propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst shared_esm_bundler_isNoUnitNumericStyleProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`)));\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst shared_esm_bundler_isKnownHtmlAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`)));\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nconst shared_esm_bundler_isKnownSvgAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));\n\nfunction shared_esm_bundler_normalizeStyle(value) {\r\n    if (dist_shared_esm_bundler_isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = dist_shared_esm_bundler_isString(item)\r\n                ? shared_esm_bundler_parseStringStyle(item)\r\n                : shared_esm_bundler_normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (dist_shared_esm_bundler_isString(value)) {\r\n        return value;\r\n    }\r\n    else if (dist_shared_esm_bundler_isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst shared_esm_bundler_listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst shared_esm_bundler_propertyDelimiterRE = /:(.+)/;\r\nfunction shared_esm_bundler_parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(shared_esm_bundler_listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(shared_esm_bundler_propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction shared_esm_bundler_stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles || dist_shared_esm_bundler_isString(styles)) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : dist_shared_esm_bundler_hyphenate(key);\r\n        if (dist_shared_esm_bundler_isString(value) ||\r\n            (typeof value === 'number' && shared_esm_bundler_isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction shared_esm_bundler_normalizeClass(value) {\r\n    let res = '';\r\n    if (dist_shared_esm_bundler_isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (dist_shared_esm_bundler_isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = shared_esm_bundler_normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (dist_shared_esm_bundler_isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nfunction shared_esm_bundler_normalizeProps(props) {\r\n    if (!props)\r\n        return null;\r\n    let { class: klass, style } = props;\r\n    if (klass && !dist_shared_esm_bundler_isString(klass)) {\r\n        props.class = shared_esm_bundler_normalizeClass(klass);\r\n    }\r\n    if (style) {\r\n        props.style = shared_esm_bundler_normalizeStyle(style);\r\n    }\r\n    return props;\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst shared_esm_bundler_HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot'));\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst shared_esm_bundler_SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view'));\r\nconst shared_esm_bundler_VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst dist_shared_esm_bundler_isHTMLTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(shared_esm_bundler_HTML_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst dist_shared_esm_bundler_isSVGTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(shared_esm_bundler_SVG_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst shared_esm_bundler_isVoidTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(shared_esm_bundler_VOID_TAGS)));\n\nconst shared_esm_bundler_escapeRE = /[\"'&<>]/;\r\nfunction shared_esm_bundler_escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = shared_esm_bundler_escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.slice(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst shared_esm_bundler_commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction shared_esm_bundler_escapeHtmlComment(src) {\r\n    return src.replace(shared_esm_bundler_commentStripRE, '');\r\n}\n\nfunction shared_esm_bundler_looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = dist_shared_esm_bundler_looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction dist_shared_esm_bundler_looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = shared_esm_bundler_isDate(a);\r\n    let bValidType = shared_esm_bundler_isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = shared_esm_bundler_isSymbol(a);\r\n    bValidType = shared_esm_bundler_isSymbol(b);\r\n    if (aValidType || bValidType) {\r\n        return a === b;\r\n    }\r\n    aValidType = dist_shared_esm_bundler_isArray(a);\r\n    bValidType = dist_shared_esm_bundler_isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? shared_esm_bundler_looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = dist_shared_esm_bundler_isObject(a);\r\n    bValidType = dist_shared_esm_bundler_isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !dist_shared_esm_bundler_looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction dist_shared_esm_bundler_looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => dist_shared_esm_bundler_looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst shared_esm_bundler_toDisplayString = (val) => {\r\n    return dist_shared_esm_bundler_isString(val)\r\n        ? val\r\n        : val == null\r\n            ? ''\r\n            : dist_shared_esm_bundler_isArray(val) ||\r\n                (dist_shared_esm_bundler_isObject(val) &&\r\n                    (val.toString === shared_esm_bundler_objectToString || !dist_shared_esm_bundler_isFunction(val.toString)))\r\n                ? JSON.stringify(val, shared_esm_bundler_replacer, 2)\r\n                : String(val);\r\n};\r\nconst shared_esm_bundler_replacer = (_key, val) => {\r\n    // can't use isRef here since @vue/shared has no deps\r\n    if (val && val.__v_isRef) {\r\n        return shared_esm_bundler_replacer(_key, val.value);\r\n    }\r\n    else if (shared_esm_bundler_isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (dist_shared_esm_bundler_isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (dist_shared_esm_bundler_isObject(val) && !dist_shared_esm_bundler_isArray(val) && !shared_esm_bundler_isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\nconst dist_shared_esm_bundler_EMPTY_OBJ = ( false)\r\n    ? 0\r\n    : {};\r\nconst shared_esm_bundler_EMPTY_ARR = ( false) ? 0 : [];\r\nconst dist_shared_esm_bundler_NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst dist_shared_esm_bundler_NO = () => false;\r\nconst shared_esm_bundler_onRE = /^on[^a-z]/;\r\nconst dist_shared_esm_bundler_isOn = (key) => shared_esm_bundler_onRE.test(key);\r\nconst shared_esm_bundler_isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst dist_shared_esm_bundler_extend = Object.assign;\r\nconst shared_esm_bundler_remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst dist_shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst dist_shared_esm_bundler_hasOwn = (val, key) => dist_shared_esm_bundler_hasOwnProperty.call(val, key);\r\nconst dist_shared_esm_bundler_isArray = Array.isArray;\r\nconst shared_esm_bundler_isMap = (val) => shared_esm_bundler_toTypeString(val) === '[object Map]';\r\nconst dist_shared_esm_bundler_isSet = (val) => shared_esm_bundler_toTypeString(val) === '[object Set]';\r\nconst shared_esm_bundler_isDate = (val) => shared_esm_bundler_toTypeString(val) === '[object Date]';\r\nconst dist_shared_esm_bundler_isFunction = (val) => typeof val === 'function';\r\nconst dist_shared_esm_bundler_isString = (val) => typeof val === 'string';\r\nconst shared_esm_bundler_isSymbol = (val) => typeof val === 'symbol';\r\nconst dist_shared_esm_bundler_isObject = (val) => val !== null && typeof val === 'object';\r\nconst dist_shared_esm_bundler_isPromise = (val) => {\r\n    return dist_shared_esm_bundler_isObject(val) && dist_shared_esm_bundler_isFunction(val.then) && dist_shared_esm_bundler_isFunction(val.catch);\r\n};\r\nconst shared_esm_bundler_objectToString = Object.prototype.toString;\r\nconst shared_esm_bundler_toTypeString = (value) => shared_esm_bundler_objectToString.call(value);\r\nconst dist_shared_esm_bundler_toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return shared_esm_bundler_toTypeString(value).slice(8, -1);\r\n};\r\nconst shared_esm_bundler_isPlainObject = (val) => shared_esm_bundler_toTypeString(val) === '[object Object]';\r\nconst shared_esm_bundler_isIntegerKey = (key) => dist_shared_esm_bundler_isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst dist_shared_esm_bundler_isReservedProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted')));\r\nconst dist_shared_esm_bundler_isBuiltInDirective = /*#__PURE__*/ (/* unused pure expression or super */ null && (dist_shared_esm_bundler_makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));\r\nconst shared_esm_bundler_cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst shared_esm_bundler_camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst shared_esm_bundler_camelize = shared_esm_bundler_cacheStringFunction((str) => {\r\n    return str.replace(shared_esm_bundler_camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst shared_esm_bundler_hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst dist_shared_esm_bundler_hyphenate = shared_esm_bundler_cacheStringFunction((str) => str.replace(shared_esm_bundler_hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst dist_shared_esm_bundler_capitalize = shared_esm_bundler_cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst dist_shared_esm_bundler_toHandlerKey = shared_esm_bundler_cacheStringFunction((str) => str ? `on${dist_shared_esm_bundler_capitalize(str)}` : ``);\r\n// compare whether a value has changed, accounting for NaN.\r\nconst dist_shared_esm_bundler_hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst shared_esm_bundler_invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst shared_esm_bundler_def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst dist_shared_esm_bundler_toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet shared_esm_bundler_globalThis;\r\nconst shared_esm_bundler_getGlobalThis = () => {\r\n    return (shared_esm_bundler_globalThis ||\r\n        (shared_esm_bundler_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof __webpack_require__.g !== 'undefined'\r\n                            ? __webpack_require__.g\r\n                            : {}));\r\n};\r\nconst shared_esm_bundler_identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\r\nfunction shared_esm_bundler_genPropsAccessExp(name) {\r\n    return shared_esm_bundler_identRE.test(name)\r\n        ? `__props.${name}`\r\n        : `__props[${JSON.stringify(name)}]`;\r\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n\n\nfunction reactivity_esm_bundler_warn(msg, ...args) {\r\n    console.warn(`[Vue warn] ${msg}`, ...args);\r\n}\n\nlet activeEffectScope;\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            const currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    on() {\r\n        activeEffectScope = this;\r\n    }\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    off() {\r\n        activeEffectScope = this.parent;\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            let i, l;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].stop();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\nfunction recordEffectScope(effect, scope = activeEffectScope) {\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if ((false)) {}\r\n}\n\nconst createDep = (effects) => {\r\n    const dep = new Set(effects);\r\n    dep.w = 0;\r\n    dep.n = 0;\r\n    return dep;\r\n};\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n\nconst targetMap = new WeakMap();\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol(( false) ? 0 : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol(( false) ? 0 : '');\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        this.parent = undefined;\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        let parent = activeEffect;\r\n        let lastShouldTrack = shouldTrack;\r\n        while (parent) {\r\n            if (parent === this) {\r\n                return;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        try {\r\n            this.parent = activeEffect;\r\n            activeEffect = this;\r\n            shouldTrack = true;\r\n            trackOpBit = 1 << ++effectTrackDepth;\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                initDepMarkers(this);\r\n            }\r\n            else {\r\n                cleanupEffect(this);\r\n            }\r\n            return this.fn();\r\n        }\r\n        finally {\r\n            if (effectTrackDepth <= maxMarkerBits) {\r\n                finalizeDepMarkers(this);\r\n            }\r\n            trackOpBit = 1 << --effectTrackDepth;\r\n            activeEffect = this.parent;\r\n            shouldTrack = lastShouldTrack;\r\n            this.parent = undefined;\r\n            if (this.deferStop) {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        // stopped while running itself - defer the cleanup\r\n        if (activeEffect === this) {\r\n            this.deferStop = true;\r\n        }\r\n        else if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nfunction effect(fn, options) {\r\n    if (fn.effect) {\r\n        fn = fn.effect.fn;\r\n    }\r\n    const _effect = new ReactiveEffect(fn);\r\n    if (options) {\r\n        extend(_effect, options);\r\n        if (options.scope)\r\n            recordEffectScope(_effect, options.scope);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run();\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nfunction stop(runner) {\r\n    runner.effect.stop();\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (shouldTrack && activeEffect) {\r\n        let depsMap = targetMap.get(target);\r\n        if (!depsMap) {\r\n            targetMap.set(target, (depsMap = new Map()));\r\n        }\r\n        let dep = depsMap.get(key);\r\n        if (!dep) {\r\n            depsMap.set(key, (dep = createDep()));\r\n        }\r\n        const eventInfo = ( false)\r\n            ? 0\r\n            : undefined;\r\n        trackEffects(dep, eventInfo);\r\n    }\r\n}\r\nfunction trackEffects(dep, debuggerEventExtraInfo) {\r\n    let shouldTrack = false;\r\n    if (effectTrackDepth <= maxMarkerBits) {\r\n        if (!newTracked(dep)) {\r\n            dep.n |= trackOpBit; // set newly tracked\r\n            shouldTrack = !wasTracked(dep);\r\n        }\r\n    }\r\n    else {\r\n        // Full cleanup mode.\r\n        shouldTrack = !dep.has(activeEffect);\r\n    }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if (false) {}\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    let deps = [];\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        deps = [...depsMap.values()];\r\n    }\r\n    else if (key === 'length' && dist_shared_esm_bundler_isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!dist_shared_esm_bundler_isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (shared_esm_bundler_isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (shared_esm_bundler_isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!dist_shared_esm_bundler_isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (shared_esm_bundler_isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (shared_esm_bundler_isMap(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const eventInfo = ( false)\r\n        ? 0\r\n        : undefined;\r\n    if (deps.length === 1) {\r\n        if (deps[0]) {\r\n            if ((false)) {}\r\n            else {\r\n                triggerEffects(deps[0]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const effects = [];\r\n        for (const dep of deps) {\r\n            if (dep) {\r\n                effects.push(...dep);\r\n            }\r\n        }\r\n        if ((false)) {}\r\n        else {\r\n            triggerEffects(createDep(effects));\r\n        }\r\n    }\r\n}\r\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\r\n    // spread into array for stabilization\r\n    const effects = dist_shared_esm_bundler_isArray(dep) ? dep : [...dep];\r\n    for (const effect of effects) {\r\n        if (effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n    for (const effect of effects) {\r\n        if (!effect.computed) {\r\n            triggerEffect(effect, debuggerEventExtraInfo);\r\n        }\r\n    }\r\n}\r\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\r\n    if (effect !== activeEffect || effect.allowRecurse) {\r\n        if (false) {}\r\n        if (effect.scheduler) {\r\n            effect.scheduler();\r\n        }\r\n        else {\r\n            effect.run();\r\n        }\r\n    }\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ dist_shared_esm_bundler_makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(\r\n/*#__PURE__*/\r\nObject.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => Symbol[key])\r\n    .filter(shared_esm_bundler_isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = reactivity_esm_bundler_toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(reactivity_esm_bundler_toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = reactivity_esm_bundler_toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_isShallow\" /* IS_SHALLOW */) {\r\n            return shallow;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = dist_shared_esm_bundler_isArray(target);\r\n        if (!isReadonly && targetIsArray && dist_shared_esm_bundler_hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (shared_esm_bundler_isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (reactivity_esm_bundler_isRef(res)) {\r\n            // ref unwrapping - skip unwrap for Array + integer key.\r\n            return targetIsArray && shared_esm_bundler_isIntegerKey(key) ? res : res.value;\r\n        }\r\n        if (dist_shared_esm_bundler_isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (reactivity_esm_bundler_isReadonly(oldValue) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\r\n            return false;\r\n        }\r\n        if (!shallow && !reactivity_esm_bundler_isReadonly(value)) {\r\n            if (!isShallow(value)) {\r\n                value = reactivity_esm_bundler_toRaw(value);\r\n                oldValue = reactivity_esm_bundler_toRaw(oldValue);\r\n            }\r\n            if (!dist_shared_esm_bundler_isArray(target) && reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = dist_shared_esm_bundler_isArray(target) && shared_esm_bundler_isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : dist_shared_esm_bundler_hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === reactivity_esm_bundler_toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (dist_shared_esm_bundler_hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = dist_shared_esm_bundler_hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!shared_esm_bundler_isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, dist_shared_esm_bundler_isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((false)) {}\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ dist_shared_esm_bundler_extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ dist_shared_esm_bundler_extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = reactivity_esm_bundler_toRaw(target);\r\n    const rawKey = reactivity_esm_bundler_toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"get\" /* GET */, key);\r\n        }\r\n        track(rawTarget, \"get\" /* GET */, rawKey);\r\n    }\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = reactivity_esm_bundler_toRaw(target);\r\n    const rawKey = reactivity_esm_bundler_toRaw(key);\r\n    if (!isReadonly) {\r\n        if (key !== rawKey) {\r\n            track(rawTarget, \"has\" /* HAS */, key);\r\n        }\r\n        track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    }\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(reactivity_esm_bundler_toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = reactivity_esm_bundler_toRaw(value);\r\n    const target = reactivity_esm_bundler_toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = reactivity_esm_bundler_toRaw(value);\r\n    const target = reactivity_esm_bundler_toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = reactivity_esm_bundler_toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (dist_shared_esm_bundler_hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = reactivity_esm_bundler_toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = reactivity_esm_bundler_toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((false)) {}\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = reactivity_esm_bundler_toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = ( false)\r\n        ? 0\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = reactivity_esm_bundler_toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = reactivity_esm_bundler_toRaw(target);\r\n        const targetIsMap = shared_esm_bundler_isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((false)) {}\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(dist_shared_esm_bundler_hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = reactivity_esm_bundler_toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(dist_shared_esm_bundler_toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (reactivity_esm_bundler_isReadonly(target)) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!dist_shared_esm_bundler_isObject(target)) {\r\n        if ((false)) {}\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only specific value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction reactivity_esm_bundler_isReactive(value) {\r\n    if (reactivity_esm_bundler_isReadonly(value)) {\r\n        return reactivity_esm_bundler_isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction reactivity_esm_bundler_isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n}\r\nfunction isProxy(value) {\r\n    return reactivity_esm_bundler_isReactive(value) || reactivity_esm_bundler_isReadonly(value);\r\n}\r\nfunction reactivity_esm_bundler_toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? reactivity_esm_bundler_toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    shared_esm_bundler_def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\r\nconst toReactive = (value) => dist_shared_esm_bundler_isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => dist_shared_esm_bundler_isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\r\n    if (shouldTrack && activeEffect) {\r\n        ref = reactivity_esm_bundler_toRaw(ref);\r\n        if ((false)) {}\r\n        else {\r\n            trackEffects(ref.dep || (ref.dep = createDep()));\r\n        }\r\n    }\r\n}\r\nfunction triggerRefValue(ref, newVal) {\r\n    ref = reactivity_esm_bundler_toRaw(ref);\r\n    if (ref.dep) {\r\n        if ((false)) {}\r\n        else {\r\n            triggerEffects(ref.dep);\r\n        }\r\n    }\r\n}\r\nfunction reactivity_esm_bundler_isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction reactivity_esm_bundler_ref(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (reactivity_esm_bundler_isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nclass RefImpl {\r\n    constructor(value, __v_isShallow) {\r\n        this.__v_isShallow = __v_isShallow;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._rawValue = __v_isShallow ? value : reactivity_esm_bundler_toRaw(value);\r\n        this._value = __v_isShallow ? value : toReactive(value);\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        newVal = this.__v_isShallow ? newVal : reactivity_esm_bundler_toRaw(newVal);\r\n        if (dist_shared_esm_bundler_hasChanged(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this.__v_isShallow ? newVal : toReactive(newVal);\r\n            triggerRefValue(this, newVal);\r\n        }\r\n    }\r\n}\r\nfunction triggerRef(ref) {\r\n    triggerRefValue(ref, ( false) ? 0 : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return reactivity_esm_bundler_isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (reactivity_esm_bundler_isRef(oldValue) && !reactivity_esm_bundler_isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return reactivity_esm_bundler_isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if (false) {}\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key, _defaultValue) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this._defaultValue = _defaultValue;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        const val = this._object[this._key];\r\n        return val === undefined ? this._defaultValue : val;\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    return reactivity_esm_bundler_isRef(val)\r\n        ? val\r\n        : new ObjectRefImpl(object, key, defaultValue);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly, isSSR) {\r\n        this._setter = _setter;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._dirty = true;\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if (!this._dirty) {\r\n                this._dirty = true;\r\n                triggerRefValue(this);\r\n            }\r\n        });\r\n        this.effect.computed = this;\r\n        this.effect.active = this._cacheable = !isSSR;\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = reactivity_esm_bundler_toRaw(this);\r\n        trackRefValue(self);\r\n        if (self._dirty || !self._cacheable) {\r\n            self._dirty = false;\r\n            self._value = self.effect.run();\r\n        }\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = dist_shared_esm_bundler_isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = ( false)\r\n            ? 0\r\n            : dist_shared_esm_bundler_NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\r\n    if (false) {}\r\n    return cRef;\r\n}\n\nvar _a;\r\nconst tick = /*#__PURE__*/ (/* unused pure expression or super */ null && (Promise.resolve()));\r\nconst queue = (/* unused pure expression or super */ null && ([]));\r\nlet queued = false;\r\nconst scheduler = (fn) => {\r\n    queue.push(fn);\r\n    if (!queued) {\r\n        queued = true;\r\n        tick.then(flush);\r\n    }\r\n};\r\nconst flush = () => {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]();\r\n    }\r\n    queue.length = 0;\r\n    queued = false;\r\n};\r\nclass DeferredComputedRefImpl {\r\n    constructor(getter) {\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this[_a] = true;\r\n        let compareTarget;\r\n        let hasCompareTarget = false;\r\n        let scheduled = false;\r\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\r\n            if (this.dep) {\r\n                if (computedTrigger) {\r\n                    compareTarget = this._value;\r\n                    hasCompareTarget = true;\r\n                }\r\n                else if (!scheduled) {\r\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\r\n                    scheduled = true;\r\n                    hasCompareTarget = false;\r\n                    scheduler(() => {\r\n                        if (this.effect.active && this._get() !== valueToCompare) {\r\n                            triggerRefValue(this);\r\n                        }\r\n                        scheduled = false;\r\n                    });\r\n                }\r\n                // chained upstream computeds are notified synchronously to ensure\r\n                // value invalidation in case of sync access; normal effects are\r\n                // deferred to be triggered in scheduler.\r\n                for (const e of this.dep) {\r\n                    if (e.computed instanceof DeferredComputedRefImpl) {\r\n                        e.scheduler(true /* computedTrigger */);\r\n                    }\r\n                }\r\n            }\r\n            this._dirty = true;\r\n        });\r\n        this.effect.computed = this;\r\n    }\r\n    _get() {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n            return (this._value = this.effect.run());\r\n        }\r\n        return this._value;\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        return reactivity_esm_bundler_toRaw(this)._get();\r\n    }\r\n}\r\n_a = \"__v_isReadonly\" /* IS_READONLY */;\r\nfunction deferredComputed(getter) {\r\n    return new DeferredComputedRefImpl(getter);\r\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n\n\n\n\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction runtime_core_esm_bundler_warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (shared_esm_bundler_isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (reactivity_esm_bundler_isRef(value)) {\r\n        value = formatProp(key, reactivity_esm_bundler_toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (shared_esm_bundler_isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = reactivity_esm_bundler_toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"sp\" /* SERVER_PREFETCH */]: 'serverPrefetch hook',\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (shared_esm_bundler_isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && shared_esm_bundler_isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = ( false) ? 0 : type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    if ((false)) {}\r\n    else {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst runtime_core_esm_bundler_queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction runtime_core_esm_bundler_nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = runtime_core_esm_bundler_queue.length;\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(runtime_core_esm_bundler_queue[middle]);\r\n        middleJobId < id ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!runtime_core_esm_bundler_queue.length ||\r\n        !runtime_core_esm_bundler_queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        if (job.id == null) {\r\n            runtime_core_esm_bundler_queue.push(job);\r\n        }\r\n        else {\r\n            runtime_core_esm_bundler_queue.splice(findInsertionIndex(job.id), 0, job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = runtime_core_esm_bundler_queue.indexOf(job);\r\n    if (i > flushIndex) {\r\n        runtime_core_esm_bundler_queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!shared_esm_bundler_isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        if ((false)) {}\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            if (false) {}\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    // flush any pre cbs queued during the flush (e.g. pre watchers)\r\n    flushPreFlushCbs();\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        if ((false)) {}\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            if (false) {}\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    if ((false)) {}\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    runtime_core_esm_bundler_queue.sort((a, b) => getId(a) - getId(b));\r\n    // conditional usage of checkRecursiveUpdate must be determined out of\r\n    // try ... catch block since Rollup by default de-optimizes treeshaking\r\n    // inside try-catch. This can leave all warning code unshaked. Although\r\n    // they would get eventually shaken by a minifier like terser, some minifiers\r\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n    const check = ( false)\r\n        ? 0\r\n        : shared_esm_bundler_NOOP;\r\n    try {\r\n        for (flushIndex = 0; flushIndex < runtime_core_esm_bundler_queue.length; flushIndex++) {\r\n            const job = runtime_core_esm_bundler_queue[flushIndex];\r\n            if (job && job.active !== false) {\r\n                if (false) {}\r\n                // console.log(`running:`, job.id)\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        runtime_core_esm_bundler_queue.length = 0;\r\n        flushPostFlushCbs(seen);\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (runtime_core_esm_bundler_queue.length ||\r\n            pendingPreFlushCbs.length ||\r\n            pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            const instance = fn.ownerInstance;\r\n            const componentName = instance && getComponentName(instance.type);\r\n            runtime_core_esm_bundler_warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n            return true;\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet isHmrUpdating = false;\r\nconst hmrDirtyComponents = new Set();\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif ((false)) {}\r\nconst map = new Map();\r\nfunction registerHMR(instance) {\r\n    const id = instance.type.__hmrId;\r\n    let record = map.get(id);\r\n    if (!record) {\r\n        createRecord(id, instance.type);\r\n        record = map.get(id);\r\n    }\r\n    record.instances.add(instance);\r\n}\r\nfunction unregisterHMR(instance) {\r\n    map.get(instance.type.__hmrId).instances.delete(instance);\r\n}\r\nfunction createRecord(id, initialDef) {\r\n    if (map.has(id)) {\r\n        return false;\r\n    }\r\n    map.set(id, {\r\n        initialDef: normalizeClassComponent(initialDef),\r\n        instances: new Set()\r\n    });\r\n    return true;\r\n}\r\nfunction normalizeClassComponent(component) {\r\n    return isClassComponent(component) ? component.__vccOpts : component;\r\n}\r\nfunction rerender(id, newRender) {\r\n    const record = map.get(id);\r\n    if (!record) {\r\n        return;\r\n    }\r\n    // update initial record (for not-yet-rendered component)\r\n    record.initialDef.render = newRender;\r\n    [...record.instances].forEach(instance => {\r\n        if (newRender) {\r\n            instance.render = newRender;\r\n            normalizeClassComponent(instance.type).render = newRender;\r\n        }\r\n        instance.renderCache = [];\r\n        // this flag forces child components with slot content to update\r\n        isHmrUpdating = true;\r\n        instance.update();\r\n        isHmrUpdating = false;\r\n    });\r\n}\r\nfunction reload(id, newComp) {\r\n    const record = map.get(id);\r\n    if (!record)\r\n        return;\r\n    newComp = normalizeClassComponent(newComp);\r\n    // update initial def (for not-yet-rendered components)\r\n    updateComponentDef(record.initialDef, newComp);\r\n    // create a snapshot which avoids the set being mutated during updates\r\n    const instances = [...record.instances];\r\n    for (const instance of instances) {\r\n        const oldComp = normalizeClassComponent(instance.type);\r\n        if (!hmrDirtyComponents.has(oldComp)) {\r\n            // 1. Update existing comp definition to match new one\r\n            if (oldComp !== record.initialDef) {\r\n                updateComponentDef(oldComp, newComp);\r\n            }\r\n            // 2. mark definition dirty. This forces the renderer to replace the\r\n            // component on patch.\r\n            hmrDirtyComponents.add(oldComp);\r\n        }\r\n        // 3. invalidate options resolution cache\r\n        instance.appContext.optionsCache.delete(instance.type);\r\n        // 4. actually update\r\n        if (instance.ceReload) {\r\n            // custom element\r\n            hmrDirtyComponents.add(oldComp);\r\n            instance.ceReload(newComp.styles);\r\n            hmrDirtyComponents.delete(oldComp);\r\n        }\r\n        else if (instance.parent) {\r\n            // 4. Force the parent instance to re-render. This will cause all updated\r\n            // components to be unmounted and re-mounted. Queue the update so that we\r\n            // don't end up forcing the same parent to re-render multiple times.\r\n            queueJob(instance.parent.update);\r\n            // instance is the inner component of an async custom element\r\n            // invoke to reset styles\r\n            if (instance.parent.type.__asyncLoader &&\r\n                instance.parent.ceReload) {\r\n                instance.parent.ceReload(newComp.styles);\r\n            }\r\n        }\r\n        else if (instance.appContext.reload) {\r\n            // root instance mounted via createApp() has a reload method\r\n            instance.appContext.reload();\r\n        }\r\n        else if (typeof window !== 'undefined') {\r\n            // root instance inside tree created via raw render(). Force reload.\r\n            window.location.reload();\r\n        }\r\n        else {\r\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\r\n        }\r\n    }\r\n    // 5. make sure to cleanup dirty hmr components after update\r\n    queuePostFlushCb(() => {\r\n        for (const instance of instances) {\r\n            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\r\n        }\r\n    });\r\n}\r\nfunction updateComponentDef(oldComp, newComp) {\r\n    extend(oldComp, newComp);\r\n    for (const key in oldComp) {\r\n        if (key !== '__file' && !(key in newComp)) {\r\n            delete oldComp[key];\r\n        }\r\n    }\r\n}\r\nfunction tryWrap(fn) {\r\n    return (id, arg) => {\r\n        try {\r\n            return fn(id, arg);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\r\n                `Full reload required.`);\r\n        }\r\n    };\r\n}\n\nlet devtools;\r\nlet buffer = [];\r\nlet devtoolsNotInstalled = false;\r\nfunction emit(event, ...args) {\r\n    if (devtools) {\r\n        devtools.emit(event, ...args);\r\n    }\r\n    else if (!devtoolsNotInstalled) {\r\n        buffer.push({ event, args });\r\n    }\r\n}\r\nfunction setDevtoolsHook(hook, target) {\r\n    var _a, _b;\r\n    devtools = hook;\r\n    if (devtools) {\r\n        devtools.enabled = true;\r\n        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));\r\n        buffer = [];\r\n    }\r\n    else if (\r\n    // handle late devtools injection - only do this if we are in an actual\r\n    // browser environment to avoid the timer handle stalling test runner exit\r\n    // (#4815)\r\n    typeof window !== 'undefined' &&\r\n        // some envs mock window but not fully\r\n        window.HTMLElement &&\r\n        // also exclude jsdom\r\n        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\r\n        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\r\n            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);\r\n        replay.push((newHook) => {\r\n            setDevtoolsHook(newHook, target);\r\n        });\r\n        // clear buffer after 3s - the user probably doesn't have devtools installed\r\n        // at all, and keeping the buffer will cause memory leaks (#4738)\r\n        setTimeout(() => {\r\n            if (!devtools) {\r\n                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\r\n                devtoolsNotInstalled = true;\r\n                buffer = [];\r\n            }\r\n        }, 3000);\r\n    }\r\n    else {\r\n        // non-browser env, assume not installed\r\n        devtoolsNotInstalled = true;\r\n        buffer = [];\r\n    }\r\n}\r\nfunction devtoolsInitApp(app, version) {\r\n    emit(\"app:init\" /* APP_INIT */, app, version, {\r\n        Fragment: runtime_core_esm_bundler_Fragment,\r\n        Text,\r\n        Comment,\r\n        Static: runtime_core_esm_bundler_Static\r\n    });\r\n}\r\nfunction devtoolsUnmountApp(app) {\r\n    emit(\"app:unmount\" /* APP_UNMOUNT */, app);\r\n}\r\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\"component:added\" /* COMPONENT_ADDED */);\r\nconst devtoolsComponentUpdated = \r\n/*#__PURE__*/ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\r\nconst devtoolsComponentRemoved = \r\n/*#__PURE__*/ createDevtoolsComponentHook(\"component:removed\" /* COMPONENT_REMOVED */);\r\nfunction createDevtoolsComponentHook(hook) {\r\n    return (component) => {\r\n        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\r\n    };\r\n}\r\nconst devtoolsPerfStart = /*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(\"perf:start\" /* PERFORMANCE_START */)));\r\nconst devtoolsPerfEnd = /*#__PURE__*/ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook(\"perf:end\" /* PERFORMANCE_END */)));\r\nfunction createDevtoolsPerformanceHook(hook) {\r\n    return (component, type, time) => {\r\n        emit(hook, component.appContext.app, component.uid, component, type, time);\r\n    };\r\n}\r\nfunction devtoolsComponentEmit(component, event, params) {\r\n    emit(\"component:emit\" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);\r\n}\n\nfunction emit$1(instance, event, ...rawArgs) {\r\n    if (instance.isUnmounted)\r\n        return;\r\n    const props = instance.vnode.props || shared_esm_bundler_EMPTY_OBJ;\r\n    if ((false)) {}\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith('update:');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || shared_esm_bundler_EMPTY_OBJ;\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        if (number) {\r\n            args = rawArgs.map(shared_esm_bundler_toNumber);\r\n        }\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsComponentEmit(instance, event, args);\r\n    }\r\n    if ((false)) {}\r\n    let handlerName;\r\n    let handler = props[(handlerName = shared_esm_bundler_toHandlerKey(event))] ||\r\n        // also try camelCase event handler (#2249)\r\n        props[(handlerName = shared_esm_bundler_toHandlerKey(camelize(event)))];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handler = props[(handlerName = shared_esm_bundler_toHandlerKey(shared_esm_bundler_hyphenate(event)))];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            instance.emitted = {};\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        instance.emitted[handlerName] = true;\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    const cache = appContext.emitsCache;\r\n    const cached = cache.get(comp);\r\n    if (cached !== undefined) {\r\n        return cached;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !shared_esm_bundler_isFunction(comp)) {\r\n        const extendEmits = (raw) => {\r\n            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\r\n            if (normalizedFromExtend) {\r\n                hasExtends = true;\r\n                shared_esm_bundler_extend(normalized, normalizedFromExtend);\r\n            }\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        cache.set(comp, null);\r\n        return null;\r\n    }\r\n    if (shared_esm_bundler_isArray(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        shared_esm_bundler_extend(normalized, raw);\r\n    }\r\n    cache.set(comp, normalized);\r\n    return normalized;\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !shared_esm_bundler_isOn(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, '');\r\n    return (shared_esm_bundler_hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        shared_esm_bundler_hasOwn(options, shared_esm_bundler_hyphenate(key)) ||\r\n        shared_esm_bundler_hasOwn(options, key));\r\n}\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nlet currentScopeId = null;\r\n/**\r\n * Note: rendering calls maybe nested. The function returns the parent rendering\r\n * instance if present, which should be restored after the render is done:\r\n *\r\n * ```js\r\n * const prev = setCurrentRenderingInstance(i)\r\n * // ...render\r\n * setCurrentRenderingInstance(prev)\r\n * ```\r\n */\r\nfunction setCurrentRenderingInstance(instance) {\r\n    const prev = currentRenderingInstance;\r\n    currentRenderingInstance = instance;\r\n    currentScopeId = (instance && instance.type.__scopeId) || null;\r\n    return prev;\r\n}\r\n/**\r\n * Set scope id when creating hoisted vnodes.\r\n * @private compiler helper\r\n */\r\nfunction pushScopeId(id) {\r\n    currentScopeId = id;\r\n}\r\n/**\r\n * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n * API for backwards compat w/ code generated by compilers.\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    currentScopeId = null;\r\n}\r\n/**\r\n * Only for backwards compat\r\n * @private\r\n */\r\nconst withScopeId = (_id) => withCtx;\r\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private compiler helper\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only\r\n) {\r\n    if (!ctx)\r\n        return fn;\r\n    // already normalized\r\n    if (fn._n) {\r\n        return fn;\r\n    }\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we disable block tracking and\r\n        // force bail out when invoking a compiled slot (indicated by the ._d flag).\r\n        // This isn't necessary if rendering a compiled `<slot>`, so we flip the\r\n        // ._d flag off when invoking the wrapped fn inside `renderSlot`.\r\n        if (renderFnWithContext._d) {\r\n            setBlockTracking(-1);\r\n        }\r\n        const prevInstance = setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(prevInstance);\r\n        if (renderFnWithContext._d) {\r\n            setBlockTracking(1);\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentUpdated(ctx);\r\n        }\r\n        return res;\r\n    };\r\n    // mark normalized to avoid duplicated wrapping\r\n    renderFnWithContext._n = true;\r\n    // mark this as compiled by default\r\n    // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n    // rendering flag.\r\n    renderFnWithContext._c = true;\r\n    // disable block tracking by default\r\n    renderFnWithContext._d = true;\r\n    return renderFnWithContext;\r\n}\n\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;\r\n    let result;\r\n    let fallthroughAttrs;\r\n    const prev = setCurrentRenderingInstance(instance);\r\n    if ((false)) {}\r\n    try {\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if (false) {}\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, ( false)\r\n                    ? 0\r\n                    : { attrs, slots, emit })\r\n                : render(props, null /* we know it doesn't need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n    }\r\n    catch (err) {\r\n        blockStack.length = 0;\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = runtime_core_esm_bundler_createVNode(Comment);\r\n    }\r\n    // attr merging\r\n    // in dev mode, comments are preserved, and it's possible for a template\r\n    // to have comments along side the root element which makes it a fragment\r\n    let root = result;\r\n    let setRoot = undefined;\r\n    if (false /* DEV_ROOT_FRAGMENT */) {}\r\n    if (fallthroughAttrs && inheritAttrs !== false) {\r\n        const keys = Object.keys(fallthroughAttrs);\r\n        const { shapeFlag } = root;\r\n        if (keys.length) {\r\n            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {\r\n                if (propsOptions && keys.some(isModelListener)) {\r\n                    // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                    // prop, it indicates this component expects to handle v-model and\r\n                    // it should not fallthrough.\r\n                    // related: #1543, #1643, #1989\r\n                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                }\r\n                root = cloneVNode(root, fallthroughAttrs);\r\n            }\r\n            else if (false) {}\r\n        }\r\n    }\r\n    // inherit directives\r\n    if (vnode.dirs) {\r\n        if (false) {}\r\n        // clone before mutating since the root may be a hoisted vnode\r\n        root = cloneVNode(root);\r\n        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n    }\r\n    // inherit transition data\r\n    if (vnode.transition) {\r\n        if (false) {}\r\n        root.transition = vnode.transition;\r\n    }\r\n    if (false) {}\r\n    else {\r\n        result = root;\r\n    }\r\n    setCurrentRenderingInstance(prev);\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicChildren) {\r\n            if (dynamicIndex > -1) {\r\n                dynamicChildren[dynamicIndex] = updatedRoot;\r\n            }\r\n            else if (updatedRoot.patchFlag > 0) {\r\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n            }\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === 'class' || key === 'style' || shared_esm_bundler_isOn(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!isModelListener(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // Parent component's render function was hot-updated. Since this may have\r\n    // caused the child component's slots content to have changed, we need to\r\n    // force the child to update as well.\r\n    if (false) {}\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag >= 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    name: 'Suspense',\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode's type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary,\r\n    normalize: normalizeSuspenseChildren\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = ((/* unused pure expression or super */ null && (SuspenseImpl)) );\r\nfunction triggerEvent(vnode, name) {\r\n    const eventListener = vnode.props && vnode.props[name];\r\n    if (shared_esm_bundler_isFunction(eventListener)) {\r\n        eventListener();\r\n    }\r\n}\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement('div');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // invoke @fallback event\r\n        triggerEvent(vnode, 'onPending');\r\n        triggerEvent(vnode, 'onFallback');\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG, slotScopeIds);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement('div');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG, slotScopeIds, optimized);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled \"back\" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            triggerEvent(n2, 'onPending');\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nlet hasWarned = false;\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\r\n    /* istanbul ignore if */\r\n    if (false) {}\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = shared_esm_bundler_toNumber(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === 'number' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            if ((false)) {}\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === 'out-in';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            triggerEvent(vnode, 'onResolve');\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n            // invoke @fallback event\r\n            triggerEvent(vnode, 'onFallback');\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            suspense.isInFallback = true;\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            const isInPendingSuspense = !!suspense.pendingBranch;\r\n            if (isInPendingSuspense) {\r\n                suspense.deps++;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                if ((false)) {}\r\n                handleSetupResult(instance, asyncSetupResult, false);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                if ((false)) {}\r\n                // only decrease deps count if suspense is not already resolved\r\n                if (isInPendingSuspense && --suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don't really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;\r\n    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\r\n    vnode.ssFallback = isSlotChildren\r\n        ? normalizeSuspenseSlot(children.fallback)\r\n        : runtime_core_esm_bundler_createVNode(Comment);\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    let block;\r\n    if (shared_esm_bundler_isFunction(s)) {\r\n        const trackBlock = isBlockTreeEnabled && s._c;\r\n        if (trackBlock) {\r\n            // disableTracking: false\r\n            // allow block tracking for compiled slots\r\n            // (see ./componentRenderContext.ts)\r\n            s._d = false;\r\n            openBlock();\r\n        }\r\n        s = s();\r\n        if (trackBlock) {\r\n            s._d = true;\r\n            block = currentBlock;\r\n            closeBlock();\r\n        }\r\n    }\r\n    if (shared_esm_bundler_isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        if (false) {}\r\n        s = singleChild;\r\n    }\r\n    s = normalizeVNode(s);\r\n    if (block && !s.dynamicChildren) {\r\n        s.dynamicChildren = block.filter(c => c !== s);\r\n    }\r\n    return s;\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (shared_esm_bundler_isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if ((false)) {}\r\n    }\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent's provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn't allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && shared_esm_bundler_isFunction(defaultValue)\r\n                ? defaultValue.call(instance.proxy)\r\n                : defaultValue;\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if ((false)) {}\r\n}\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction runtime_core_esm_bundler_watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, (( false)\r\n        ? 0 : { flush: 'post' }));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, (( false)\r\n        ? 0 : { flush: 'sync' }));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if (false) {}\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared_esm_bundler_EMPTY_OBJ) {\r\n    if (false) {}\r\n    const warnInvalidSource = (s) => {\r\n        runtime_core_esm_bundler_warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\r\n            `a reactive object, or an array of these types.`);\r\n    };\r\n    const instance = currentInstance;\r\n    let getter;\r\n    let forceTrigger = false;\r\n    let isMultiSource = false;\r\n    if (reactivity_esm_bundler_isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (reactivity_esm_bundler_isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (shared_esm_bundler_isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(s => reactivity_esm_bundler_isReactive(s) || isShallow(s));\r\n        getter = () => source.map(s => {\r\n            if (reactivity_esm_bundler_isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (reactivity_esm_bundler_isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (shared_esm_bundler_isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);\r\n            }\r\n            else {\r\n                ( false) && 0;\r\n            }\r\n        });\r\n    }\r\n    else if (shared_esm_bundler_isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = shared_esm_bundler_NOOP;\r\n        ( false) && 0;\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onCleanup = (fn) => {\r\n        cleanup = effect.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isInSSRComponentSetup) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = shared_esm_bundler_NOOP;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return shared_esm_bundler_NOOP;\r\n    }\r\n    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!effect.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = effect.run();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some((v, i) => shared_esm_bundler_hasChanged(v, oldValue[i]))\r\n                    : shared_esm_bundler_hasChanged(newValue, oldValue)) ||\r\n                (false  )) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            effect.run();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job; // the scheduler function gets called directly\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => queuePreFlushCb(job);\r\n    }\r\n    const effect = new ReactiveEffect(getter, scheduler);\r\n    if ((false)) {}\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = effect.run();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\r\n    }\r\n    else {\r\n        effect.run();\r\n    }\r\n    return () => {\r\n        effect.stop();\r\n        if (instance && instance.scope) {\r\n            remove(instance.scope.effects, effect);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, value, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = shared_esm_bundler_isString(source)\r\n        ? source.includes('.')\r\n            ? createPathGetter(publicThis, source)\r\n            : () => publicThis[source]\r\n        : source.bind(publicThis, publicThis);\r\n    let cb;\r\n    if (shared_esm_bundler_isFunction(value)) {\r\n        cb = value;\r\n    }\r\n    else {\r\n        cb = value.handler;\r\n        options = value;\r\n    }\r\n    const cur = currentInstance;\r\n    setCurrentInstance(this);\r\n    const res = doWatch(getter, cb.bind(publicThis), options);\r\n    if (cur) {\r\n        setCurrentInstance(cur);\r\n    }\r\n    else {\r\n        unsetCurrentInstance();\r\n    }\r\n    return res;\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction traverse(value, seen) {\r\n    if (!shared_esm_bundler_isObject(value) || value[\"__v_skip\" /* SKIP */]) {\r\n        return value;\r\n    }\r\n    seen = seen || new Set();\r\n    if (seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (reactivity_esm_bundler_isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (shared_esm_bundler_isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (shared_esm_bundler_isSet(value) || isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else if (isPlainObject(value)) {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    runtime_core_esm_bundler_onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = runtime_core_esm_bundler_getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            let child = children[0];\r\n            if (children.length > 1) {\r\n                let hasFound = false;\r\n                // locate first non-comment child\r\n                for (const c of children) {\r\n                    if (c.type !== Comment) {\r\n                        if (false) {}\r\n                        child = c;\r\n                        hasFound = true;\r\n                        if (true)\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            // there's no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = reactivity_esm_bundler_toRaw(props);\r\n            const { mode } = rawProps;\r\n            // check mode\r\n            if (false) {}\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree's hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === 'out-in') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === 'in-out' && innerChild.type !== Comment) {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const callAsyncHook = (hook, args) => {\r\n        const done = args[1];\r\n        callHook(hook, args);\r\n        if (shared_esm_bundler_isArray(hook)) {\r\n            if (hook.every(hook => hook.length <= 1))\r\n                done();\r\n        }\r\n        else if (hook.length <= 1) {\r\n            done();\r\n        }\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                callAsyncHook(hook, [el, done]);\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                callAsyncHook(onLeave, [el, done]);\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        // #5360 inherit parent key in case of <template v-for>\r\n        const key = parentKey == null\r\n            ? child.key\r\n            : String(parentKey) + String(child.key != null ? child.key : i);\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === runtime_core_esm_bundler_Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(key != null ? cloneVNode(child, { key }) : child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-op\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n// implementation, close to no-op\r\nfunction runtime_core_esm_bundler_defineComponent(options) {\r\n    return shared_esm_bundler_isFunction(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(err => {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise((resolve, reject) => {\r\n                            const userRetry = () => resolve(retry());\r\n                            const userFail = () => reject(err);\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then((comp) => {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if (false) {}\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if (false) {}\r\n                    resolvedComp = comp;\r\n                    return comp;\r\n                })));\r\n    };\r\n    return runtime_core_esm_bundler_defineComponent({\r\n        name: 'AsyncComponentWrapper',\r\n        __asyncLoader: load,\r\n        get __asyncResolved() {\r\n            return resolvedComp;\r\n        },\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if ((suspensible && instance.suspense) ||\r\n                (isInSSRComponentSetup)) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? runtime_core_esm_bundler_createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = ref(false);\r\n            const error = ref();\r\n            const delayed = ref(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n                if (instance.parent && isKeepAlive(instance.parent.vnode)) {\r\n                    // parent is keep-alive, force update so the loaded component's\r\n                    // name is taken into account\r\n                    queueJob(instance.parent.update);\r\n                }\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return runtime_core_esm_bundler_createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return runtime_core_esm_bundler_createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {\r\n    const vnode = runtime_core_esm_bundler_createVNode(comp, props, children);\r\n    // ensure inner component inherits the async wrapper's ref owner\r\n    vnode.ref = ref;\r\n    return vnode;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = runtime_core_esm_bundler_getCurrentInstance();\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n        // for KeepAlive, we just need to render its children\r\n        if (!sharedContext.renderer) {\r\n            return () => {\r\n                const children = slots.default && slots.default();\r\n                return children && children.length === 1 ? children[0] : children;\r\n            };\r\n        }\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            instance.__v_cache = cache;\r\n        }\r\n        const parentSuspense = instance.suspense;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement('div');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    invokeArrayFns(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n            if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                // Update components tree\r\n                devtoolsComponentAdded(instance);\r\n            }\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    invokeArrayFns(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n            if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                // Update components tree\r\n                devtoolsComponentAdded(instance);\r\n            }\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense, true);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getComponentName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can't unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => matches(include, name));\r\n            exclude && pruneCache(name => !matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: 'post', deep: true });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        runtime_core_esm_bundler_onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive's unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                if ((false)) {}\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            // for async components, name check should be based in its loaded\r\n            // inner component if available\r\n            const name = getComponentName(isAsyncWrapper(vnode)\r\n                ? vnode.type.__asyncResolved || {}\r\n                : comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !matches(include, name))) ||\r\n                (exclude && name && matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it's reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it's possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return isSuspense(rawVNode.type) ? rawVNode : vnode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = (/* unused pure expression or super */ null && (KeepAliveImpl));\r\nfunction matches(pattern, name) {\r\n    if (shared_esm_bundler_isArray(pattern)) {\r\n        return pattern.some((p) => matches(p, name));\r\n    }\r\n    else if (shared_esm_bundler_isString(pattern)) {\r\n        return pattern.split(',').includes(name);\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n    // deactivation check\".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            return hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    runtime_core_esm_bundler_onUnmounted(() => {\r\n        remove(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n        // handling\".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                unsetCurrentInstance();\r\n                resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\r\n(!isInSSRComponentSetup || lifecycle === \"sp\" /* SERVER_PREFETCH */) &&\r\n    injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\nconst runtime_core_esm_bundler_onMounted = createHook(\"m\" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook(\"u\" /* UPDATED */);\r\nconst onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\nconst runtime_core_esm_bundler_onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\nconst onServerPrefetch = createHook(\"sp\" /* SERVER_PREFETCH */);\r\nconst onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\nfunction onErrorCaptured(hook, target = currentInstance) {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n}\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\nfunction validateDirectiveName(name) {\r\n    if (isBuiltInDirective(name)) {\r\n        runtime_core_esm_bundler_warn('Do not use built-in directive ids as custom directive id: ' + name);\r\n    }\r\n}\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        ( false) && 0;\r\n        return vnode;\r\n    }\r\n    const instance = getExposeProxy(internalInstance) ||\r\n        internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = shared_esm_bundler_EMPTY_OBJ] = directives[i];\r\n        if (shared_esm_bundler_isFunction(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        if (dir.deep) {\r\n            traverse(value);\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        let hook = binding.dir[name];\r\n        if (hook) {\r\n            // disable tracking inside all lifecycle hooks\r\n            // since they can potentially be called inside effects.\r\n            pauseTracking();\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n            resetTracking();\r\n        }\r\n    }\r\n}\n\nconst COMPONENTS = 'components';\r\nconst DIRECTIVES = 'directives';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name, maybeSelfReference) {\r\n    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if (isString(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // explicit self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            const selfName = getComponentName(Component);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === camelize(name) ||\r\n                    selfName === shared_esm_bundler_capitalize(camelize(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first which is resolved for options API\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if (!res && maybeSelfReference) {\r\n            // fallback to implicit self-reference\r\n            return Component;\r\n        }\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    else if ((false)) {}\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[camelize(name)] ||\r\n            registry[shared_esm_bundler_capitalize(camelize(name))]));\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem, cache, index) {\r\n    let ret;\r\n    const cached = (cache && cache[index]);\r\n    if (shared_esm_bundler_isArray(source) || shared_esm_bundler_isString(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        if (false) {}\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\r\n        }\r\n    }\r\n    else if (shared_esm_bundler_isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i, cached && cached[i]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    if (cache) {\r\n        cache[index] = ret;\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n        if (isArray(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if=\"...\" #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback, noSlotted) {\r\n    if (currentRenderingInstance.isCE ||\r\n        (currentRenderingInstance.parent &&\r\n            isAsyncWrapper(currentRenderingInstance.parent) &&\r\n            currentRenderingInstance.parent.isCE)) {\r\n        return runtime_core_esm_bundler_createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());\r\n    }\r\n    let slot = slots[name];\r\n    if (false) {}\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it's template-based so we can force\r\n    // enable it.\r\n    if (slot && slot._c) {\r\n        slot._d = false;\r\n    }\r\n    openBlock();\r\n    const validSlotContent = slot && ensureValidVNode(slot(props));\r\n    const rendered = createBlock(runtime_core_esm_bundler_Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n        ? 64 /* STABLE_FRAGMENT */\r\n        : -2 /* BAIL */);\r\n    if (!noSlotted && rendered.scopeId) {\r\n        rendered.slotScopeIds = [rendered.scopeId + '-s'];\r\n    }\r\n    if (slot && slot._c) {\r\n        slot._d = true;\r\n    }\r\n    return rendered;\r\n}\r\nfunction ensureValidVNode(vnodes) {\r\n    return vnodes.some(child => {\r\n        if (!isVNode(child))\r\n            return true;\r\n        if (child.type === Comment)\r\n            return false;\r\n        if (child.type === runtime_core_esm_bundler_Fragment &&\r\n            !ensureValidVNode(child.children))\r\n            return false;\r\n        return true;\r\n    })\r\n        ? vnodes\r\n        : null;\r\n}\n\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    if (false) {}\r\n    for (const key in obj) {\r\n        ret[toHandlerKey(key)] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return getExposeProxy(i) || i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = \r\n// Move PURE marker to new line to workaround compiler discarding it\r\n// due to type annotation\r\n/*#__PURE__*/ shared_esm_bundler_extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (( false) ? 0 : i.props),\r\n    $attrs: i => (( false) ? 0 : i.attrs),\r\n    $slots: i => (( false) ? 0 : i.slots),\r\n    $refs: i => (( false) ? 0 : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\r\n    $nextTick: i => i.n || (i.n = runtime_core_esm_bundler_nextTick.bind(i.proxy)),\r\n    $watch: i => (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : shared_esm_bundler_NOOP)\r\n});\r\nconst isReservedPrefix = (key) => key === '_' || key === '$';\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // for internal formatters to know that this is a Vue instance\r\n        if (false) {}\r\n        // prioritize <script setup> bindings during dev.\r\n        // this allows even properties that start with _ or $ to be used - so that\r\n        // it aligns with the production behavior where the render fn is inlined and\r\n        // indeed has access to all declared variables.\r\n        if (false) {}\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 1 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 2 /* DATA */:\r\n                        return data[key];\r\n                    case 4 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 3 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) {\r\n                accessCache[key] = 1 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {\r\n                accessCache[key] = 2 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                shared_esm_bundler_hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 3 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {\r\n                accessCache[key] = 4 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\r\n                accessCache[key] = 0 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                track(instance, \"get\" /* GET */, key);\r\n                ( false) && 0;\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 4 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            shared_esm_bundler_hasOwn(globalProperties, key))) {\r\n            {\r\n                return globalProperties[key];\r\n            }\r\n        }\r\n        else if (false) {}\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n            return true;\r\n        }\r\n        else if (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) {\r\n            data[key] = value;\r\n            return true;\r\n        }\r\n        else if (shared_esm_bundler_hasOwn(instance.props, key)) {\r\n            ( false) &&\r\n                0;\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            ( false) &&\r\n                0;\r\n            return false;\r\n        }\r\n        else {\r\n            if (false) {}\r\n            else {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (!!accessCache[key] ||\r\n            (data !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(data, key)) ||\r\n            (setupState !== shared_esm_bundler_EMPTY_OBJ && shared_esm_bundler_hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && shared_esm_bundler_hasOwn(normalizedProps, key)) ||\r\n            shared_esm_bundler_hasOwn(ctx, key) ||\r\n            shared_esm_bundler_hasOwn(publicPropertiesMap, key) ||\r\n            shared_esm_bundler_hasOwn(appContext.config.globalProperties, key));\r\n    },\r\n    defineProperty(target, key, descriptor) {\r\n        if (descriptor.get != null) {\r\n            // invalidate key cache of a getter based property #5417\r\n            target._.accessCache[key] = 0;\r\n        }\r\n        else if (shared_esm_bundler_hasOwn(descriptor, 'value')) {\r\n            this.set(target, key, descriptor.value, null);\r\n        }\r\n        return Reflect.defineProperty(target, key, descriptor);\r\n    }\r\n};\r\nif (false) {}\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ shared_esm_bundler_extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !isGloballyWhitelisted(key);\r\n        if (false) {}\r\n        return has;\r\n    }\r\n});\r\n// dev only\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nfunction createDevRenderContext(instance) {\r\n    const target = {};\r\n    // expose internal instance for proxy handlers\r\n    Object.defineProperty(target, `_`, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: () => instance\r\n    });\r\n    // expose public properties\r\n    Object.keys(publicPropertiesMap).forEach(key => {\r\n        Object.defineProperty(target, key, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            get: () => publicPropertiesMap[key](instance),\r\n            // intercepted by the proxy so no need for implementation,\r\n            // but needed to prevent set errors\r\n            set: NOOP\r\n        });\r\n    });\r\n    return target;\r\n}\r\n// dev only\r\nfunction exposePropsOnRenderContext(instance) {\r\n    const { ctx, propsOptions: [propsOptions] } = instance;\r\n    if (propsOptions) {\r\n        Object.keys(propsOptions).forEach(key => {\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => instance.props[key],\r\n                set: NOOP\r\n            });\r\n        });\r\n    }\r\n}\r\n// dev only\r\nfunction exposeSetupStateOnRenderContext(instance) {\r\n    const { ctx, setupState } = instance;\r\n    Object.keys(toRaw(setupState)).forEach(key => {\r\n        if (!setupState.__isScriptSetup) {\r\n            if (isReservedPrefix(key[0])) {\r\n                runtime_core_esm_bundler_warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\r\n                    `which are reserved prefixes for Vue internals.`);\r\n                return;\r\n            }\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => setupState[key],\r\n                set: NOOP\r\n            });\r\n        }\r\n    });\r\n}\n\nfunction createDuplicateChecker() {\r\n    const cache = Object.create(null);\r\n    return (type, key) => {\r\n        if (cache[key]) {\r\n            runtime_core_esm_bundler_warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\r\n        }\r\n        else {\r\n            cache[key] = type;\r\n        }\r\n    };\r\n}\r\nlet shouldCacheAccess = true;\r\nfunction applyOptions(instance) {\r\n    const options = resolveMergedOptions(instance);\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    // do not cache property access on public proxy during state initialization\r\n    shouldCacheAccess = false;\r\n    // call beforeCreate first before accessing other options since\r\n    // the hook may mutate resolved options (#2791)\r\n    if (options.beforeCreate) {\r\n        callHook(options.beforeCreate, instance, \"bc\" /* BEFORE_CREATE */);\r\n    }\r\n    const { \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // lifecycle\r\n    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, \r\n    // public API\r\n    expose, inheritAttrs, \r\n    // assets\r\n    components, directives, filters } = options;\r\n    const checkDuplicateProperties = ( false) ? 0 : null;\r\n    if ((false)) {}\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (shared_esm_bundler_isFunction(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define\r\n                // methods to the proxy target, and those are read-only but\r\n                // reconfigurable, so it needs to be redefined here\r\n                if ((false)) {}\r\n                else {\r\n                    ctx[key] = methodHandler.bind(publicThis);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    if (dataOptions) {\r\n        if (false) {}\r\n        const data = dataOptions.call(publicThis, publicThis);\r\n        if (false) {}\r\n        if (!shared_esm_bundler_isObject(data)) {\r\n            ( false) && 0;\r\n        }\r\n        else {\r\n            instance.data = reactive(data);\r\n            if ((false)) {}\r\n        }\r\n    }\r\n    // state initialization complete at this point - start caching access\r\n    shouldCacheAccess = true;\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = shared_esm_bundler_isFunction(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : shared_esm_bundler_isFunction(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : shared_esm_bundler_NOOP;\r\n            if (false) {}\r\n            const set = !shared_esm_bundler_isFunction(opt) && shared_esm_bundler_isFunction(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : ( false)\r\n                    ? 0\r\n                    : shared_esm_bundler_NOOP;\r\n            const c = runtime_core_esm_bundler_computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n            if ((false)) {}\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        for (const key in watchOptions) {\r\n            createWatcher(watchOptions[key], ctx, publicThis, key);\r\n        }\r\n    }\r\n    if (provideOptions) {\r\n        const provides = shared_esm_bundler_isFunction(provideOptions)\r\n            ? provideOptions.call(publicThis)\r\n            : provideOptions;\r\n        Reflect.ownKeys(provides).forEach(key => {\r\n            provide(key, provides[key]);\r\n        });\r\n    }\r\n    if (created) {\r\n        callHook(created, instance, \"c\" /* CREATED */);\r\n    }\r\n    function registerLifecycleHook(register, hook) {\r\n        if (shared_esm_bundler_isArray(hook)) {\r\n            hook.forEach(_hook => register(_hook.bind(publicThis)));\r\n        }\r\n        else if (hook) {\r\n            register(hook.bind(publicThis));\r\n        }\r\n    }\r\n    registerLifecycleHook(onBeforeMount, beforeMount);\r\n    registerLifecycleHook(runtime_core_esm_bundler_onMounted, mounted);\r\n    registerLifecycleHook(onBeforeUpdate, beforeUpdate);\r\n    registerLifecycleHook(onUpdated, updated);\r\n    registerLifecycleHook(onActivated, activated);\r\n    registerLifecycleHook(onDeactivated, deactivated);\r\n    registerLifecycleHook(onErrorCaptured, errorCaptured);\r\n    registerLifecycleHook(onRenderTracked, renderTracked);\r\n    registerLifecycleHook(onRenderTriggered, renderTriggered);\r\n    registerLifecycleHook(onBeforeUnmount, beforeUnmount);\r\n    registerLifecycleHook(runtime_core_esm_bundler_onUnmounted, unmounted);\r\n    registerLifecycleHook(onServerPrefetch, serverPrefetch);\r\n    if (shared_esm_bundler_isArray(expose)) {\r\n        if (expose.length) {\r\n            const exposed = instance.exposed || (instance.exposed = {});\r\n            expose.forEach(key => {\r\n                Object.defineProperty(exposed, key, {\r\n                    get: () => publicThis[key],\r\n                    set: val => (publicThis[key] = val)\r\n                });\r\n            });\r\n        }\r\n        else if (!instance.exposed) {\r\n            instance.exposed = {};\r\n        }\r\n    }\r\n    // options that are handled when creating the instance but also need to be\r\n    // applied from mixins\r\n    if (render && instance.render === shared_esm_bundler_NOOP) {\r\n        instance.render = render;\r\n    }\r\n    if (inheritAttrs != null) {\r\n        instance.inheritAttrs = inheritAttrs;\r\n    }\r\n    // asset options.\r\n    if (components)\r\n        instance.components = components;\r\n    if (directives)\r\n        instance.directives = directives;\r\n}\r\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared_esm_bundler_NOOP, unwrapRef = false) {\r\n    if (shared_esm_bundler_isArray(injectOptions)) {\r\n        injectOptions = normalizeInject(injectOptions);\r\n    }\r\n    for (const key in injectOptions) {\r\n        const opt = injectOptions[key];\r\n        let injected;\r\n        if (shared_esm_bundler_isObject(opt)) {\r\n            if ('default' in opt) {\r\n                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n            }\r\n            else {\r\n                injected = inject(opt.from || key);\r\n            }\r\n        }\r\n        else {\r\n            injected = inject(opt);\r\n        }\r\n        if (reactivity_esm_bundler_isRef(injected)) {\r\n            // TODO remove the check in 3.3\r\n            if (unwrapRef) {\r\n                Object.defineProperty(ctx, key, {\r\n                    enumerable: true,\r\n                    configurable: true,\r\n                    get: () => injected.value,\r\n                    set: v => (injected.value = v)\r\n                });\r\n            }\r\n            else {\r\n                if ((false)) {}\r\n                ctx[key] = injected;\r\n            }\r\n        }\r\n        else {\r\n            ctx[key] = injected;\r\n        }\r\n        if ((false)) {}\r\n    }\r\n}\r\nfunction callHook(hook, instance, type) {\r\n    callWithAsyncErrorHandling(shared_esm_bundler_isArray(hook)\r\n        ? hook.map(h => h.bind(instance.proxy))\r\n        : hook.bind(instance.proxy), instance, type);\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes('.')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (shared_esm_bundler_isString(raw)) {\r\n        const handler = ctx[raw];\r\n        if (shared_esm_bundler_isFunction(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    else if (shared_esm_bundler_isFunction(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (shared_esm_bundler_isObject(raw)) {\r\n        if (shared_esm_bundler_isArray(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = shared_esm_bundler_isFunction(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (shared_esm_bundler_isFunction(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n            else if ((false)) {}\r\n        }\r\n    }\r\n    else if ((false)) {}\r\n}\r\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\r\nfunction resolveMergedOptions(instance) {\r\n    const base = instance.type;\r\n    const { mixins, extends: extendsOptions } = base;\r\n    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;\r\n    const cached = cache.get(base);\r\n    let resolved;\r\n    if (cached) {\r\n        resolved = cached;\r\n    }\r\n    else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n        {\r\n            resolved = base;\r\n        }\r\n    }\r\n    else {\r\n        resolved = {};\r\n        if (globalMixins.length) {\r\n            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\r\n        }\r\n        mergeOptions(resolved, base, optionMergeStrategies);\r\n    }\r\n    cache.set(base, resolved);\r\n    return resolved;\r\n}\r\nfunction mergeOptions(to, from, strats, asMixin = false) {\r\n    const { mixins, extends: extendsOptions } = from;\r\n    if (extendsOptions) {\r\n        mergeOptions(to, extendsOptions, strats, true);\r\n    }\r\n    if (mixins) {\r\n        mixins.forEach((m) => mergeOptions(to, m, strats, true));\r\n    }\r\n    for (const key in from) {\r\n        if (asMixin && key === 'expose') {\r\n            ( false) &&\r\n                0;\r\n        }\r\n        else {\r\n            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);\r\n            to[key] = strat ? strat(to[key], from[key]) : from[key];\r\n        }\r\n    }\r\n    return to;\r\n}\r\nconst internalOptionMergeStrats = {\r\n    data: mergeDataFn,\r\n    props: mergeObjectOptions,\r\n    emits: mergeObjectOptions,\r\n    // objects\r\n    methods: mergeObjectOptions,\r\n    computed: mergeObjectOptions,\r\n    // lifecycle\r\n    beforeCreate: mergeAsArray,\r\n    created: mergeAsArray,\r\n    beforeMount: mergeAsArray,\r\n    mounted: mergeAsArray,\r\n    beforeUpdate: mergeAsArray,\r\n    updated: mergeAsArray,\r\n    beforeDestroy: mergeAsArray,\r\n    beforeUnmount: mergeAsArray,\r\n    destroyed: mergeAsArray,\r\n    unmounted: mergeAsArray,\r\n    activated: mergeAsArray,\r\n    deactivated: mergeAsArray,\r\n    errorCaptured: mergeAsArray,\r\n    serverPrefetch: mergeAsArray,\r\n    // assets\r\n    components: mergeObjectOptions,\r\n    directives: mergeObjectOptions,\r\n    // watch\r\n    watch: mergeWatchOptions,\r\n    // provide / inject\r\n    provide: mergeDataFn,\r\n    inject: mergeInject\r\n};\r\nfunction mergeDataFn(to, from) {\r\n    if (!from) {\r\n        return to;\r\n    }\r\n    if (!to) {\r\n        return from;\r\n    }\r\n    return function mergedDataFn() {\r\n        return (shared_esm_bundler_extend)(shared_esm_bundler_isFunction(to) ? to.call(this, this) : to, shared_esm_bundler_isFunction(from) ? from.call(this, this) : from);\r\n    };\r\n}\r\nfunction mergeInject(to, from) {\r\n    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\r\n}\r\nfunction normalizeInject(raw) {\r\n    if (shared_esm_bundler_isArray(raw)) {\r\n        const res = {};\r\n        for (let i = 0; i < raw.length; i++) {\r\n            res[raw[i]] = raw[i];\r\n        }\r\n        return res;\r\n    }\r\n    return raw;\r\n}\r\nfunction mergeAsArray(to, from) {\r\n    return to ? [...new Set([].concat(to, from))] : from;\r\n}\r\nfunction mergeObjectOptions(to, from) {\r\n    return to ? shared_esm_bundler_extend(shared_esm_bundler_extend(Object.create(null), to), from) : from;\r\n}\r\nfunction mergeWatchOptions(to, from) {\r\n    if (!to)\r\n        return from;\r\n    if (!from)\r\n        return to;\r\n    const merged = shared_esm_bundler_extend(Object.create(null), to);\r\n    for (const key in from) {\r\n        merged[key] = mergeAsArray(to[key], from[key]);\r\n    }\r\n    return merged;\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    def(attrs, InternalObjectKey, 1);\r\n    instance.propsDefaults = Object.create(null);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    // ensure all declared prop keys are present\r\n    for (const key in instance.propsOptions[0]) {\r\n        if (!(key in props)) {\r\n            props[key] = undefined;\r\n        }\r\n    }\r\n    // validation\r\n    if ((false)) {}\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = reactivity_esm_bundler_toRaw(props);\r\n    const [options] = instance.propsOptions;\r\n    let hasAttrsChanged = false;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n     true &&\r\n        (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                let key = propsToUpdate[i];\r\n                // skip if the prop key is a declared emit event listener\r\n                if (isEmitListener(instance.emitsOptions, key)) {\r\n                    continue;\r\n                }\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if (shared_esm_bundler_hasOwn(attrs, key)) {\r\n                        if (value !== attrs[key]) {\r\n                            attrs[key] = value;\r\n                            hasAttrsChanged = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        const camelizedKey = camelize(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\r\n                    }\r\n                }\r\n                else {\r\n                    if (value !== attrs[key]) {\r\n                        attrs[key] = value;\r\n                        hasAttrsChanged = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        if (setFullProps(instance, rawProps, props, attrs)) {\r\n            hasAttrsChanged = true;\r\n        }\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!shared_esm_bundler_hasOwn(rawProps, key) &&\r\n                    // it's possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = shared_esm_bundler_hyphenate(key)) === key || !shared_esm_bundler_hasOwn(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps ||\r\n                    (!shared_esm_bundler_hasOwn(rawProps, key) &&\r\n                        (!false ))) {\r\n                    delete attrs[key];\r\n                    hasAttrsChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it's used in component slots\r\n    if (hasAttrsChanged) {\r\n        trigger(instance, \"set\" /* SET */, '$attrs');\r\n    }\r\n    if ((false)) {}\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    let hasAttrsChanged = false;\r\n    let rawCastValues;\r\n    if (rawProps) {\r\n        for (let key in rawProps) {\r\n            // key, ref are reserved and never passed down\r\n            if (shared_esm_bundler_isReservedProp(key)) {\r\n                continue;\r\n            }\r\n            const value = rawProps[key];\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && shared_esm_bundler_hasOwn(options, (camelKey = camelize(key)))) {\r\n                if (!needCastKeys || !needCastKeys.includes(camelKey)) {\r\n                    props[camelKey] = value;\r\n                }\r\n                else {\r\n                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;\r\n                }\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                if (!(key in attrs) || value !== attrs[key]) {\r\n                    attrs[key] = value;\r\n                    hasAttrsChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = reactivity_esm_bundler_toRaw(props);\r\n        const castValues = rawCastValues || shared_esm_bundler_EMPTY_OBJ;\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !shared_esm_bundler_hasOwn(castValues, key));\r\n        }\r\n    }\r\n    return hasAttrsChanged;\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = shared_esm_bundler_hasOwn(opt, 'default');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && shared_esm_bundler_isFunction(defaultValue)) {\r\n                const { propsDefaults } = instance;\r\n                if (key in propsDefaults) {\r\n                    value = propsDefaults[key];\r\n                }\r\n                else {\r\n                    setCurrentInstance(instance);\r\n                    value = propsDefaults[key] = defaultValue.call(null, props);\r\n                    unsetCurrentInstance();\r\n                }\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (isAbsent && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === '' || value === shared_esm_bundler_hyphenate(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    const cache = appContext.propsCache;\r\n    const cached = cache.get(comp);\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (__VUE_OPTIONS_API__ && !shared_esm_bundler_isFunction(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            shared_esm_bundler_extend(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        cache.set(comp, EMPTY_ARR);\r\n        return EMPTY_ARR;\r\n    }\r\n    if (shared_esm_bundler_isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            if (false) {}\r\n            const normalizedKey = camelize(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = shared_esm_bundler_EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        if (false) {}\r\n        for (const key in raw) {\r\n            const normalizedKey = camelize(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    shared_esm_bundler_isArray(opt) || shared_esm_bundler_isFunction(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || shared_esm_bundler_hasOwn(prop, 'default')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const res = [normalized, needCastKeys];\r\n    cache.set(comp, res);\r\n    return res;\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== '$') {\r\n        return true;\r\n    }\r\n    else if ((false)) {}\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : ctor === null ? 'null' : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (shared_esm_bundler_isArray(expectedTypes)) {\r\n        return expectedTypes.findIndex(t => isSameType(t, type));\r\n    }\r\n    else if (shared_esm_bundler_isFunction(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(rawProps, props, instance) {\r\n    const resolvedValues = toRaw(props);\r\n    const options = instance.propsOptions[0];\r\n    for (const key in options) {\r\n        let opt = options[key];\r\n        if (opt == null)\r\n            continue;\r\n        validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(name, value, prop, isAbsent) {\r\n    const { type, required, validator } = prop;\r\n    // required!\r\n    if (required && isAbsent) {\r\n        runtime_core_esm_bundler_warn('Missing required prop: \"' + name + '\"');\r\n        return;\r\n    }\r\n    // missing but optional\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    // type check\r\n    if (type != null && type !== true) {\r\n        let isValid = false;\r\n        const types = isArray(type) ? type : [type];\r\n        const expectedTypes = [];\r\n        // value is valid as long as one of the specified types match\r\n        for (let i = 0; i < types.length && !isValid; i++) {\r\n            const { valid, expectedType } = assertType(value, types[i]);\r\n            expectedTypes.push(expectedType || '');\r\n            isValid = valid;\r\n        }\r\n        if (!isValid) {\r\n            runtime_core_esm_bundler_warn(getInvalidTypeMessage(name, value, expectedTypes));\r\n            return;\r\n        }\r\n    }\r\n    // custom validator\r\n    if (validator && !validator(value)) {\r\n        runtime_core_esm_bundler_warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\r\n    }\r\n}\r\nconst isSimpleType = /*#__PURE__*/ (/* unused pure expression or super */ null && (makeMap('String,Number,Boolean,Function,Symbol,BigInt')));\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value, type) {\r\n    let valid;\r\n    const expectedType = getType(type);\r\n    if (isSimpleType(expectedType)) {\r\n        const t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else if (expectedType === 'null') {\r\n        valid = value === null;\r\n    }\r\n    else {\r\n        valid = value instanceof type;\r\n    }\r\n    return {\r\n        valid,\r\n        expectedType\r\n    };\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\r\n        ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;\r\n    const expectedType = expectedTypes[0];\r\n    const receivedType = toRawType(value);\r\n    const expectedValue = styleValue(value, expectedType);\r\n    const receivedValue = styleValue(value, receivedType);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += ` with value ${expectedValue}`;\r\n    }\r\n    message += `, got ${receivedType} `;\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += `with value ${receivedValue}.`;\r\n    }\r\n    return message;\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return `\"${value}\"`;\r\n    }\r\n    else if (type === 'Number') {\r\n        return `${Number(value)}`;\r\n    }\r\n    else {\r\n        return `${value}`;\r\n    }\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type) {\r\n    const explicitTypes = ['string', 'number', 'boolean'];\r\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\r\n}\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args) {\r\n    return args.some(elem => elem.toLowerCase() === 'boolean');\r\n}\n\nconst isInternalKey = (key) => key[0] === '_' || key === '$stable';\r\nconst normalizeSlotValue = (value) => shared_esm_bundler_isArray(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => {\r\n    if (rawSlot._n) {\r\n        // already normalized - #5353\r\n        return rawSlot;\r\n    }\r\n    const normalized = withCtx((...args) => {\r\n        if (false) {}\r\n        return normalizeSlotValue(rawSlot(...args));\r\n    }, ctx);\r\n    normalized._c = false;\r\n    return normalized;\r\n};\r\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if (shared_esm_bundler_isFunction(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            if (false) {}\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    if (false) {}\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // users can get the shallow readonly version of the slots object through `this.$slots`,\r\n            // we should avoid the proxy object polluting the slots of the internal instance\r\n            instance.slots = reactivity_esm_bundler_toRaw(children);\r\n            // make compiler marker non-enumerable\r\n            def(children, '_', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    def(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children, optimized) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = shared_esm_bundler_EMPTY_OBJ;\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if (false) {}\r\n            else if (optimized && type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                shared_esm_bundler_extend(slots, children);\r\n                // #2893\r\n                // when rendering the optimized slots by manually written render function,\r\n                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n                // i.e. let the `renderSlot` create the bailed Fragment\r\n                if (!optimized && type === 1 /* STABLE */) {\r\n                    delete slots._;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: shared_esm_bundler_NO,\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            errorHandler: undefined,\r\n            warnHandler: undefined,\r\n            compilerOptions: {}\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null),\r\n        optionsCache: new WeakMap(),\r\n        propsCache: new WeakMap(),\r\n        emitsCache: new WeakMap()\r\n    };\r\n}\r\nlet uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (!shared_esm_bundler_isFunction(rootComponent)) {\r\n            rootComponent = Object.assign({}, rootComponent);\r\n        }\r\n        if (rootProps != null && !shared_esm_bundler_isObject(rootProps)) {\r\n            ( false) && 0;\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            _instance: null,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n                if ((false)) {}\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) {\r\n                    ( false) && 0;\r\n                }\r\n                else if (plugin && shared_esm_bundler_isFunction(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (shared_esm_bundler_isFunction(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                if (__VUE_OPTIONS_API__) {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if ((false)) {}\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if ((false)) {}\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                if (false) {}\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if ((false)) {}\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                if (false) {}\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate, isSVG) {\r\n                if (!isMounted) {\r\n                    // #5571\r\n                    if (false) {}\r\n                    const vnode = runtime_core_esm_bundler_createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    // HMR root reload\r\n                    if ((false)) {}\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer, isSVG);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        app._instance = vnode.component;\r\n                        devtoolsInitApp(app, version);\r\n                    }\r\n                    return getExposeProxy(vnode.component) || vnode.component.proxy;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                        app._instance = null;\r\n                        devtoolsUnmountApp(app);\r\n                    }\r\n                    delete app._container.__vue_app__;\r\n                }\r\n                else if ((false)) {}\r\n            },\r\n            provide(key, value) {\r\n                if (false) {}\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\n/**\r\n * Function for handling a template ref\r\n */\r\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\r\n    if (shared_esm_bundler_isArray(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (shared_esm_bundler_isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\r\n        return;\r\n    }\r\n    if (isAsyncWrapper(vnode) && !isUnmount) {\r\n        // when mounting async components, nothing needs to be done,\r\n        // because the template ref is forwarded to inner component\r\n        return;\r\n    }\r\n    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */\r\n        ? getExposeProxy(vnode.component) || vnode.component.proxy\r\n        : vnode.el;\r\n    const value = isUnmount ? null : refValue;\r\n    const { i: owner, r: ref } = rawRef;\r\n    if (false) {}\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === shared_esm_bundler_EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // dynamic ref changed. unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (shared_esm_bundler_isString(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (shared_esm_bundler_hasOwn(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (reactivity_esm_bundler_isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (shared_esm_bundler_isFunction(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else {\r\n        const _isString = shared_esm_bundler_isString(ref);\r\n        const _isRef = reactivity_esm_bundler_isRef(ref);\r\n        if (_isString || _isRef) {\r\n            const doSet = () => {\r\n                if (rawRef.f) {\r\n                    const existing = _isString ? refs[ref] : ref.value;\r\n                    if (isUnmount) {\r\n                        shared_esm_bundler_isArray(existing) && remove(existing, refValue);\r\n                    }\r\n                    else {\r\n                        if (!shared_esm_bundler_isArray(existing)) {\r\n                            if (_isString) {\r\n                                refs[ref] = [refValue];\r\n                                if (shared_esm_bundler_hasOwn(setupState, ref)) {\r\n                                    setupState[ref] = refs[ref];\r\n                                }\r\n                            }\r\n                            else {\r\n                                ref.value = [refValue];\r\n                                if (rawRef.k)\r\n                                    refs[rawRef.k] = ref.value;\r\n                            }\r\n                        }\r\n                        else if (!existing.includes(refValue)) {\r\n                            existing.push(refValue);\r\n                        }\r\n                    }\r\n                }\r\n                else if (_isString) {\r\n                    refs[ref] = value;\r\n                    if (shared_esm_bundler_hasOwn(setupState, ref)) {\r\n                        setupState[ref] = value;\r\n                    }\r\n                }\r\n                else if (reactivity_esm_bundler_isRef(ref)) {\r\n                    ref.value = value;\r\n                    if (rawRef.k)\r\n                        refs[rawRef.k] = value;\r\n                }\r\n                else if ((false)) {}\r\n            };\r\n            if (value) {\r\n                doSet.id = -1;\r\n                queuePostRenderEffect(doSet, parentSuspense);\r\n            }\r\n            else {\r\n                doSet();\r\n            }\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        if (!container.hasChildNodes()) {\r\n            ( false) &&\r\n                0;\r\n            patch(null, vnode, container);\r\n            flushPostFlushCbs();\r\n            return;\r\n        }\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null, null);\r\n        flushPostFlushCbs();\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === '[';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\r\n        const { type, ref, shapeFlag, patchFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        if (patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            vnode.dynamicChildren = null;\r\n        }\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    // #5728 empty text node inside a slot can cause hydration failure\r\n                    // because the server rendered HTML won't contain a text node\r\n                    if (vnode.children === '') {\r\n                        insert((vnode.el = createText('')), parentNode(node), node);\r\n                        nextNode = node;\r\n                    }\r\n                    else {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        ( false) &&\r\n                            0;\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case runtime_core_esm_bundler_Static:\r\n                if (domType !== 1 /* ELEMENT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children += nextNode.outerHTML;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case runtime_core_esm_bundler_Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type.toLowerCase() !==\r\n                            node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    vnode.slotScopeIds = slotScopeIds;\r\n                    const container = parentNode(node);\r\n                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component's rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                    // #4293 teleport as component root\r\n                    if (nextNode &&\r\n                        isComment(nextNode) &&\r\n                        nextNode.data === 'teleport end') {\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    // #3787\r\n                    // if component is async, it may get moved / unmounted before its\r\n                    // inner component is loaded, so we need to give it a placeholder\r\n                    // vnode that matches its adopted DOM.\r\n                    if (isAsyncWrapper(vnode)) {\r\n                        let subTree;\r\n                        if (isFragmentStart) {\r\n                            subTree = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment);\r\n                            subTree.anchor = nextNode\r\n                                ? nextNode.previousSibling\r\n                                : container.lastChild;\r\n                        }\r\n                        else {\r\n                            subTree =\r\n                                node.nodeType === 3 ? createTextVNode('') : runtime_core_esm_bundler_createVNode('div');\r\n                        }\r\n                        subTree.el = node;\r\n                        vnode.component.subTree = subTree;\r\n                    }\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { type, props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // #4006 for form elements with non-string v-model value bindings\r\n        // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\r\n        const forcePatchValue = (type === 'input' && dirs) || type === 'option';\r\n        // skip props & children if this is hoisted static nodes\r\n        // #5405 in dev, always hydrate children for HMR\r\n        if (( false) || forcePatchValue || patchFlag !== -1 /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (forcePatchValue ||\r\n                    !optimized ||\r\n                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if ((forcePatchValue && key.endsWith('value')) ||\r\n                            (isOn(key) && !isReservedProp(key))) {\r\n                            patchProp(el, key, null, props[key], false, undefined, parentComponent);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                let hasWarned = false;\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    if (false) {}\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    ( false) &&\r\n                        0;\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        let hasWarned = false;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n            else if (vnode.type === Text && !vnode.children) {\r\n                continue;\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                if (false) {}\r\n                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        const { slotScopeIds: fragmentSlotScopeIds } = vnode;\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n        if (next && isComment(next) && next.data === ']') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\r\n        hasMismatch = true;\r\n        ( false) &&\r\n            0;\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === '[')\r\n                    match++;\r\n                if (node.data === ']') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\n/* eslint-disable no-restricted-globals */\r\nlet supported;\r\nlet perf;\r\nfunction startMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        perf.mark(`vue-${type}-${instance.uid}`);\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\r\n    }\r\n}\r\nfunction endMeasure(instance, type) {\r\n    if (instance.appContext.config.performance && isSupported()) {\r\n        const startTag = `vue-${type}-${instance.uid}`;\r\n        const endTag = startTag + `:end`;\r\n        perf.mark(endTag);\r\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\r\n        perf.clearMarks(startTag);\r\n        perf.clearMarks(endTag);\r\n    }\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\r\n    }\r\n}\r\nfunction isSupported() {\r\n    if (supported !== undefined) {\r\n        return supported;\r\n    }\r\n    if (typeof window !== 'undefined' && window.performance) {\r\n        supported = true;\r\n        perf = window.performance;\r\n    }\r\n    else {\r\n        supported = false;\r\n    }\r\n    return supported;\r\n}\n\n/**\r\n * This is only called in esm-bundler builds.\r\n * It is called when a renderer is created, in `baseCreateRenderer` so that\r\n * importing runtime-core is side-effects free.\r\n *\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    const needWarn = [];\r\n    if (typeof __VUE_OPTIONS_API__ !== 'boolean') {\r\n        ( false) && 0;\r\n        getGlobalThis().__VUE_OPTIONS_API__ = true;\r\n    }\r\n    if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {\r\n        ( false) && 0;\r\n        getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if (false) {}\r\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction runtime_core_esm_bundler_createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    // compile-time feature flags check\r\n    {\r\n        initFeatureFlags();\r\n    }\r\n    const target = getGlobalThis();\r\n    target.__VUE__ = true;\r\n    if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\r\n    }\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared_esm_bundler_NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {\r\n        if (n1 === n2) {\r\n            return;\r\n        }\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case runtime_core_esm_bundler_Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                else if ((false)) {}\r\n                break;\r\n            case runtime_core_esm_bundler_Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if ((false)) {}\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\r\n    };\r\n    /**\r\n     * Dev / HMR only\r\n     */\r\n    const patchStaticNode = (n1, n2, container, isSVG) => {\r\n        // static nodes are only patched during dev for HMR\r\n        if (n2.children !== n1.children) {\r\n            const anchor = hostNextSibling(n1.anchor);\r\n            // remove existing\r\n            removeStaticNode(n1);\r\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n        }\r\n        else {\r\n            n2.el = n1.el;\r\n            n2.anchor = n1.anchor;\r\n        }\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        isSVG = isSVG || n2.type === 'svg';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\r\n        if ( true &&\r\n            vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it's being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (key !== 'value' && !shared_esm_bundler_isReservedProp(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                /**\r\n                 * Special case for setting value on DOM elements:\r\n                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n                 * - it needs to be forced (#1471)\r\n                 * #2353 proposes adding another renderer option to configure this, but\r\n                 * the properties affects are so finite it is worth special casing it\r\n                 * here to reduce the complexity. (Special casing it also should not\r\n                 * affect non-DOM renderers)\r\n                 */\r\n                if ('value' in props) {\r\n                    hostPatchProp(el, 'value', null, props.value);\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            Object.defineProperty(el, '__vnode', {\r\n                value: vnode,\r\n                enumerable: false\r\n            });\r\n            Object.defineProperty(el, '__vueParentComponent', {\r\n                value: parentComponent,\r\n                enumerable: false\r\n            });\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (slotScopeIds) {\r\n            for (let i = 0; i < slotScopeIds.length; i++) {\r\n                hostSetScopeId(el, slotScopeIds[i]);\r\n            }\r\n        }\r\n        if (parentComponent) {\r\n            let subTree = parentComponent.subTree;\r\n            if (false /* DEV_ROOT_FRAGMENT */) {}\r\n            if (vnode === subTree) {\r\n                const parentVNode = parentComponent.vnode;\r\n                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode's patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || shared_esm_bundler_EMPTY_OBJ;\r\n        const newProps = n2.props || shared_esm_bundler_EMPTY_OBJ;\r\n        let vnodeHook;\r\n        // disable recurse in beforeUpdate hooks\r\n        parentComponent && toggleRecurse(parentComponent, false);\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n        }\r\n        parentComponent && toggleRecurse(parentComponent, true);\r\n        if (false) {}\r\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\r\n            if (false) {}\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        // #1471 force patch value\r\n                        if (next !== prev || key === 'value') {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // oldVNode may be an errored async setup() component inside Suspense\r\n            // which will not have a mounted element\r\n            oldVNode.el &&\r\n                // - In the case of a Fragment, we need to provide the actual parent\r\n                // of the Fragment itself so it can move its children.\r\n                (oldVNode.type === runtime_core_esm_bundler_Fragment ||\r\n                    // - In the case of different nodes, there is going to be a replacement\r\n                    // which also requires the correct parent container\r\n                    !isSameVNodeType(oldVNode, newVNode) ||\r\n                    // - In the case of a component, it could contain anything.\r\n                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if (shared_esm_bundler_isReservedProp(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                // defer patching value\r\n                if (next !== prev && key !== 'value') {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== shared_esm_bundler_EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (!shared_esm_bundler_isReservedProp(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n            if ('value' in newProps) {\r\n                hostPatchProp(el, 'value', oldProps.value, newProps.value);\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\r\n        if (false) {}\r\n        // check if this is a slot fragment with :slotted scope ids\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could've been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn't need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                if (false) {}\r\n                else if (\r\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it's a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        n2.slotScopeIds = slotScopeIds;\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        if (false) {}\r\n        if ((false)) {}\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        // resolve props and slots for setup context\r\n        {\r\n            if ((false)) {}\r\n            setupComponent(instance);\r\n            if ((false)) {}\r\n        }\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = runtime_core_esm_bundler_createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n        if ((false)) {}\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                // async & still pending - just update props and slots\r\n                // since the component's reactive effect for render isn't set-up yet\r\n                if ((false)) {}\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                if ((false)) {}\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        const componentUpdateFn = () => {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\r\n                toggleRecurse(instance, false);\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    invokeArrayFns(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                toggleRecurse(instance, true);\r\n                if (el && hydrateNode) {\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    const hydrateSubTree = () => {\r\n                        if ((false)) {}\r\n                        instance.subTree = renderComponentRoot(instance);\r\n                        if ((false)) {}\r\n                        if ((false)) {}\r\n                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);\r\n                        if ((false)) {}\r\n                    };\r\n                    if (isAsyncWrapperVNode) {\r\n                        initialVNode.type.__asyncLoader().then(\r\n                        // note: we are moving the render call into an async callback,\r\n                        // which means it won't track dependencies - but it's ok because\r\n                        // a server-rendered async wrapper is already in resolved state\r\n                        // and it will never need to change.\r\n                        () => !instance.isUnmounted && hydrateSubTree());\r\n                    }\r\n                    else {\r\n                        hydrateSubTree();\r\n                    }\r\n                }\r\n                else {\r\n                    if ((false)) {}\r\n                    const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                    if ((false)) {}\r\n                    if ((false)) {}\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    if ((false)) {}\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if (!isAsyncWrapperVNode &&\r\n                    (vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||\r\n                    (parent &&\r\n                        isAsyncWrapper(parent.vnode) &&\r\n                        parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {\r\n                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentAdded(instance);\r\n                }\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if ((false)) {}\r\n                // Disallow component effect recursion during pre-lifecycle hooks.\r\n                toggleRecurse(instance, false);\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    invokeArrayFns(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                toggleRecurse(instance, true);\r\n                // render\r\n                if ((false)) {}\r\n                const nextTree = renderComponentRoot(instance);\r\n                if ((false)) {}\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                if ((false)) {}\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                if ((false)) {}\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\r\n                }\r\n                if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n                    devtoolsComponentUpdated(instance);\r\n                }\r\n                if ((false)) {}\r\n            }\r\n        };\r\n        // create reactive effect for rendering\r\n        const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope\r\n        ));\r\n        const update = (instance.update = () => effect.run());\r\n        update.id = instance.uid;\r\n        // allowRecurse\r\n        // #1801, #2043 component render effects should allow recursive updates\r\n        toggleRecurse(instance, true);\r\n        if ((false)) {}\r\n        update();\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children, optimized);\r\n        pauseTracking();\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n        resetTracking();\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        c1 = c1 || EMPTY_ARR;\r\n        c2 = c2 || EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    if (false) {}\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === runtime_core_esm_bundler_Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === runtime_core_esm_bundler_Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode, true);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\r\n        let vnodeHook;\r\n        if (shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n            }\r\n            if (shapeFlag & 64 /* TELEPORT */) {\r\n                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\r\n            }\r\n            else if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== runtime_core_esm_bundler_Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === runtime_core_esm_bundler_Fragment &&\r\n                patchFlag &\r\n                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((shouldInvokeVnodeHook &&\r\n            (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n            shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === runtime_core_esm_bundler_Fragment) {\r\n            if (false) {}\r\n            else {\r\n                removeFragment(el, anchor);\r\n            }\r\n            return;\r\n        }\r\n        if (type === runtime_core_esm_bundler_Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        if (false) {}\r\n        const { bum, scope, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            invokeArrayFns(bum);\r\n        }\r\n        // stop effects in component scope\r\n        scope.stop();\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            // so that scheduler will no longer invoke it\r\n            update.active = false;\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            devtoolsComponentRemoved(instance);\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container, isSVG) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container, null, null, null, isSVG);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction toggleRecurse({ effect, update }, allowed) {\r\n    effect.allowRecurse = update.allowRecurse = allowed;\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always be moved. Therefore, in order to ensure correct move\r\n * position, el should be inherited from previous nodes.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (shared_esm_bundler_isArray(ch1) && shared_esm_bundler_isArray(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n            // would have received .el during block patch)\r\n            if (false) {}\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = (u + v) >> 1;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\r\nconst isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if (shared_esm_bundler_isString(targetSelector)) {\r\n        if (!select) {\r\n            ( false) &&\r\n                0;\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            if (!target) {\r\n                ( false) &&\r\n                    0;\r\n            }\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        if (false) {}\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        let { shapeFlag, children, dynamicChildren } = n2;\r\n        // #3302\r\n        // HMR updated, force full diff\r\n        if (false) {}\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = ( false)\r\n                ? 0\r\n                : createText(''));\r\n            const mainAnchor = (n2.anchor = ( false)\r\n                ? 0\r\n                : createText(''));\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(''));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                isSVG = isSVG || isTargetSVG(target);\r\n            }\r\n            else if (false) {}\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            isSVG = isSVG || isTargetSVG(target);\r\n            if (dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                    else if ((false)) {}\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\r\n        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\r\n        if (target) {\r\n            hostRemove(targetAnchor);\r\n        }\r\n        // an unmounted teleport should always remove its children if not disabled\r\n        if (doRemove || !isTeleportDisabled(props)) {\r\n            hostRemove(anchor);\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                for (let i = 0; i < children.length; i++) {\r\n                    const child = children[i];\r\n                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                // lookahead until we find the target anchor\r\n                // we cannot rely on return value of hydrateChildren() because there\r\n                // could be nested teleports\r\n                let targetAnchor = targetNode;\r\n                while (targetAnchor) {\r\n                    targetAnchor = nextSibling(targetAnchor);\r\n                    if (targetAnchor &&\r\n                        targetAnchor.nodeType === 8 &&\r\n                        targetAnchor.data === 'teleport anchor') {\r\n                        vnode.targetAnchor = targetAnchor;\r\n                        target._lpa =\r\n                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n                        break;\r\n                    }\r\n                }\r\n                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = (/* unused pure expression or super */ null && (TeleportImpl));\n\nconst runtime_core_esm_bundler_Fragment = Symbol(( false) ? 0 : undefined);\r\nconst Text = Symbol(( false) ? 0 : undefined);\r\nconst Comment = Symbol(( false) ? 0 : undefined);\r\nconst runtime_core_esm_bundler_Static = Symbol(( false) ? 0 : undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet isBlockTreeEnabled = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    isBlockTreeEnabled += value;\r\n}\r\nfunction setupBlock(vnode) {\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren =\r\n        isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (isBlockTreeEnabled > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\r\n    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    return setupBlock(runtime_core_esm_bundler_createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    if (false) {}\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\nlet vnodeArgsTransformer;\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n    vnodeArgsTransformer = transformer;\r\n}\r\nconst createVNodeWithArgsTransform = (...args) => {\r\n    return _createVNode(...(vnodeArgsTransformer\r\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n        : args));\r\n};\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref, ref_key, ref_for }) => {\r\n    return (ref != null\r\n        ? shared_esm_bundler_isString(ref) || reactivity_esm_bundler_isRef(ref) || shared_esm_bundler_isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n            : ref\r\n        : null);\r\n};\r\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === runtime_core_esm_bundler_Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        slotScopeIds: null,\r\n        children,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    if (needFullChildrenNormalization) {\r\n        normalizeChildren(vnode, children);\r\n        // normalize suspense children\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            type.normalize(vnode);\r\n        }\r\n    }\r\n    else if (children) {\r\n        // compiled element vnode - if children is passed, only possible types are\r\n        // string or Array.\r\n        vnode.shapeFlag |= shared_esm_bundler_isString(children)\r\n            ? 8 /* TEXT_CHILDREN */\r\n            : 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    // validate key\r\n    if (false) {}\r\n    // track vnode for block tree\r\n    if (isBlockTreeEnabled > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nconst runtime_core_esm_bundler_createVNode = (( false) ? 0 : _createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        if (false) {}\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\r\n            if (cloned.shapeFlag & 6 /* COMPONENT */) {\r\n                currentBlock[currentBlock.indexOf(type)] = cloned;\r\n            }\r\n            else {\r\n                currentBlock.push(cloned);\r\n            }\r\n        }\r\n        cloned.patchFlag |= -2 /* BAIL */;\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        props = guardReactiveProps(props);\r\n        let { class: klass, style } = props;\r\n        if (klass && !shared_esm_bundler_isString(klass)) {\r\n            props.class = normalizeClass(klass);\r\n        }\r\n        if (shared_esm_bundler_isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (isProxy(style) && !shared_esm_bundler_isArray(style)) {\r\n                style = shared_esm_bundler_extend({}, style);\r\n            }\r\n            props.style = normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = shared_esm_bundler_isString(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : shared_esm_bundler_isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : shared_esm_bundler_isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    if (false) {}\r\n    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\r\n}\r\nfunction guardReactiveProps(props) {\r\n    if (!props)\r\n        return null;\r\n    return isProxy(props) || InternalObjectKey in props\r\n        ? shared_esm_bundler_extend({}, props)\r\n        : props;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    const cloned = {\r\n        __v_isVNode: true,\r\n        __v_skip: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? shared_esm_bundler_isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        slotScopeIds: vnode.slotScopeIds,\r\n        children:  false\r\n            ? 0\r\n            : children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: preserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== runtime_core_esm_bundler_Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n    return cloned;\r\n}\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode) {\r\n    const cloned = cloneVNode(vnode);\r\n    if (isArray(vnode.children)) {\r\n        cloned.children = vnode.children.map(deepCloneVNode);\r\n    }\r\n    return cloned;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return runtime_core_esm_bundler_createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = '', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : runtime_core_esm_bundler_createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return runtime_core_esm_bundler_createVNode(Comment);\r\n    }\r\n    else if (shared_esm_bundler_isArray(child)) {\r\n        // fragment\r\n        return runtime_core_esm_bundler_createVNode(runtime_core_esm_bundler_Fragment, null, \r\n        // #3666, avoid reference pollution when reusing vnode\r\n        child.slice());\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return cloneIfMounted(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return runtime_core_esm_bundler_createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null || child.memo ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (shared_esm_bundler_isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && (slot._d = false);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && (slot._d = true);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n                else {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (shared_esm_bundler_isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = {};\r\n    for (let i = 0; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (shared_esm_bundler_isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (incoming &&\r\n                    existing !== incoming &&\r\n                    !(shared_esm_bundler_isArray(existing) && existing.includes(incoming))) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, incoming)\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        effect: null,\r\n        update: null,\r\n        scope: new EffectScope(true /* detached */),\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        exposeProxy: null,\r\n        withProxy: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resolved assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // props default value\r\n        propsDefaults: shared_esm_bundler_EMPTY_OBJ,\r\n        // inheritAttrs\r\n        inheritAttrs: type.inheritAttrs,\r\n        // state\r\n        ctx: shared_esm_bundler_EMPTY_OBJ,\r\n        data: shared_esm_bundler_EMPTY_OBJ,\r\n        props: shared_esm_bundler_EMPTY_OBJ,\r\n        attrs: shared_esm_bundler_EMPTY_OBJ,\r\n        slots: shared_esm_bundler_EMPTY_OBJ,\r\n        refs: shared_esm_bundler_EMPTY_OBJ,\r\n        setupState: shared_esm_bundler_EMPTY_OBJ,\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null,\r\n        sp: null\r\n    };\r\n    if ((false)) {}\r\n    else {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = emit$1.bind(null, instance);\r\n    // apply custom element special handling\r\n    if (vnode.ce) {\r\n        vnode.ce(instance);\r\n    }\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst runtime_core_esm_bundler_getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n    instance.scope.on();\r\n};\r\nconst unsetCurrentInstance = () => {\r\n    currentInstance && currentInstance.scope.off();\r\n    currentInstance = null;\r\n};\r\nconst isBuiltInTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (makeMap('slot,component')));\r\nfunction validateComponentName(name, config) {\r\n    const appIsNativeTag = config.isNativeTag || NO;\r\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n        runtime_core_esm_bundler_warn('Do not use built-in or reserved HTML elements as component id: ' + name);\r\n    }\r\n}\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    var _a;\r\n    const Component = instance.type;\r\n    if ((false)) {}\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it's never observed\r\n    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\r\n    if ((false)) {}\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        setCurrentInstance(instance);\r\n        pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? 0 : instance.props, setupContext]);\r\n        resetTracking();\r\n        unsetCurrentInstance();\r\n        if (shared_esm_bundler_isPromise(setupResult)) {\r\n            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult\r\n                    .then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult, isSSR);\r\n                })\r\n                    .catch(e => {\r\n                    handleError(e, instance, 0 /* SETUP_FUNCTION */);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n                if (false) {}\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult, isSSR);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance, isSSR);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (shared_esm_bundler_isFunction(setupResult)) {\r\n        // setup returned an inline render function\r\n        if (instance.type.__ssrInlineRender) {\r\n            // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n            // set it as ssrRender instead.\r\n            instance.ssrRender = setupResult;\r\n        }\r\n        else {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if (shared_esm_bundler_isObject(setupResult)) {\r\n        if (false) {}\r\n        // setup returned bindings.\r\n        // assuming a render function compiled from template is present.\r\n        if (( false) || __VUE_PROD_DEVTOOLS__) {\r\n            instance.devtoolsRawSetupState = setupResult;\r\n        }\r\n        instance.setupState = proxyRefs(setupResult);\r\n        if ((false)) {}\r\n    }\r\n    else if (false) {}\r\n    finishComponentSetup(instance, isSSR);\r\n}\r\nlet compile;\r\nlet installWithProxy;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n    installWithProxy = i => {\r\n        if (i.render._rc) {\r\n            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    };\r\n}\r\n// dev only\r\nconst runtime_core_esm_bundler_isRuntimeOnly = () => !compile;\r\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    // could be already set when returned from setup()\r\n    if (!instance.render) {\r\n        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n        // is done by server-renderer\r\n        if (!isSSR && compile && !Component.render) {\r\n            const template = Component.template;\r\n            if (template) {\r\n                if ((false)) {}\r\n                const { isCustomElement, compilerOptions } = instance.appContext.config;\r\n                const { delimiters, compilerOptions: componentCompilerOptions } = Component;\r\n                const finalCompilerOptions = shared_esm_bundler_extend(shared_esm_bundler_extend({\r\n                    isCustomElement,\r\n                    delimiters\r\n                }, compilerOptions), componentCompilerOptions);\r\n                Component.render = compile(template, finalCompilerOptions);\r\n                if ((false)) {}\r\n            }\r\n        }\r\n        instance.render = (Component.render || shared_esm_bundler_NOOP);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (installWithProxy) {\r\n            installWithProxy(instance);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    if (__VUE_OPTIONS_API__ && !(false )) {\r\n        setCurrentInstance(instance);\r\n        pauseTracking();\r\n        applyOptions(instance);\r\n        resetTracking();\r\n        unsetCurrentInstance();\r\n    }\r\n    // warn missing template/render\r\n    // the runtime compilation of template in SSR is done by server-render\r\n    if (false) {}\r\n}\r\nfunction createAttrsProxy(instance) {\r\n    return new Proxy(instance.attrs, ( false)\r\n        ? 0\r\n        : {\r\n            get(target, key) {\r\n                track(instance, \"get\" /* GET */, '$attrs');\r\n                return target[key];\r\n            }\r\n        });\r\n}\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        if (false) {}\r\n        instance.exposed = exposed || {};\r\n    };\r\n    let attrs;\r\n    if ((false)) {}\r\n    else {\r\n        return {\r\n            get attrs() {\r\n                return attrs || (attrs = createAttrsProxy(instance));\r\n            },\r\n            slots: instance.slots,\r\n            emit: instance.emit,\r\n            expose\r\n        };\r\n    }\r\n}\r\nfunction getExposeProxy(instance) {\r\n    if (instance.exposed) {\r\n        return (instance.exposeProxy ||\r\n            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n                get(target, key) {\r\n                    if (key in target) {\r\n                        return target[key];\r\n                    }\r\n                    else if (key in publicPropertiesMap) {\r\n                        return publicPropertiesMap[key](instance);\r\n                    }\r\n                }\r\n            })));\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component) {\r\n    return shared_esm_bundler_isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return shared_esm_bundler_isFunction(value) && '__vccOpts' in value;\r\n}\n\nconst runtime_core_esm_bundler_computed = ((getterOrOptions, debugOptions) => {\r\n    // @ts-ignore\r\n    return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);\r\n});\n\n// dev only\r\nconst warnRuntimeUsage = (method) => runtime_core_esm_bundler_warn(`${method}() is a compiler-hint helper that is only usable inside ` +\r\n    `<script setup> of a single file component. Its arguments should be ` +\r\n    `compiled away and passing it at runtime has no effect.`);\r\n// implementation\r\nfunction defineProps() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmits() {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's exposed\r\n * instance properties when it is accessed by a parent component via template\r\n * refs.\r\n *\r\n * `<script setup>` components are closed by default - i.e. variables inside\r\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\r\n * via `defineExpose`.\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n */\r\nfunction defineExpose(exposed) {\r\n    if ((false)) {}\r\n}\r\n/**\r\n * Vue `<script setup>` compiler macro for providing props default values when\r\n * using type-based `defineProps` declaration.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * withDefaults(defineProps<{\r\n *   size?: number\r\n *   labels?: string[]\r\n * }>(), {\r\n *   size: 3,\r\n *   labels: () => ['default label']\r\n * })\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the output\r\n * and should **not** be actually called at runtime.\r\n */\r\nfunction withDefaults(props, defaults) {\r\n    if ((false)) {}\r\n    return null;\r\n}\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\nfunction getContext() {\r\n    const i = runtime_core_esm_bundler_getCurrentInstance();\r\n    if (false) {}\r\n    return i.setupContext || (i.setupContext = createSetupContext(i));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    const props = isArray(raw)\r\n        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\r\n        : raw;\r\n    for (const key in defaults) {\r\n        const opt = props[key];\r\n        if (opt) {\r\n            if (isArray(opt) || isFunction(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else if ((false)) {}\r\n    }\r\n    return props;\r\n}\r\n/**\r\n * Used to create a proxy for the rest element when destructuring props with\r\n * defineProps().\r\n * @internal\r\n */\r\nfunction createPropsRestProxy(props, excludedKeys) {\r\n    const ret = {};\r\n    for (const key in props) {\r\n        if (!excludedKeys.includes(key)) {\r\n            Object.defineProperty(ret, key, {\r\n                enumerable: true,\r\n                get: () => props[key]\r\n            });\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * `<script setup>` helper for persisting the current instance context over\r\n * async/await flows.\r\n *\r\n * `@vue/compiler-sfc` converts the following:\r\n *\r\n * ```ts\r\n * const x = await foo()\r\n * ```\r\n *\r\n * into:\r\n *\r\n * ```ts\r\n * let __temp, __restore\r\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\r\n * ```\r\n * @internal\r\n */\r\nfunction withAsyncContext(getAwaitable) {\r\n    const ctx = runtime_core_esm_bundler_getCurrentInstance();\r\n    if (false) {}\r\n    let awaitable = getAwaitable();\r\n    unsetCurrentInstance();\r\n    if (isPromise(awaitable)) {\r\n        awaitable = awaitable.catch(e => {\r\n            setCurrentInstance(ctx);\r\n            throw e;\r\n        });\r\n    }\r\n    return [awaitable, () => setCurrentInstance(ctx)];\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if (shared_esm_bundler_isObject(propsOrChildren) && !shared_esm_bundler_isArray(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return runtime_core_esm_bundler_createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return runtime_core_esm_bundler_createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return runtime_core_esm_bundler_createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return runtime_core_esm_bundler_createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol(( false) ? 0 : ``);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            runtime_core_esm_bundler_warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSSRContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction runtime_core_esm_bundler_isShallow(value) {\r\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\r\n}\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    if (true) {\r\n        return;\r\n    }\r\n    const vueStyle = { style: 'color:#3ba776' };\r\n    const numberStyle = { style: 'color:#0b1bc9' };\r\n    const stringStyle = { style: 'color:#b62e24' };\r\n    const keywordStyle = { style: 'color:#9d288c' };\r\n    // custom formatter for Chrome\r\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n    const formatter = {\r\n        header(obj) {\r\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n            if (!isObject(obj)) {\r\n                return null;\r\n            }\r\n            if (obj.__isVue) {\r\n                return ['div', vueStyle, `VueInstance`];\r\n            }\r\n            else if (isRef(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, genRefFlag(obj)],\r\n                    '<',\r\n                    formatValue(obj.value),\r\n                    `>`\r\n                ];\r\n            }\r\n            else if (isReactive(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, runtime_core_esm_bundler_isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n                ];\r\n            }\r\n            else if (isReadonly(obj)) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ['span', vueStyle, runtime_core_esm_bundler_isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\r\n                    '<',\r\n                    formatValue(obj),\r\n                    '>'\r\n                ];\r\n            }\r\n            return null;\r\n        },\r\n        hasBody(obj) {\r\n            return obj && obj.__isVue;\r\n        },\r\n        body(obj) {\r\n            if (obj && obj.__isVue) {\r\n                return [\r\n                    'div',\r\n                    {},\r\n                    ...formatInstance(obj.$)\r\n                ];\r\n            }\r\n        }\r\n    };\r\n    function formatInstance(instance) {\r\n        const blocks = [];\r\n        if (instance.type.props && instance.props) {\r\n            blocks.push(createInstanceBlock('props', toRaw(instance.props)));\r\n        }\r\n        if (instance.setupState !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('setup', instance.setupState));\r\n        }\r\n        if (instance.data !== EMPTY_OBJ) {\r\n            blocks.push(createInstanceBlock('data', toRaw(instance.data)));\r\n        }\r\n        const computed = extractKeys(instance, 'computed');\r\n        if (computed) {\r\n            blocks.push(createInstanceBlock('computed', computed));\r\n        }\r\n        const injected = extractKeys(instance, 'inject');\r\n        if (injected) {\r\n            blocks.push(createInstanceBlock('injected', injected));\r\n        }\r\n        blocks.push([\r\n            'div',\r\n            {},\r\n            [\r\n                'span',\r\n                {\r\n                    style: keywordStyle.style + ';opacity:0.66'\r\n                },\r\n                '$ (internal): '\r\n            ],\r\n            ['object', { object: instance }]\r\n        ]);\r\n        return blocks;\r\n    }\r\n    function createInstanceBlock(type, target) {\r\n        target = extend({}, target);\r\n        if (!Object.keys(target).length) {\r\n            return ['span', {}];\r\n        }\r\n        return [\r\n            'div',\r\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'color:#476582'\r\n                },\r\n                type\r\n            ],\r\n            [\r\n                'div',\r\n                {\r\n                    style: 'padding-left:1.25em'\r\n                },\r\n                ...Object.keys(target).map(key => {\r\n                    return [\r\n                        'div',\r\n                        {},\r\n                        ['span', keywordStyle, key + ': '],\r\n                        formatValue(target[key], false)\r\n                    ];\r\n                })\r\n            ]\r\n        ];\r\n    }\r\n    function formatValue(v, asRaw = true) {\r\n        if (typeof v === 'number') {\r\n            return ['span', numberStyle, v];\r\n        }\r\n        else if (typeof v === 'string') {\r\n            return ['span', stringStyle, JSON.stringify(v)];\r\n        }\r\n        else if (typeof v === 'boolean') {\r\n            return ['span', keywordStyle, v];\r\n        }\r\n        else if (isObject(v)) {\r\n            return ['object', { object: asRaw ? toRaw(v) : v }];\r\n        }\r\n        else {\r\n            return ['span', stringStyle, String(v)];\r\n        }\r\n    }\r\n    function extractKeys(instance, type) {\r\n        const Comp = instance.type;\r\n        if (isFunction(Comp)) {\r\n            return;\r\n        }\r\n        const extracted = {};\r\n        for (const key in instance.ctx) {\r\n            if (isKeyOfType(Comp, key, type)) {\r\n                extracted[key] = instance.ctx[key];\r\n            }\r\n        }\r\n        return extracted;\r\n    }\r\n    function isKeyOfType(Comp, key, type) {\r\n        const opts = Comp[type];\r\n        if ((isArray(opts) && opts.includes(key)) ||\r\n            (isObject(opts) && key in opts)) {\r\n            return true;\r\n        }\r\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n            return true;\r\n        }\r\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n            return true;\r\n        }\r\n    }\r\n    function genRefFlag(v) {\r\n        if (runtime_core_esm_bundler_isShallow(v)) {\r\n            return `ShallowRef`;\r\n        }\r\n        if (v.effect) {\r\n            return `ComputedRef`;\r\n        }\r\n        return `Ref`;\r\n    }\r\n    if (window.devtoolsFormatters) {\r\n        window.devtoolsFormatters.push(formatter);\r\n    }\r\n    else {\r\n        window.devtoolsFormatters = [formatter];\r\n    }\r\n}\n\nfunction withMemo(memo, render, cache, index) {\r\n    const cached = cache[index];\r\n    if (cached && isMemoSame(cached, memo)) {\r\n        return cached;\r\n    }\r\n    const ret = render();\r\n    // shallow clone\r\n    ret.memo = memo.slice();\r\n    return (cache[index] = ret);\r\n}\r\nfunction isMemoSame(cached, memo) {\r\n    const prev = cached.memo;\r\n    if (prev.length != memo.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < prev.length; i++) {\r\n        if (hasChanged(prev[i], memo[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    // make sure to let parent block track it when returning cached\r\n    if (isBlockTreeEnabled > 0 && currentBlock) {\r\n        currentBlock.push(cached);\r\n    }\r\n    return true;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = \"3.2.36\";\r\nconst _ssrUtils = {\r\n    createComponentInstance,\r\n    setupComponent,\r\n    renderComponentRoot,\r\n    setCurrentRenderingInstance,\r\n    isVNode,\r\n    normalizeVNode\r\n};\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\r\nconst ssrUtils = ((/* unused pure expression or super */ null && (_ssrUtils)) );\r\n/**\r\n * @internal only exposed in compat builds\r\n */\r\nconst resolveFilter = null;\r\n/**\r\n * @internal only exposed in compat builds.\r\n */\r\nconst compatUtils = (null);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction shared_dist_shared_esm_bundler_makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst dist_shared_esm_bundler_PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst dist_shared_esm_bundler_slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst dist_shared_esm_bundler_GLOBALS_WHITE_LISTED = (/* unused pure expression or super */ null && ('Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'));\r\nconst dist_shared_esm_bundler_isGloballyWhitelisted = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_GLOBALS_WHITE_LISTED)));\n\nconst dist_shared_esm_bundler_range = 2;\r\nfunction dist_shared_esm_bundler_generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - dist_shared_esm_bundler_range; j <= i + dist_shared_esm_bundler_range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst dist_shared_esm_bundler_specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst dist_shared_esm_bundler_isSpecialBooleanAttr = /*#__PURE__*/ shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst dist_shared_esm_bundler_isBooleanAttr = /*#__PURE__*/ shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nfunction dist_shared_esm_bundler_includeBooleanAttr(value) {\r\n    return !!value || value === '';\r\n}\r\nconst dist_shared_esm_bundler_unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst dist_shared_esm_bundler_attrValidationCache = {};\r\nfunction dist_shared_esm_bundler_isSSRSafeAttrName(name) {\r\n    if (dist_shared_esm_bundler_attrValidationCache.hasOwnProperty(name)) {\r\n        return dist_shared_esm_bundler_attrValidationCache[name];\r\n    }\r\n    const isUnsafe = dist_shared_esm_bundler_unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (dist_shared_esm_bundler_attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst dist_shared_esm_bundler_propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst dist_shared_esm_bundler_isNoUnitNumericStyleProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`)));\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst dist_shared_esm_bundler_isKnownHtmlAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`)));\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nconst dist_shared_esm_bundler_isKnownSvgAttr = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`)));\n\nfunction dist_shared_esm_bundler_normalizeStyle(value) {\r\n    if (shared_dist_shared_esm_bundler_isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = shared_dist_shared_esm_bundler_isString(item)\r\n                ? dist_shared_esm_bundler_parseStringStyle(item)\r\n                : dist_shared_esm_bundler_normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isString(value)) {\r\n        return value;\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst dist_shared_esm_bundler_listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst dist_shared_esm_bundler_propertyDelimiterRE = /:(.+)/;\r\nfunction dist_shared_esm_bundler_parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(dist_shared_esm_bundler_listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(dist_shared_esm_bundler_propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction dist_shared_esm_bundler_stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles || shared_dist_shared_esm_bundler_isString(styles)) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : shared_dist_shared_esm_bundler_hyphenate(key);\r\n        if (shared_dist_shared_esm_bundler_isString(value) ||\r\n            (typeof value === 'number' && dist_shared_esm_bundler_isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction dist_shared_esm_bundler_normalizeClass(value) {\r\n    let res = '';\r\n    if (shared_dist_shared_esm_bundler_isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = dist_shared_esm_bundler_normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nfunction dist_shared_esm_bundler_normalizeProps(props) {\r\n    if (!props)\r\n        return null;\r\n    let { class: klass, style } = props;\r\n    if (klass && !shared_dist_shared_esm_bundler_isString(klass)) {\r\n        props.class = dist_shared_esm_bundler_normalizeClass(klass);\r\n    }\r\n    if (style) {\r\n        props.style = dist_shared_esm_bundler_normalizeStyle(style);\r\n    }\r\n    return props;\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst dist_shared_esm_bundler_HTML_TAGS = (/* unused pure expression or super */ null && ('html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot'));\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst dist_shared_esm_bundler_SVG_TAGS = (/* unused pure expression or super */ null && ('svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view'));\r\nconst dist_shared_esm_bundler_VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst shared_dist_shared_esm_bundler_isHTMLTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_HTML_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst shared_dist_shared_esm_bundler_isSVGTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_SVG_TAGS)));\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst dist_shared_esm_bundler_isVoidTag = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(dist_shared_esm_bundler_VOID_TAGS)));\n\nconst dist_shared_esm_bundler_escapeRE = /[\"'&<>]/;\r\nfunction dist_shared_esm_bundler_escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = dist_shared_esm_bundler_escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.slice(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst dist_shared_esm_bundler_commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction dist_shared_esm_bundler_escapeHtmlComment(src) {\r\n    return src.replace(dist_shared_esm_bundler_commentStripRE, '');\r\n}\n\nfunction dist_shared_esm_bundler_looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = shared_dist_shared_esm_bundler_looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction shared_dist_shared_esm_bundler_looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = dist_shared_esm_bundler_isDate(a);\r\n    let bValidType = dist_shared_esm_bundler_isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = dist_shared_esm_bundler_isSymbol(a);\r\n    bValidType = dist_shared_esm_bundler_isSymbol(b);\r\n    if (aValidType || bValidType) {\r\n        return a === b;\r\n    }\r\n    aValidType = shared_dist_shared_esm_bundler_isArray(a);\r\n    bValidType = shared_dist_shared_esm_bundler_isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? dist_shared_esm_bundler_looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = shared_dist_shared_esm_bundler_isObject(a);\r\n    bValidType = shared_dist_shared_esm_bundler_isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !shared_dist_shared_esm_bundler_looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction shared_dist_shared_esm_bundler_looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => shared_dist_shared_esm_bundler_looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst dist_shared_esm_bundler_toDisplayString = (val) => {\r\n    return shared_dist_shared_esm_bundler_isString(val)\r\n        ? val\r\n        : val == null\r\n            ? ''\r\n            : shared_dist_shared_esm_bundler_isArray(val) ||\r\n                (shared_dist_shared_esm_bundler_isObject(val) &&\r\n                    (val.toString === dist_shared_esm_bundler_objectToString || !shared_dist_shared_esm_bundler_isFunction(val.toString)))\r\n                ? JSON.stringify(val, dist_shared_esm_bundler_replacer, 2)\r\n                : String(val);\r\n};\r\nconst dist_shared_esm_bundler_replacer = (_key, val) => {\r\n    // can't use isRef here since @vue/shared has no deps\r\n    if (val && val.__v_isRef) {\r\n        return dist_shared_esm_bundler_replacer(_key, val.value);\r\n    }\r\n    else if (dist_shared_esm_bundler_isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isObject(val) && !shared_dist_shared_esm_bundler_isArray(val) && !dist_shared_esm_bundler_isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\nconst shared_dist_shared_esm_bundler_EMPTY_OBJ = ( false)\r\n    ? 0\r\n    : {};\r\nconst dist_shared_esm_bundler_EMPTY_ARR = ( false) ? 0 : [];\r\nconst shared_dist_shared_esm_bundler_NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst shared_dist_shared_esm_bundler_NO = () => false;\r\nconst dist_shared_esm_bundler_onRE = /^on[^a-z]/;\r\nconst shared_dist_shared_esm_bundler_isOn = (key) => dist_shared_esm_bundler_onRE.test(key);\r\nconst dist_shared_esm_bundler_isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst shared_dist_shared_esm_bundler_extend = Object.assign;\r\nconst dist_shared_esm_bundler_remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst shared_dist_shared_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst shared_dist_shared_esm_bundler_hasOwn = (val, key) => shared_dist_shared_esm_bundler_hasOwnProperty.call(val, key);\r\nconst shared_dist_shared_esm_bundler_isArray = Array.isArray;\r\nconst dist_shared_esm_bundler_isMap = (val) => dist_shared_esm_bundler_toTypeString(val) === '[object Map]';\r\nconst shared_dist_shared_esm_bundler_isSet = (val) => dist_shared_esm_bundler_toTypeString(val) === '[object Set]';\r\nconst dist_shared_esm_bundler_isDate = (val) => dist_shared_esm_bundler_toTypeString(val) === '[object Date]';\r\nconst shared_dist_shared_esm_bundler_isFunction = (val) => typeof val === 'function';\r\nconst shared_dist_shared_esm_bundler_isString = (val) => typeof val === 'string';\r\nconst dist_shared_esm_bundler_isSymbol = (val) => typeof val === 'symbol';\r\nconst shared_dist_shared_esm_bundler_isObject = (val) => val !== null && typeof val === 'object';\r\nconst shared_dist_shared_esm_bundler_isPromise = (val) => {\r\n    return shared_dist_shared_esm_bundler_isObject(val) && shared_dist_shared_esm_bundler_isFunction(val.then) && shared_dist_shared_esm_bundler_isFunction(val.catch);\r\n};\r\nconst dist_shared_esm_bundler_objectToString = Object.prototype.toString;\r\nconst dist_shared_esm_bundler_toTypeString = (value) => dist_shared_esm_bundler_objectToString.call(value);\r\nconst shared_dist_shared_esm_bundler_toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return dist_shared_esm_bundler_toTypeString(value).slice(8, -1);\r\n};\r\nconst dist_shared_esm_bundler_isPlainObject = (val) => dist_shared_esm_bundler_toTypeString(val) === '[object Object]';\r\nconst dist_shared_esm_bundler_isIntegerKey = (key) => shared_dist_shared_esm_bundler_isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst shared_dist_shared_esm_bundler_isReservedProp = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted')));\r\nconst shared_dist_shared_esm_bundler_isBuiltInDirective = /*#__PURE__*/ (/* unused pure expression or super */ null && (shared_dist_shared_esm_bundler_makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo')));\r\nconst dist_shared_esm_bundler_cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst dist_shared_esm_bundler_camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst dist_shared_esm_bundler_camelize = dist_shared_esm_bundler_cacheStringFunction((str) => {\r\n    return str.replace(dist_shared_esm_bundler_camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst dist_shared_esm_bundler_hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst shared_dist_shared_esm_bundler_hyphenate = dist_shared_esm_bundler_cacheStringFunction((str) => str.replace(dist_shared_esm_bundler_hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst shared_dist_shared_esm_bundler_capitalize = dist_shared_esm_bundler_cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst shared_dist_shared_esm_bundler_toHandlerKey = dist_shared_esm_bundler_cacheStringFunction((str) => str ? `on${shared_dist_shared_esm_bundler_capitalize(str)}` : ``);\r\n// compare whether a value has changed, accounting for NaN.\r\nconst shared_dist_shared_esm_bundler_hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst dist_shared_esm_bundler_invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst dist_shared_esm_bundler_def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst shared_dist_shared_esm_bundler_toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet dist_shared_esm_bundler_globalThis;\r\nconst dist_shared_esm_bundler_getGlobalThis = () => {\r\n    return (dist_shared_esm_bundler_globalThis ||\r\n        (dist_shared_esm_bundler_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof __webpack_require__.g !== 'undefined'\r\n                            ? __webpack_require__.g\r\n                            : {}));\r\n};\r\nconst dist_shared_esm_bundler_identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\r\nfunction dist_shared_esm_bundler_genPropsAccessExp(name) {\r\n    return dist_shared_esm_bundler_identRE.test(name)\r\n        ? `__props.${name}`\r\n        : `__props[${JSON.stringify(name)}]`;\r\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n\n\n\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template');\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is, props) => {\r\n        const el = isSVG\r\n            ? doc.createElementNS(svgNS, tag)\r\n            : doc.createElement(tag, is ? { is } : undefined);\r\n        if (tag === 'select' && props && props.multiple != null) {\r\n            el.setAttribute('multiple', props.multiple);\r\n        }\r\n        return el;\r\n    },\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        const cloned = el.cloneNode(true);\r\n        // #3072\r\n        // - in `patchDOMProp`, we store the actual value in the `el._value` property.\r\n        // - normally, elements using `:value` bindings will not be hoisted, but if\r\n        //   the bound value is a constant, e.g. `:value=\"true\"` - they do get\r\n        //   hoisted.\r\n        // - in production, hoisted nodes are cloned when subsequent inserts, but\r\n        //   cloneNode() does not copy the custom property we attached.\r\n        // - This may need to account for other custom DOM properties we attach to\r\n        //   elements in addition to `_value` in the future.\r\n        if (`_value` in el) {\r\n            cloned._value = el._value;\r\n        }\r\n        return cloned;\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG, start, end) {\r\n        // <parent> before | first ... last | anchor </parent>\r\n        const before = anchor ? anchor.previousSibling : parent.lastChild;\r\n        // #5308 can only take cached path if:\r\n        // - has a single root node\r\n        // - nextSibling info is still available\r\n        if (start && (start === end || start.nextSibling)) {\r\n            // cached\r\n            while (true) {\r\n                parent.insertBefore(start.cloneNode(true), anchor);\r\n                if (start === end || !(start = start.nextSibling))\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            // fresh insert\r\n            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\r\n            const template = templateContainer.content;\r\n            if (isSVG) {\r\n                // remove outer svg wrapper\r\n                const wrapper = template.firstChild;\r\n                while (wrapper.firstChild) {\r\n                    template.appendChild(wrapper.firstChild);\r\n                }\r\n                template.removeChild(wrapper);\r\n            }\r\n            parent.insertBefore(template, anchor);\r\n        }\r\n        return [\r\n            // first\r\n            before ? before.nextSibling : parent.firstChild,\r\n            // last\r\n            anchor ? anchor.previousSibling : parent.lastChild\r\n        ];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    // directly setting className should be faster than setAttribute in theory\r\n    // if this is an element during a transition, take the temporary transition\r\n    // classes into account.\r\n    const transitionClasses = el._vtc;\r\n    if (transitionClasses) {\r\n        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\r\n    }\r\n    if (value == null) {\r\n        el.removeAttribute('class');\r\n    }\r\n    else if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    const isCssString = shared_dist_shared_esm_bundler_isString(next);\r\n    if (next && !isCssString) {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !shared_dist_shared_esm_bundler_isString(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const currentDisplay = style.display;\r\n        if (isCssString) {\r\n            if (prev !== next) {\r\n                style.cssText = next;\r\n            }\r\n        }\r\n        else if (prev) {\r\n            el.removeAttribute('style');\r\n        }\r\n        // indicates that the `display` of the element is controlled by `v-show`,\r\n        // so we always keep the current `display` value regardless of the `style`\r\n        // value, thus handing over control to `v-show`.\r\n        if ('_vod' in el) {\r\n            style.display = currentDisplay;\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (shared_dist_shared_esm_bundler_isArray(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (val == null)\r\n            val = '';\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(shared_dist_shared_esm_bundler_hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = camelize(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = shared_dist_shared_esm_bundler_capitalize(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG, instance) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = dist_shared_esm_bundler_isSpecialBooleanAttr(key);\r\n        if (value == null || (isBoolean && !dist_shared_esm_bundler_includeBooleanAttr(value))) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' &&\r\n        el.tagName !== 'PROGRESS' &&\r\n        // custom elements may use _value internally\r\n        !el.tagName.includes('-')) {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue ||\r\n            // #4956: always set for OPTION elements because its value falls back to\r\n            // textContent if no value attribute is present. And setting .value for\r\n            // OPTION has no side effect\r\n            el.tagName === 'OPTION') {\r\n            el.value = newValue;\r\n        }\r\n        if (value == null) {\r\n            el.removeAttribute(key);\r\n        }\r\n        return;\r\n    }\r\n    let needRemove = false;\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            value = dist_shared_esm_bundler_includeBooleanAttr(value);\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            value = '';\r\n            needRemove = true;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error\r\n            value = 0;\r\n            needRemove = true;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw,\r\n    // some properties has getter, no setter, will error in 'use strict'\r\n    // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n        if ((false)) {}\r\n    }\r\n    needRemove && el.removeAttribute(key);\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nconst [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {\r\n    let _getNow = Date.now;\r\n    let skipTimestampCheck = false;\r\n    if (typeof window !== 'undefined') {\r\n        // Determine what event timestamp the browser is using. Annoyingly, the\r\n        // timestamp can either be hi-res (relative to page load) or low-res\r\n        // (relative to UNIX epoch), so in order to compare time we have to use the\r\n        // same timestamp type when saving the flush timestamp.\r\n        if (Date.now() > document.createEvent('Event').timeStamp) {\r\n            // if the low-res timestamp which is bigger than the event timestamp\r\n            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n            // and we need to use the hi-res version for event listeners as well.\r\n            _getNow = performance.now.bind(performance);\r\n        }\r\n        // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation\r\n        // and does not fire microtasks in between event propagation, so safe to exclude.\r\n        const ffMatch = navigator.userAgent.match(/firefox\\/(\\d+)/i);\r\n        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);\r\n    }\r\n    return [_getNow, skipTimestampCheck];\r\n})();\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = /*#__PURE__*/ Promise.resolve();\r\nconst runtime_dom_esm_bundler_reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(runtime_dom_esm_bundler_reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [shared_dist_shared_esm_bundler_hyphenate(name.slice(2)), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {\r\n            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (shared_dist_shared_esm_bundler_isArray(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    if (key === 'class') {\r\n        patchClass(el, nextValue, isSVG);\r\n    }\r\n    else if (key === 'style') {\r\n        patchStyle(el, prevValue, nextValue);\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isOn(key)) {\r\n        // ignore v-model listeners\r\n        if (!dist_shared_esm_bundler_isModelListener(key)) {\r\n            patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n        }\r\n    }\r\n    else if (key[0] === '.'\r\n        ? ((key = key.slice(1)), true)\r\n        : key[0] === '^'\r\n            ? ((key = key.slice(1)), false)\r\n            : shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n    }\r\n    else {\r\n        // special case for <input v-model type=\"checkbox\"> with\r\n        // :true-value & :false-value\r\n        // store value as dom properties since non-string values will be\r\n        // stringified.\r\n        if (key === 'true-value') {\r\n            el._trueValue = nextValue;\r\n        }\r\n        else if (key === 'false-value') {\r\n            el._falseValue = nextValue;\r\n        }\r\n        patchAttr(el, key, nextValue, isSVG);\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML & textContent\r\n        if (key === 'innerHTML' || key === 'textContent') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && shared_dist_shared_esm_bundler_isFunction(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // these are enumerated attrs, however their corresponding DOM properties\r\n    // are actually booleans - this leads to setting it with a string \"false\"\r\n    // value leading it to be coerced to `true`, so we need to always treat\r\n    // them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\r\n        return false;\r\n    }\r\n    // #1787, #2840 form property on form elements is readonly and must be set as\r\n    // attribute.\r\n    if (key === 'form') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // #2766 <textarea type> must be set as attribute\r\n    if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && shared_dist_shared_esm_bundler_isString(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nfunction defineCustomElement(options, hydrate) {\r\n    const Comp = defineComponent(options);\r\n    class VueCustomElement extends VueElement {\r\n        constructor(initialProps) {\r\n            super(Comp, initialProps, hydrate);\r\n        }\r\n    }\r\n    VueCustomElement.def = Comp;\r\n    return VueCustomElement;\r\n}\r\nconst defineSSRCustomElement = ((options) => {\r\n    // @ts-ignore\r\n    return defineCustomElement(options, hydrate);\r\n});\r\nconst BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {\r\n});\r\nclass VueElement extends (/* unused pure expression or super */ null && (BaseClass)) {\r\n    constructor(_def, _props = {}, hydrate) {\r\n        super();\r\n        this._def = _def;\r\n        this._props = _props;\r\n        /**\r\n         * @internal\r\n         */\r\n        this._instance = null;\r\n        this._connected = false;\r\n        this._resolved = false;\r\n        this._numberProps = null;\r\n        if (this.shadowRoot && hydrate) {\r\n            hydrate(this._createVNode(), this.shadowRoot);\r\n        }\r\n        else {\r\n            if (false) {}\r\n            this.attachShadow({ mode: 'open' });\r\n        }\r\n    }\r\n    connectedCallback() {\r\n        this._connected = true;\r\n        if (!this._instance) {\r\n            this._resolveDef();\r\n        }\r\n    }\r\n    disconnectedCallback() {\r\n        this._connected = false;\r\n        nextTick(() => {\r\n            if (!this._connected) {\r\n                render(null, this.shadowRoot);\r\n                this._instance = null;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * resolve inner component definition (handle possible async component)\r\n     */\r\n    _resolveDef() {\r\n        if (this._resolved) {\r\n            return;\r\n        }\r\n        this._resolved = true;\r\n        // set initial attrs\r\n        for (let i = 0; i < this.attributes.length; i++) {\r\n            this._setAttr(this.attributes[i].name);\r\n        }\r\n        // watch future attr changes\r\n        new MutationObserver(mutations => {\r\n            for (const m of mutations) {\r\n                this._setAttr(m.attributeName);\r\n            }\r\n        }).observe(this, { attributes: true });\r\n        const resolve = (def) => {\r\n            const { props, styles } = def;\r\n            const hasOptions = !isArray(props);\r\n            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];\r\n            // cast Number-type props set before resolve\r\n            let numberProps;\r\n            if (hasOptions) {\r\n                for (const key in this._props) {\r\n                    const opt = props[key];\r\n                    if (opt === Number || (opt && opt.type === Number)) {\r\n                        this._props[key] = toNumber(this._props[key]);\r\n                        (numberProps || (numberProps = Object.create(null)))[key] = true;\r\n                    }\r\n                }\r\n            }\r\n            this._numberProps = numberProps;\r\n            // check if there are props set pre-upgrade or connect\r\n            for (const key of Object.keys(this)) {\r\n                if (key[0] !== '_') {\r\n                    this._setProp(key, this[key], true, false);\r\n                }\r\n            }\r\n            // defining getter/setters on prototype\r\n            for (const key of rawKeys.map(camelize$1)) {\r\n                Object.defineProperty(this, key, {\r\n                    get() {\r\n                        return this._getProp(key);\r\n                    },\r\n                    set(val) {\r\n                        this._setProp(key, val);\r\n                    }\r\n                });\r\n            }\r\n            // apply CSS\r\n            this._applyStyles(styles);\r\n            // initial render\r\n            this._update();\r\n        };\r\n        const asyncDef = this._def.__asyncLoader;\r\n        if (asyncDef) {\r\n            asyncDef().then(resolve);\r\n        }\r\n        else {\r\n            resolve(this._def);\r\n        }\r\n    }\r\n    _setAttr(key) {\r\n        let value = this.getAttribute(key);\r\n        if (this._numberProps && this._numberProps[key]) {\r\n            value = toNumber(value);\r\n        }\r\n        this._setProp(camelize$1(key), value, false);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _getProp(key) {\r\n        return this._props[key];\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\r\n        if (val !== this._props[key]) {\r\n            this._props[key] = val;\r\n            if (shouldUpdate && this._instance) {\r\n                this._update();\r\n            }\r\n            // reflect\r\n            if (shouldReflect) {\r\n                if (val === true) {\r\n                    this.setAttribute(hyphenate(key), '');\r\n                }\r\n                else if (typeof val === 'string' || typeof val === 'number') {\r\n                    this.setAttribute(hyphenate(key), val + '');\r\n                }\r\n                else if (!val) {\r\n                    this.removeAttribute(hyphenate(key));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _update() {\r\n        render(this._createVNode(), this.shadowRoot);\r\n    }\r\n    _createVNode() {\r\n        const vnode = createVNode(this._def, extend({}, this._props));\r\n        if (!this._instance) {\r\n            vnode.ce = instance => {\r\n                this._instance = instance;\r\n                instance.isCE = true;\r\n                // HMR\r\n                if ((false)) {}\r\n                // intercept emit\r\n                instance.emit = (event, ...args) => {\r\n                    this.dispatchEvent(new CustomEvent(event, {\r\n                        detail: args\r\n                    }));\r\n                };\r\n                // locate nearest Vue custom element parent for provide/inject\r\n                let parent = this;\r\n                while ((parent =\r\n                    parent && (parent.parentNode || parent.host))) {\r\n                    if (parent instanceof VueElement) {\r\n                        instance.parent = parent._instance;\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return vnode;\r\n    }\r\n    _applyStyles(styles) {\r\n        if (styles) {\r\n            styles.forEach(css => {\r\n                const s = document.createElement('style');\r\n                s.textContent = css;\r\n                this.shadowRoot.appendChild(s);\r\n                // record for HMR\r\n                if ((false)) {}\r\n            });\r\n        }\r\n    }\r\n}\n\nfunction useCssModule(name = '$style') {\r\n    /* istanbul ignore else */\r\n    {\r\n        const instance = getCurrentInstance();\r\n        if (!instance) {\r\n            ( false) && 0;\r\n            return EMPTY_OBJ;\r\n        }\r\n        const modules = instance.type.__cssModules;\r\n        if (!modules) {\r\n            ( false) && 0;\r\n            return EMPTY_OBJ;\r\n        }\r\n        const mod = modules[name];\r\n        if (!mod) {\r\n            ( false) &&\r\n                0;\r\n            return EMPTY_OBJ;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    const instance = getCurrentInstance();\r\n    /* istanbul ignore next */\r\n    if (!instance) {\r\n        ( false) &&\r\n            0;\r\n        return;\r\n    }\r\n    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));\r\n    watchPostEffect(setVars);\r\n    onMounted(() => {\r\n        const ob = new MutationObserver(setVars);\r\n        ob.observe(instance.subTree.el.parentNode, { childList: true });\r\n        onUnmounted(() => ob.disconnect());\r\n    });\r\n}\r\nfunction setVarsOnVNode(vnode, vars) {\r\n    if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        const suspense = vnode.suspense;\r\n        vnode = suspense.activeBranch;\r\n        if (suspense.pendingBranch && !suspense.isHydrating) {\r\n            suspense.effects.push(() => {\r\n                setVarsOnVNode(suspense.activeBranch, vars);\r\n            });\r\n        }\r\n    }\r\n    // drill down HOCs until it's a non-component vnode\r\n    while (vnode.component) {\r\n        vnode = vnode.component.subTree;\r\n    }\r\n    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {\r\n        setVarsOnNode(vnode.el, vars);\r\n    }\r\n    else if (vnode.type === Fragment) {\r\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\r\n    }\r\n    else if (vnode.type === Static) {\r\n        let { el, anchor } = vnode;\r\n        while (el) {\r\n            setVarsOnNode(el, vars);\r\n            if (el === anchor)\r\n                break;\r\n            el = el.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction setVarsOnNode(el, vars) {\r\n    if (el.nodeType === 1) {\r\n        const style = el.style;\r\n        for (const key in vars) {\r\n            style.setProperty(`--${key}`, vars[key]);\r\n        }\r\n    }\r\n}\n\nconst TRANSITION = 'transition';\r\nconst ANIMATION = 'animation';\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nconst Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\r\nTransition.displayName = 'Transition';\r\nconst DOMTransitionPropsValidators = {\r\n    name: String,\r\n    type: String,\r\n    css: {\r\n        type: Boolean,\r\n        default: true\r\n    },\r\n    duration: [String, Number, Object],\r\n    enterFromClass: String,\r\n    enterActiveClass: String,\r\n    enterToClass: String,\r\n    appearFromClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    leaveFromClass: String,\r\n    leaveActiveClass: String,\r\n    leaveToClass: String\r\n};\r\nconst TransitionPropsValidators = (Transition.props =\r\n    /*#__PURE__*/ shared_dist_shared_esm_bundler_extend({}, BaseTransition.props, DOMTransitionPropsValidators));\r\n/**\r\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\r\n * with custom HOCs.\r\n */\r\nconst runtime_dom_esm_bundler_callHook = (hook, args = []) => {\r\n    if (shared_dist_shared_esm_bundler_isArray(hook)) {\r\n        hook.forEach(h => h(...args));\r\n    }\r\n    else if (hook) {\r\n        hook(...args);\r\n    }\r\n};\r\n/**\r\n * Check if a hook expects a callback (2nd arg), which means the user\r\n * intends to explicitly control the end of the transition.\r\n */\r\nconst hasExplicitCallback = (hook) => {\r\n    return hook\r\n        ? shared_dist_shared_esm_bundler_isArray(hook)\r\n            ? hook.some(h => h.length > 1)\r\n            : hook.length > 1\r\n        : false;\r\n};\r\nfunction resolveTransitionProps(rawProps) {\r\n    const baseProps = {};\r\n    for (const key in rawProps) {\r\n        if (!(key in DOMTransitionPropsValidators)) {\r\n            baseProps[key] = rawProps[key];\r\n        }\r\n    }\r\n    if (rawProps.css === false) {\r\n        return baseProps;\r\n    }\r\n    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n    const durations = normalizeDuration(duration);\r\n    const enterDuration = durations && durations[0];\r\n    const leaveDuration = durations && durations[1];\r\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n    const finishEnter = (el, isAppear, done) => {\r\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n        done && done();\r\n    };\r\n    const finishLeave = (el, done) => {\r\n        el._isLeaving = false;\r\n        removeTransitionClass(el, leaveFromClass);\r\n        removeTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveActiveClass);\r\n        done && done();\r\n    };\r\n    const makeEnterHook = (isAppear) => {\r\n        return (el, done) => {\r\n            const hook = isAppear ? onAppear : onEnter;\r\n            const resolve = () => finishEnter(el, isAppear, done);\r\n            runtime_dom_esm_bundler_callHook(hook, [el, resolve]);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                if (!hasExplicitCallback(hook)) {\r\n                    whenTransitionEnds(el, type, enterDuration, resolve);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    return shared_dist_shared_esm_bundler_extend(baseProps, {\r\n        onBeforeEnter(el) {\r\n            runtime_dom_esm_bundler_callHook(onBeforeEnter, [el]);\r\n            addTransitionClass(el, enterFromClass);\r\n            addTransitionClass(el, enterActiveClass);\r\n        },\r\n        onBeforeAppear(el) {\r\n            runtime_dom_esm_bundler_callHook(onBeforeAppear, [el]);\r\n            addTransitionClass(el, appearFromClass);\r\n            addTransitionClass(el, appearActiveClass);\r\n        },\r\n        onEnter: makeEnterHook(false),\r\n        onAppear: makeEnterHook(true),\r\n        onLeave(el, done) {\r\n            el._isLeaving = true;\r\n            const resolve = () => finishLeave(el, done);\r\n            addTransitionClass(el, leaveFromClass);\r\n            // force reflow so *-leave-from classes immediately take effect (#2593)\r\n            forceReflow();\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                if (!el._isLeaving) {\r\n                    // cancelled\r\n                    return;\r\n                }\r\n                removeTransitionClass(el, leaveFromClass);\r\n                addTransitionClass(el, leaveToClass);\r\n                if (!hasExplicitCallback(onLeave)) {\r\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                }\r\n            });\r\n            runtime_dom_esm_bundler_callHook(onLeave, [el, resolve]);\r\n        },\r\n        onEnterCancelled(el) {\r\n            finishEnter(el, false);\r\n            runtime_dom_esm_bundler_callHook(onEnterCancelled, [el]);\r\n        },\r\n        onAppearCancelled(el) {\r\n            finishEnter(el, true);\r\n            runtime_dom_esm_bundler_callHook(onAppearCancelled, [el]);\r\n        },\r\n        onLeaveCancelled(el) {\r\n            finishLeave(el);\r\n            runtime_dom_esm_bundler_callHook(onLeaveCancelled, [el]);\r\n        }\r\n    });\r\n}\r\nfunction normalizeDuration(duration) {\r\n    if (duration == null) {\r\n        return null;\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isObject(duration)) {\r\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n    }\r\n    else {\r\n        const n = NumberOf(duration);\r\n        return [n, n];\r\n    }\r\n}\r\nfunction NumberOf(val) {\r\n    const res = shared_dist_shared_esm_bundler_toNumber(val);\r\n    if ((false))\r\n        {}\r\n    return res;\r\n}\r\nfunction validateDuration(val) {\r\n    if (typeof val !== 'number') {\r\n        warn(`<transition> explicit duration is not a valid number - ` +\r\n            `got ${JSON.stringify(val)}.`);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn(`<transition> explicit duration is NaN - ` +\r\n            'the duration expression might be incorrect.');\r\n    }\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n    (el._vtc ||\r\n        (el._vtc = new Set())).add(cls);\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n    const { _vtc } = el;\r\n    if (_vtc) {\r\n        _vtc.delete(cls);\r\n        if (!_vtc.size) {\r\n            el._vtc = undefined;\r\n        }\r\n    }\r\n}\r\nfunction nextFrame(cb) {\r\n    requestAnimationFrame(() => {\r\n        requestAnimationFrame(cb);\r\n    });\r\n}\r\nlet endId = 0;\r\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n    const id = (el._endId = ++endId);\r\n    const resolveIfNotStale = () => {\r\n        if (id === el._endId) {\r\n            resolve();\r\n        }\r\n    };\r\n    if (explicitTimeout) {\r\n        return setTimeout(resolveIfNotStale, explicitTimeout);\r\n    }\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type) {\r\n        return resolve();\r\n    }\r\n    const endEvent = type + 'end';\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(endEvent, onEnd);\r\n        resolveIfNotStale();\r\n    };\r\n    const onEnd = (e) => {\r\n        if (e.target === el && ++ended >= propCount) {\r\n            end();\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(endEvent, onEnd);\r\n}\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const getStyleProperties = (key) => (styles[key] || '').split(', ');\r\n    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');\r\n    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = getStyleProperties(ANIMATION + 'Delay');\r\n    const animationDurations = getStyleProperties(ANIMATION + 'Duration');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type = null;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION &&\r\n        /\\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\r\n// synchronously force layout to put elements into a certain state\r\nfunction forceReflow() {\r\n    return document.body.offsetHeight;\r\n}\n\nconst positionMap = new WeakMap();\r\nconst newPositionMap = new WeakMap();\r\nconst TransitionGroupImpl = {\r\n    name: 'TransitionGroup',\r\n    props: /*#__PURE__*/ shared_dist_shared_esm_bundler_extend({}, TransitionPropsValidators, {\r\n        tag: String,\r\n        moveClass: String\r\n    }),\r\n    setup(props, { slots }) {\r\n        const instance = runtime_core_esm_bundler_getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevChildren;\r\n        let children;\r\n        onUpdated(() => {\r\n            // children is guaranteed to exist after initial render\r\n            if (!prevChildren.length) {\r\n                return;\r\n            }\r\n            const moveClass = props.moveClass || `${props.name || 'v'}-move`;\r\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                return;\r\n            }\r\n            // we divide the work into three loops to avoid mixing DOM reads and writes\r\n            // in each iteration - which helps prevent layout thrashing.\r\n            prevChildren.forEach(callPendingCbs);\r\n            prevChildren.forEach(recordPosition);\r\n            const movedChildren = prevChildren.filter(applyTranslation);\r\n            // force reflow to put everything in position\r\n            forceReflow();\r\n            movedChildren.forEach(c => {\r\n                const el = c.el;\r\n                const style = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                style.transform = style.webkitTransform = style.transitionDuration = '';\r\n                const cb = (el._moveCb = (e) => {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener('transitionend', cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                });\r\n                el.addEventListener('transitionend', cb);\r\n            });\r\n        });\r\n        return () => {\r\n            const rawProps = reactivity_esm_bundler_toRaw(props);\r\n            const cssTransitionProps = resolveTransitionProps(rawProps);\r\n            let tag = rawProps.tag || runtime_core_esm_bundler_Fragment;\r\n            prevChildren = children;\r\n            children = slots.default ? getTransitionRawChildren(slots.default()) : [];\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child.key != null) {\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                }\r\n                else if ((false)) {}\r\n            }\r\n            if (prevChildren) {\r\n                for (let i = 0; i < prevChildren.length; i++) {\r\n                    const child = prevChildren[i];\r\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                    positionMap.set(child, child.el.getBoundingClientRect());\r\n                }\r\n            }\r\n            return runtime_core_esm_bundler_createVNode(tag, null, children);\r\n        };\r\n    }\r\n};\r\nconst TransitionGroup = (/* unused pure expression or super */ null && (TransitionGroupImpl));\r\nfunction callPendingCbs(c) {\r\n    const el = c.el;\r\n    if (el._moveCb) {\r\n        el._moveCb();\r\n    }\r\n    if (el._enterCb) {\r\n        el._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    newPositionMap.set(c, c.el.getBoundingClientRect());\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = positionMap.get(c);\r\n    const newPos = newPositionMap.get(c);\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        const s = c.el.style;\r\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = '0s';\r\n        return c;\r\n    }\r\n}\r\nfunction hasCSSTransform(el, root, moveClass) {\r\n    // Detect whether an element with the move class applied has\r\n    // CSS transitions. Since the element may be inside an entering\r\n    // transition at this very moment, we make a clone of it and remove\r\n    // all other transition classes applied to ensure only the move class\r\n    // is applied.\r\n    const clone = el.cloneNode();\r\n    if (el._vtc) {\r\n        el._vtc.forEach(cls => {\r\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n        });\r\n    }\r\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n    clone.style.display = 'none';\r\n    const container = (root.nodeType === 1 ? root : root.parentNode);\r\n    container.appendChild(clone);\r\n    const { hasTransform } = getTransitionInfo(clone);\r\n    container.removeChild(clone);\r\n    return hasTransform;\r\n}\n\nconst getModelAssigner = (vnode) => {\r\n    const fn = vnode.props['onUpdate:modelValue'] ||\r\n        (false );\r\n    return shared_dist_shared_esm_bundler_isArray(fn) ? value => dist_shared_esm_bundler_invokeArrayFns(fn, value) : fn;\r\n};\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    const target = e.target;\r\n    if (target.composing) {\r\n        target.composing = false;\r\n        target.dispatchEvent(new Event('input'));\r\n    }\r\n}\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nconst vModelText = {\r\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        const castToNumber = number || (vnode.props && vnode.props.type === 'number');\r\n        addEventListener(el, lazy ? 'change' : 'input', e => {\r\n            if (e.target.composing)\r\n                return;\r\n            let domValue = el.value;\r\n            if (trim) {\r\n                domValue = domValue.trim();\r\n            }\r\n            if (castToNumber) {\r\n                domValue = shared_dist_shared_esm_bundler_toNumber(domValue);\r\n            }\r\n            el._assign(domValue);\r\n        });\r\n        if (trim) {\r\n            addEventListener(el, 'change', () => {\r\n                el.value = el.value.trim();\r\n            });\r\n        }\r\n        if (!lazy) {\r\n            addEventListener(el, 'compositionstart', onCompositionStart);\r\n            addEventListener(el, 'compositionend', onCompositionEnd);\r\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n            // switching focus before confirming composition choice\r\n            // this also fixes the issue where some browsers e.g. iOS Chrome\r\n            // fires \"change\" instead of \"input\" on autocomplete.\r\n            addEventListener(el, 'change', onCompositionEnd);\r\n        }\r\n    },\r\n    // set value on mounted so it's after min/max for type=\"range\"\r\n    mounted(el, { value }) {\r\n        el.value = value == null ? '' : value;\r\n    },\r\n    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        // avoid clearing unresolved text. #2302\r\n        if (el.composing)\r\n            return;\r\n        if (document.activeElement === el && el.type !== 'range') {\r\n            if (lazy) {\r\n                return;\r\n            }\r\n            if (trim && el.value.trim() === value) {\r\n                return;\r\n            }\r\n            if ((number || el.type === 'number') && shared_dist_shared_esm_bundler_toNumber(el.value) === value) {\r\n                return;\r\n            }\r\n        }\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n    }\r\n};\r\nconst vModelCheckbox = {\r\n    // #4096 array checkboxes need to be deep traversed\r\n    deep: true,\r\n    created(el, _, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            const modelValue = el._modelValue;\r\n            const elementValue = getValue(el);\r\n            const checked = el.checked;\r\n            const assign = el._assign;\r\n            if (shared_dist_shared_esm_bundler_isArray(modelValue)) {\r\n                const index = shared_dist_shared_esm_bundler_looseIndexOf(modelValue, elementValue);\r\n                const found = index !== -1;\r\n                if (checked && !found) {\r\n                    assign(modelValue.concat(elementValue));\r\n                }\r\n                else if (!checked && found) {\r\n                    const filtered = [...modelValue];\r\n                    filtered.splice(index, 1);\r\n                    assign(filtered);\r\n                }\r\n            }\r\n            else if (shared_dist_shared_esm_bundler_isSet(modelValue)) {\r\n                const cloned = new Set(modelValue);\r\n                if (checked) {\r\n                    cloned.add(elementValue);\r\n                }\r\n                else {\r\n                    cloned.delete(elementValue);\r\n                }\r\n                assign(cloned);\r\n            }\r\n            else {\r\n                assign(getCheckboxValue(el, checked));\r\n            }\r\n        });\r\n    },\r\n    // set initial checked on mount to wait for true-value/false-value\r\n    mounted: setChecked,\r\n    beforeUpdate(el, binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        setChecked(el, binding, vnode);\r\n    }\r\n};\r\nfunction setChecked(el, { value, oldValue }, vnode) {\r\n    el._modelValue = value;\r\n    if (shared_dist_shared_esm_bundler_isArray(value)) {\r\n        el.checked = shared_dist_shared_esm_bundler_looseIndexOf(value, vnode.props.value) > -1;\r\n    }\r\n    else if (shared_dist_shared_esm_bundler_isSet(value)) {\r\n        el.checked = value.has(vnode.props.value);\r\n    }\r\n    else if (value !== oldValue) {\r\n        el.checked = shared_dist_shared_esm_bundler_looseEqual(value, getCheckboxValue(el, true));\r\n    }\r\n}\r\nconst vModelRadio = {\r\n    created(el, { value }, vnode) {\r\n        el.checked = shared_dist_shared_esm_bundler_looseEqual(value, vnode.props.value);\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            el._assign(getValue(el));\r\n        });\r\n    },\r\n    beforeUpdate(el, { value, oldValue }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        if (value !== oldValue) {\r\n            el.checked = shared_dist_shared_esm_bundler_looseEqual(value, vnode.props.value);\r\n        }\r\n    }\r\n};\r\nconst vModelSelect = {\r\n    // <select multiple> value need to be deep traversed\r\n    deep: true,\r\n    created(el, { value, modifiers: { number } }, vnode) {\r\n        const isSetModel = shared_dist_shared_esm_bundler_isSet(value);\r\n        addEventListener(el, 'change', () => {\r\n            const selectedVal = Array.prototype.filter\r\n                .call(el.options, (o) => o.selected)\r\n                .map((o) => number ? shared_dist_shared_esm_bundler_toNumber(getValue(o)) : getValue(o));\r\n            el._assign(el.multiple\r\n                ? isSetModel\r\n                    ? new Set(selectedVal)\r\n                    : selectedVal\r\n                : selectedVal[0]);\r\n        });\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    // set value in mounted & updated because <select> relies on its children\r\n    // <option>s.\r\n    mounted(el, { value }) {\r\n        setSelected(el, value);\r\n    },\r\n    beforeUpdate(el, _binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    updated(el, { value }) {\r\n        setSelected(el, value);\r\n    }\r\n};\r\nfunction setSelected(el, value) {\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !shared_dist_shared_esm_bundler_isArray(value) && !shared_dist_shared_esm_bundler_isSet(value)) {\r\n        ( false) &&\r\n            0;\r\n        return;\r\n    }\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        const option = el.options[i];\r\n        const optionValue = getValue(option);\r\n        if (isMultiple) {\r\n            if (shared_dist_shared_esm_bundler_isArray(value)) {\r\n                option.selected = shared_dist_shared_esm_bundler_looseIndexOf(value, optionValue) > -1;\r\n            }\r\n            else {\r\n                option.selected = value.has(optionValue);\r\n            }\r\n        }\r\n        else {\r\n            if (shared_dist_shared_esm_bundler_looseEqual(getValue(option), value)) {\r\n                if (el.selectedIndex !== i)\r\n                    el.selectedIndex = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple && el.selectedIndex !== -1) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el) {\r\n    return '_value' in el ? el._value : el.value;\r\n}\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(el, checked) {\r\n    const key = checked ? '_trueValue' : '_falseValue';\r\n    return key in el ? el[key] : checked;\r\n}\r\nconst vModelDynamic = {\r\n    created(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'created');\r\n    },\r\n    mounted(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'mounted');\r\n    },\r\n    beforeUpdate(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\r\n    },\r\n    updated(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'updated');\r\n    }\r\n};\r\nfunction resolveDynamicModel(tagName, type) {\r\n    switch (tagName) {\r\n        case 'SELECT':\r\n            return vModelSelect;\r\n        case 'TEXTAREA':\r\n            return vModelText;\r\n        default:\r\n            switch (type) {\r\n                case 'checkbox':\r\n                    return vModelCheckbox;\r\n                case 'radio':\r\n                    return vModelRadio;\r\n                default:\r\n                    return vModelText;\r\n            }\r\n    }\r\n}\r\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\r\n    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\r\n    const fn = modelToUse[hook];\r\n    fn && fn(el, binding, vnode, prevVNode);\r\n}\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nfunction initVModelForSSR() {\r\n    vModelText.getSSRProps = ({ value }) => ({ value });\r\n    vModelRadio.getSSRProps = ({ value }, vnode) => {\r\n        if (vnode.props && looseEqual(vnode.props.value, value)) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n    vModelCheckbox.getSSRProps = ({ value }, vnode) => {\r\n        if (isArray(value)) {\r\n            if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if (isSet(value)) {\r\n            if (vnode.props && value.has(vnode.props.value)) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if (value) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n    vModelDynamic.getSSRProps = (binding, vnode) => {\r\n        if (typeof vnode.type !== 'string') {\r\n            return;\r\n        }\r\n        const modelToUse = resolveDynamicModel(\r\n        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\r\n        vnode.type.toUpperCase(), vnode.props && vnode.props.type);\r\n        if (modelToUse.getSSRProps) {\r\n            return modelToUse.getSSRProps(binding, vnode);\r\n        }\r\n    };\r\n}\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\r\nconst modifierGuards = {\r\n    stop: e => e.stopPropagation(),\r\n    prevent: e => e.preventDefault(),\r\n    self: e => e.target !== e.currentTarget,\r\n    ctrl: e => !e.ctrlKey,\r\n    shift: e => !e.shiftKey,\r\n    alt: e => !e.altKey,\r\n    meta: e => !e.metaKey,\r\n    left: e => 'button' in e && e.button !== 0,\r\n    middle: e => 'button' in e && e.button !== 1,\r\n    right: e => 'button' in e && e.button !== 2,\r\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withModifiers = (fn, modifiers) => {\r\n    return (event, ...args) => {\r\n        for (let i = 0; i < modifiers.length; i++) {\r\n            const guard = modifierGuards[modifiers[i]];\r\n            if (guard && guard(event, modifiers))\r\n                return;\r\n        }\r\n        return fn(event, ...args);\r\n    };\r\n};\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames = {\r\n    esc: 'escape',\r\n    space: ' ',\r\n    up: 'arrow-up',\r\n    left: 'arrow-left',\r\n    right: 'arrow-right',\r\n    down: 'arrow-down',\r\n    delete: 'backspace'\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withKeys = (fn, modifiers) => {\r\n    return (event) => {\r\n        if (!('key' in event)) {\r\n            return;\r\n        }\r\n        const eventKey = hyphenate(event.key);\r\n        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n            return fn(event);\r\n        }\r\n    };\r\n};\n\nconst vShow = {\r\n    beforeMount(el, { value }, { transition }) {\r\n        el._vod = el.style.display === 'none' ? '' : el.style.display;\r\n        if (transition && value) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    mounted(el, { value }, { transition }) {\r\n        if (transition && value) {\r\n            transition.enter(el);\r\n        }\r\n    },\r\n    updated(el, { value, oldValue }, { transition }) {\r\n        if (!value === !oldValue)\r\n            return;\r\n        if (transition) {\r\n            if (value) {\r\n                transition.beforeEnter(el);\r\n                setDisplay(el, true);\r\n                transition.enter(el);\r\n            }\r\n            else {\r\n                transition.leave(el, () => {\r\n                    setDisplay(el, false);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    beforeUnmount(el, { value }) {\r\n        setDisplay(el, value);\r\n    }\r\n};\r\nfunction setDisplay(el, value) {\r\n    el.style.display = value ? el._vod : 'none';\r\n}\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nfunction initVShowForSSR() {\r\n    vShow.getSSRProps = ({ value }) => {\r\n        if (!value) {\r\n            return { style: { display: 'none' } };\r\n        }\r\n    };\r\n}\n\nconst rendererOptions = /*#__PURE__*/ shared_dist_shared_esm_bundler_extend({ patchProp }, nodeOps);\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer;\r\nlet enabledHydration = false;\r\nfunction ensureRenderer() {\r\n    return (renderer ||\r\n        (renderer = createRenderer(rendererOptions)));\r\n}\r\nfunction ensureHydrationRenderer() {\r\n    renderer = enabledHydration\r\n        ? renderer\r\n        : createHydrationRenderer(rendererOptions);\r\n    enabledHydration = true;\r\n    return renderer;\r\n}\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nconst render = ((...args) => {\r\n    ensureRenderer().render(...args);\r\n});\r\nconst hydrate = ((...args) => {\r\n    ensureHydrationRenderer().hydrate(...args);\r\n});\r\nconst createApp = ((...args) => {\r\n    const app = ensureRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (!container)\r\n            return;\r\n        const component = app._component;\r\n        if (!shared_dist_shared_esm_bundler_isFunction(component) && !component.render && !component.template) {\r\n            // __UNSAFE__\r\n            // Reason: potential execution of JS expressions in in-DOM template.\r\n            // The user must make sure the in-DOM template is trusted. If it's\r\n            // rendered by the server, the template should not contain any user data.\r\n            component.template = container.innerHTML;\r\n        }\r\n        // clear content before mounting\r\n        container.innerHTML = '';\r\n        const proxy = mount(container, false, container instanceof SVGElement);\r\n        if (container instanceof Element) {\r\n            container.removeAttribute('v-cloak');\r\n            container.setAttribute('data-v-app', '');\r\n        }\r\n        return proxy;\r\n    };\r\n    return app;\r\n});\r\nconst createSSRApp = ((...args) => {\r\n    const app = ensureHydrationRenderer().createApp(...args);\r\n    if ((false)) {}\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (container) {\r\n            return mount(container, true, container instanceof SVGElement);\r\n        }\r\n    };\r\n    return app;\r\n});\r\nfunction injectNativeTagCheck(app) {\r\n    // Inject `isNativeTag`\r\n    // this is used for component name validation (dev only)\r\n    Object.defineProperty(app.config, 'isNativeTag', {\r\n        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),\r\n        writable: false\r\n    });\r\n}\r\n// dev only\r\nfunction injectCompilerOptionsCheck(app) {\r\n    if (isRuntimeOnly()) {\r\n        const isCustomElement = app.config.isCustomElement;\r\n        Object.defineProperty(app.config, 'isCustomElement', {\r\n            get() {\r\n                return isCustomElement;\r\n            },\r\n            set() {\r\n                warn(`The \\`isCustomElement\\` config option is deprecated. Use ` +\r\n                    `\\`compilerOptions.isCustomElement\\` instead.`);\r\n            }\r\n        });\r\n        const compilerOptions = app.config.compilerOptions;\r\n        const msg = `The \\`compilerOptions\\` config option is only respected when using ` +\r\n            `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\r\n            `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\r\n            `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\r\n            `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\r\n            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\r\n            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\r\n        Object.defineProperty(app.config, 'compilerOptions', {\r\n            get() {\r\n                warn(msg);\r\n                return compilerOptions;\r\n            },\r\n            set() {\r\n                warn(msg);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction normalizeContainer(container) {\r\n    if (shared_dist_shared_esm_bundler_isString(container)) {\r\n        const res = document.querySelector(container);\r\n        if (false) {}\r\n        return res;\r\n    }\r\n    if (false) {}\r\n    return container;\r\n}\r\nlet ssrDirectiveInitialized = false;\r\n/**\r\n * @internal\r\n */\r\nconst initDirectivesForSSR = () => {\r\n        if (!ssrDirectiveInitialized) {\r\n            ssrDirectiveInitialized = true;\r\n            initVModelForSSR();\r\n            initVShowForSSR();\r\n        }\r\n    }\r\n    ;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@intlify/shared/dist/shared.mjs\n/*!\n  * shared v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n/**\n * Original Utilities\n * written by kazuya kawaguchi\n */\nconst inBrowser = typeof window !== 'undefined';\nlet mark;\nlet measure;\nif ((false)) {}\nconst RE_ARGS = /\\{([0-9a-zA-Z]+)\\}/g;\n/* eslint-disable */\nfunction shared_format(message, ...args) {\n    if (args.length === 1 && shared_isObject(args[0])) {\n        args = args[0];\n    }\n    if (!args || !args.hasOwnProperty) {\n        args = {};\n    }\n    return message.replace(RE_ARGS, (match, identifier) => {\n        return args.hasOwnProperty(identifier) ? args[identifier] : '';\n    });\n}\nconst makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);\nconst generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });\nconst friendlyJSONstringify = (json) => JSON.stringify(json)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n    .replace(/\\u0027/g, '\\\\u0027');\nconst isNumber = (val) => typeof val === 'number' && isFinite(val);\nconst shared_isDate = (val) => shared_toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => shared_toTypeString(val) === '[object RegExp]';\nconst isEmptyObject = (val) => shared_isPlainObject(val) && Object.keys(val).length === 0;\nfunction shared_warn(msg, err) {\n    if (typeof console !== 'undefined') {\n        console.warn(`[intlify] ` + msg);\n        /* istanbul ignore if */\n        if (err) {\n            console.warn(err.stack);\n        }\n    }\n}\nconst shared_assign = Object.assign;\nlet shared_globalThis;\nconst shared_getGlobalThis = () => {\n    // prettier-ignore\n    return (shared_globalThis ||\n        (shared_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof global !== 'undefined'\n                            ? global\n                            : {}));\n};\nfunction shared_escapeHtml(rawText) {\n    return rawText\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;');\n}\nconst shared_hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction shared_hasOwn(obj, key) {\n    return shared_hasOwnProperty.call(obj, key);\n}\n/* eslint-enable */\n/**\n * Useful Utilities By Evan you\n * Modified by kazuya kawaguchi\n * MIT License\n * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts\n * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts\n */\nconst shared_isArray = Array.isArray;\nconst shared_isFunction = (val) => typeof val === 'function';\nconst shared_isString = (val) => typeof val === 'string';\nconst shared_isBoolean = (val) => typeof val === 'boolean';\nconst shared_isSymbol = (val) => typeof val === 'symbol';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst shared_isObject = (val) => val !== null && typeof val === 'object';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst shared_isPromise = (val) => {\n    return shared_isObject(val) && shared_isFunction(val.then) && shared_isFunction(val.catch);\n};\nconst shared_objectToString = Object.prototype.toString;\nconst shared_toTypeString = (value) => shared_objectToString.call(value);\nconst shared_isPlainObject = (val) => {\n    if (!shared_isObject(val))\n        return false;\n    const proto = Object.getPrototypeOf(val);\n    return proto === null || proto.constructor === Object;\n};\n// for converting list and named values to displayed strings.\nconst shared_toDisplayString = (val) => {\n    return val == null\n        ? ''\n        : shared_isArray(val) || (shared_isPlainObject(val) && val.toString === shared_objectToString)\n            ? JSON.stringify(val, null, 2)\n            : String(val);\n};\nfunction join(items, separator = '') {\n    return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');\n}\nconst RANGE = 2;\nfunction shared_generateCodeFrame(source, start = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count += lines[i].length + 1;\n        if (count >= start) {\n            for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - lineLength) + 1;\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + 1;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\n/**\n * Event emitter, forked from the below:\n * - original repository url: https://github.com/developit/mitt\n * - code url: https://github.com/developit/mitt/blob/master/src/index.ts\n * - author: Jason Miller (https://github.com/developit)\n * - license: MIT\n */\n/**\n * Create a event emitter\n *\n * @returns An event emitter\n */\nfunction createEmitter() {\n    const events = new Map();\n    const emitter = {\n        events,\n        on(event, handler) {\n            const handlers = events.get(event);\n            const added = handlers && handlers.push(handler);\n            if (!added) {\n                events.set(event, [handler]);\n            }\n        },\n        off(event, handler) {\n            const handlers = events.get(event);\n            if (handlers) {\n                handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n            }\n        },\n        emit(event, payload) {\n            (events.get(event) || [])\n                .slice()\n                .map(handler => handler(payload));\n            (events.get('*') || [])\n                .slice()\n                .map(handler => handler(event, payload));\n        }\n    };\n    return emitter;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@intlify/message-compiler/dist/message-compiler.esm-browser.js\n/*!\n  * message-compiler v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nconst LOCATION_STUB = {\n    start: { line: 1, column: 1, offset: 0 },\n    end: { line: 1, column: 1, offset: 0 }\n};\nfunction createPosition(line, column, offset) {\n    return { line, column, offset };\n}\nfunction createLocation(start, end, source) {\n    const loc = { start, end };\n    if (source != null) {\n        loc.source = source;\n    }\n    return loc;\n}\n\n/**\n * Original Utilities\n * written by kazuya kawaguchi\n */\nconst message_compiler_esm_browser_RE_ARGS = /\\{([0-9a-zA-Z]+)\\}/g;\n/* eslint-disable */\nfunction message_compiler_esm_browser_format(message, ...args) {\n    if (args.length === 1 && message_compiler_esm_browser_isObject(args[0])) {\n        args = args[0];\n    }\n    if (!args || !args.hasOwnProperty) {\n        args = {};\n    }\n    return message.replace(message_compiler_esm_browser_RE_ARGS, (match, identifier) => {\n        return args.hasOwnProperty(identifier) ? args[identifier] : '';\n    });\n}\nconst message_compiler_esm_browser_assign = Object.assign;\nconst message_compiler_esm_browser_isString = (val) => typeof val === 'string';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst message_compiler_esm_browser_isObject = (val) => val !== null && typeof val === 'object';\nfunction message_compiler_esm_browser_join(items, separator = '') {\n    return items.reduce((str, item, index) => (index === 0 ? str + item : str + separator + item), '');\n}\n\nconst CompileErrorCodes = {\n    // tokenizer error codes\n    EXPECTED_TOKEN: 1,\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n    UNBALANCED_CLOSING_BRACE: 6,\n    UNTERMINATED_CLOSING_BRACE: 7,\n    EMPTY_PLACEHOLDER: 8,\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\n    INVALID_LINKED_FORMAT: 10,\n    // parser error codes\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\n    // Special value for higher-order compilers to pick up the last code\n    // to avoid collision of error codes. This should always be kept as the last\n    // item.\n    __EXTEND_POINT__: 15\n};\n/** @internal */\nconst errorMessages = {\n    // tokenizer error messages\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n    // parser error messages\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n    const { domain, messages, args } = options;\n    const msg = message_compiler_esm_browser_format((messages || errorMessages)[code] || '', ...(args || []))\n        ;\n    const error = new SyntaxError(String(msg));\n    error.code = code;\n    if (loc) {\n        error.location = loc;\n    }\n    error.domain = domain;\n    return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n    throw error;\n}\n\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst message_compiler_esm_browser_detectHtmlTag = (source) => RE_HTML_TAG.test(source);\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n    const _buf = str;\n    let _index = 0;\n    let _line = 1;\n    let _column = 1;\n    let _peekOffset = 0;\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n    const isLF = (index) => _buf[index] === CHAR_LF;\n    const isPS = (index) => _buf[index] === CHAR_PS;\n    const isLS = (index) => _buf[index] === CHAR_LS;\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n    const index = () => _index;\n    const line = () => _line;\n    const column = () => _column;\n    const peekOffset = () => _peekOffset;\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n    const currentChar = () => charAt(_index);\n    const currentPeek = () => charAt(_index + _peekOffset);\n    function next() {\n        _peekOffset = 0;\n        if (isLineEnd(_index)) {\n            _line++;\n            _column = 0;\n        }\n        if (isCRLF(_index)) {\n            _index++;\n        }\n        _index++;\n        _column++;\n        return _buf[_index];\n    }\n    function peek() {\n        if (isCRLF(_index + _peekOffset)) {\n            _peekOffset++;\n        }\n        _peekOffset++;\n        return _buf[_index + _peekOffset];\n    }\n    function reset() {\n        _index = 0;\n        _line = 1;\n        _column = 1;\n        _peekOffset = 0;\n    }\n    function resetPeek(offset = 0) {\n        _peekOffset = offset;\n    }\n    function skipToPeek() {\n        const target = _index + _peekOffset;\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while (target !== _index) {\n            next();\n        }\n        _peekOffset = 0;\n    }\n    return {\n        index,\n        line,\n        column,\n        peekOffset,\n        charAt,\n        currentChar,\n        currentPeek,\n        next,\n        peek,\n        reset,\n        resetPeek,\n        skipToPeek\n    };\n}\n\nconst EOF = undefined;\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$1 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n    const location = options.location !== false;\n    const _scnr = createScanner(source);\n    const currentOffset = () => _scnr.index();\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n    const _initLoc = currentPosition();\n    const _initOffset = currentOffset();\n    const _context = {\n        currentType: 14 /* TokenTypes.EOF */,\n        offset: _initOffset,\n        startLoc: _initLoc,\n        endLoc: _initLoc,\n        lastType: 14 /* TokenTypes.EOF */,\n        lastOffset: _initOffset,\n        lastStartLoc: _initLoc,\n        lastEndLoc: _initLoc,\n        braceNest: 0,\n        inLinked: false,\n        text: ''\n    };\n    const context = () => _context;\n    const { onError } = options;\n    function emitError(code, pos, offset, ...args) {\n        const ctx = context();\n        pos.column += offset;\n        pos.offset += offset;\n        if (onError) {\n            const loc = location ? createLocation(ctx.startLoc, pos) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$1,\n                args\n            });\n            onError(err);\n        }\n    }\n    function getToken(context, type, value) {\n        context.endLoc = currentPosition();\n        context.currentType = type;\n        const token = { type };\n        if (location) {\n            token.loc = createLocation(context.startLoc, context.endLoc);\n        }\n        if (value != null) {\n            token.value = value;\n        }\n        return token;\n    }\n    const getEndToken = (context) => getToken(context, 14 /* TokenTypes.EOF */);\n    function eat(scnr, ch) {\n        if (scnr.currentChar() === ch) {\n            scnr.next();\n            return ch;\n        }\n        else {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n            return '';\n        }\n    }\n    function peekSpaces(scnr) {\n        let buf = '';\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n            buf += scnr.currentPeek();\n            scnr.peek();\n        }\n        return buf;\n    }\n    function skipSpaces(scnr) {\n        const buf = peekSpaces(scnr);\n        scnr.skipToPeek();\n        return buf;\n    }\n    function isIdentifierStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            cc === 95 // _\n        );\n    }\n    function isNumberStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function isNamedIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isListIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n        const ret = isNumberStart(ch);\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLiteralStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDotStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 8 /* TokenTypes.LinkedAlias */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedModifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 9 /* TokenTypes.LinkedDot */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDelimiterStart(scnr, context) {\n        const { currentType } = context;\n        if (!(currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */)) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedReferStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {\n            return false;\n        }\n        const fn = () => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return isIdentifierStart(scnr.peek());\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \":\" /* TokenChars.LinkedDelimiter */ ||\n                ch === \".\" /* TokenChars.LinkedDot */ ||\n                ch === CHAR_SP ||\n                !ch) {\n                return false;\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn();\n            }\n            else {\n                // other characters\n                return isIdentifierStart(ch);\n            }\n        };\n        const ret = fn();\n        scnr.resetPeek();\n        return ret;\n    }\n    function isPluralStart(scnr) {\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function detectModuloStart(scnr) {\n        const spaces = peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"%\" /* TokenChars.Modulo */ &&\n            scnr.peek() === \"{\" /* TokenChars.BraceLeft */;\n        scnr.resetPeek();\n        return {\n            isModulo: ret,\n            hasSpace: spaces.length > 0\n        };\n    }\n    function isTextStart(scnr, reset = true) {\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? false : hasSpace;\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? true : hasSpace;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                scnr.peek();\n                return fn(hasSpace, \"%\" /* TokenChars.Modulo */, true);\n            }\n            else if (ch === \"|\" /* TokenChars.Pipe */) {\n                return prev === \"%\" /* TokenChars.Modulo */ || detectModulo\n                    ? true\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\n            }\n            else if (ch === CHAR_SP) {\n                scnr.peek();\n                return fn(true, CHAR_SP, detectModulo);\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn(true, CHAR_LF, detectModulo);\n            }\n            else {\n                return true;\n            }\n        };\n        const ret = fn();\n        reset && scnr.resetPeek();\n        return ret;\n    }\n    function takeChar(scnr, fn) {\n        const ch = scnr.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (fn(ch)) {\n            scnr.next();\n            return ch;\n        }\n        return null;\n    }\n    function takeIdentifierChar(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 97 && cc <= 122) || // a-z\n                (cc >= 65 && cc <= 90) || // A-Z\n                (cc >= 48 && cc <= 57) || // 0-9\n                cc === 95 || // _\n                cc === 36 // $\n            );\n        };\n        return takeChar(scnr, closure);\n    }\n    function takeDigit(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return cc >= 48 && cc <= 57; // 0-9\n        };\n        return takeChar(scnr, closure);\n    }\n    function takeHexDigit(scnr) {\n        const closure = (ch) => {\n            const cc = ch.charCodeAt(0);\n            return ((cc >= 48 && cc <= 57) || // 0-9\n                (cc >= 65 && cc <= 70) || // A-F\n                (cc >= 97 && cc <= 102)); // a-f\n        };\n        return takeChar(scnr, closure);\n    }\n    function getDigits(scnr) {\n        let ch = '';\n        let num = '';\n        while ((ch = takeDigit(scnr))) {\n            num += ch;\n        }\n        return num;\n    }\n    function readModulo(scnr) {\n        skipSpaces(scnr);\n        const ch = scnr.currentChar();\n        if (ch !== \"%\" /* TokenChars.Modulo */) {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n        }\n        scnr.next();\n        return \"%\" /* TokenChars.Modulo */;\n    }\n    function readText(scnr) {\n        let buf = '';\n        while (true) {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"}\" /* TokenChars.BraceRight */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                !ch) {\n                break;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else if (isPluralStart(scnr)) {\n                    break;\n                }\n                else {\n                    buf += ch;\n                    scnr.next();\n                }\n            }\n            else {\n                buf += ch;\n                scnr.next();\n            }\n        }\n        return buf;\n    }\n    function readNamedIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return name;\n    }\n    function readListIdentifier(scnr) {\n        skipSpaces(scnr);\n        let value = '';\n        if (scnr.currentChar() === '-') {\n            scnr.next();\n            value += `-${getDigits(scnr)}`;\n        }\n        else {\n            value += getDigits(scnr);\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return value;\n    }\n    function readLiteral(scnr) {\n        skipSpaces(scnr);\n        eat(scnr, `\\'`);\n        let ch = '';\n        let literal = '';\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\n        while ((ch = takeChar(scnr, fn))) {\n            if (ch === '\\\\') {\n                literal += readEscapeSequence(scnr);\n            }\n            else {\n                literal += ch;\n            }\n        }\n        const current = scnr.currentChar();\n        if (current === CHAR_LF || current === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n            // TODO: Is it correct really?\n            if (current === CHAR_LF) {\n                scnr.next();\n                eat(scnr, `\\'`);\n            }\n            return literal;\n        }\n        eat(scnr, `\\'`);\n        return literal;\n    }\n    function readEscapeSequence(scnr) {\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case '\\\\':\n            case `\\'`:\n                scnr.next();\n                return `\\\\${ch}`;\n            case 'u':\n                return readUnicodeEscapeSequence(scnr, ch, 4);\n            case 'U':\n                return readUnicodeEscapeSequence(scnr, ch, 6);\n            default:\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n                return '';\n        }\n    }\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\n        eat(scnr, unicode);\n        let sequence = '';\n        for (let i = 0; i < digits; i++) {\n            const ch = takeHexDigit(scnr);\n            if (!ch) {\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n                break;\n            }\n            sequence += ch;\n        }\n        return `\\\\${unicode}${sequence}`;\n    }\n    function readInvalidIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let identifiers = '';\n        const closure = (ch) => ch !== \"{\" /* TokenChars.BraceLeft */ &&\n            ch !== \"}\" /* TokenChars.BraceRight */ &&\n            ch !== CHAR_SP &&\n            ch !== CHAR_LF;\n        while ((ch = takeChar(scnr, closure))) {\n            identifiers += ch;\n        }\n        return identifiers;\n    }\n    function readLinkedModifier(scnr) {\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        return name;\n    }\n    function readLinkedRefer(scnr) {\n        const fn = (detect = false, buf) => {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                !ch) {\n                return buf;\n            }\n            else if (ch === CHAR_SP) {\n                return buf;\n            }\n            else if (ch === CHAR_LF) {\n                buf += ch;\n                scnr.next();\n                return fn(detect, buf);\n            }\n            else {\n                buf += ch;\n                scnr.next();\n                return fn(true, buf);\n            }\n        };\n        return fn(false, '');\n    }\n    function readPlural(scnr) {\n        skipSpaces(scnr);\n        const plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n        skipSpaces(scnr);\n        return plural;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInPlaceholder(scnr, context) {\n        let token = null;\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                if (context.braceNest >= 1) {\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n                skipSpaces(scnr);\n                context.braceNest++;\n                return token;\n            case \"}\" /* TokenChars.BraceRight */:\n                if (context.braceNest > 0 &&\n                    context.currentType === 2 /* TokenTypes.BraceLeft */) {\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n                context.braceNest--;\n                context.braceNest > 0 && skipSpaces(scnr);\n                if (context.inLinked && context.braceNest === 0) {\n                    context.inLinked = false;\n                }\n                return token;\n            case \"@\" /* TokenChars.LinkedAlias */:\n                if (context.braceNest > 0) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                }\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\n                context.braceNest = 0;\n                return token;\n            default:\n                let validNamedIdentifier = true;\n                let validListIdentifier = true;\n                let validLiteral = true;\n                if (isPluralStart(scnr)) {\n                    if (context.braceNest > 0) {\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    }\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (context.braceNest > 0 &&\n                    (context.currentType === 5 /* TokenTypes.Named */ ||\n                        context.currentType === 6 /* TokenTypes.List */ ||\n                        context.currentType === 7 /* TokenTypes.Literal */)) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    context.braceNest = 0;\n                    return readToken(scnr, context);\n                }\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\n                    token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\n                    token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validLiteral = isLiteralStart(scnr, context))) {\n                    token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n                    token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n                    skipSpaces(scnr);\n                    return token;\n                }\n                break;\n        }\n        return token;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInLinked(scnr, context) {\n        const { currentType } = context;\n        let token = null;\n        const ch = scnr.currentChar();\n        if ((currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 9 /* TokenTypes.LinkedDot */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */ ||\n            currentType === 10 /* TokenTypes.LinkedDelimiter */) &&\n            (ch === CHAR_LF || ch === CHAR_SP)) {\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        switch (ch) {\n            case \"@\" /* TokenChars.LinkedAlias */:\n                scnr.next();\n                token = getToken(context, 8 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n                context.inLinked = true;\n                return token;\n            case \".\" /* TokenChars.LinkedDot */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 9 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n            case \":\" /* TokenChars.LinkedDelimiter */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (isLinkedDotStart(scnr, context) ||\n                    isLinkedDelimiterStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return readTokenInLinked(scnr, context);\n                }\n                if (isLinkedModifierStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n                }\n                if (isLinkedReferStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                        // scan the placeholder\n                        return readTokenInPlaceholder(scnr, context) || token;\n                    }\n                    else {\n                        return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n                    }\n                }\n                if (currentType === 8 /* TokenTypes.LinkedAlias */) {\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n                }\n                context.braceNest = 0;\n                context.inLinked = false;\n                return readToken(scnr, context);\n        }\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readToken(scnr, context) {\n        let token = { type: 14 /* TokenTypes.EOF */ };\n        if (context.braceNest > 0) {\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n        }\n        if (context.inLinked) {\n            return readTokenInLinked(scnr, context) || getEndToken(context);\n        }\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n            case \"}\" /* TokenChars.BraceRight */:\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n                scnr.next();\n                return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n            case \"@\" /* TokenChars.LinkedAlias */:\n                return readTokenInLinked(scnr, context) || getEndToken(context);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                const { isModulo, hasSpace } = detectModuloStart(scnr);\n                if (isModulo) {\n                    return hasSpace\n                        ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr))\n                        : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));\n                }\n                if (isTextStart(scnr)) {\n                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n                }\n                break;\n        }\n        return token;\n    }\n    function nextToken() {\n        const { currentType, offset, startLoc, endLoc } = _context;\n        _context.lastType = currentType;\n        _context.lastOffset = offset;\n        _context.lastStartLoc = startLoc;\n        _context.lastEndLoc = endLoc;\n        _context.offset = currentOffset();\n        _context.startLoc = currentPosition();\n        if (_scnr.currentChar() === EOF) {\n            return getToken(_context, 14 /* TokenTypes.EOF */);\n        }\n        return readToken(_scnr, _context);\n    }\n    return {\n        nextToken,\n        currentOffset,\n        currentPosition,\n        context\n    };\n}\n\nconst ERROR_DOMAIN = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n    switch (match) {\n        case `\\\\\\\\`:\n            return `\\\\`;\n        case `\\\\\\'`:\n            return `\\'`;\n        default: {\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n                return String.fromCodePoint(codePoint);\n            }\n            // invalid ...\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\n            return '�';\n        }\n    }\n}\nfunction createParser(options = {}) {\n    const location = options.location !== false;\n    const { onError } = options;\n    function emitError(tokenzer, code, start, offset, ...args) {\n        const end = tokenzer.currentPosition();\n        end.offset += offset;\n        end.column += offset;\n        if (onError) {\n            const loc = location ? createLocation(start, end) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN,\n                args\n            });\n            onError(err);\n        }\n    }\n    function startNode(type, offset, loc) {\n        const node = { type };\n        if (location) {\n            node.start = offset;\n            node.end = offset;\n            node.loc = { start: loc, end: loc };\n        }\n        return node;\n    }\n    function endNode(node, offset, pos, type) {\n        if (type) {\n            node.type = type;\n        }\n        if (location) {\n            node.end = offset;\n            if (node.loc) {\n                node.loc.end = pos;\n            }\n        }\n    }\n    function parseText(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseList(tokenizer, index) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(5 /* NodeTypes.List */, offset, loc);\n        node.index = parseInt(index, 10);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseNamed(tokenizer, key) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(4 /* NodeTypes.Named */, offset, loc);\n        node.key = key;\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLiteral(tokenizer, value) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinkedModifier(tokenizer) {\n        const token = tokenizer.nextToken();\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\n        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n        if (token.type !== 12 /* TokenTypes.LinkedModifier */) {\n            // empty modifier\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n            node.value = '';\n            endNode(node, offset, loc);\n            return {\n                nextConsumeToken: token,\n                node\n            };\n        }\n        // check token\n        if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        node.value = token.value || '';\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node\n        };\n    }\n    function parseLinkedKey(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinked(tokenizer) {\n        const context = tokenizer.context();\n        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n        let token = tokenizer.nextToken();\n        if (token.type === 9 /* TokenTypes.LinkedDot */) {\n            const parsed = parseLinkedModifier(tokenizer);\n            linkedNode.modifier = parsed.node;\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\n        }\n        // asset check token\n        if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        token = tokenizer.nextToken();\n        // skip brace left\n        if (token.type === 2 /* TokenTypes.BraceLeft */) {\n            token = tokenizer.nextToken();\n        }\n        switch (token.type) {\n            case 11 /* TokenTypes.LinkedKey */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n                break;\n            case 5 /* TokenTypes.Named */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\n                break;\n            case 6 /* TokenTypes.List */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseList(tokenizer, token.value || '');\n                break;\n            case 7 /* TokenTypes.Literal */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\n                break;\n            default:\n                // empty key\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n                const nextContext = tokenizer.context();\n                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n                emptyLinkedKeyNode.value = '';\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n                linkedNode.key = emptyLinkedKeyNode;\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n                return {\n                    nextConsumeToken: token,\n                    node: linkedNode\n                };\n        }\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node: linkedNode\n        };\n    }\n    function parseMessage(tokenizer) {\n        const context = tokenizer.context();\n        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? tokenizer.currentOffset()\n            : context.offset;\n        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.endLoc\n            : context.startLoc;\n        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n        node.items = [];\n        let nextToken = null;\n        do {\n            const token = nextToken || tokenizer.nextToken();\n            nextToken = null;\n            switch (token.type) {\n                case 0 /* TokenTypes.Text */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseText(tokenizer, token.value || ''));\n                    break;\n                case 6 /* TokenTypes.List */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseList(tokenizer, token.value || ''));\n                    break;\n                case 5 /* TokenTypes.Named */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseNamed(tokenizer, token.value || ''));\n                    break;\n                case 7 /* TokenTypes.Literal */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\n                    break;\n                case 8 /* TokenTypes.LinkedAlias */:\n                    const parsed = parseLinked(tokenizer);\n                    node.items.push(parsed.node);\n                    nextToken = parsed.nextConsumeToken || null;\n                    break;\n            }\n        } while (context.currentType !== 14 /* TokenTypes.EOF */ &&\n            context.currentType !== 1 /* TokenTypes.Pipe */);\n        // adjust message node loc\n        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastOffset\n            : tokenizer.currentOffset();\n        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastEndLoc\n            : tokenizer.currentPosition();\n        endNode(node, endOffset, endLoc);\n        return node;\n    }\n    function parsePlural(tokenizer, offset, loc, msgNode) {\n        const context = tokenizer.context();\n        let hasEmptyMessage = msgNode.items.length === 0;\n        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n        node.cases = [];\n        node.cases.push(msgNode);\n        do {\n            const msg = parseMessage(tokenizer);\n            if (!hasEmptyMessage) {\n                hasEmptyMessage = msg.items.length === 0;\n            }\n            node.cases.push(msg);\n        } while (context.currentType !== 14 /* TokenTypes.EOF */);\n        if (hasEmptyMessage) {\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseResource(tokenizer) {\n        const context = tokenizer.context();\n        const { offset, startLoc } = context;\n        const msgNode = parseMessage(tokenizer);\n        if (context.currentType === 14 /* TokenTypes.EOF */) {\n            return msgNode;\n        }\n        else {\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\n        }\n    }\n    function parse(source) {\n        const tokenizer = createTokenizer(source, message_compiler_esm_browser_assign({}, options));\n        const context = tokenizer.context();\n        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n        if (location && node.loc) {\n            node.loc.source = source;\n        }\n        node.body = parseResource(tokenizer);\n        if (options.onCacheKey) {\n            node.cacheKey = options.onCacheKey(source);\n        }\n        // assert whether achieved to EOF\n        if (context.currentType !== 14 /* TokenTypes.EOF */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    return { parse };\n}\nfunction getTokenCaption(token) {\n    if (token.type === 14 /* TokenTypes.EOF */) {\n        return 'EOF';\n    }\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n    const _context = {\n        ast,\n        helpers: new Set()\n    };\n    const context = () => _context;\n    const helper = (name) => {\n        _context.helpers.add(name);\n        return name;\n    };\n    return { context, helper };\n}\nfunction traverseNodes(nodes, transformer) {\n    for (let i = 0; i < nodes.length; i++) {\n        traverseNode(nodes[i], transformer);\n    }\n}\nfunction traverseNode(node, transformer) {\n    // TODO: if we need pre-hook of transform, should be implemented to here\n    switch (node.type) {\n        case 1 /* NodeTypes.Plural */:\n            traverseNodes(node.cases, transformer);\n            transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n            break;\n        case 2 /* NodeTypes.Message */:\n            traverseNodes(node.items, transformer);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            const linked = node;\n            traverseNode(linked.key, transformer);\n            transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n            transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n            break;\n        case 5 /* NodeTypes.List */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"list\" /* HelperNameMap.LIST */);\n            break;\n        case 4 /* NodeTypes.Named */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n            break;\n    }\n    // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n    const transformer = createTransformer(ast);\n    transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n    // traverse\n    ast.body && traverseNode(ast.body, transformer);\n    // set meta information\n    const context = transformer.context();\n    ast.helpers = Array.from(context.helpers);\n}\n\nfunction optimize(ast) {\n    const body = ast.body;\n    if (body.type === 2 /* NodeTypes.Message */) {\n        optimizeMessageNode(body);\n    }\n    else {\n        body.cases.forEach(c => optimizeMessageNode(c));\n    }\n    return ast;\n}\nfunction optimizeMessageNode(message) {\n    if (message.items.length === 1) {\n        const item = message.items[0];\n        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n            message.static = item.value;\n            delete item.value; // optimization for size\n        }\n    }\n    else {\n        const values = [];\n        for (let i = 0; i < message.items.length; i++) {\n            const item = message.items[i];\n            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {\n                break;\n            }\n            if (item.value == null) {\n                break;\n            }\n            values.push(item.value);\n        }\n        if (values.length === message.items.length) {\n            message.static = message_compiler_esm_browser_join(values);\n            for (let i = 0; i < message.items.length; i++) {\n                const item = message.items[i];\n                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n                    delete item.value; // optimization for size\n                }\n            }\n        }\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction minify(node) {\n    node.t = node.type;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            const resource = node;\n            minify(resource.body);\n            resource.b = resource.body;\n            delete resource.body;\n            break;\n        case 1 /* NodeTypes.Plural */:\n            const plural = node;\n            const cases = plural.cases;\n            for (let i = 0; i < cases.length; i++) {\n                minify(cases[i]);\n            }\n            plural.c = cases;\n            delete plural.cases;\n            break;\n        case 2 /* NodeTypes.Message */:\n            const message = node;\n            const items = message.items;\n            for (let i = 0; i < items.length; i++) {\n                minify(items[i]);\n            }\n            message.i = items;\n            delete message.items;\n            if (message.static) {\n                message.s = message.static;\n                delete message.static;\n            }\n            break;\n        case 3 /* NodeTypes.Text */:\n        case 9 /* NodeTypes.Literal */:\n        case 8 /* NodeTypes.LinkedModifier */:\n        case 7 /* NodeTypes.LinkedKey */:\n            const valueNode = node;\n            if (valueNode.value) {\n                valueNode.v = valueNode.value;\n                delete valueNode.value;\n            }\n            break;\n        case 6 /* NodeTypes.Linked */:\n            const linked = node;\n            minify(linked.key);\n            linked.k = linked.key;\n            delete linked.key;\n            if (linked.modifier) {\n                minify(linked.modifier);\n                linked.m = linked.modifier;\n                delete linked.modifier;\n            }\n            break;\n        case 5 /* NodeTypes.List */:\n            const list = node;\n            list.i = list.index;\n            delete list.index;\n            break;\n        case 4 /* NodeTypes.Named */:\n            const named = node;\n            named.k = named.key;\n            delete named.key;\n            break;\n        default:\n            {\n                throw new Error(`unhandled minify node type: ${node.type}`);\n            }\n    }\n    delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nfunction createCodeGenerator(ast, options) {\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\n    const location = options.location !== false;\n    const _context = {\n        filename,\n        code: '',\n        column: 1,\n        line: 1,\n        offset: 0,\n        map: undefined,\n        breakLineCode,\n        needIndent: _needIndent,\n        indentLevel: 0\n    };\n    if (location && ast.loc) {\n        _context.source = ast.loc.source;\n    }\n    const context = () => _context;\n    function push(code, node) {\n        _context.code += code;\n    }\n    function _newline(n, withBreakLine = true) {\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n    }\n    function indent(withNewLine = true) {\n        const level = ++_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function deindent(withNewLine = true) {\n        const level = --_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function newline() {\n        _newline(_context.indentLevel);\n    }\n    const helper = (key) => `_${key}`;\n    const needIndent = () => _context.needIndent;\n    return {\n        context,\n        push,\n        indent,\n        deindent,\n        newline,\n        helper,\n        needIndent\n    };\n}\nfunction generateLinkedNode(generator, node) {\n    const { helper } = generator;\n    generator.push(`${helper(\"linked\" /* HelperNameMap.LINKED */)}(`);\n    generateNode(generator, node.key);\n    if (node.modifier) {\n        generator.push(`, `);\n        generateNode(generator, node.modifier);\n        generator.push(`, _type`);\n    }\n    else {\n        generator.push(`, undefined, _type`);\n    }\n    generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n    const { helper, needIndent } = generator;\n    generator.push(`${helper(\"normalize\" /* HelperNameMap.NORMALIZE */)}([`);\n    generator.indent(needIndent());\n    const length = node.items.length;\n    for (let i = 0; i < length; i++) {\n        generateNode(generator, node.items[i]);\n        if (i === length - 1) {\n            break;\n        }\n        generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n    const { helper, needIndent } = generator;\n    if (node.cases.length > 1) {\n        generator.push(`${helper(\"plural\" /* HelperNameMap.PLURAL */)}([`);\n        generator.indent(needIndent());\n        const length = node.cases.length;\n        for (let i = 0; i < length; i++) {\n            generateNode(generator, node.cases[i]);\n            if (i === length - 1) {\n                break;\n            }\n            generator.push(', ');\n        }\n        generator.deindent(needIndent());\n        generator.push(`])`);\n    }\n}\nfunction generateResource(generator, node) {\n    if (node.body) {\n        generateNode(generator, node.body);\n    }\n    else {\n        generator.push('null');\n    }\n}\nfunction generateNode(generator, node) {\n    const { helper } = generator;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            generateResource(generator, node);\n            break;\n        case 1 /* NodeTypes.Plural */:\n            generatePluralNode(generator, node);\n            break;\n        case 2 /* NodeTypes.Message */:\n            generateMessageNode(generator, node);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            generateLinkedNode(generator, node);\n            break;\n        case 8 /* NodeTypes.LinkedModifier */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 7 /* NodeTypes.LinkedKey */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 5 /* NodeTypes.List */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"list\" /* HelperNameMap.LIST */)}(${node.index}))`, node);\n            break;\n        case 4 /* NodeTypes.Named */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"named\" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);\n            break;\n        case 9 /* NodeTypes.Literal */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 3 /* NodeTypes.Text */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        default:\n            {\n                throw new Error(`unhandled codegen node type: ${node.type}`);\n            }\n    }\n}\n// generate code from AST\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n    const mode = message_compiler_esm_browser_isString(options.mode) ? options.mode : 'normal';\n    const filename = message_compiler_esm_browser_isString(options.filename)\n        ? options.filename\n        : 'message.intl';\n    const sourceMap = !!options.sourceMap;\n    // prettier-ignore\n    const breakLineCode = options.breakLineCode != null\n        ? options.breakLineCode\n        : mode === 'arrow'\n            ? ';'\n            : '\\n';\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n    const helpers = ast.helpers || [];\n    const generator = createCodeGenerator(ast, {\n        mode,\n        filename,\n        sourceMap,\n        breakLineCode,\n        needIndent\n    });\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n    generator.indent(needIndent);\n    if (helpers.length > 0) {\n        generator.push(`const { ${message_compiler_esm_browser_join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);\n        generator.newline();\n    }\n    generator.push(`return `);\n    generateNode(generator, ast);\n    generator.deindent(needIndent);\n    generator.push(`}`);\n    delete ast.helpers;\n    const { code, map } = generator.context();\n    return {\n        ast,\n        code,\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n    };\n};\n\nfunction baseCompile(source, options = {}) {\n    const assignedOptions = message_compiler_esm_browser_assign({}, options);\n    const jit = !!assignedOptions.jit;\n    const enalbeMinify = !!assignedOptions.minify;\n    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n    // parse source codes\n    const parser = createParser(assignedOptions);\n    const ast = parser.parse(source);\n    if (!jit) {\n        // transform ASTs\n        transform(ast, assignedOptions);\n        // generate javascript codes\n        return generate(ast, assignedOptions);\n    }\n    else {\n        // optimize ASTs\n        enambeOptimize && optimize(ast);\n        // minimize ASTs\n        enalbeMinify && minify(ast);\n        // In JIT mode, no ast transform, no code generation.\n        return { ast, code: '' };\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@intlify/devtools-if/dist/devtools-if.mjs\n/*!\n  * devtools-if v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nconst IntlifyDevToolsHooks =  {\n    I18nInit: 'i18n:init',\n    FunctionTranslate: 'function:translate'\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@intlify/core-base/dist/core-base.mjs\n/*!\n  * core-base v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\n\n\n\n/**\n * This is only called in esm-bundler builds.\n * istanbul-ignore-next\n */\nfunction core_base_initFeatureFlags() {\n    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {\n        shared_getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;\n    }\n    if (typeof __INTLIFY_JIT_COMPILATION__ !== 'boolean') {\n        shared_getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;\n    }\n}\n\nconst pathStateMachine =  [];\npathStateMachine[0 /* States.BEFORE_PATH */] = {\n    [\"w\" /* PathCharTypes.WORKSPACE */]: [0 /* States.BEFORE_PATH */],\n    [\"i\" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],\n    [\"[\" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */]\n};\npathStateMachine[1 /* States.IN_PATH */] = {\n    [\"w\" /* PathCharTypes.WORKSPACE */]: [1 /* States.IN_PATH */],\n    [\".\" /* PathCharTypes.DOT */]: [2 /* States.BEFORE_IDENT */],\n    [\"[\" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */]\n};\npathStateMachine[2 /* States.BEFORE_IDENT */] = {\n    [\"w\" /* PathCharTypes.WORKSPACE */]: [2 /* States.BEFORE_IDENT */],\n    [\"i\" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],\n    [\"0\" /* PathCharTypes.ZERO */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */]\n};\npathStateMachine[3 /* States.IN_IDENT */] = {\n    [\"i\" /* PathCharTypes.IDENT */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],\n    [\"0\" /* PathCharTypes.ZERO */]: [3 /* States.IN_IDENT */, 0 /* Actions.APPEND */],\n    [\"w\" /* PathCharTypes.WORKSPACE */]: [1 /* States.IN_PATH */, 1 /* Actions.PUSH */],\n    [\".\" /* PathCharTypes.DOT */]: [2 /* States.BEFORE_IDENT */, 1 /* Actions.PUSH */],\n    [\"[\" /* PathCharTypes.LEFT_BRACKET */]: [4 /* States.IN_SUB_PATH */, 1 /* Actions.PUSH */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: [7 /* States.AFTER_PATH */, 1 /* Actions.PUSH */]\n};\npathStateMachine[4 /* States.IN_SUB_PATH */] = {\n    [\"'\" /* PathCharTypes.SINGLE_QUOTE */]: [5 /* States.IN_SINGLE_QUOTE */, 0 /* Actions.APPEND */],\n    [\"\\\"\" /* PathCharTypes.DOUBLE_QUOTE */]: [6 /* States.IN_DOUBLE_QUOTE */, 0 /* Actions.APPEND */],\n    [\"[\" /* PathCharTypes.LEFT_BRACKET */]: [\n        4 /* States.IN_SUB_PATH */,\n        2 /* Actions.INC_SUB_PATH_DEPTH */\n    ],\n    [\"]\" /* PathCharTypes.RIGHT_BRACKET */]: [1 /* States.IN_PATH */, 3 /* Actions.PUSH_SUB_PATH */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,\n    [\"l\" /* PathCharTypes.ELSE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */]\n};\npathStateMachine[5 /* States.IN_SINGLE_QUOTE */] = {\n    [\"'\" /* PathCharTypes.SINGLE_QUOTE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,\n    [\"l\" /* PathCharTypes.ELSE */]: [5 /* States.IN_SINGLE_QUOTE */, 0 /* Actions.APPEND */]\n};\npathStateMachine[6 /* States.IN_DOUBLE_QUOTE */] = {\n    [\"\\\"\" /* PathCharTypes.DOUBLE_QUOTE */]: [4 /* States.IN_SUB_PATH */, 0 /* Actions.APPEND */],\n    [\"o\" /* PathCharTypes.END_OF_FAIL */]: 8 /* States.ERROR */,\n    [\"l\" /* PathCharTypes.ELSE */]: [6 /* States.IN_DOUBLE_QUOTE */, 0 /* Actions.APPEND */]\n};\n/**\n * Check if an expression is a literal value.\n */\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|'[^']*'|\"[^\"]*\")\\s?$/;\nfunction isLiteral(exp) {\n    return literalValueRE.test(exp);\n}\n/**\n * Strip quotes from a string\n */\nfunction stripQuotes(str) {\n    const a = str.charCodeAt(0);\n    const b = str.charCodeAt(str.length - 1);\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n}\n/**\n * Determine the type of a character in a keypath.\n */\nfunction getPathCharType(ch) {\n    if (ch === undefined || ch === null) {\n        return \"o\" /* PathCharTypes.END_OF_FAIL */;\n    }\n    const code = ch.charCodeAt(0);\n    switch (code) {\n        case 0x5b: // [\n        case 0x5d: // ]\n        case 0x2e: // .\n        case 0x22: // \"\n        case 0x27: // '\n            return ch;\n        case 0x5f: // _\n        case 0x24: // $\n        case 0x2d: // -\n            return \"i\" /* PathCharTypes.IDENT */;\n        case 0x09: // Tab (HT)\n        case 0x0a: // Newline (LF)\n        case 0x0d: // Return (CR)\n        case 0xa0: // No-break space (NBSP)\n        case 0xfeff: // Byte Order Mark (BOM)\n        case 0x2028: // Line Separator (LS)\n        case 0x2029: // Paragraph Separator (PS)\n            return \"w\" /* PathCharTypes.WORKSPACE */;\n    }\n    return \"i\" /* PathCharTypes.IDENT */;\n}\n/**\n * Format a subPath, return its plain form if it is\n * a literal string or number. Otherwise prepend the\n * dynamic indicator (*).\n */\nfunction formatSubPath(path) {\n    const trimmed = path.trim();\n    // invalid leading 0\n    if (path.charAt(0) === '0' && isNaN(parseInt(path))) {\n        return false;\n    }\n    return isLiteral(trimmed)\n        ? stripQuotes(trimmed)\n        : \"*\" /* PathCharTypes.ASTARISK */ + trimmed;\n}\n/**\n * Parse a string path into an array of segments\n */\nfunction parse(path) {\n    const keys = [];\n    let index = -1;\n    let mode = 0 /* States.BEFORE_PATH */;\n    let subPathDepth = 0;\n    let c;\n    let key; // eslint-disable-line\n    let newChar;\n    let type;\n    let transition;\n    let action;\n    let typeMap;\n    const actions = [];\n    actions[0 /* Actions.APPEND */] = () => {\n        if (key === undefined) {\n            key = newChar;\n        }\n        else {\n            key += newChar;\n        }\n    };\n    actions[1 /* Actions.PUSH */] = () => {\n        if (key !== undefined) {\n            keys.push(key);\n            key = undefined;\n        }\n    };\n    actions[2 /* Actions.INC_SUB_PATH_DEPTH */] = () => {\n        actions[0 /* Actions.APPEND */]();\n        subPathDepth++;\n    };\n    actions[3 /* Actions.PUSH_SUB_PATH */] = () => {\n        if (subPathDepth > 0) {\n            subPathDepth--;\n            mode = 4 /* States.IN_SUB_PATH */;\n            actions[0 /* Actions.APPEND */]();\n        }\n        else {\n            subPathDepth = 0;\n            if (key === undefined) {\n                return false;\n            }\n            key = formatSubPath(key);\n            if (key === false) {\n                return false;\n            }\n            else {\n                actions[1 /* Actions.PUSH */]();\n            }\n        }\n    };\n    function maybeUnescapeQuote() {\n        const nextChar = path[index + 1];\n        if ((mode === 5 /* States.IN_SINGLE_QUOTE */ &&\n            nextChar === \"'\" /* PathCharTypes.SINGLE_QUOTE */) ||\n            (mode === 6 /* States.IN_DOUBLE_QUOTE */ &&\n                nextChar === \"\\\"\" /* PathCharTypes.DOUBLE_QUOTE */)) {\n            index++;\n            newChar = '\\\\' + nextChar;\n            actions[0 /* Actions.APPEND */]();\n            return true;\n        }\n    }\n    while (mode !== null) {\n        index++;\n        c = path[index];\n        if (c === '\\\\' && maybeUnescapeQuote()) {\n            continue;\n        }\n        type = getPathCharType(c);\n        typeMap = pathStateMachine[mode];\n        transition = typeMap[type] || typeMap[\"l\" /* PathCharTypes.ELSE */] || 8 /* States.ERROR */;\n        // check parse error\n        if (transition === 8 /* States.ERROR */) {\n            return;\n        }\n        mode = transition[0];\n        if (transition[1] !== undefined) {\n            action = actions[transition[1]];\n            if (action) {\n                newChar = c;\n                if (action() === false) {\n                    return;\n                }\n            }\n        }\n        // check parse finish\n        if (mode === 7 /* States.AFTER_PATH */) {\n            return keys;\n        }\n    }\n}\n// path token cache\nconst cache = new Map();\n/**\n * key-value message resolver\n *\n * @remarks\n * Resolves messages with the key-value structure. Note that messages with a hierarchical structure such as objects cannot be resolved\n *\n * @param obj - A target object to be resolved with path\n * @param path - A {@link Path | path} to resolve the value of message\n *\n * @returns A resolved {@link PathValue | path value}\n *\n * @VueI18nGeneral\n */\nfunction resolveWithKeyValue(obj, path) {\n    return shared_isObject(obj) ? obj[path] : null;\n}\n/**\n * message resolver\n *\n * @remarks\n * Resolves messages. messages with a hierarchical structure such as objects can be resolved. This resolver is used in VueI18n as default.\n *\n * @param obj - A target object to be resolved with path\n * @param path - A {@link Path | path} to resolve the value of message\n *\n * @returns A resolved {@link PathValue | path value}\n *\n * @VueI18nGeneral\n */\nfunction resolveValue(obj, path) {\n    // check object\n    if (!shared_isObject(obj)) {\n        return null;\n    }\n    // parse path\n    let hit = cache.get(path);\n    if (!hit) {\n        hit = parse(path);\n        if (hit) {\n            cache.set(path, hit);\n        }\n    }\n    // check hit\n    if (!hit) {\n        return null;\n    }\n    // resolve path value\n    const len = hit.length;\n    let last = obj;\n    let i = 0;\n    while (i < len) {\n        const val = last[hit[i]];\n        if (val === undefined) {\n            return null;\n        }\n        last = val;\n        i++;\n    }\n    return last;\n}\n\nconst DEFAULT_MODIFIER = (str) => str;\nconst DEFAULT_MESSAGE = (ctx) => ''; // eslint-disable-line\nconst DEFAULT_MESSAGE_DATA_TYPE = 'text';\nconst DEFAULT_NORMALIZE = (values) => values.length === 0 ? '' : join(values);\nconst DEFAULT_INTERPOLATE = shared_toDisplayString;\nfunction pluralDefault(choice, choicesLength) {\n    choice = Math.abs(choice);\n    if (choicesLength === 2) {\n        // prettier-ignore\n        return choice\n            ? choice > 1\n                ? 1\n                : 0\n            : 1;\n    }\n    return choice ? Math.min(choice, 2) : 0;\n}\nfunction getPluralIndex(options) {\n    // prettier-ignore\n    const index = isNumber(options.pluralIndex)\n        ? options.pluralIndex\n        : -1;\n    // prettier-ignore\n    return options.named && (isNumber(options.named.count) || isNumber(options.named.n))\n        ? isNumber(options.named.count)\n            ? options.named.count\n            : isNumber(options.named.n)\n                ? options.named.n\n                : index\n        : index;\n}\nfunction normalizeNamed(pluralIndex, props) {\n    if (!props.count) {\n        props.count = pluralIndex;\n    }\n    if (!props.n) {\n        props.n = pluralIndex;\n    }\n}\nfunction createMessageContext(options = {}) {\n    const locale = options.locale;\n    const pluralIndex = getPluralIndex(options);\n    const pluralRule = shared_isObject(options.pluralRules) &&\n        shared_isString(locale) &&\n        shared_isFunction(options.pluralRules[locale])\n        ? options.pluralRules[locale]\n        : pluralDefault;\n    const orgPluralRule = shared_isObject(options.pluralRules) &&\n        shared_isString(locale) &&\n        shared_isFunction(options.pluralRules[locale])\n        ? pluralDefault\n        : undefined;\n    const plural = (messages) => {\n        return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];\n    };\n    const _list = options.list || [];\n    const list = (index) => _list[index];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const _named = options.named || {};\n    isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);\n    const named = (key) => _named[key];\n    function message(key) {\n        // prettier-ignore\n        const msg = shared_isFunction(options.messages)\n            ? options.messages(key)\n            : shared_isObject(options.messages)\n                ? options.messages[key]\n                : false;\n        return !msg\n            ? options.parent\n                ? options.parent.message(key) // resolve from parent messages\n                : DEFAULT_MESSAGE\n            : msg;\n    }\n    const _modifier = (name) => options.modifiers\n        ? options.modifiers[name]\n        : DEFAULT_MODIFIER;\n    const normalize = shared_isPlainObject(options.processor) && shared_isFunction(options.processor.normalize)\n        ? options.processor.normalize\n        : DEFAULT_NORMALIZE;\n    const interpolate = shared_isPlainObject(options.processor) &&\n        shared_isFunction(options.processor.interpolate)\n        ? options.processor.interpolate\n        : DEFAULT_INTERPOLATE;\n    const type = shared_isPlainObject(options.processor) && shared_isString(options.processor.type)\n        ? options.processor.type\n        : DEFAULT_MESSAGE_DATA_TYPE;\n    const linked = (key, ...args) => {\n        const [arg1, arg2] = args;\n        let type = 'text';\n        let modifier = '';\n        if (args.length === 1) {\n            if (shared_isObject(arg1)) {\n                modifier = arg1.modifier || modifier;\n                type = arg1.type || type;\n            }\n            else if (shared_isString(arg1)) {\n                modifier = arg1 || modifier;\n            }\n        }\n        else if (args.length === 2) {\n            if (shared_isString(arg1)) {\n                modifier = arg1 || modifier;\n            }\n            if (shared_isString(arg2)) {\n                type = arg2 || type;\n            }\n        }\n        const ret = message(key)(ctx);\n        const msg = \n        // The message in vnode resolved with linked are returned as an array by processor.nomalize\n        type === 'vnode' && shared_isArray(ret) && modifier\n            ? ret[0]\n            : ret;\n        return modifier ? _modifier(modifier)(msg, type) : msg;\n    };\n    const ctx = {\n        [\"list\" /* HelperNameMap.LIST */]: list,\n        [\"named\" /* HelperNameMap.NAMED */]: named,\n        [\"plural\" /* HelperNameMap.PLURAL */]: plural,\n        [\"linked\" /* HelperNameMap.LINKED */]: linked,\n        [\"message\" /* HelperNameMap.MESSAGE */]: message,\n        [\"type\" /* HelperNameMap.TYPE */]: type,\n        [\"interpolate\" /* HelperNameMap.INTERPOLATE */]: interpolate,\n        [\"normalize\" /* HelperNameMap.NORMALIZE */]: normalize\n    };\n    return ctx;\n}\n\nlet core_base_devtools = null;\nfunction setDevToolsHook(hook) {\n    core_base_devtools = hook;\n}\nfunction getDevToolsHook() {\n    return core_base_devtools;\n}\nfunction initI18nDevTools(i18n, version, meta) {\n    // TODO: queue if devtools is undefined\n    core_base_devtools &&\n        core_base_devtools.emit(IntlifyDevToolsHooks.I18nInit, {\n            timestamp: Date.now(),\n            i18n,\n            version,\n            meta\n        });\n}\nconst translateDevTools = /* #__PURE__*/ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);\nfunction createDevToolsHook(hook) {\n    return (payloads) => core_base_devtools && core_base_devtools.emit(hook, payloads);\n}\n\nconst CoreWarnCodes = {\n    NOT_FOUND_KEY: 1,\n    FALLBACK_TO_TRANSLATE: 2,\n    CANNOT_FORMAT_NUMBER: 3,\n    FALLBACK_TO_NUMBER_FORMAT: 4,\n    CANNOT_FORMAT_DATE: 5,\n    FALLBACK_TO_DATE_FORMAT: 6,\n    __EXTEND_POINT__: 7\n};\n/** @internal */\nconst warnMessages = {\n    [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,\n    [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,\n    [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,\n    [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,\n    [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,\n    [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`\n};\nfunction getWarnMessage(code, ...args) {\n    return format$1(warnMessages[code], ...args);\n}\n\n/**\n * Fallback with simple implemenation\n *\n * @remarks\n * A fallback locale function implemented with a simple fallback algorithm.\n *\n * Basically, it returns the value as specified in the `fallbackLocale` props, and is processed with the fallback inside intlify.\n *\n * @param ctx - A {@link CoreContext | context}\n * @param fallback - A {@link FallbackLocale | fallback locale}\n * @param start - A starting {@link Locale | locale}\n *\n * @returns Fallback locales\n *\n * @VueI18nGeneral\n */\nfunction fallbackWithSimple(ctx, fallback, start // eslint-disable-line @typescript-eslint/no-unused-vars\n) {\n    // prettier-ignore\n    return [...new Set([\n            start,\n            ...(shared_isArray(fallback)\n                ? fallback\n                : shared_isObject(fallback)\n                    ? Object.keys(fallback)\n                    : shared_isString(fallback)\n                        ? [fallback]\n                        : [start])\n        ])];\n}\n/**\n * Fallback with locale chain\n *\n * @remarks\n * A fallback locale function implemented with a fallback chain algorithm. It's used in VueI18n as default.\n *\n * @param ctx - A {@link CoreContext | context}\n * @param fallback - A {@link FallbackLocale | fallback locale}\n * @param start - A starting {@link Locale | locale}\n *\n * @returns Fallback locales\n *\n * @VueI18nSee [Fallbacking](../guide/essentials/fallback)\n *\n * @VueI18nGeneral\n */\nfunction fallbackWithLocaleChain(ctx, fallback, start) {\n    const startLocale = shared_isString(start) ? start : DEFAULT_LOCALE;\n    const context = ctx;\n    if (!context.__localeChainCache) {\n        context.__localeChainCache = new Map();\n    }\n    let chain = context.__localeChainCache.get(startLocale);\n    if (!chain) {\n        chain = [];\n        // first block defined by start\n        let block = [start];\n        // while any intervening block found\n        while (shared_isArray(block)) {\n            block = appendBlockToChain(chain, block, fallback);\n        }\n        // prettier-ignore\n        // last block defined by default\n        const defaults = shared_isArray(fallback) || !shared_isPlainObject(fallback)\n            ? fallback\n            : fallback['default']\n                ? fallback['default']\n                : null;\n        // convert defaults to array\n        block = shared_isString(defaults) ? [defaults] : defaults;\n        if (shared_isArray(block)) {\n            appendBlockToChain(chain, block, false);\n        }\n        context.__localeChainCache.set(startLocale, chain);\n    }\n    return chain;\n}\nfunction appendBlockToChain(chain, block, blocks) {\n    let follow = true;\n    for (let i = 0; i < block.length && shared_isBoolean(follow); i++) {\n        const locale = block[i];\n        if (shared_isString(locale)) {\n            follow = appendLocaleToChain(chain, block[i], blocks);\n        }\n    }\n    return follow;\n}\nfunction appendLocaleToChain(chain, locale, blocks) {\n    let follow;\n    const tokens = locale.split('-');\n    do {\n        const target = tokens.join('-');\n        follow = appendItemToChain(chain, target, blocks);\n        tokens.splice(-1, 1);\n    } while (tokens.length && follow === true);\n    return follow;\n}\nfunction appendItemToChain(chain, target, blocks) {\n    let follow = false;\n    if (!chain.includes(target)) {\n        follow = true;\n        if (target) {\n            follow = target[target.length - 1] !== '!';\n            const locale = target.replace(/!/g, '');\n            chain.push(locale);\n            if ((shared_isArray(blocks) || shared_isPlainObject(blocks)) &&\n                blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any\n            ) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                follow = blocks[locale];\n            }\n        }\n    }\n    return follow;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Intlify core-base version\n * @internal\n */\nconst VERSION = '9.3.0-beta.25';\nconst NOT_REOSLVED = -1;\nconst DEFAULT_LOCALE = 'en-US';\nconst MISSING_RESOLVE_VALUE = '';\nconst core_base_capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;\nfunction getDefaultLinkedModifiers() {\n    return {\n        upper: (val, type) => {\n            // prettier-ignore\n            return type === 'text' && shared_isString(val)\n                ? val.toUpperCase()\n                : type === 'vnode' && shared_isObject(val) && '__v_isVNode' in val\n                    ? val.children.toUpperCase()\n                    : val;\n        },\n        lower: (val, type) => {\n            // prettier-ignore\n            return type === 'text' && shared_isString(val)\n                ? val.toLowerCase()\n                : type === 'vnode' && shared_isObject(val) && '__v_isVNode' in val\n                    ? val.children.toLowerCase()\n                    : val;\n        },\n        capitalize: (val, type) => {\n            // prettier-ignore\n            return (type === 'text' && shared_isString(val)\n                ? core_base_capitalize(val)\n                : type === 'vnode' && shared_isObject(val) && '__v_isVNode' in val\n                    ? core_base_capitalize(val.children)\n                    : val);\n        }\n    };\n}\nlet _compiler;\nfunction registerMessageCompiler(compiler) {\n    _compiler = compiler;\n}\nlet _resolver;\n/**\n * Register the message resolver\n *\n * @param resolver - A {@link MessageResolver} function\n *\n * @VueI18nGeneral\n */\nfunction registerMessageResolver(resolver) {\n    _resolver = resolver;\n}\nlet _fallbacker;\n/**\n * Register the locale fallbacker\n *\n * @param fallbacker - A {@link LocaleFallbacker} function\n *\n * @VueI18nGeneral\n */\nfunction registerLocaleFallbacker(fallbacker) {\n    _fallbacker = fallbacker;\n}\n// Additional Meta for Intlify DevTools\nlet _additionalMeta =  null;\nconst setAdditionalMeta =  (meta) => {\n    _additionalMeta = meta;\n};\nconst getAdditionalMeta =  () => _additionalMeta;\nlet _fallbackContext = null;\nconst setFallbackContext = (context) => {\n    _fallbackContext = context;\n};\nconst getFallbackContext = () => _fallbackContext;\n// ID for CoreContext\nlet _cid = 0;\nfunction createCoreContext(options = {}) {\n    // setup options\n    const version = shared_isString(options.version) ? options.version : VERSION;\n    const locale = shared_isString(options.locale) ? options.locale : DEFAULT_LOCALE;\n    const fallbackLocale = shared_isArray(options.fallbackLocale) ||\n        shared_isPlainObject(options.fallbackLocale) ||\n        shared_isString(options.fallbackLocale) ||\n        options.fallbackLocale === false\n        ? options.fallbackLocale\n        : locale;\n    const messages = shared_isPlainObject(options.messages)\n        ? options.messages\n        : { [locale]: {} };\n    const datetimeFormats = shared_isPlainObject(options.datetimeFormats)\n            ? options.datetimeFormats\n            : { [locale]: {} }\n        ;\n    const numberFormats = shared_isPlainObject(options.numberFormats)\n            ? options.numberFormats\n            : { [locale]: {} }\n        ;\n    const modifiers = shared_assign({}, options.modifiers || {}, getDefaultLinkedModifiers());\n    const pluralRules = options.pluralRules || {};\n    const missing = shared_isFunction(options.missing) ? options.missing : null;\n    const missingWarn = shared_isBoolean(options.missingWarn) || isRegExp(options.missingWarn)\n        ? options.missingWarn\n        : true;\n    const fallbackWarn = shared_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)\n        ? options.fallbackWarn\n        : true;\n    const fallbackFormat = !!options.fallbackFormat;\n    const unresolving = !!options.unresolving;\n    const postTranslation = shared_isFunction(options.postTranslation)\n        ? options.postTranslation\n        : null;\n    const processor = shared_isPlainObject(options.processor) ? options.processor : null;\n    const warnHtmlMessage = shared_isBoolean(options.warnHtmlMessage)\n        ? options.warnHtmlMessage\n        : true;\n    const escapeParameter = !!options.escapeParameter;\n    const messageCompiler = shared_isFunction(options.messageCompiler)\n        ? options.messageCompiler\n        : _compiler;\n    const messageResolver = shared_isFunction(options.messageResolver)\n        ? options.messageResolver\n        : _resolver || resolveWithKeyValue;\n    const localeFallbacker = shared_isFunction(options.localeFallbacker)\n        ? options.localeFallbacker\n        : _fallbacker || fallbackWithSimple;\n    const fallbackContext = shared_isObject(options.fallbackContext)\n        ? options.fallbackContext\n        : undefined;\n    const onWarn = shared_isFunction(options.onWarn) ? options.onWarn : shared_warn;\n    // setup internal options\n    const internalOptions = options;\n    const __datetimeFormatters = shared_isObject(internalOptions.__datetimeFormatters)\n            ? internalOptions.__datetimeFormatters\n            : new Map()\n        ;\n    const __numberFormatters = shared_isObject(internalOptions.__numberFormatters)\n            ? internalOptions.__numberFormatters\n            : new Map()\n        ;\n    const __meta = shared_isObject(internalOptions.__meta) ? internalOptions.__meta : {};\n    _cid++;\n    const context = {\n        version,\n        cid: _cid,\n        locale,\n        fallbackLocale,\n        messages,\n        modifiers,\n        pluralRules,\n        missing,\n        missingWarn,\n        fallbackWarn,\n        fallbackFormat,\n        unresolving,\n        postTranslation,\n        processor,\n        warnHtmlMessage,\n        escapeParameter,\n        messageCompiler,\n        messageResolver,\n        localeFallbacker,\n        fallbackContext,\n        onWarn,\n        __meta\n    };\n    {\n        context.datetimeFormats = datetimeFormats;\n        context.numberFormats = numberFormats;\n        context.__datetimeFormatters = __datetimeFormatters;\n        context.__numberFormatters = __numberFormatters;\n    }\n    // for vue-devtools timeline event\n    if ((false)) {}\n    // NOTE: experimental !!\n    if (( false) || __INTLIFY_PROD_DEVTOOLS__) {\n        initI18nDevTools(context, version, __meta);\n    }\n    return context;\n}\n/** @internal */\nfunction isTranslateFallbackWarn(fallback, key) {\n    return fallback instanceof RegExp ? fallback.test(key) : fallback;\n}\n/** @internal */\nfunction isTranslateMissingWarn(missing, key) {\n    return missing instanceof RegExp ? missing.test(key) : missing;\n}\n/** @internal */\nfunction handleMissing(context, key, locale, missingWarn, type) {\n    const { missing, onWarn } = context;\n    // for vue-devtools timeline event\n    if ((false)) {}\n    if (missing !== null) {\n        const ret = missing(context, locale, key, type);\n        return shared_isString(ret) ? ret : key;\n    }\n    else {\n        if (false) {}\n        return key;\n    }\n}\n/** @internal */\nfunction updateFallbackLocale(ctx, locale, fallback) {\n    const context = ctx;\n    context.__localeChainCache = new Map();\n    ctx.localeFallbacker(ctx, fallback, locale);\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nfunction core_base_format(ast) {\n    const msg = (ctx) => formatParts(ctx, ast);\n    return msg;\n}\nfunction formatParts(ctx, ast) {\n    const body = ast.b || ast.body;\n    if ((body.t || body.type) === 1 /* NodeTypes.Plural */) {\n        const plural = body;\n        const cases = plural.c || plural.cases;\n        return ctx.plural(cases.reduce((messages, c) => [\n            ...messages,\n            formatMessageParts(ctx, c)\n        ], []));\n    }\n    else {\n        return formatMessageParts(ctx, body);\n    }\n}\nfunction formatMessageParts(ctx, node) {\n    const _static = node.s || node.static;\n    if (_static) {\n        return ctx.type === 'text'\n            ? _static\n            : ctx.normalize([_static]);\n    }\n    else {\n        const messages = (node.i || node.items).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);\n        return ctx.normalize(messages);\n    }\n}\nfunction formatMessagePart(ctx, node) {\n    const type = node.t || node.type;\n    switch (type) {\n        case 3 /* NodeTypes.Text */:\n            const text = node;\n            return (text.v || text.value);\n        case 9 /* NodeTypes.Literal */:\n            const literal = node;\n            return (literal.v || literal.value);\n        case 4 /* NodeTypes.Named */:\n            const named = node;\n            return ctx.interpolate(ctx.named(named.k || named.key));\n        case 5 /* NodeTypes.List */:\n            const list = node;\n            return ctx.interpolate(ctx.list(list.i || list.index));\n        case 6 /* NodeTypes.Linked */:\n            const linked = node;\n            const modifier = linked.m || linked.modifier;\n            return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : undefined, ctx.type);\n        case 7 /* NodeTypes.LinkedKey */:\n            const linkedKey = node;\n            return (linkedKey.v || linkedKey.value);\n        case 8 /* NodeTypes.LinkedModifier */:\n            const linkedModifier = node;\n            return (linkedModifier.v || linkedModifier.value);\n        default:\n            throw new Error(`unhandled node type on format message part: ${type}`);\n    }\n}\n\nlet code = CompileErrorCodes.__EXTEND_POINT__;\nconst inc = () => ++code;\nconst CoreErrorCodes = {\n    INVALID_ARGUMENT: code,\n    INVALID_DATE_ARGUMENT: inc(),\n    INVALID_ISO_DATE_ARGUMENT: inc(),\n    NOT_SUPPORT_AST: inc(),\n    __EXTEND_POINT__: inc() // 19\n};\nfunction createCoreError(code) {\n    return createCompileError(code, null, ( false) ? 0 : undefined);\n}\n/** @internal */\nconst core_base_errorMessages = {\n    [CoreErrorCodes.INVALID_ARGUMENT]: 'Invalid arguments',\n    [CoreErrorCodes.INVALID_DATE_ARGUMENT]: 'The date provided is an invalid Date object.' +\n        'Make sure your Date represents a valid date.',\n    [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: 'The argument provided is not a valid ISO date string',\n    [CoreErrorCodes.NOT_SUPPORT_AST]: 'Not support AST'\n};\n\nconst WARN_MESSAGE = (/* unused pure expression or super */ null && (`Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`));\nfunction checkHtmlMessage(source, warnHtmlMessage) {\n    if (warnHtmlMessage && detectHtmlTag(source)) {\n        warn(format$1(WARN_MESSAGE, { source }));\n    }\n}\nconst defaultOnCacheKey = (message) => message;\nlet compileCache = Object.create(null);\nfunction clearCompileCache() {\n    compileCache = Object.create(null);\n}\nfunction core_base_baseCompile(message, options = {}) {\n    // error detecting on compile\n    let detectError = false;\n    const onError = options.onError || defaultOnError;\n    options.onError = (err) => {\n        detectError = true;\n        onError(err);\n    };\n    // compile with mesasge-compiler\n    return { ...baseCompile(message, options), detectError };\n}\nfunction compileToFunction(message, options = {}) {\n    if (!shared_isString(message)) {\n        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_AST);\n    }\n    {\n        // check HTML message\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const warnHtmlMessage = shared_isBoolean(options.warnHtmlMessage)\n            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                options.warnHtmlMessage\n            : true;\n        ( false) && 0;\n        // check caches\n        const onCacheKey = options.onCacheKey || defaultOnCacheKey;\n        const cacheKey = onCacheKey(message);\n        const cached = compileCache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        // compile\n        const { code, detectError } = core_base_baseCompile(message, options);\n        // evaluate function\n        const msg = new Function(`return ${code}`)();\n        // if occurred compile error, don't cache\n        return !detectError\n            ? (compileCache[cacheKey] = msg)\n            : msg;\n    }\n}\nfunction core_base_compile(message, options = {}) {\n    if (shared_isString(message)) {\n        // check HTML message\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const warnHtmlMessage = shared_isBoolean(options.warnHtmlMessage)\n            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                options.warnHtmlMessage\n            : true;\n        ( false) && 0;\n        // check caches\n        const onCacheKey = options.onCacheKey || defaultOnCacheKey;\n        const cacheKey = onCacheKey(message);\n        const cached = compileCache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        // compile with JIT mode\n        const { ast, detectError } = core_base_baseCompile(message, {\n            ...options,\n            location: (\"production\" !== 'production'),\n            jit: true\n        });\n        // compose message function from AST\n        const msg = core_base_format(ast);\n        // if occurred compile error, don't cache\n        return !detectError\n            ? (compileCache[cacheKey] = msg)\n            : msg;\n    }\n    else {\n        // AST case (passed from bundler)\n        const cacheKey = message.cacheKey;\n        if (cacheKey) {\n            const cached = compileCache[cacheKey];\n            if (cached) {\n                return cached;\n            }\n            // compose message function from message (AST)\n            return (compileCache[cacheKey] =\n                core_base_format(message));\n        }\n        else {\n            return core_base_format(message);\n        }\n    }\n}\n\nconst NOOP_MESSAGE_FUNCTION = () => '';\nconst isMessageFunction = (val) => shared_isFunction(val);\nconst isMessageAST = (val) => shared_isObject(val) && val.type === 0 && 'body' in val;\n// implementation of `translate` function\nfunction translate(context, ...args) {\n    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;\n    const [key, options] = parseTranslateArgs(...args);\n    const missingWarn = shared_isBoolean(options.missingWarn)\n        ? options.missingWarn\n        : context.missingWarn;\n    const fallbackWarn = shared_isBoolean(options.fallbackWarn)\n        ? options.fallbackWarn\n        : context.fallbackWarn;\n    const escapeParameter = shared_isBoolean(options.escapeParameter)\n        ? options.escapeParameter\n        : context.escapeParameter;\n    const resolvedMessage = !!options.resolvedMessage;\n    // prettier-ignore\n    const defaultMsgOrKey = shared_isString(options.default) || shared_isBoolean(options.default) // default by function option\n        ? !shared_isBoolean(options.default)\n            ? options.default\n            : (!messageCompiler ? () => key : key)\n        : fallbackFormat // default by `fallbackFormat` option\n            ? (!messageCompiler ? () => key : key)\n            : '';\n    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';\n    const locale = shared_isString(options.locale) ? options.locale : context.locale;\n    // escape params\n    escapeParameter && escapeParams(options);\n    // resolve message format\n    // eslint-disable-next-line prefer-const\n    let [formatScope, targetLocale, message] = !resolvedMessage\n        ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn)\n        : [\n            key,\n            locale,\n            messages[locale] || {}\n        ];\n    // NOTE:\n    //  Fix to work around `ssrTransfrom` bug in Vite.\n    //  https://github.com/vitejs/vite/issues/4306\n    //  To get around this, use temporary variables.\n    //  https://github.com/nuxt/framework/issues/1461#issuecomment-954606243\n    let format = formatScope;\n    // if you use default message, set it as message format!\n    let cacheBaseKey = key;\n    if (!resolvedMessage &&\n        !(shared_isString(format) ||\n            isMessageAST(format) ||\n            isMessageFunction(format))) {\n        if (enableDefaultMsg) {\n            format = defaultMsgOrKey;\n            cacheBaseKey = format;\n        }\n    }\n    // checking message format and target locale\n    if (!resolvedMessage &&\n        (!(shared_isString(format) ||\n            isMessageAST(format) ||\n            isMessageFunction(format)) ||\n            !shared_isString(targetLocale))) {\n        return unresolving ? NOT_REOSLVED : key;\n    }\n    // TODO: refactor\n    if (false) {}\n    // setup compile error detecting\n    let occurred = false;\n    const errorDetector = () => {\n        occurred = true;\n    };\n    // compile message format\n    const msg = !isMessageFunction(format)\n        ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector)\n        : format;\n    // if occurred compile error, return the message format\n    if (occurred) {\n        return format;\n    }\n    // evaluate message with context\n    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);\n    const msgContext = createMessageContext(ctxOptions);\n    const messaged = evaluateMessage(context, msg, msgContext);\n    // if use post translation option, proceed it with handler\n    const ret = postTranslation\n        ? postTranslation(messaged, key)\n        : messaged;\n    // NOTE: experimental !!\n    if (( false) || __INTLIFY_PROD_DEVTOOLS__) {\n        // prettier-ignore\n        const payloads = {\n            timestamp: Date.now(),\n            key: shared_isString(key)\n                ? key\n                : isMessageFunction(format)\n                    ? format.key\n                    : '',\n            locale: targetLocale || (isMessageFunction(format)\n                ? format.locale\n                : ''),\n            format: shared_isString(format)\n                ? format\n                : isMessageFunction(format)\n                    ? format.source\n                    : '',\n            message: ret\n        };\n        payloads.meta = shared_assign({}, context.__meta, getAdditionalMeta() || {});\n        translateDevTools(payloads);\n    }\n    return ret;\n}\nfunction escapeParams(options) {\n    if (shared_isArray(options.list)) {\n        options.list = options.list.map(item => shared_isString(item) ? shared_escapeHtml(item) : item);\n    }\n    else if (shared_isObject(options.named)) {\n        Object.keys(options.named).forEach(key => {\n            if (shared_isString(options.named[key])) {\n                options.named[key] = shared_escapeHtml(options.named[key]);\n            }\n        });\n    }\n}\nfunction resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {\n    const { messages, onWarn, messageResolver: resolveValue, localeFallbacker } = context;\n    const locales = localeFallbacker(context, fallbackLocale, locale); // eslint-disable-line @typescript-eslint/no-explicit-any\n    let message = {};\n    let targetLocale;\n    let format = null;\n    let from = locale;\n    let to = null;\n    const type = 'translate';\n    for (let i = 0; i < locales.length; i++) {\n        targetLocale = to = locales[i];\n        if (false) {}\n        // for vue-devtools timeline event\n        if (false) {}\n        message =\n            messages[targetLocale] || {};\n        // for vue-devtools timeline event\n        let start = null;\n        let startTag;\n        let endTag;\n        if (false) {}\n        if ((format = resolveValue(message, key)) === null) {\n            // if null, resolve with object key path\n            format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any\n        }\n        // for vue-devtools timeline event\n        if (false) {}\n        if (shared_isString(format) || isMessageAST(format) || isMessageFunction(format)) {\n            break;\n        }\n        const missingRet = handleMissing(context, // eslint-disable-line @typescript-eslint/no-explicit-any\n        key, targetLocale, missingWarn, type);\n        if (missingRet !== key) {\n            format = missingRet;\n        }\n        from = to;\n    }\n    return [format, targetLocale, message];\n}\nfunction compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {\n    const { messageCompiler, warnHtmlMessage } = context;\n    if (isMessageFunction(format)) {\n        const msg = format;\n        msg.locale = msg.locale || targetLocale;\n        msg.key = msg.key || key;\n        return msg;\n    }\n    if (messageCompiler == null) {\n        const msg = (() => format);\n        msg.locale = targetLocale;\n        msg.key = key;\n        return msg;\n    }\n    // for vue-devtools timeline event\n    let start = null;\n    let startTag;\n    let endTag;\n    if (false) {}\n    const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector));\n    // for vue-devtools timeline event\n    if (false) {}\n    msg.locale = targetLocale;\n    msg.key = key;\n    msg.source = format;\n    return msg;\n}\nfunction evaluateMessage(context, msg, msgCtx) {\n    // for vue-devtools timeline event\n    let start = null;\n    let startTag;\n    let endTag;\n    if (false) {}\n    const messaged = msg(msgCtx);\n    // for vue-devtools timeline event\n    if (false) {}\n    return messaged;\n}\n/** @internal */\nfunction parseTranslateArgs(...args) {\n    const [arg1, arg2, arg3] = args;\n    const options = {};\n    if (!shared_isString(arg1) &&\n        !isNumber(arg1) &&\n        !isMessageFunction(arg1) &&\n        !isMessageAST(arg1)) {\n        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);\n    }\n    // prettier-ignore\n    const key = isNumber(arg1)\n        ? String(arg1)\n        : isMessageFunction(arg1)\n            ? arg1\n            : arg1;\n    if (isNumber(arg2)) {\n        options.plural = arg2;\n    }\n    else if (shared_isString(arg2)) {\n        options.default = arg2;\n    }\n    else if (shared_isPlainObject(arg2) && !isEmptyObject(arg2)) {\n        options.named = arg2;\n    }\n    else if (shared_isArray(arg2)) {\n        options.list = arg2;\n    }\n    if (isNumber(arg3)) {\n        options.plural = arg3;\n    }\n    else if (shared_isString(arg3)) {\n        options.default = arg3;\n    }\n    else if (shared_isPlainObject(arg3)) {\n        shared_assign(options, arg3);\n    }\n    return [key, options];\n}\nfunction getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {\n    return {\n        warnHtmlMessage,\n        onError: (err) => {\n            errorDetector && errorDetector(err);\n            if ((false)) {}\n            else {\n                throw err;\n            }\n        },\n        onCacheKey: (source) => generateFormatCacheKey(locale, key, source)\n    };\n}\nfunction getSourceForCodeFrame(source) {\n    if (isString(source)) ;\n    else {\n        if (source.loc?.source) {\n            return source.loc.source;\n        }\n    }\n}\nfunction getMessageContextOptions(context, locale, message, options) {\n    const { modifiers, pluralRules, messageResolver: resolveValue, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;\n    const resolveMessage = (key) => {\n        let val = resolveValue(message, key);\n        // fallback to root context\n        if (val == null && fallbackContext) {\n            const [, , message] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);\n            val = resolveValue(message, key);\n        }\n        if (shared_isString(val) || isMessageAST(val)) {\n            let occurred = false;\n            const errorDetector = () => {\n                occurred = true;\n            };\n            const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);\n            return !occurred\n                ? msg\n                : NOOP_MESSAGE_FUNCTION;\n        }\n        else if (isMessageFunction(val)) {\n            return val;\n        }\n        else {\n            // TODO: should be implemented warning message\n            return NOOP_MESSAGE_FUNCTION;\n        }\n    };\n    const ctxOptions = {\n        locale,\n        modifiers,\n        pluralRules,\n        messages: resolveMessage\n    };\n    if (context.processor) {\n        ctxOptions.processor = context.processor;\n    }\n    if (options.list) {\n        ctxOptions.list = options.list;\n    }\n    if (options.named) {\n        ctxOptions.named = options.named;\n    }\n    if (isNumber(options.plural)) {\n        ctxOptions.pluralIndex = options.plural;\n    }\n    return ctxOptions;\n}\n\nconst intlDefined = typeof Intl !== 'undefined';\nconst Availabilities = {\n    dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',\n    numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'\n};\n\n// implementation of `datetime` function\nfunction datetime(context, ...args) {\n    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;\n    const { __datetimeFormatters } = context;\n    if (false) {}\n    const [key, value, options, overrides] = parseDateTimeArgs(...args);\n    const missingWarn = shared_isBoolean(options.missingWarn)\n        ? options.missingWarn\n        : context.missingWarn;\n    const fallbackWarn = shared_isBoolean(options.fallbackWarn)\n        ? options.fallbackWarn\n        : context.fallbackWarn;\n    const part = !!options.part;\n    const locale = shared_isString(options.locale) ? options.locale : context.locale;\n    const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any\n    fallbackLocale, locale);\n    if (!shared_isString(key) || key === '') {\n        return new Intl.DateTimeFormat(locale, overrides).format(value);\n    }\n    // resolve format\n    let datetimeFormat = {};\n    let targetLocale;\n    let format = null;\n    let from = locale;\n    let to = null;\n    const type = 'datetime format';\n    for (let i = 0; i < locales.length; i++) {\n        targetLocale = to = locales[i];\n        if (false) {}\n        // for vue-devtools timeline event\n        if (false) {}\n        datetimeFormat =\n            datetimeFormats[targetLocale] || {};\n        format = datetimeFormat[key];\n        if (shared_isPlainObject(format))\n            break;\n        handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any\n        from = to;\n    }\n    // checking format and target locale\n    if (!shared_isPlainObject(format) || !shared_isString(targetLocale)) {\n        return unresolving ? NOT_REOSLVED : key;\n    }\n    let id = `${targetLocale}__${key}`;\n    if (!isEmptyObject(overrides)) {\n        id = `${id}__${JSON.stringify(overrides)}`;\n    }\n    let formatter = __datetimeFormatters.get(id);\n    if (!formatter) {\n        formatter = new Intl.DateTimeFormat(targetLocale, shared_assign({}, format, overrides));\n        __datetimeFormatters.set(id, formatter);\n    }\n    return !part ? formatter.format(value) : formatter.formatToParts(value);\n}\n/** @internal */\nconst DATETIME_FORMAT_OPTIONS_KEYS = [\n    'localeMatcher',\n    'weekday',\n    'era',\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'timeZoneName',\n    'formatMatcher',\n    'hour12',\n    'timeZone',\n    'dateStyle',\n    'timeStyle',\n    'calendar',\n    'dayPeriod',\n    'numberingSystem',\n    'hourCycle',\n    'fractionalSecondDigits'\n];\n/** @internal */\nfunction parseDateTimeArgs(...args) {\n    const [arg1, arg2, arg3, arg4] = args;\n    const options = {};\n    let overrides = {};\n    let value;\n    if (shared_isString(arg1)) {\n        // Only allow ISO strings - other date formats are often supported,\n        // but may cause different results in different browsers.\n        const matches = arg1.match(/(\\d{4}-\\d{2}-\\d{2})(T|\\s)?(.*)/);\n        if (!matches) {\n            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);\n        }\n        // Some browsers can not parse the iso datetime separated by space,\n        // this is a compromise solution by replace the 'T'/' ' with 'T'\n        const dateTime = matches[3]\n            ? matches[3].trim().startsWith('T')\n                ? `${matches[1].trim()}${matches[3].trim()}`\n                : `${matches[1].trim()}T${matches[3].trim()}`\n            : matches[1].trim();\n        value = new Date(dateTime);\n        try {\n            // This will fail if the date is not valid\n            value.toISOString();\n        }\n        catch (e) {\n            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);\n        }\n    }\n    else if (shared_isDate(arg1)) {\n        if (isNaN(arg1.getTime())) {\n            throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);\n        }\n        value = arg1;\n    }\n    else if (isNumber(arg1)) {\n        value = arg1;\n    }\n    else {\n        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);\n    }\n    if (shared_isString(arg2)) {\n        options.key = arg2;\n    }\n    else if (shared_isPlainObject(arg2)) {\n        Object.keys(arg2).forEach(key => {\n            if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {\n                overrides[key] = arg2[key];\n            }\n            else {\n                options[key] = arg2[key];\n            }\n        });\n    }\n    if (shared_isString(arg3)) {\n        options.locale = arg3;\n    }\n    else if (shared_isPlainObject(arg3)) {\n        overrides = arg3;\n    }\n    if (shared_isPlainObject(arg4)) {\n        overrides = arg4;\n    }\n    return [options.key || '', value, options, overrides];\n}\n/** @internal */\nfunction clearDateTimeFormat(ctx, locale, format) {\n    const context = ctx;\n    for (const key in format) {\n        const id = `${locale}__${key}`;\n        if (!context.__datetimeFormatters.has(id)) {\n            continue;\n        }\n        context.__datetimeFormatters.delete(id);\n    }\n}\n\n// implementation of `number` function\nfunction number(context, ...args) {\n    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;\n    const { __numberFormatters } = context;\n    if (false) {}\n    const [key, value, options, overrides] = parseNumberArgs(...args);\n    const missingWarn = shared_isBoolean(options.missingWarn)\n        ? options.missingWarn\n        : context.missingWarn;\n    const fallbackWarn = shared_isBoolean(options.fallbackWarn)\n        ? options.fallbackWarn\n        : context.fallbackWarn;\n    const part = !!options.part;\n    const locale = shared_isString(options.locale) ? options.locale : context.locale;\n    const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any\n    fallbackLocale, locale);\n    if (!shared_isString(key) || key === '') {\n        return new Intl.NumberFormat(locale, overrides).format(value);\n    }\n    // resolve format\n    let numberFormat = {};\n    let targetLocale;\n    let format = null;\n    let from = locale;\n    let to = null;\n    const type = 'number format';\n    for (let i = 0; i < locales.length; i++) {\n        targetLocale = to = locales[i];\n        if (false) {}\n        // for vue-devtools timeline event\n        if (false) {}\n        numberFormat =\n            numberFormats[targetLocale] || {};\n        format = numberFormat[key];\n        if (shared_isPlainObject(format))\n            break;\n        handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any\n        from = to;\n    }\n    // checking format and target locale\n    if (!shared_isPlainObject(format) || !shared_isString(targetLocale)) {\n        return unresolving ? NOT_REOSLVED : key;\n    }\n    let id = `${targetLocale}__${key}`;\n    if (!isEmptyObject(overrides)) {\n        id = `${id}__${JSON.stringify(overrides)}`;\n    }\n    let formatter = __numberFormatters.get(id);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(targetLocale, shared_assign({}, format, overrides));\n        __numberFormatters.set(id, formatter);\n    }\n    return !part ? formatter.format(value) : formatter.formatToParts(value);\n}\n/** @internal */\nconst NUMBER_FORMAT_OPTIONS_KEYS = [\n    'localeMatcher',\n    'style',\n    'currency',\n    'currencyDisplay',\n    'currencySign',\n    'useGrouping',\n    'minimumIntegerDigits',\n    'minimumFractionDigits',\n    'maximumFractionDigits',\n    'minimumSignificantDigits',\n    'maximumSignificantDigits',\n    'compactDisplay',\n    'notation',\n    'signDisplay',\n    'unit',\n    'unitDisplay',\n    'roundingMode',\n    'roundingPriority',\n    'roundingIncrement',\n    'trailingZeroDisplay'\n];\n/** @internal */\nfunction parseNumberArgs(...args) {\n    const [arg1, arg2, arg3, arg4] = args;\n    const options = {};\n    let overrides = {};\n    if (!isNumber(arg1)) {\n        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);\n    }\n    const value = arg1;\n    if (shared_isString(arg2)) {\n        options.key = arg2;\n    }\n    else if (shared_isPlainObject(arg2)) {\n        Object.keys(arg2).forEach(key => {\n            if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {\n                overrides[key] = arg2[key];\n            }\n            else {\n                options[key] = arg2[key];\n            }\n        });\n    }\n    if (shared_isString(arg3)) {\n        options.locale = arg3;\n    }\n    else if (shared_isPlainObject(arg3)) {\n        overrides = arg3;\n    }\n    if (shared_isPlainObject(arg4)) {\n        overrides = arg4;\n    }\n    return [options.key || '', value, options, overrides];\n}\n/** @internal */\nfunction clearNumberFormat(ctx, locale, format) {\n    const context = ctx;\n    for (const key in format) {\n        const id = `${locale}__${key}`;\n        if (!context.__numberFormatters.has(id)) {\n            continue;\n        }\n        context.__numberFormatters.delete(id);\n    }\n}\n\n{\n    core_base_initFeatureFlags();\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/env.js\nfunction getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nfunction getTarget() {\n    // @ts-ignore\n    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')\n        ? window\n        : typeof __webpack_require__.g !== 'undefined'\n            ? __webpack_require__.g\n            : {};\n}\nconst isProxyAvailable = typeof Proxy === 'function';\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/const.js\nconst HOOK_SETUP = 'devtools-plugin:setup';\nconst HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/time.js\nlet time_supported;\nlet time_perf;\nfunction isPerformanceSupported() {\n    var _a;\n    if (time_supported !== undefined) {\n        return time_supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        time_supported = true;\n        time_perf = window.performance;\n    }\n    else if (typeof __webpack_require__.g !== 'undefined' && ((_a = __webpack_require__.g.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n        time_supported = true;\n        time_perf = __webpack_require__.g.perf_hooks.performance;\n    }\n    else {\n        time_supported = false;\n    }\n    return time_supported;\n}\nfunction now() {\n    return isPerformanceSupported() ? time_perf.now() : Date.now();\n}\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/proxy.js\n\n\nclass ApiProxy {\n    constructor(plugin, hook) {\n        this.target = null;\n        this.targetQueue = [];\n        this.onQueue = [];\n        this.plugin = plugin;\n        this.hook = hook;\n        const defaultSettings = {};\n        if (plugin.settings) {\n            for (const id in plugin.settings) {\n                const item = plugin.settings[id];\n                defaultSettings[id] = item.defaultValue;\n            }\n        }\n        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n        let currentSettings = Object.assign({}, defaultSettings);\n        try {\n            const raw = localStorage.getItem(localSettingsSaveId);\n            const data = JSON.parse(raw);\n            Object.assign(currentSettings, data);\n        }\n        catch (e) {\n            // noop\n        }\n        this.fallbacks = {\n            getSettings() {\n                return currentSettings;\n            },\n            setSettings(value) {\n                try {\n                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n                }\n                catch (e) {\n                    // noop\n                }\n                currentSettings = value;\n            },\n            now() {\n                return now();\n            },\n        };\n        if (hook) {\n            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n                if (pluginId === this.plugin.id) {\n                    this.fallbacks.setSettings(value);\n                }\n            });\n        }\n        this.proxiedOn = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target.on[prop];\n                }\n                else {\n                    return (...args) => {\n                        this.onQueue.push({\n                            method: prop,\n                            args,\n                        });\n                    };\n                }\n            },\n        });\n        this.proxiedTarget = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target[prop];\n                }\n                else if (prop === 'on') {\n                    return this.proxiedOn;\n                }\n                else if (Object.keys(this.fallbacks).includes(prop)) {\n                    return (...args) => {\n                        this.targetQueue.push({\n                            method: prop,\n                            args,\n                            resolve: () => { },\n                        });\n                        return this.fallbacks[prop](...args);\n                    };\n                }\n                else {\n                    return (...args) => {\n                        return new Promise(resolve => {\n                            this.targetQueue.push({\n                                method: prop,\n                                args,\n                                resolve,\n                            });\n                        });\n                    };\n                }\n            },\n        });\n    }\n    async setRealTarget(target) {\n        this.target = target;\n        for (const item of this.onQueue) {\n            this.target.on[item.method](...item.args);\n        }\n        for (const item of this.targetQueue) {\n            item.resolve(await this.target[item.method](...item.args));\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@vue/devtools-api/lib/esm/index.js\n\n\n\n\n\n\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const descriptor = pluginDescriptor;\n    const target = getTarget();\n    const hook = getDevtoolsGlobalHook();\n    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor: descriptor,\n            setupFn,\n            proxy,\n        });\n        if (proxy)\n            setupFn(proxy.proxiedTarget);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/@intlify/vue-devtools/dist/vue-devtools.mjs\n/*!\n  * vue-devtools v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nconst VueDevToolsLabels = {\n    [\"vue-devtools-plugin-vue-i18n\" /* VueDevToolsIDs.PLUGIN */]: 'Vue I18n devtools',\n    [\"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */]: 'I18n Resources',\n    [\"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */]: 'Vue I18n'\n};\nconst VueDevToolsPlaceholders = {\n    [\"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */]: 'Search for scopes ...'\n};\nconst VueDevToolsTimelineColors = {\n    [\"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */]: 0xffcd19\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/vue-i18n/dist/vue-i18n.mjs\n/*!\n  * vue-i18n v9.3.0-beta.25\n  * (c) 2023 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\n\n\n\n\n/**\n * Vue I18n Version\n *\n * @remarks\n * Semver format. Same format as the package.json `version` field.\n *\n * @VueI18nGeneral\n */\nconst vue_i18n_VERSION = '9.3.0-beta.25';\n/**\n * This is only called in esm-bundler builds.\n * istanbul-ignore-next\n */\nfunction vue_i18n_initFeatureFlags() {\n    if (typeof __VUE_I18N_FULL_INSTALL__ !== 'boolean') {\n        shared_getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;\n    }\n    if (typeof __VUE_I18N_LEGACY_API__ !== 'boolean') {\n        shared_getGlobalThis().__VUE_I18N_LEGACY_API__ = true;\n    }\n    if (typeof __INTLIFY_JIT_COMPILATION__ !== 'boolean') {\n        shared_getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;\n    }\n    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {\n        shared_getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;\n    }\n}\n\nlet code$1 = CoreWarnCodes.__EXTEND_POINT__;\nconst inc$1 = () => ++code$1;\nconst I18nWarnCodes = {\n    FALLBACK_TO_ROOT: code$1,\n    NOT_SUPPORTED_PRESERVE: inc$1(),\n    NOT_SUPPORTED_FORMATTER: inc$1(),\n    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),\n    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),\n    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),\n    NOT_FOUND_PARENT_SCOPE: inc$1(),\n    IGNORE_OBJ_FLATTEN: inc$1() // 14\n};\nconst vue_i18n_warnMessages = {\n    [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,\n    [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,\n    [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,\n    [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,\n    [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,\n    [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,\n    [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,\n    [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`\n};\nfunction vue_i18n_getWarnMessage(code, ...args) {\n    return format(vue_i18n_warnMessages[code], ...args);\n}\n\nlet vue_i18n_code = CompileErrorCodes.__EXTEND_POINT__;\nconst vue_i18n_inc = () => ++vue_i18n_code;\nconst I18nErrorCodes = {\n    // composer module errors\n    UNEXPECTED_RETURN_TYPE: vue_i18n_code,\n    // legacy module errors\n    INVALID_ARGUMENT: vue_i18n_inc(),\n    // i18n module errors\n    MUST_BE_CALL_SETUP_TOP: vue_i18n_inc(),\n    NOT_INSTALLED: vue_i18n_inc(),\n    NOT_AVAILABLE_IN_LEGACY_MODE: vue_i18n_inc(),\n    // directive module errors\n    REQUIRED_VALUE: vue_i18n_inc(),\n    INVALID_VALUE: vue_i18n_inc(),\n    // vue-devtools errors\n    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: vue_i18n_inc(),\n    NOT_INSTALLED_WITH_PROVIDE: vue_i18n_inc(),\n    // unexpected error\n    UNEXPECTED_ERROR: vue_i18n_inc(),\n    // not compatible legacy vue-i18n constructor\n    NOT_COMPATIBLE_LEGACY_VUE_I18N: vue_i18n_inc(),\n    // bridge support vue 2.x only\n    BRIDGE_SUPPORT_VUE_2_ONLY: vue_i18n_inc(),\n    // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``\n    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: vue_i18n_inc(),\n    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly\n    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: vue_i18n_inc(),\n    // for enhancement\n    __EXTEND_POINT__: vue_i18n_inc() // 29\n};\nfunction createI18nError(code, ...args) {\n    return createCompileError(code, null, ( false) ? 0 : undefined);\n}\nconst vue_i18n_errorMessages = {\n    [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: 'Unexpected return type in composer',\n    [I18nErrorCodes.INVALID_ARGUMENT]: 'Invalid argument',\n    [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: 'Must be called at the top of a `setup` function',\n    [I18nErrorCodes.NOT_INSTALLED]: 'Need to install with `app.use` function',\n    [I18nErrorCodes.UNEXPECTED_ERROR]: 'Unexpected error',\n    [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: 'Not available in legacy mode',\n    [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,\n    [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,\n    [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,\n    [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: 'Need to install with `provide` function',\n    [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: 'Not compatible legacy VueI18n.',\n    [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: 'vue-i18n-bridge support Vue 2.x only',\n    [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: 'Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode',\n    [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: 'Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly'\n};\n\nconst TranslateVNodeSymbol = \n/* #__PURE__*/ makeSymbol('__translateVNode');\nconst DatetimePartsSymbol = /* #__PURE__*/ makeSymbol('__datetimeParts');\nconst NumberPartsSymbol = /* #__PURE__*/ makeSymbol('__numberParts');\nconst EnableEmitter = /* #__PURE__*/ makeSymbol('__enableEmitter');\nconst DisableEmitter = /* #__PURE__*/ makeSymbol('__disableEmitter');\nconst SetPluralRulesSymbol = makeSymbol('__setPluralRules');\nmakeSymbol('__intlifyMeta');\nconst InejctWithOption = /* #__PURE__*/ makeSymbol('__injectWithOption');\nconst __VUE_I18N_BRIDGE__ =  '__VUE_I18N_BRIDGE__';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Transform flat json in obj to normal json in obj\n */\nfunction handleFlatJson(obj) {\n    // check obj\n    if (!shared_isObject(obj)) {\n        return obj;\n    }\n    for (const key in obj) {\n        // check key\n        if (!shared_hasOwn(obj, key)) {\n            continue;\n        }\n        // handle for normal json\n        if (!key.includes('.')) {\n            // recursive process value if value is also a object\n            if (shared_isObject(obj[key])) {\n                handleFlatJson(obj[key]);\n            }\n        }\n        // handle for flat json, transform to normal json\n        else {\n            // go to the last object\n            const subKeys = key.split('.');\n            const lastIndex = subKeys.length - 1;\n            let currentObj = obj;\n            let hasStringValue = false;\n            for (let i = 0; i < lastIndex; i++) {\n                if (!(subKeys[i] in currentObj)) {\n                    currentObj[subKeys[i]] = {};\n                }\n                if (!shared_isObject(currentObj[subKeys[i]])) {\n                    ( false) &&\n                        0;\n                    hasStringValue = true;\n                    break;\n                }\n                currentObj = currentObj[subKeys[i]];\n            }\n            // update last object value, delete old property\n            if (!hasStringValue) {\n                currentObj[subKeys[lastIndex]] = obj[key];\n                delete obj[key];\n            }\n            // recursive process value if value is also a object\n            if (shared_isObject(currentObj[subKeys[lastIndex]])) {\n                handleFlatJson(currentObj[subKeys[lastIndex]]);\n            }\n        }\n    }\n    return obj;\n}\nfunction getLocaleMessages(locale, options) {\n    const { messages, __i18n, messageResolver, flatJson } = options;\n    // prettier-ignore\n    const ret = (shared_isPlainObject(messages)\n        ? messages\n        : shared_isArray(__i18n)\n            ? {}\n            : { [locale]: {} });\n    // merge locale messages of i18n custom block\n    if (shared_isArray(__i18n)) {\n        __i18n.forEach(custom => {\n            if ('locale' in custom && 'resource' in custom) {\n                const { locale, resource } = custom;\n                if (locale) {\n                    ret[locale] = ret[locale] || {};\n                    deepCopy(resource, ret[locale]);\n                }\n                else {\n                    deepCopy(resource, ret);\n                }\n            }\n            else {\n                shared_isString(custom) && deepCopy(JSON.parse(custom), ret);\n            }\n        });\n    }\n    // handle messages for flat json\n    if (messageResolver == null && flatJson) {\n        for (const key in ret) {\n            if (shared_hasOwn(ret, key)) {\n                handleFlatJson(ret[key]);\n            }\n        }\n    }\n    return ret;\n}\nconst isNotObjectOrIsArray = (val) => !shared_isObject(val) || shared_isArray(val);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nfunction deepCopy(src, des) {\n    // src and des should both be objects, and non of then can be a array\n    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {\n        throw createI18nError(I18nErrorCodes.INVALID_VALUE);\n    }\n    for (const key in src) {\n        if (shared_hasOwn(src, key)) {\n            if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {\n                // replace with src[key] when:\n                // src[key] or des[key] is not a object, or\n                // src[key] or des[key] is a array\n                des[key] = src[key];\n            }\n            else {\n                // src[key] and des[key] are both object, merge them\n                deepCopy(src[key], des[key]);\n            }\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getComponentOptions(instance) {\n    return instance.type ;\n}\nfunction adjustI18nResources(gl, options, componentOptions // eslint-disable-line @typescript-eslint/no-explicit-any\n) {\n    let messages = shared_isObject(options.messages) ? options.messages : {};\n    if ('__i18nGlobal' in componentOptions) {\n        messages = getLocaleMessages(gl.locale.value, {\n            messages,\n            __i18n: componentOptions.__i18nGlobal\n        });\n    }\n    // merge locale messages\n    const locales = Object.keys(messages);\n    if (locales.length) {\n        locales.forEach(locale => {\n            gl.mergeLocaleMessage(locale, messages[locale]);\n        });\n    }\n    {\n        // merge datetime formats\n        if (shared_isObject(options.datetimeFormats)) {\n            const locales = Object.keys(options.datetimeFormats);\n            if (locales.length) {\n                locales.forEach(locale => {\n                    gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);\n                });\n            }\n        }\n        // merge number formats\n        if (shared_isObject(options.numberFormats)) {\n            const locales = Object.keys(options.numberFormats);\n            if (locales.length) {\n                locales.forEach(locale => {\n                    gl.mergeNumberFormat(locale, options.numberFormats[locale]);\n                });\n            }\n        }\n    }\n}\nfunction createTextNode(key) {\n    return runtime_core_esm_bundler_createVNode(Text, null, key, 0)\n        ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// extend VNode interface\nconst DEVTOOLS_META = '__INTLIFY_META__';\nlet composerID = 0;\nfunction defineCoreMissingHandler(missing) {\n    return ((ctx, locale, key, type) => {\n        return missing(locale, key, runtime_core_esm_bundler_getCurrentInstance() || undefined, type);\n    });\n}\n// for Intlify DevTools\nconst getMetaInfo =  () => {\n    const instance = runtime_core_esm_bundler_getCurrentInstance();\n    let meta = null; // eslint-disable-line @typescript-eslint/no-explicit-any\n    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META])\n        ? { [DEVTOOLS_META]: meta } // eslint-disable-line @typescript-eslint/no-explicit-any\n        : null;\n};\n/**\n * Create composer interface factory\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction createComposer(options = {}, VueI18nLegacy) {\n    const { __root } = options;\n    const _isGlobal = __root === undefined;\n    let _inheritLocale = shared_isBoolean(options.inheritLocale)\n        ? options.inheritLocale\n        : true;\n    const _locale = reactivity_esm_bundler_ref(\n    // prettier-ignore\n    __root && _inheritLocale\n        ? __root.locale.value\n        : shared_isString(options.locale)\n            ? options.locale\n            : DEFAULT_LOCALE);\n    const _fallbackLocale = reactivity_esm_bundler_ref(\n    // prettier-ignore\n    __root && _inheritLocale\n        ? __root.fallbackLocale.value\n        : shared_isString(options.fallbackLocale) ||\n            shared_isArray(options.fallbackLocale) ||\n            shared_isPlainObject(options.fallbackLocale) ||\n            options.fallbackLocale === false\n            ? options.fallbackLocale\n            : _locale.value);\n    const _messages = reactivity_esm_bundler_ref(getLocaleMessages(_locale.value, options));\n    // prettier-ignore\n    const _datetimeFormats = reactivity_esm_bundler_ref(shared_isPlainObject(options.datetimeFormats)\n            ? options.datetimeFormats\n            : { [_locale.value]: {} })\n        ;\n    // prettier-ignore\n    const _numberFormats = reactivity_esm_bundler_ref(shared_isPlainObject(options.numberFormats)\n            ? options.numberFormats\n            : { [_locale.value]: {} })\n        ;\n    // warning suppress options\n    // prettier-ignore\n    let _missingWarn = __root\n        ? __root.missingWarn\n        : shared_isBoolean(options.missingWarn) || isRegExp(options.missingWarn)\n            ? options.missingWarn\n            : true;\n    // prettier-ignore\n    let _fallbackWarn = __root\n        ? __root.fallbackWarn\n        : shared_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)\n            ? options.fallbackWarn\n            : true;\n    // prettier-ignore\n    let _fallbackRoot = __root\n        ? __root.fallbackRoot\n        : shared_isBoolean(options.fallbackRoot)\n            ? options.fallbackRoot\n            : true;\n    // configure fall back to root\n    let _fallbackFormat = !!options.fallbackFormat;\n    // runtime missing\n    let _missing = shared_isFunction(options.missing) ? options.missing : null;\n    let _runtimeMissing = shared_isFunction(options.missing)\n        ? defineCoreMissingHandler(options.missing)\n        : null;\n    // postTranslation handler\n    let _postTranslation = shared_isFunction(options.postTranslation)\n        ? options.postTranslation\n        : null;\n    // prettier-ignore\n    let _warnHtmlMessage = __root\n        ? __root.warnHtmlMessage\n        : shared_isBoolean(options.warnHtmlMessage)\n            ? options.warnHtmlMessage\n            : true;\n    let _escapeParameter = !!options.escapeParameter;\n    // custom linked modifiers\n    // prettier-ignore\n    const _modifiers = __root\n        ? __root.modifiers\n        : shared_isPlainObject(options.modifiers)\n            ? options.modifiers\n            : {};\n    // pluralRules\n    let _pluralRules = options.pluralRules || (__root && __root.pluralRules);\n    // runtime context\n    // eslint-disable-next-line prefer-const\n    let _context;\n    const getCoreContext = () => {\n        _isGlobal && setFallbackContext(null);\n        const ctxOptions = {\n            version: vue_i18n_VERSION,\n            locale: _locale.value,\n            fallbackLocale: _fallbackLocale.value,\n            messages: _messages.value,\n            modifiers: _modifiers,\n            pluralRules: _pluralRules,\n            missing: _runtimeMissing === null ? undefined : _runtimeMissing,\n            missingWarn: _missingWarn,\n            fallbackWarn: _fallbackWarn,\n            fallbackFormat: _fallbackFormat,\n            unresolving: true,\n            postTranslation: _postTranslation === null ? undefined : _postTranslation,\n            warnHtmlMessage: _warnHtmlMessage,\n            escapeParameter: _escapeParameter,\n            messageResolver: options.messageResolver,\n            __meta: { framework: 'vue' }\n        };\n        {\n            ctxOptions.datetimeFormats = _datetimeFormats.value;\n            ctxOptions.numberFormats = _numberFormats.value;\n            ctxOptions.__datetimeFormatters = shared_isPlainObject(_context)\n                ? _context.__datetimeFormatters\n                : undefined;\n            ctxOptions.__numberFormatters = shared_isPlainObject(_context)\n                ? _context.__numberFormatters\n                : undefined;\n        }\n        if ((false)) {}\n        const ctx = createCoreContext(ctxOptions);\n        _isGlobal && setFallbackContext(ctx);\n        return ctx;\n    };\n    _context = getCoreContext();\n    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\n    // track reactivity\n    function trackReactivityValues() {\n        return [\n                _locale.value,\n                _fallbackLocale.value,\n                _messages.value,\n                _datetimeFormats.value,\n                _numberFormats.value\n            ]\n            ;\n    }\n    // locale\n    const locale = runtime_core_esm_bundler_computed({\n        get: () => _locale.value,\n        set: val => {\n            _locale.value = val;\n            _context.locale = _locale.value;\n        }\n    });\n    // fallbackLocale\n    const fallbackLocale = runtime_core_esm_bundler_computed({\n        get: () => _fallbackLocale.value,\n        set: val => {\n            _fallbackLocale.value = val;\n            _context.fallbackLocale = _fallbackLocale.value;\n            updateFallbackLocale(_context, _locale.value, val);\n        }\n    });\n    // messages\n    const messages = runtime_core_esm_bundler_computed(() => _messages.value);\n    // datetimeFormats\n    const datetimeFormats = /* #__PURE__*/ runtime_core_esm_bundler_computed(() => _datetimeFormats.value);\n    // numberFormats\n    const numberFormats = /* #__PURE__*/ runtime_core_esm_bundler_computed(() => _numberFormats.value);\n    // getPostTranslationHandler\n    function getPostTranslationHandler() {\n        return shared_isFunction(_postTranslation) ? _postTranslation : null;\n    }\n    // setPostTranslationHandler\n    function setPostTranslationHandler(handler) {\n        _postTranslation = handler;\n        _context.postTranslation = handler;\n    }\n    // getMissingHandler\n    function getMissingHandler() {\n        return _missing;\n    }\n    // setMissingHandler\n    function setMissingHandler(handler) {\n        if (handler !== null) {\n            _runtimeMissing = defineCoreMissingHandler(handler);\n        }\n        _missing = handler;\n        _context.missing = _runtimeMissing;\n    }\n    function isResolvedTranslateMessage(type, arg // eslint-disable-line @typescript-eslint/no-explicit-any\n    ) {\n        return type !== 'translate' || !arg.resolvedMessage;\n    }\n    const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {\n        trackReactivityValues(); // track reactive dependency\n        // NOTE: experimental !!\n        let ret;\n        try {\n            if (( false) || __INTLIFY_PROD_DEVTOOLS__) {\n                setAdditionalMeta(getMetaInfo());\n            }\n            if (!_isGlobal) {\n                _context.fallbackContext = __root\n                    ? getFallbackContext()\n                    : undefined;\n            }\n            ret = fn(_context);\n        }\n        finally {\n            if (( false) || __INTLIFY_PROD_DEVTOOLS__) {\n                setAdditionalMeta(null);\n            }\n            if (!_isGlobal) {\n                _context.fallbackContext = undefined;\n            }\n        }\n        if (isNumber(ret) && ret === NOT_REOSLVED) {\n            const [key, arg2] = argumentParser();\n            if (false) {}\n            return __root && _fallbackRoot\n                ? fallbackSuccess(__root)\n                : fallbackFail(key);\n        }\n        else if (successCondition(ret)) {\n            return ret;\n        }\n        else {\n            /* istanbul ignore next */\n            throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);\n        }\n    };\n    // t\n    function t(...args) {\n        return wrapWithDeps(context => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), 'translate', root => Reflect.apply(root.t, root, [...args]), key => key, val => shared_isString(val));\n    }\n    // rt\n    function rt(...args) {\n        const [arg1, arg2, arg3] = args;\n        if (arg3 && !shared_isObject(arg3)) {\n            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);\n        }\n        return t(...[arg1, arg2, shared_assign({ resolvedMessage: true }, arg3 || {})]);\n    }\n    // d\n    function d(...args) {\n        return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', root => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, val => shared_isString(val));\n    }\n    // n\n    function n(...args) {\n        return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', root => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, val => shared_isString(val));\n    }\n    // for custom processor\n    function normalize(values) {\n        return values.map(val => shared_isString(val) || isNumber(val) || shared_isBoolean(val)\n            ? createTextNode(String(val))\n            : val);\n    }\n    const interpolate = (val) => val;\n    const processor = {\n        normalize,\n        interpolate,\n        type: 'vnode'\n    };\n    // translateVNode, using for `i18n-t` component\n    function translateVNode(...args) {\n        return wrapWithDeps(context => {\n            let ret;\n            const _context = context;\n            try {\n                _context.processor = processor;\n                ret = Reflect.apply(translate, null, [_context, ...args]);\n            }\n            finally {\n                _context.processor = null;\n            }\n            return ret;\n        }, () => parseTranslateArgs(...args), 'translate', \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        root => root[TranslateVNodeSymbol](...args), key => [createTextNode(key)], val => shared_isArray(val));\n    }\n    // numberParts, using for `i18n-n` component\n    function numberParts(...args) {\n        return wrapWithDeps(context => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), 'number format', \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        root => root[NumberPartsSymbol](...args), () => [], val => shared_isString(val) || shared_isArray(val));\n    }\n    // datetimeParts, using for `i18n-d` component\n    function datetimeParts(...args) {\n        return wrapWithDeps(context => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), 'datetime format', \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        root => root[DatetimePartsSymbol](...args), () => [], val => shared_isString(val) || shared_isArray(val));\n    }\n    function setPluralRules(rules) {\n        _pluralRules = rules;\n        _context.pluralRules = _pluralRules;\n    }\n    // te\n    function te(key, locale) {\n        const targetLocale = shared_isString(locale) ? locale : _locale.value;\n        const message = getLocaleMessage(targetLocale);\n        return _context.messageResolver(message, key) !== null;\n    }\n    function resolveMessages(key) {\n        let messages = null;\n        const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);\n        for (let i = 0; i < locales.length; i++) {\n            const targetLocaleMessages = _messages.value[locales[i]] || {};\n            const messageValue = _context.messageResolver(targetLocaleMessages, key);\n            if (messageValue != null) {\n                messages = messageValue;\n                break;\n            }\n        }\n        return messages;\n    }\n    // tm\n    function tm(key) {\n        const messages = resolveMessages(key);\n        // prettier-ignore\n        return messages != null\n            ? messages\n            : __root\n                ? __root.tm(key) || {}\n                : {};\n    }\n    // getLocaleMessage\n    function getLocaleMessage(locale) {\n        return (_messages.value[locale] || {});\n    }\n    // setLocaleMessage\n    function setLocaleMessage(locale, message) {\n        _messages.value[locale] = message;\n        _context.messages = _messages.value;\n    }\n    // mergeLocaleMessage\n    function mergeLocaleMessage(locale, message) {\n        _messages.value[locale] = _messages.value[locale] || {};\n        deepCopy(message, _messages.value[locale]);\n        _context.messages = _messages.value;\n    }\n    // getDateTimeFormat\n    function getDateTimeFormat(locale) {\n        return _datetimeFormats.value[locale] || {};\n    }\n    // setDateTimeFormat\n    function setDateTimeFormat(locale, format) {\n        _datetimeFormats.value[locale] = format;\n        _context.datetimeFormats = _datetimeFormats.value;\n        clearDateTimeFormat(_context, locale, format);\n    }\n    // mergeDateTimeFormat\n    function mergeDateTimeFormat(locale, format) {\n        _datetimeFormats.value[locale] = shared_assign(_datetimeFormats.value[locale] || {}, format);\n        _context.datetimeFormats = _datetimeFormats.value;\n        clearDateTimeFormat(_context, locale, format);\n    }\n    // getNumberFormat\n    function getNumberFormat(locale) {\n        return _numberFormats.value[locale] || {};\n    }\n    // setNumberFormat\n    function setNumberFormat(locale, format) {\n        _numberFormats.value[locale] = format;\n        _context.numberFormats = _numberFormats.value;\n        clearNumberFormat(_context, locale, format);\n    }\n    // mergeNumberFormat\n    function mergeNumberFormat(locale, format) {\n        _numberFormats.value[locale] = shared_assign(_numberFormats.value[locale] || {}, format);\n        _context.numberFormats = _numberFormats.value;\n        clearNumberFormat(_context, locale, format);\n    }\n    // for debug\n    composerID++;\n    // watch root locale & fallbackLocale\n    if (__root && inBrowser) {\n        watch(__root.locale, (val) => {\n            if (_inheritLocale) {\n                _locale.value = val;\n                _context.locale = val;\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\n            }\n        });\n        watch(__root.fallbackLocale, (val) => {\n            if (_inheritLocale) {\n                _fallbackLocale.value = val;\n                _context.fallbackLocale = val;\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\n            }\n        });\n    }\n    // define basic composition API!\n    const composer = {\n        id: composerID,\n        locale,\n        fallbackLocale,\n        get inheritLocale() {\n            return _inheritLocale;\n        },\n        set inheritLocale(val) {\n            _inheritLocale = val;\n            if (val && __root) {\n                _locale.value = __root.locale.value;\n                _fallbackLocale.value = __root.fallbackLocale.value;\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\n            }\n        },\n        get availableLocales() {\n            return Object.keys(_messages.value).sort();\n        },\n        messages,\n        get modifiers() {\n            return _modifiers;\n        },\n        get pluralRules() {\n            return _pluralRules || {};\n        },\n        get isGlobal() {\n            return _isGlobal;\n        },\n        get missingWarn() {\n            return _missingWarn;\n        },\n        set missingWarn(val) {\n            _missingWarn = val;\n            _context.missingWarn = _missingWarn;\n        },\n        get fallbackWarn() {\n            return _fallbackWarn;\n        },\n        set fallbackWarn(val) {\n            _fallbackWarn = val;\n            _context.fallbackWarn = _fallbackWarn;\n        },\n        get fallbackRoot() {\n            return _fallbackRoot;\n        },\n        set fallbackRoot(val) {\n            _fallbackRoot = val;\n        },\n        get fallbackFormat() {\n            return _fallbackFormat;\n        },\n        set fallbackFormat(val) {\n            _fallbackFormat = val;\n            _context.fallbackFormat = _fallbackFormat;\n        },\n        get warnHtmlMessage() {\n            return _warnHtmlMessage;\n        },\n        set warnHtmlMessage(val) {\n            _warnHtmlMessage = val;\n            _context.warnHtmlMessage = val;\n        },\n        get escapeParameter() {\n            return _escapeParameter;\n        },\n        set escapeParameter(val) {\n            _escapeParameter = val;\n            _context.escapeParameter = val;\n        },\n        t,\n        getLocaleMessage,\n        setLocaleMessage,\n        mergeLocaleMessage,\n        getPostTranslationHandler,\n        setPostTranslationHandler,\n        getMissingHandler,\n        setMissingHandler,\n        [SetPluralRulesSymbol]: setPluralRules\n    };\n    {\n        composer.datetimeFormats = datetimeFormats;\n        composer.numberFormats = numberFormats;\n        composer.rt = rt;\n        composer.te = te;\n        composer.tm = tm;\n        composer.d = d;\n        composer.n = n;\n        composer.getDateTimeFormat = getDateTimeFormat;\n        composer.setDateTimeFormat = setDateTimeFormat;\n        composer.mergeDateTimeFormat = mergeDateTimeFormat;\n        composer.getNumberFormat = getNumberFormat;\n        composer.setNumberFormat = setNumberFormat;\n        composer.mergeNumberFormat = mergeNumberFormat;\n        composer[InejctWithOption] = options.__injectWithOption;\n        composer[TranslateVNodeSymbol] = translateVNode;\n        composer[DatetimePartsSymbol] = datetimeParts;\n        composer[NumberPartsSymbol] = numberParts;\n    }\n    // for vue-devtools timeline event\n    if ((false)) {}\n    return composer;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Convert to I18n Composer Options from VueI18n Options\n *\n * @internal\n */\nfunction convertComposerOptions(options) {\n    const locale = shared_isString(options.locale) ? options.locale : DEFAULT_LOCALE;\n    const fallbackLocale = shared_isString(options.fallbackLocale) ||\n        shared_isArray(options.fallbackLocale) ||\n        shared_isPlainObject(options.fallbackLocale) ||\n        options.fallbackLocale === false\n        ? options.fallbackLocale\n        : locale;\n    const missing = shared_isFunction(options.missing) ? options.missing : undefined;\n    const missingWarn = shared_isBoolean(options.silentTranslationWarn) ||\n        isRegExp(options.silentTranslationWarn)\n        ? !options.silentTranslationWarn\n        : true;\n    const fallbackWarn = shared_isBoolean(options.silentFallbackWarn) ||\n        isRegExp(options.silentFallbackWarn)\n        ? !options.silentFallbackWarn\n        : true;\n    const fallbackRoot = shared_isBoolean(options.fallbackRoot)\n        ? options.fallbackRoot\n        : true;\n    const fallbackFormat = !!options.formatFallbackMessages;\n    const modifiers = shared_isPlainObject(options.modifiers) ? options.modifiers : {};\n    const pluralizationRules = options.pluralizationRules;\n    const postTranslation = shared_isFunction(options.postTranslation)\n        ? options.postTranslation\n        : undefined;\n    const warnHtmlMessage = shared_isString(options.warnHtmlInMessage)\n        ? options.warnHtmlInMessage !== 'off'\n        : true;\n    const escapeParameter = !!options.escapeParameterHtml;\n    const inheritLocale = shared_isBoolean(options.sync) ? options.sync : true;\n    if (false) {}\n    if (false) {}\n    let messages = options.messages;\n    if (shared_isPlainObject(options.sharedMessages)) {\n        const sharedMessages = options.sharedMessages;\n        const locales = Object.keys(sharedMessages);\n        messages = locales.reduce((messages, locale) => {\n            const message = messages[locale] || (messages[locale] = {});\n            shared_assign(message, sharedMessages[locale]);\n            return messages;\n        }, (messages || {}));\n    }\n    const { __i18n, __root, __injectWithOption } = options;\n    const datetimeFormats = options.datetimeFormats;\n    const numberFormats = options.numberFormats;\n    const flatJson = options.flatJson;\n    return {\n        locale,\n        fallbackLocale,\n        messages,\n        flatJson,\n        datetimeFormats,\n        numberFormats,\n        missing,\n        missingWarn,\n        fallbackWarn,\n        fallbackRoot,\n        fallbackFormat,\n        modifiers,\n        pluralRules: pluralizationRules,\n        postTranslation,\n        warnHtmlMessage,\n        escapeParameter,\n        messageResolver: options.messageResolver,\n        inheritLocale,\n        __i18n,\n        __root,\n        __injectWithOption\n    };\n}\n/**\n * create VueI18n interface factory\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction createVueI18n(options = {}, VueI18nLegacy) {\n    {\n        const composer = createComposer(convertComposerOptions(options));\n        // defines VueI18n\n        const vueI18n = {\n            // id\n            id: composer.id,\n            // locale\n            get locale() {\n                return composer.locale.value;\n            },\n            set locale(val) {\n                composer.locale.value = val;\n            },\n            // fallbackLocale\n            get fallbackLocale() {\n                return composer.fallbackLocale.value;\n            },\n            set fallbackLocale(val) {\n                composer.fallbackLocale.value = val;\n            },\n            // messages\n            get messages() {\n                return composer.messages.value;\n            },\n            // datetimeFormats\n            get datetimeFormats() {\n                return composer.datetimeFormats.value;\n            },\n            // numberFormats\n            get numberFormats() {\n                return composer.numberFormats.value;\n            },\n            // availableLocales\n            get availableLocales() {\n                return composer.availableLocales;\n            },\n            // formatter\n            get formatter() {\n                ( false) && 0;\n                // dummy\n                return {\n                    interpolate() {\n                        return [];\n                    }\n                };\n            },\n            set formatter(val) {\n                ( false) && 0;\n            },\n            // missing\n            get missing() {\n                return composer.getMissingHandler();\n            },\n            set missing(handler) {\n                composer.setMissingHandler(handler);\n            },\n            // silentTranslationWarn\n            get silentTranslationWarn() {\n                return shared_isBoolean(composer.missingWarn)\n                    ? !composer.missingWarn\n                    : composer.missingWarn;\n            },\n            set silentTranslationWarn(val) {\n                composer.missingWarn = shared_isBoolean(val) ? !val : val;\n            },\n            // silentFallbackWarn\n            get silentFallbackWarn() {\n                return shared_isBoolean(composer.fallbackWarn)\n                    ? !composer.fallbackWarn\n                    : composer.fallbackWarn;\n            },\n            set silentFallbackWarn(val) {\n                composer.fallbackWarn = shared_isBoolean(val) ? !val : val;\n            },\n            // modifiers\n            get modifiers() {\n                return composer.modifiers;\n            },\n            // formatFallbackMessages\n            get formatFallbackMessages() {\n                return composer.fallbackFormat;\n            },\n            set formatFallbackMessages(val) {\n                composer.fallbackFormat = val;\n            },\n            // postTranslation\n            get postTranslation() {\n                return composer.getPostTranslationHandler();\n            },\n            set postTranslation(handler) {\n                composer.setPostTranslationHandler(handler);\n            },\n            // sync\n            get sync() {\n                return composer.inheritLocale;\n            },\n            set sync(val) {\n                composer.inheritLocale = val;\n            },\n            // warnInHtmlMessage\n            get warnHtmlInMessage() {\n                return composer.warnHtmlMessage ? 'warn' : 'off';\n            },\n            set warnHtmlInMessage(val) {\n                composer.warnHtmlMessage = val !== 'off';\n            },\n            // escapeParameterHtml\n            get escapeParameterHtml() {\n                return composer.escapeParameter;\n            },\n            set escapeParameterHtml(val) {\n                composer.escapeParameter = val;\n            },\n            // preserveDirectiveContent\n            get preserveDirectiveContent() {\n                ( false) &&\n                    0;\n                return true;\n            },\n            set preserveDirectiveContent(val) {\n                ( false) &&\n                    0;\n            },\n            // pluralizationRules\n            get pluralizationRules() {\n                return composer.pluralRules || {};\n            },\n            // for internal\n            __composer: composer,\n            // t\n            t(...args) {\n                const [arg1, arg2, arg3] = args;\n                const options = {};\n                let list = null;\n                let named = null;\n                if (!shared_isString(arg1)) {\n                    throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);\n                }\n                const key = arg1;\n                if (shared_isString(arg2)) {\n                    options.locale = arg2;\n                }\n                else if (shared_isArray(arg2)) {\n                    list = arg2;\n                }\n                else if (shared_isPlainObject(arg2)) {\n                    named = arg2;\n                }\n                if (shared_isArray(arg3)) {\n                    list = arg3;\n                }\n                else if (shared_isPlainObject(arg3)) {\n                    named = arg3;\n                }\n                // return composer.t(key, (list || named || {}) as any, options)\n                return Reflect.apply(composer.t, composer, [\n                    key,\n                    (list || named || {}),\n                    options\n                ]);\n            },\n            rt(...args) {\n                return Reflect.apply(composer.rt, composer, [...args]);\n            },\n            // tc\n            tc(...args) {\n                const [arg1, arg2, arg3] = args;\n                const options = { plural: 1 };\n                let list = null;\n                let named = null;\n                if (!shared_isString(arg1)) {\n                    throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);\n                }\n                const key = arg1;\n                if (shared_isString(arg2)) {\n                    options.locale = arg2;\n                }\n                else if (isNumber(arg2)) {\n                    options.plural = arg2;\n                }\n                else if (shared_isArray(arg2)) {\n                    list = arg2;\n                }\n                else if (shared_isPlainObject(arg2)) {\n                    named = arg2;\n                }\n                if (shared_isString(arg3)) {\n                    options.locale = arg3;\n                }\n                else if (shared_isArray(arg3)) {\n                    list = arg3;\n                }\n                else if (shared_isPlainObject(arg3)) {\n                    named = arg3;\n                }\n                // return composer.t(key, (list || named || {}) as any, options)\n                return Reflect.apply(composer.t, composer, [\n                    key,\n                    (list || named || {}),\n                    options\n                ]);\n            },\n            // te\n            te(key, locale) {\n                return composer.te(key, locale);\n            },\n            // tm\n            tm(key) {\n                return composer.tm(key);\n            },\n            // getLocaleMessage\n            getLocaleMessage(locale) {\n                return composer.getLocaleMessage(locale);\n            },\n            // setLocaleMessage\n            setLocaleMessage(locale, message) {\n                composer.setLocaleMessage(locale, message);\n            },\n            // mergeLocaleMessage\n            mergeLocaleMessage(locale, message) {\n                composer.mergeLocaleMessage(locale, message);\n            },\n            // d\n            d(...args) {\n                return Reflect.apply(composer.d, composer, [...args]);\n            },\n            // getDateTimeFormat\n            getDateTimeFormat(locale) {\n                return composer.getDateTimeFormat(locale);\n            },\n            // setDateTimeFormat\n            setDateTimeFormat(locale, format) {\n                composer.setDateTimeFormat(locale, format);\n            },\n            // mergeDateTimeFormat\n            mergeDateTimeFormat(locale, format) {\n                composer.mergeDateTimeFormat(locale, format);\n            },\n            // n\n            n(...args) {\n                return Reflect.apply(composer.n, composer, [...args]);\n            },\n            // getNumberFormat\n            getNumberFormat(locale) {\n                return composer.getNumberFormat(locale);\n            },\n            // setNumberFormat\n            setNumberFormat(locale, format) {\n                composer.setNumberFormat(locale, format);\n            },\n            // mergeNumberFormat\n            mergeNumberFormat(locale, format) {\n                composer.mergeNumberFormat(locale, format);\n            },\n            // getChoiceIndex\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            getChoiceIndex(choice, choicesLength) {\n                ( false) &&\n                    0;\n                return -1;\n            },\n            // for internal\n            __onComponentInstanceCreated(target) {\n                const { componentInstanceCreatedListener } = options;\n                if (componentInstanceCreatedListener) {\n                    componentInstanceCreatedListener(target, vueI18n);\n                }\n            }\n        };\n        // for vue-devtools timeline event\n        if ((false)) {}\n        return vueI18n;\n    }\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nconst baseFormatProps = {\n    tag: {\n        type: [String, Object]\n    },\n    locale: {\n        type: String\n    },\n    scope: {\n        type: String,\n        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050\n        validator: (val /* ComponentI18nScope */) => val === 'parent' || val === 'global',\n        default: 'parent' /* ComponentI18nScope */\n    },\n    i18n: {\n        type: Object\n    }\n};\n\nfunction getInterpolateArg(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n{ slots }, // SetupContext,\nkeys) {\n    if (keys.length === 1 && keys[0] === 'default') {\n        // default slot with list\n        const ret = slots.default ? slots.default() : [];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return ret.reduce((slot, current) => {\n            return [\n                ...slot,\n                // prettier-ignore\n                ...(current.type === runtime_core_esm_bundler_Fragment ? current.children : [current]\n                    )\n            ];\n        }, []);\n    }\n    else {\n        // named slots\n        return keys.reduce((arg, key) => {\n            const slot = slots[key];\n            if (slot) {\n                arg[key] = slot();\n            }\n            return arg;\n        }, {});\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getFragmentableTag(tag) {\n    return runtime_core_esm_bundler_Fragment ;\n}\n\nconst TranslationImpl = /*#__PURE__*/ runtime_core_esm_bundler_defineComponent({\n    /* eslint-disable */\n    name: 'i18n-t',\n    props: shared_assign({\n        keypath: {\n            type: String,\n            required: true\n        },\n        plural: {\n            type: [Number, String],\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            validator: (val) => isNumber(val) || !isNaN(val)\n        }\n    }, baseFormatProps),\n    /* eslint-enable */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setup(props, context) {\n        const { slots, attrs } = context;\n        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050\n        const i18n = props.i18n ||\n            useI18n({\n                useScope: props.scope,\n                __useComponent: true\n            });\n        return () => {\n            const keys = Object.keys(slots).filter(key => key !== '_');\n            const options = {};\n            if (props.locale) {\n                options.locale = props.locale;\n            }\n            if (props.plural !== undefined) {\n                options.plural = shared_isString(props.plural) ? +props.plural : props.plural;\n            }\n            const arg = getInterpolateArg(context, keys);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);\n            const assignedAttrs = shared_assign({}, attrs);\n            const tag = shared_isString(props.tag) || shared_isObject(props.tag)\n                ? props.tag\n                : getFragmentableTag();\n            return h(tag, assignedAttrs, children);\n        };\n    }\n});\n/**\n * export the public type for h/tsx inference\n * also to avoid inline import() in generated d.ts files\n */\n/**\n * Translation Component\n *\n * @remarks\n * See the following items for property about details\n *\n * @VueI18nSee [TranslationProps](component#translationprops)\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\n * @VueI18nSee [Component Interpolation](../guide/advanced/component)\n *\n * @example\n * ```html\n * <div id=\"app\">\n *   <!-- ... -->\n *   <i18n keypath=\"term\" tag=\"label\" for=\"tos\">\n *     <a :href=\"url\" target=\"_blank\">{{ $t('tos') }}</a>\n *   </i18n>\n *   <!-- ... -->\n * </div>\n * ```\n * ```js\n * import { createApp } from 'vue'\n * import { createI18n } from 'vue-i18n'\n *\n * const messages = {\n *   en: {\n *     tos: 'Term of Service',\n *     term: 'I accept xxx {0}.'\n *   },\n *   ja: {\n *     tos: '利用規約',\n *     term: '私は xxx の{0}に同意します。'\n *   }\n * }\n *\n * const i18n = createI18n({\n *   locale: 'en',\n *   messages\n * })\n *\n * const app = createApp({\n *   data: {\n *     url: '/term'\n *   }\n * }).use(i18n).mount('#app')\n * ```\n *\n * @VueI18nComponent\n */\nconst Translation = TranslationImpl;\nconst I18nT = (/* unused pure expression or super */ null && (Translation));\n\nfunction vue_i18n_isVNode(target) {\n    return shared_isArray(target) && !shared_isString(target[0]);\n}\nfunction renderFormatter(props, context, slotKeys, partFormatter) {\n    const { slots, attrs } = context;\n    return () => {\n        const options = { part: true };\n        let overrides = {};\n        if (props.locale) {\n            options.locale = props.locale;\n        }\n        if (shared_isString(props.format)) {\n            options.key = props.format;\n        }\n        else if (shared_isObject(props.format)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (shared_isString(props.format.key)) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                options.key = props.format.key;\n            }\n            // Filter out number format options only\n            overrides = Object.keys(props.format).reduce((options, prop) => {\n                return slotKeys.includes(prop)\n                    ? shared_assign({}, options, { [prop]: props.format[prop] }) // eslint-disable-line @typescript-eslint/no-explicit-any\n                    : options;\n            }, {});\n        }\n        const parts = partFormatter(...[props.value, options, overrides]);\n        let children = [options.key];\n        if (shared_isArray(parts)) {\n            children = parts.map((part, index) => {\n                const slot = slots[part.type];\n                const node = slot\n                    ? slot({ [part.type]: part.value, index, parts })\n                    : [part.value];\n                if (vue_i18n_isVNode(node)) {\n                    node[0].key = `${part.type}-${index}`;\n                }\n                return node;\n            });\n        }\n        else if (shared_isString(parts)) {\n            children = [parts];\n        }\n        const assignedAttrs = shared_assign({}, attrs);\n        const tag = shared_isString(props.tag) || shared_isObject(props.tag)\n            ? props.tag\n            : getFragmentableTag();\n        return h(tag, assignedAttrs, children);\n    };\n}\n\nconst NumberFormatImpl = /*#__PURE__*/ runtime_core_esm_bundler_defineComponent({\n    /* eslint-disable */\n    name: 'i18n-n',\n    props: shared_assign({\n        value: {\n            type: Number,\n            required: true\n        },\n        format: {\n            type: [String, Object]\n        }\n    }, baseFormatProps),\n    /* eslint-enable */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setup(props, context) {\n        const i18n = props.i18n ||\n            useI18n({\n                useScope: 'parent',\n                __useComponent: true\n            });\n        return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        i18n[NumberPartsSymbol](...args));\n    }\n});\n/**\n * export the public type for h/tsx inference\n * also to avoid inline import() in generated d.ts files\n */\n/**\n * Number Format Component\n *\n * @remarks\n * See the following items for property about details\n *\n * @VueI18nSee [FormattableProps](component#formattableprops)\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\n * @VueI18nSee [Custom Formatting](../guide/essentials/number#custom-formatting)\n *\n * @VueI18nDanger\n * Not supported IE, due to no support `Intl.NumberFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)\n *\n * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)\n *\n * @VueI18nComponent\n */\nconst NumberFormat = NumberFormatImpl;\nconst I18nN = (/* unused pure expression or super */ null && (NumberFormat));\n\nconst DatetimeFormatImpl = /* #__PURE__*/ runtime_core_esm_bundler_defineComponent({\n    /* eslint-disable */\n    name: 'i18n-d',\n    props: shared_assign({\n        value: {\n            type: [Number, Date],\n            required: true\n        },\n        format: {\n            type: [String, Object]\n        }\n    }, baseFormatProps),\n    /* eslint-enable */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    setup(props, context) {\n        const i18n = props.i18n ||\n            useI18n({\n                useScope: 'parent',\n                __useComponent: true\n            });\n        return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        i18n[DatetimePartsSymbol](...args));\n    }\n});\n/**\n * Datetime Format Component\n *\n * @remarks\n * See the following items for property about details\n *\n * @VueI18nSee [FormattableProps](component#formattableprops)\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\n * @VueI18nSee [Custom Formatting](../guide/essentials/datetime#custom-formatting)\n *\n * @VueI18nDanger\n * Not supported IE, due to no support `Intl.DateTimeFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)\n *\n * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)\n *\n * @VueI18nComponent\n */\nconst DatetimeFormat = DatetimeFormatImpl;\nconst I18nD = (/* unused pure expression or super */ null && (DatetimeFormat));\n\nfunction getComposer$2(i18n, instance) {\n    const i18nInternal = i18n;\n    if (i18n.mode === 'composition') {\n        return (i18nInternal.__getInstance(instance) || i18n.global);\n    }\n    else {\n        const vueI18n = i18nInternal.__getInstance(instance);\n        return vueI18n != null\n            ? vueI18n.__composer\n            : i18n.global.__composer;\n    }\n}\nfunction vTDirective(i18n) {\n    const _process = (binding) => {\n        const { instance, modifiers, value } = binding;\n        /* istanbul ignore if */\n        if (!instance || !instance.$) {\n            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n        }\n        const composer = getComposer$2(i18n, instance.$);\n        if (false) {}\n        const parsedValue = parseValue(value);\n        return [\n            Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),\n            composer\n        ];\n    };\n    const register = (el, binding) => {\n        const [textContent, composer] = _process(binding);\n        if (inBrowser && i18n.global === composer) {\n            // global scope only\n            el.__i18nWatcher = watch(composer.locale, () => {\n                binding.instance && binding.instance.$forceUpdate();\n            });\n        }\n        el.__composer = composer;\n        el.textContent = textContent;\n    };\n    const unregister = (el) => {\n        if (inBrowser && el.__i18nWatcher) {\n            el.__i18nWatcher();\n            el.__i18nWatcher = undefined;\n            delete el.__i18nWatcher;\n        }\n        if (el.__composer) {\n            el.__composer = undefined;\n            delete el.__composer;\n        }\n    };\n    const update = (el, { value }) => {\n        if (el.__composer) {\n            const composer = el.__composer;\n            const parsedValue = parseValue(value);\n            el.textContent = Reflect.apply(composer.t, composer, [\n                ...makeParams(parsedValue)\n            ]);\n        }\n    };\n    const getSSRProps = (binding) => {\n        const [textContent] = _process(binding);\n        return { textContent };\n    };\n    return {\n        created: register,\n        unmounted: unregister,\n        beforeUpdate: update,\n        getSSRProps\n    };\n}\nfunction parseValue(value) {\n    if (shared_isString(value)) {\n        return { path: value };\n    }\n    else if (shared_isPlainObject(value)) {\n        if (!('path' in value)) {\n            throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, 'path');\n        }\n        return value;\n    }\n    else {\n        throw createI18nError(I18nErrorCodes.INVALID_VALUE);\n    }\n}\nfunction makeParams(value) {\n    const { path, locale, args, choice, plural } = value;\n    const options = {};\n    const named = args || {};\n    if (shared_isString(locale)) {\n        options.locale = locale;\n    }\n    if (isNumber(choice)) {\n        options.plural = choice;\n    }\n    if (isNumber(plural)) {\n        options.plural = plural;\n    }\n    return [path, named, options];\n}\n\nfunction apply(app, i18n, ...options) {\n    const pluginOptions = shared_isPlainObject(options[0])\n        ? options[0]\n        : {};\n    const useI18nComponentName = !!pluginOptions.useI18nComponentName;\n    const globalInstall = shared_isBoolean(pluginOptions.globalInstall)\n        ? pluginOptions.globalInstall\n        : true;\n    if (false) {}\n    if (globalInstall) {\n        [!useI18nComponentName ? Translation.name : 'i18n', 'I18nT'].forEach(name => app.component(name, Translation));\n        [NumberFormat.name, 'I18nN'].forEach(name => app.component(name, NumberFormat));\n        [DatetimeFormat.name, 'I18nD'].forEach(name => app.component(name, DatetimeFormat));\n    }\n    // install directive\n    {\n        app.directive('t', vTDirective(i18n));\n    }\n}\n\nconst VUE_I18N_COMPONENT_TYPES = 'vue-i18n: composer properties';\nlet devtoolsApi;\nasync function enableDevTools(app, i18n) {\n    return new Promise((resolve, reject) => {\n        try {\n            setupDevtoolsPlugin({\n                id: \"vue-devtools-plugin-vue-i18n\" /* VueDevToolsIDs.PLUGIN */,\n                label: VueDevToolsLabels[\"vue-devtools-plugin-vue-i18n\" /* VueDevToolsIDs.PLUGIN */],\n                packageName: 'vue-i18n',\n                homepage: 'https://vue-i18n.intlify.dev',\n                logo: 'https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png',\n                componentStateTypes: [VUE_I18N_COMPONENT_TYPES],\n                app: app // eslint-disable-line @typescript-eslint/no-explicit-any\n            }, api => {\n                devtoolsApi = api;\n                api.on.visitComponentTree(({ componentInstance, treeNode }) => {\n                    updateComponentTreeTags(componentInstance, treeNode, i18n);\n                });\n                api.on.inspectComponent(({ componentInstance, instanceData }) => {\n                    if (componentInstance.vnode.el &&\n                        componentInstance.vnode.el.__VUE_I18N__ &&\n                        instanceData) {\n                        if (i18n.mode === 'legacy') {\n                            // ignore global scope on legacy mode\n                            if (componentInstance.vnode.el.__VUE_I18N__ !==\n                                i18n.global.__composer) {\n                                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);\n                            }\n                        }\n                        else {\n                            inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);\n                        }\n                    }\n                });\n                api.addInspector({\n                    id: \"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */,\n                    label: VueDevToolsLabels[\"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */],\n                    icon: 'language',\n                    treeFilterPlaceholder: VueDevToolsPlaceholders[\"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */]\n                });\n                api.on.getInspectorTree(payload => {\n                    if (payload.app === app &&\n                        payload.inspectorId === \"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */) {\n                        registerScope(payload, i18n);\n                    }\n                });\n                const roots = new Map();\n                api.on.getInspectorState(async (payload) => {\n                    if (payload.app === app &&\n                        payload.inspectorId === \"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */) {\n                        api.unhighlightElement();\n                        inspectScope(payload, i18n);\n                        if (payload.nodeId === 'global') {\n                            if (!roots.has(payload.app)) {\n                                const [root] = await api.getComponentInstances(payload.app);\n                                roots.set(payload.app, root);\n                            }\n                            api.highlightElement(roots.get(payload.app));\n                        }\n                        else {\n                            const instance = getComponentInstance(payload.nodeId, i18n);\n                            instance && api.highlightElement(instance);\n                        }\n                    }\n                });\n                api.on.editInspectorState(payload => {\n                    if (payload.app === app &&\n                        payload.inspectorId === \"vue-i18n-resource-inspector\" /* VueDevToolsIDs.CUSTOM_INSPECTOR */) {\n                        editScope(payload, i18n);\n                    }\n                });\n                api.addTimelineLayer({\n                    id: \"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */,\n                    label: VueDevToolsLabels[\"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */],\n                    color: VueDevToolsTimelineColors[\"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */]\n                });\n                resolve(true);\n            });\n        }\n        catch (e) {\n            console.error(e);\n            reject(false);\n        }\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getI18nScopeLable(instance) {\n    return (instance.type.name ||\n        instance.type.displayName ||\n        instance.type.__file ||\n        'Anonymous');\n}\nfunction updateComponentTreeTags(instance, // eslint-disable-line @typescript-eslint/no-explicit-any\ntreeNode, i18n) {\n    // prettier-ignore\n    const global = i18n.mode === 'composition'\n        ? i18n.global\n        : i18n.global.__composer;\n    if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {\n        // add custom tags local scope only\n        if (instance.vnode.el.__VUE_I18N__ !== global) {\n            const tag = {\n                label: `i18n (${getI18nScopeLable(instance)} Scope)`,\n                textColor: 0x000000,\n                backgroundColor: 0xffcd19\n            };\n            treeNode.tags.push(tag);\n        }\n    }\n}\nfunction inspectComposer(instanceData, composer) {\n    const type = VUE_I18N_COMPONENT_TYPES;\n    instanceData.state.push({\n        type,\n        key: 'locale',\n        editable: true,\n        value: composer.locale.value\n    });\n    instanceData.state.push({\n        type,\n        key: 'availableLocales',\n        editable: false,\n        value: composer.availableLocales\n    });\n    instanceData.state.push({\n        type,\n        key: 'fallbackLocale',\n        editable: true,\n        value: composer.fallbackLocale.value\n    });\n    instanceData.state.push({\n        type,\n        key: 'inheritLocale',\n        editable: true,\n        value: composer.inheritLocale\n    });\n    instanceData.state.push({\n        type,\n        key: 'messages',\n        editable: false,\n        value: getLocaleMessageValue(composer.messages.value)\n    });\n    {\n        instanceData.state.push({\n            type,\n            key: 'datetimeFormats',\n            editable: false,\n            value: composer.datetimeFormats.value\n        });\n        instanceData.state.push({\n            type,\n            key: 'numberFormats',\n            editable: false,\n            value: composer.numberFormats.value\n        });\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getLocaleMessageValue(messages) {\n    const value = {};\n    Object.keys(messages).forEach((key) => {\n        const v = messages[key];\n        if (shared_isFunction(v) && 'source' in v) {\n            value[key] = getMessageFunctionDetails(v);\n        }\n        else if (isMessageAST(v) && v.loc && v.loc.source) {\n            value[key] = v.loc.source;\n        }\n        else if (shared_isObject(v)) {\n            value[key] = getLocaleMessageValue(v);\n        }\n        else {\n            value[key] = v;\n        }\n    });\n    return value;\n}\nconst ESC = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '&': '&amp;'\n};\nfunction vue_i18n_escape(s) {\n    return s.replace(/[<>\"&]/g, escapeChar);\n}\nfunction escapeChar(a) {\n    return ESC[a] || a;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMessageFunctionDetails(func) {\n    const argString = func.source ? `(\"${vue_i18n_escape(func.source)}\")` : `(?)`;\n    return {\n        _custom: {\n            type: 'function',\n            display: `<span>ƒ</span> ${argString}`\n        }\n    };\n}\nfunction registerScope(payload, i18n) {\n    payload.rootNodes.push({\n        id: 'global',\n        label: 'Global Scope'\n    });\n    // prettier-ignore\n    const global = i18n.mode === 'composition'\n        ? i18n.global\n        : i18n.global.__composer;\n    for (const [keyInstance, instance] of i18n.__instances) {\n        // prettier-ignore\n        const composer = i18n.mode === 'composition'\n            ? instance\n            : instance.__composer;\n        if (global === composer) {\n            continue;\n        }\n        payload.rootNodes.push({\n            id: composer.id.toString(),\n            label: `${getI18nScopeLable(keyInstance)} Scope`\n        });\n    }\n}\nfunction getComponentInstance(nodeId, i18n) {\n    let instance = null;\n    if (nodeId !== 'global') {\n        for (const [component, composer] of i18n.__instances.entries()) {\n            if (composer.id.toString() === nodeId) {\n                instance = component;\n                break;\n            }\n        }\n    }\n    return instance;\n}\nfunction getComposer$1(nodeId, i18n) {\n    if (nodeId === 'global') {\n        return i18n.mode === 'composition'\n            ? i18n.global\n            : i18n.global.__composer;\n    }\n    else {\n        const instance = Array.from(i18n.__instances.values()).find(item => item.id.toString() === nodeId);\n        if (instance) {\n            return i18n.mode === 'composition'\n                ? instance\n                : instance.__composer;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction inspectScope(payload, i18n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const composer = getComposer$1(payload.nodeId, i18n);\n    if (composer) {\n        // TODO:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        payload.state = makeScopeInspectState(composer);\n    }\n    return null;\n}\nfunction makeScopeInspectState(composer) {\n    const state = {};\n    const localeType = 'Locale related info';\n    const localeStates = [\n        {\n            type: localeType,\n            key: 'locale',\n            editable: true,\n            value: composer.locale.value\n        },\n        {\n            type: localeType,\n            key: 'fallbackLocale',\n            editable: true,\n            value: composer.fallbackLocale.value\n        },\n        {\n            type: localeType,\n            key: 'availableLocales',\n            editable: false,\n            value: composer.availableLocales\n        },\n        {\n            type: localeType,\n            key: 'inheritLocale',\n            editable: true,\n            value: composer.inheritLocale\n        }\n    ];\n    state[localeType] = localeStates;\n    const localeMessagesType = 'Locale messages info';\n    const localeMessagesStates = [\n        {\n            type: localeMessagesType,\n            key: 'messages',\n            editable: false,\n            value: getLocaleMessageValue(composer.messages.value)\n        }\n    ];\n    state[localeMessagesType] = localeMessagesStates;\n    {\n        const datetimeFormatsType = 'Datetime formats info';\n        const datetimeFormatsStates = [\n            {\n                type: datetimeFormatsType,\n                key: 'datetimeFormats',\n                editable: false,\n                value: composer.datetimeFormats.value\n            }\n        ];\n        state[datetimeFormatsType] = datetimeFormatsStates;\n        const numberFormatsType = 'Datetime formats info';\n        const numberFormatsStates = [\n            {\n                type: numberFormatsType,\n                key: 'numberFormats',\n                editable: false,\n                value: composer.numberFormats.value\n            }\n        ];\n        state[numberFormatsType] = numberFormatsStates;\n    }\n    return state;\n}\nfunction addTimelineEvent(event, payload) {\n    if (devtoolsApi) {\n        let groupId;\n        if (payload && 'groupId' in payload) {\n            groupId = payload.groupId;\n            delete payload.groupId;\n        }\n        devtoolsApi.addTimelineEvent({\n            layerId: \"vue-i18n-timeline\" /* VueDevToolsIDs.TIMELINE */,\n            event: {\n                title: event,\n                groupId,\n                time: Date.now(),\n                meta: {},\n                data: payload || {},\n                logType: event === \"compile-error\" /* VueDevToolsTimelineEvents.COMPILE_ERROR */\n                    ? 'error'\n                    : event === \"fallback\" /* VueDevToolsTimelineEvents.FALBACK */ ||\n                        event === \"missing\" /* VueDevToolsTimelineEvents.MISSING */\n                        ? 'warning'\n                        : 'default'\n            }\n        });\n    }\n}\nfunction editScope(payload, i18n) {\n    const composer = getComposer$1(payload.nodeId, i18n);\n    if (composer) {\n        const [field] = payload.path;\n        if (field === 'locale' && shared_isString(payload.state.value)) {\n            composer.locale.value = payload.state.value;\n        }\n        else if (field === 'fallbackLocale' &&\n            (shared_isString(payload.state.value) ||\n                shared_isArray(payload.state.value) ||\n                shared_isObject(payload.state.value))) {\n            composer.fallbackLocale.value = payload.state.value;\n        }\n        else if (field === 'inheritLocale' && shared_isBoolean(payload.state.value)) {\n            composer.inheritLocale = payload.state.value;\n        }\n    }\n}\n\n/**\n * Supports compatibility for legacy vue-i18n APIs\n * This mixin is used when we use vue-i18n@v9.x or later\n */\nfunction defineMixin(vuei18n, composer, i18n) {\n    return {\n        beforeCreate() {\n            const instance = runtime_core_esm_bundler_getCurrentInstance();\n            /* istanbul ignore if */\n            if (!instance) {\n                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n            }\n            const options = this.$options;\n            if (options.i18n) {\n                const optionsI18n = options.i18n;\n                if (options.__i18n) {\n                    optionsI18n.__i18n = options.__i18n;\n                }\n                optionsI18n.__root = composer;\n                if (this === this.$root) {\n                    this.$i18n = mergeToRoot(vuei18n, optionsI18n);\n                }\n                else {\n                    optionsI18n.__injectWithOption = true;\n                    this.$i18n = createVueI18n(optionsI18n);\n                }\n            }\n            else if (options.__i18n) {\n                if (this === this.$root) {\n                    this.$i18n = mergeToRoot(vuei18n, options);\n                }\n                else {\n                    this.$i18n = createVueI18n({\n                        __i18n: options.__i18n,\n                        __injectWithOption: true,\n                        __root: composer\n                    });\n                }\n            }\n            else {\n                // set global\n                this.$i18n = vuei18n;\n            }\n            if (options.__i18nGlobal) {\n                adjustI18nResources(composer, options, options);\n            }\n            vuei18n.__onComponentInstanceCreated(this.$i18n);\n            i18n.__setInstance(instance, this.$i18n);\n            // defines vue-i18n legacy APIs\n            this.$t = (...args) => this.$i18n.t(...args);\n            this.$rt = (...args) => this.$i18n.rt(...args);\n            this.$tc = (...args) => this.$i18n.tc(...args);\n            this.$te = (key, locale) => this.$i18n.te(key, locale);\n            this.$d = (...args) => this.$i18n.d(...args);\n            this.$n = (...args) => this.$i18n.n(...args);\n            this.$tm = (key) => this.$i18n.tm(key);\n            // extend vue-i18n legacy APIs\n            if (this !== this.$root &&\n                !this.$i18n.__extended__ &&\n                i18n.__vueI18nExtend) {\n                i18n.__vueI18nExtend(this.$i18n);\n                this.$i18n.__extended__ = true;\n            }\n        },\n        mounted() {\n            /* istanbul ignore if */\n            if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                !false &&\n                this.$el &&\n                this.$i18n) {\n                this.$el.__VUE_I18N__ = this.$i18n.__composer;\n                const emitter = (this.__v_emitter =\n                    createEmitter());\n                const _vueI18n = this.$i18n;\n                _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);\n                emitter.on('*', addTimelineEvent);\n            }\n        },\n        unmounted() {\n            const instance = runtime_core_esm_bundler_getCurrentInstance();\n            /* istanbul ignore if */\n            if (!instance) {\n                throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n            }\n            /* istanbul ignore if */\n            if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                !false &&\n                this.$el &&\n                this.$el.__VUE_I18N__) {\n                if (this.__v_emitter) {\n                    this.__v_emitter.off('*', addTimelineEvent);\n                    delete this.__v_emitter;\n                }\n                if (this.$i18n) {\n                    const _vueI18n = this.$i18n;\n                    _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();\n                    delete this.$el.__VUE_I18N__;\n                }\n            }\n            delete this.$t;\n            delete this.$rt;\n            delete this.$tc;\n            delete this.$te;\n            delete this.$d;\n            delete this.$n;\n            delete this.$tm;\n            i18n.__deleteInstance(instance);\n            delete this.$i18n;\n        }\n    };\n}\nfunction mergeToRoot(root, options) {\n    root.locale = options.locale || root.locale;\n    root.fallbackLocale = options.fallbackLocale || root.fallbackLocale;\n    root.missing = options.missing || root.missing;\n    root.silentTranslationWarn =\n        options.silentTranslationWarn || root.silentFallbackWarn;\n    root.silentFallbackWarn =\n        options.silentFallbackWarn || root.silentFallbackWarn;\n    root.formatFallbackMessages =\n        options.formatFallbackMessages || root.formatFallbackMessages;\n    root.postTranslation = options.postTranslation || root.postTranslation;\n    root.warnHtmlInMessage = options.warnHtmlInMessage || root.warnHtmlInMessage;\n    root.escapeParameterHtml =\n        options.escapeParameterHtml || root.escapeParameterHtml;\n    root.sync = options.sync || root.sync;\n    root.__composer[SetPluralRulesSymbol](options.pluralizationRules || root.pluralizationRules);\n    const messages = getLocaleMessages(root.locale, {\n        messages: options.messages,\n        __i18n: options.__i18n\n    });\n    Object.keys(messages).forEach(locale => root.mergeLocaleMessage(locale, messages[locale]));\n    if (options.datetimeFormats) {\n        Object.keys(options.datetimeFormats).forEach(locale => root.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));\n    }\n    if (options.numberFormats) {\n        Object.keys(options.numberFormats).forEach(locale => root.mergeNumberFormat(locale, options.numberFormats[locale]));\n    }\n    return root;\n}\n\n/**\n * Injection key for {@link useI18n}\n *\n * @remarks\n * The global injection key for I18n instances with `useI18n`. this injection key is used in Web Components.\n * Specify the i18n instance created by {@link createI18n} together with `provide` function.\n *\n * @VueI18nGeneral\n */\nconst I18nInjectionKey = \n/* #__PURE__*/ makeSymbol('global-vue-i18n');\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nfunction createI18n(options = {}, VueI18nLegacy) {\n    // prettier-ignore\n    const __legacyMode = __VUE_I18N_LEGACY_API__ && shared_isBoolean(options.legacy)\n            ? options.legacy\n            : __VUE_I18N_LEGACY_API__;\n    // prettier-ignore\n    const __globalInjection = shared_isBoolean(options.globalInjection)\n        ? options.globalInjection\n        : true;\n    // prettier-ignore\n    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode\n            ? !!options.allowComposition\n            : true;\n    const __instances = new Map();\n    const [globalScope, __global] = createGlobal(options, __legacyMode);\n    const symbol = /* #__PURE__*/ makeSymbol(( false) ? 0 : '');\n    function __getInstance(component) {\n        return __instances.get(component) || null;\n    }\n    function __setInstance(component, instance) {\n        __instances.set(component, instance);\n    }\n    function __deleteInstance(component) {\n        __instances.delete(component);\n    }\n    {\n        const i18n = {\n            // mode\n            get mode() {\n                return __VUE_I18N_LEGACY_API__ && __legacyMode\n                    ? 'legacy'\n                    : 'composition';\n            },\n            // allowComposition\n            get allowComposition() {\n                return __allowComposition;\n            },\n            // install plugin\n            async install(app, ...options) {\n                if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                    !false) {\n                    app.__VUE_I18N__ = i18n;\n                }\n                // setup global provider\n                app.__VUE_I18N_SYMBOL__ = symbol;\n                app.provide(app.__VUE_I18N_SYMBOL__, i18n);\n                // set composer & vuei18n extend hook options from plugin options\n                if (shared_isPlainObject(options[0])) {\n                    const opts = options[0];\n                    i18n.__composerExtend =\n                        opts.__composerExtend;\n                    i18n.__vueI18nExtend =\n                        opts.__vueI18nExtend;\n                }\n                // global method and properties injection for Composition API\n                let globalReleaseHandler = null;\n                if (!__legacyMode && __globalInjection) {\n                    globalReleaseHandler = injectGlobalFields(app, i18n.global);\n                }\n                // install built-in components and directive\n                if (__VUE_I18N_FULL_INSTALL__) {\n                    apply(app, i18n, ...options);\n                }\n                // setup mixin for Legacy API\n                if (__VUE_I18N_LEGACY_API__ && __legacyMode) {\n                    app.mixin(defineMixin(__global, __global.__composer, i18n));\n                }\n                // release global scope\n                const unmountApp = app.unmount;\n                app.unmount = () => {\n                    globalReleaseHandler && globalReleaseHandler();\n                    i18n.dispose();\n                    unmountApp();\n                };\n                // setup vue-devtools plugin\n                if ((( false) || __VUE_PROD_DEVTOOLS__) && !false) {\n                    const ret = await enableDevTools(app, i18n);\n                    if (!ret) {\n                        throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);\n                    }\n                    const emitter = createEmitter();\n                    if (__legacyMode) {\n                        const _vueI18n = __global;\n                        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        const _composer = __global;\n                        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);\n                    }\n                    emitter.on('*', addTimelineEvent);\n                }\n            },\n            // global accessor\n            get global() {\n                return __global;\n            },\n            dispose() {\n                globalScope.stop();\n            },\n            // @internal\n            __instances,\n            // @internal\n            __getInstance,\n            // @internal\n            __setInstance,\n            // @internal\n            __deleteInstance\n        };\n        return i18n;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction useI18n(options = {}) {\n    const instance = runtime_core_esm_bundler_getCurrentInstance();\n    if (instance == null) {\n        throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);\n    }\n    if (!instance.isCE &&\n        instance.appContext.app != null &&\n        !instance.appContext.app.__VUE_I18N_SYMBOL__) {\n        throw createI18nError(I18nErrorCodes.NOT_INSTALLED);\n    }\n    const i18n = getI18nInstance(instance);\n    const gl = getGlobalComposer(i18n);\n    const componentOptions = getComponentOptions(instance);\n    const scope = getScope(options, componentOptions);\n    if (__VUE_I18N_LEGACY_API__) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (i18n.mode === 'legacy' && !options.__useComponent) {\n            if (!i18n.allowComposition) {\n                throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);\n            }\n            return useI18nForLegacy(instance, scope, gl, options);\n        }\n    }\n    if (scope === 'global') {\n        adjustI18nResources(gl, options, componentOptions);\n        return gl;\n    }\n    if (scope === 'parent') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let composer = getComposer(i18n, instance, options.__useComponent);\n        if (composer == null) {\n            if ((false)) {}\n            composer = gl;\n        }\n        return composer;\n    }\n    const i18nInternal = i18n;\n    let composer = i18nInternal.__getInstance(instance);\n    if (composer == null) {\n        const composerOptions = shared_assign({}, options);\n        if ('__i18n' in componentOptions) {\n            composerOptions.__i18n = componentOptions.__i18n;\n        }\n        if (gl) {\n            composerOptions.__root = gl;\n        }\n        composer = createComposer(composerOptions);\n        if (i18nInternal.__composerExtend) {\n            i18nInternal.__composerExtend(composer);\n        }\n        setupLifeCycle(i18nInternal, instance, composer);\n        i18nInternal.__setInstance(instance, composer);\n    }\n    return composer;\n}\n/**\n * Cast to VueI18n legacy compatible type\n *\n * @remarks\n * This API is provided only with [vue-i18n-bridge](https://vue-i18n.intlify.dev/guide/migration/ways.html#what-is-vue-i18n-bridge).\n *\n * The purpose of this function is to convert an {@link I18n} instance created with {@link createI18n | createI18n(legacy: true)} into a `vue-i18n@v8.x` compatible instance of `new VueI18n` in a TypeScript environment.\n *\n * @param i18n - An instance of {@link I18n}\n * @returns A i18n instance which is casted to {@link VueI18n} type\n *\n * @VueI18nTip\n * :new: provided by **vue-i18n-bridge only**\n *\n * @VueI18nGeneral\n */\nconst castToVueI18n =  (i18n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    if (!(__VUE_I18N_BRIDGE__ in i18n)) {\n        throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);\n    }\n    return i18n;\n};\nfunction createGlobal(options, legacyMode, VueI18nLegacy // eslint-disable-line @typescript-eslint/no-explicit-any\n) {\n    const scope = effectScope();\n    {\n        const obj = __VUE_I18N_LEGACY_API__ && legacyMode\n            ? scope.run(() => createVueI18n(options))\n            : scope.run(() => createComposer(options));\n        if (obj == null) {\n            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n        }\n        return [scope, obj];\n    }\n}\nfunction getI18nInstance(instance) {\n    {\n        const i18n = inject(!instance.isCE\n            ? instance.appContext.app.__VUE_I18N_SYMBOL__\n            : I18nInjectionKey);\n        /* istanbul ignore if */\n        if (!i18n) {\n            throw createI18nError(!instance.isCE\n                ? I18nErrorCodes.UNEXPECTED_ERROR\n                : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);\n        }\n        return i18n;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScope(options, componentOptions) {\n    // prettier-ignore\n    return isEmptyObject(options)\n        ? ('__i18n' in componentOptions)\n            ? 'local'\n            : 'global'\n        : !options.useScope\n            ? 'local'\n            : options.useScope;\n}\nfunction getGlobalComposer(i18n) {\n    // prettier-ignore\n    return i18n.mode === 'composition'\n            ? i18n.global\n            : i18n.global.__composer\n        ;\n}\nfunction getComposer(i18n, target, useComponent = false) {\n    let composer = null;\n    const root = target.root;\n    let current = getParentComponentInstance(target, useComponent);\n    while (current != null) {\n        const i18nInternal = i18n;\n        if (i18n.mode === 'composition') {\n            composer = i18nInternal.__getInstance(current);\n        }\n        else {\n            if (__VUE_I18N_LEGACY_API__) {\n                const vueI18n = i18nInternal.__getInstance(current);\n                if (vueI18n != null) {\n                    composer = vueI18n\n                        .__composer;\n                    if (useComponent &&\n                        composer &&\n                        !composer[InejctWithOption] // eslint-disable-line @typescript-eslint/no-explicit-any\n                    ) {\n                        composer = null;\n                    }\n                }\n            }\n        }\n        if (composer != null) {\n            break;\n        }\n        if (root === current) {\n            break;\n        }\n        current = current.parent;\n    }\n    return composer;\n}\nfunction getParentComponentInstance(target, useComponent = false) {\n    if (target == null) {\n        return null;\n    }\n    {\n        // if `useComponent: true` will be specified, we get lexical scope owner instance for use-case slots\n        return !useComponent\n            ? target.parent\n            : target.vnode.ctx || target.parent; // eslint-disable-line @typescript-eslint/no-explicit-any\n    }\n}\nfunction setupLifeCycle(i18n, target, composer) {\n    let emitter = null;\n    {\n        runtime_core_esm_bundler_onMounted(() => {\n            // inject composer instance to DOM for intlify-devtools\n            if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                !false &&\n                target.vnode.el) {\n                target.vnode.el.__VUE_I18N__ = composer;\n                emitter = createEmitter();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const _composer = composer;\n                _composer[EnableEmitter] && _composer[EnableEmitter](emitter);\n                emitter.on('*', addTimelineEvent);\n            }\n        }, target);\n        runtime_core_esm_bundler_onUnmounted(() => {\n            // remove composer instance from DOM for intlify-devtools\n            if ((( false) || __VUE_PROD_DEVTOOLS__) &&\n                !false &&\n                target.vnode.el &&\n                target.vnode.el.__VUE_I18N__) {\n                emitter && emitter.off('*', addTimelineEvent);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const _composer = composer;\n                _composer[DisableEmitter] && _composer[DisableEmitter]();\n                delete target.vnode.el.__VUE_I18N__;\n            }\n            i18n.__deleteInstance(target);\n        }, target);\n    }\n}\nfunction useI18nForLegacy(instance, scope, root, options = {} // eslint-disable-line @typescript-eslint/no-explicit-any\n) {\n    const isLocalScope = scope === 'local';\n    const _composer = shallowRef(null);\n    if (isLocalScope &&\n        instance.proxy &&\n        !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {\n        throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);\n    }\n    const _inheritLocale = shared_isBoolean(options.inheritLocale)\n        ? options.inheritLocale\n        : !shared_isString(options.locale);\n    const _locale = reactivity_esm_bundler_ref(\n    // prettier-ignore\n    !isLocalScope || _inheritLocale\n        ? root.locale.value\n        : shared_isString(options.locale)\n            ? options.locale\n            : DEFAULT_LOCALE);\n    const _fallbackLocale = reactivity_esm_bundler_ref(\n    // prettier-ignore\n    !isLocalScope || _inheritLocale\n        ? root.fallbackLocale.value\n        : shared_isString(options.fallbackLocale) ||\n            shared_isArray(options.fallbackLocale) ||\n            shared_isPlainObject(options.fallbackLocale) ||\n            options.fallbackLocale === false\n            ? options.fallbackLocale\n            : _locale.value);\n    const _messages = reactivity_esm_bundler_ref(getLocaleMessages(_locale.value, options));\n    // prettier-ignore\n    const _datetimeFormats = reactivity_esm_bundler_ref(shared_isPlainObject(options.datetimeFormats)\n        ? options.datetimeFormats\n        : { [_locale.value]: {} });\n    // prettier-ignore\n    const _numberFormats = reactivity_esm_bundler_ref(shared_isPlainObject(options.numberFormats)\n        ? options.numberFormats\n        : { [_locale.value]: {} });\n    // prettier-ignore\n    const _missingWarn = isLocalScope\n        ? root.missingWarn\n        : shared_isBoolean(options.missingWarn) || isRegExp(options.missingWarn)\n            ? options.missingWarn\n            : true;\n    // prettier-ignore\n    const _fallbackWarn = isLocalScope\n        ? root.fallbackWarn\n        : shared_isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn)\n            ? options.fallbackWarn\n            : true;\n    // prettier-ignore\n    const _fallbackRoot = isLocalScope\n        ? root.fallbackRoot\n        : shared_isBoolean(options.fallbackRoot)\n            ? options.fallbackRoot\n            : true;\n    // configure fall back to root\n    const _fallbackFormat = !!options.fallbackFormat;\n    // runtime missing\n    const _missing = shared_isFunction(options.missing) ? options.missing : null;\n    // postTranslation handler\n    const _postTranslation = shared_isFunction(options.postTranslation)\n        ? options.postTranslation\n        : null;\n    // prettier-ignore\n    const _warnHtmlMessage = isLocalScope\n        ? root.warnHtmlMessage\n        : shared_isBoolean(options.warnHtmlMessage)\n            ? options.warnHtmlMessage\n            : true;\n    const _escapeParameter = !!options.escapeParameter;\n    // prettier-ignore\n    const _modifiers = isLocalScope\n        ? root.modifiers\n        : shared_isPlainObject(options.modifiers)\n            ? options.modifiers\n            : {};\n    // pluralRules\n    const _pluralRules = options.pluralRules || (isLocalScope && root.pluralRules);\n    // track reactivity\n    function trackReactivityValues() {\n        return [\n            _locale.value,\n            _fallbackLocale.value,\n            _messages.value,\n            _datetimeFormats.value,\n            _numberFormats.value\n        ];\n    }\n    // locale\n    const locale = runtime_core_esm_bundler_computed({\n        get: () => {\n            return _composer.value ? _composer.value.locale.value : _locale.value;\n        },\n        set: val => {\n            if (_composer.value) {\n                _composer.value.locale.value = val;\n            }\n            _locale.value = val;\n        }\n    });\n    // fallbackLocale\n    const fallbackLocale = runtime_core_esm_bundler_computed({\n        get: () => {\n            return _composer.value\n                ? _composer.value.fallbackLocale.value\n                : _fallbackLocale.value;\n        },\n        set: val => {\n            if (_composer.value) {\n                _composer.value.fallbackLocale.value = val;\n            }\n            _fallbackLocale.value = val;\n        }\n    });\n    // messages\n    const messages = runtime_core_esm_bundler_computed(() => {\n        if (_composer.value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return _composer.value.messages.value;\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return _messages.value;\n        }\n    });\n    const datetimeFormats = runtime_core_esm_bundler_computed(() => _datetimeFormats.value);\n    const numberFormats = runtime_core_esm_bundler_computed(() => _numberFormats.value);\n    function getPostTranslationHandler() {\n        return _composer.value\n            ? _composer.value.getPostTranslationHandler()\n            : _postTranslation;\n    }\n    function setPostTranslationHandler(handler) {\n        if (_composer.value) {\n            _composer.value.setPostTranslationHandler(handler);\n        }\n    }\n    function getMissingHandler() {\n        return _composer.value ? _composer.value.getMissingHandler() : _missing;\n    }\n    function setMissingHandler(handler) {\n        if (_composer.value) {\n            _composer.value.setMissingHandler(handler);\n        }\n    }\n    function warpWithDeps(fn) {\n        trackReactivityValues();\n        return fn();\n    }\n    function t(...args) {\n        return _composer.value\n            ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args]))\n            : warpWithDeps(() => '');\n    }\n    function rt(...args) {\n        return _composer.value\n            ? Reflect.apply(_composer.value.rt, null, [...args])\n            : '';\n    }\n    function d(...args) {\n        return _composer.value\n            ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args]))\n            : warpWithDeps(() => '');\n    }\n    function n(...args) {\n        return _composer.value\n            ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args]))\n            : warpWithDeps(() => '');\n    }\n    function tm(key) {\n        return _composer.value ? _composer.value.tm(key) : {};\n    }\n    function te(key, locale) {\n        return _composer.value ? _composer.value.te(key, locale) : false;\n    }\n    function getLocaleMessage(locale) {\n        return _composer.value ? _composer.value.getLocaleMessage(locale) : {};\n    }\n    function setLocaleMessage(locale, message) {\n        if (_composer.value) {\n            _composer.value.setLocaleMessage(locale, message);\n            _messages.value[locale] = message;\n        }\n    }\n    function mergeLocaleMessage(locale, message) {\n        if (_composer.value) {\n            _composer.value.mergeLocaleMessage(locale, message);\n        }\n    }\n    function getDateTimeFormat(locale) {\n        return _composer.value ? _composer.value.getDateTimeFormat(locale) : {};\n    }\n    function setDateTimeFormat(locale, format) {\n        if (_composer.value) {\n            _composer.value.setDateTimeFormat(locale, format);\n            _datetimeFormats.value[locale] = format;\n        }\n    }\n    function mergeDateTimeFormat(locale, format) {\n        if (_composer.value) {\n            _composer.value.mergeDateTimeFormat(locale, format);\n        }\n    }\n    function getNumberFormat(locale) {\n        return _composer.value ? _composer.value.getNumberFormat(locale) : {};\n    }\n    function setNumberFormat(locale, format) {\n        if (_composer.value) {\n            _composer.value.setNumberFormat(locale, format);\n            _numberFormats.value[locale] = format;\n        }\n    }\n    function mergeNumberFormat(locale, format) {\n        if (_composer.value) {\n            _composer.value.mergeNumberFormat(locale, format);\n        }\n    }\n    const wrapper = {\n        get id() {\n            return _composer.value ? _composer.value.id : -1;\n        },\n        locale,\n        fallbackLocale,\n        messages,\n        datetimeFormats,\n        numberFormats,\n        get inheritLocale() {\n            return _composer.value ? _composer.value.inheritLocale : _inheritLocale;\n        },\n        set inheritLocale(val) {\n            if (_composer.value) {\n                _composer.value.inheritLocale = val;\n            }\n        },\n        get availableLocales() {\n            return _composer.value\n                ? _composer.value.availableLocales\n                : Object.keys(_messages.value);\n        },\n        get modifiers() {\n            return (_composer.value ? _composer.value.modifiers : _modifiers);\n        },\n        get pluralRules() {\n            return (_composer.value ? _composer.value.pluralRules : _pluralRules);\n        },\n        get isGlobal() {\n            return _composer.value ? _composer.value.isGlobal : false;\n        },\n        get missingWarn() {\n            return _composer.value ? _composer.value.missingWarn : _missingWarn;\n        },\n        set missingWarn(val) {\n            if (_composer.value) {\n                _composer.value.missingWarn = val;\n            }\n        },\n        get fallbackWarn() {\n            return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;\n        },\n        set fallbackWarn(val) {\n            if (_composer.value) {\n                _composer.value.missingWarn = val;\n            }\n        },\n        get fallbackRoot() {\n            return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;\n        },\n        set fallbackRoot(val) {\n            if (_composer.value) {\n                _composer.value.fallbackRoot = val;\n            }\n        },\n        get fallbackFormat() {\n            return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;\n        },\n        set fallbackFormat(val) {\n            if (_composer.value) {\n                _composer.value.fallbackFormat = val;\n            }\n        },\n        get warnHtmlMessage() {\n            return _composer.value\n                ? _composer.value.warnHtmlMessage\n                : _warnHtmlMessage;\n        },\n        set warnHtmlMessage(val) {\n            if (_composer.value) {\n                _composer.value.warnHtmlMessage = val;\n            }\n        },\n        get escapeParameter() {\n            return _composer.value\n                ? _composer.value.escapeParameter\n                : _escapeParameter;\n        },\n        set escapeParameter(val) {\n            if (_composer.value) {\n                _composer.value.escapeParameter = val;\n            }\n        },\n        t,\n        getPostTranslationHandler,\n        setPostTranslationHandler,\n        getMissingHandler,\n        setMissingHandler,\n        rt,\n        d,\n        n,\n        tm,\n        te,\n        getLocaleMessage,\n        setLocaleMessage,\n        mergeLocaleMessage,\n        getDateTimeFormat,\n        setDateTimeFormat,\n        mergeDateTimeFormat,\n        getNumberFormat,\n        setNumberFormat,\n        mergeNumberFormat\n    };\n    function sync(composer) {\n        composer.locale.value = _locale.value;\n        composer.fallbackLocale.value = _fallbackLocale.value;\n        Object.keys(_messages.value).forEach(locale => {\n            composer.mergeLocaleMessage(locale, _messages.value[locale]);\n        });\n        Object.keys(_datetimeFormats.value).forEach(locale => {\n            composer.mergeDateTimeFormat(locale, _datetimeFormats.value[locale]);\n        });\n        Object.keys(_numberFormats.value).forEach(locale => {\n            composer.mergeNumberFormat(locale, _numberFormats.value[locale]);\n        });\n        composer.escapeParameter = _escapeParameter;\n        composer.fallbackFormat = _fallbackFormat;\n        composer.fallbackRoot = _fallbackRoot;\n        composer.fallbackWarn = _fallbackWarn;\n        composer.missingWarn = _missingWarn;\n        composer.warnHtmlMessage = _warnHtmlMessage;\n    }\n    onBeforeMount(() => {\n        if (instance.proxy == null || instance.proxy.$i18n == null) {\n            throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const composer = (_composer.value = instance.proxy.$i18n\n            .__composer);\n        if (scope === 'global') {\n            _locale.value = composer.locale.value;\n            _fallbackLocale.value = composer.fallbackLocale.value;\n            _messages.value = composer.messages.value;\n            _datetimeFormats.value = composer.datetimeFormats.value;\n            _numberFormats.value = composer.numberFormats.value;\n        }\n        else if (isLocalScope) {\n            sync(composer);\n        }\n    });\n    return wrapper;\n}\nconst globalExportProps = [\n    'locale',\n    'fallbackLocale',\n    'availableLocales'\n];\nconst globalExportMethods = ['t', 'rt', 'd', 'n', 'tm', 'te']\n    ;\nfunction injectGlobalFields(app, composer) {\n    const i18n = Object.create(null);\n    globalExportProps.forEach(prop => {\n        const desc = Object.getOwnPropertyDescriptor(composer, prop);\n        if (!desc) {\n            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n        }\n        const wrap = reactivity_esm_bundler_isRef(desc.value) // check computed props\n            ? {\n                get() {\n                    return desc.value.value;\n                },\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                set(val) {\n                    desc.value.value = val;\n                }\n            }\n            : {\n                get() {\n                    return desc.get && desc.get();\n                }\n            };\n        Object.defineProperty(i18n, prop, wrap);\n    });\n    app.config.globalProperties.$i18n = i18n;\n    globalExportMethods.forEach(method => {\n        const desc = Object.getOwnPropertyDescriptor(composer, method);\n        if (!desc || !desc.value) {\n            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);\n        }\n        Object.defineProperty(app.config.globalProperties, `$${method}`, desc);\n    });\n    const release = () => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        delete app.config.globalProperties.$i18n;\n        globalExportMethods.forEach(method => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            delete app.config.globalProperties[`$${method}`];\n        });\n    };\n    return release;\n}\n\n{\n    vue_i18n_initFeatureFlags();\n}\n// register message compiler at vue-i18n\nif (!__INTLIFY_JIT_COMPILATION__) {\n    registerMessageCompiler(compileToFunction);\n}\nelse {\n    registerMessageCompiler(core_base_compile);\n}\n// register message resolver at vue-i18n\nregisterMessageResolver(resolveValue);\n// register fallback locale at vue-i18n\nregisterLocaleFallbacker(fallbackWithLocaleChain);\n// NOTE: experimental !!\nif (( false) || __INTLIFY_PROD_DEVTOOLS__) {\n    const target = shared_getGlobalThis();\n    target.__INTLIFY__ = true;\n    setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);\n}\nif ((false)) {}\n\n\n\n;// CONCATENATED MODULE: ./src/i18n/i18n.js\nvar translations = {\n  fi: __webpack_require__(6),\n  sv: __webpack_require__(2220),\n  en: __webpack_require__(6),\n  se: __webpack_require__(4360)\n};\n/* harmony default export */ var i18n = (translations);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestNewButton.vue?vue&type=template&id=150727ae\n\nvar _hoisted_1 = [\"href\"];\nvar _hoisted_2 = {\n  id: \"vocab-info\"\n};\nfunction SuggestNewButtonvue_type_template_id_150727ae_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_new_suggestion = resolveComponent(\"new-suggestion\");\n  var _component_success_message = resolveComponent(\"success-message\");\n  var _component_failure_message = resolveComponent(\"failure-message\");\n  var _component_centered_dialog = resolveComponent(\"centered-dialog\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"a\", {\n    role: \"button\",\n    onClick: _cache[0] || (_cache[0] = function ($event) {\n      return _ctx.isOpened = !_ctx.isOpened;\n    }),\n    id: \"fordirectnew\",\n    href: \"\".concat(_ctx.pageUrl.split('#')[0], \"#suggestion\")\n  }, [createBaseVNode(\"span\", null, [createBaseVNode(\"div\", _hoisted_2, [createBaseVNode(\"div\", null, [createBaseVNode(\"h3\", null, toDisplayString(_ctx.$t('new.button')), 1 /* TEXT */)])])])], 8 /* PROPS */, _hoisted_1), _ctx.isOpened ? (openBlock(), createBlock(_component_centered_dialog, {\n    key: 0,\n    onClose: _cache[21] || (_cache[21] = function ($event) {\n      return _ctx.closeDialog();\n    })\n  }, {\n    default: withCtx(function () {\n      return [!_ctx.showSuccessMessage && !_ctx.showFailureMessage ? (openBlock(), createBlock(_component_new_suggestion, {\n        key: 0,\n        conceptTypeIsSelected: _ctx.conceptTypeIsSelected,\n        prefLabelOkay: _ctx.prefLabelOkay,\n        explanationOkay: _ctx.explanationOkay,\n        neededForOkay: _ctx.neededForOkay,\n        sending: _ctx.sending,\n        \"onUpdate:conceptTypeIsSelected\": _cache[1] || (_cache[1] = function ($event) {\n          return _ctx.conceptTypeIsSelected = true;\n        }),\n        \"onUpdate:prefLabelOkay\": _cache[2] || (_cache[2] = function ($event) {\n          return _ctx.prefLabelOkay = true;\n        }),\n        \"onUpdate:explanationOkay\": _cache[3] || (_cache[3] = function ($event) {\n          return _ctx.explanationOkay = true;\n        }),\n        \"onUpdate:neededForOkay\": _cache[4] || (_cache[4] = function ($event) {\n          return _ctx.neededForOkay = true;\n        }),\n        d: _ctx.formData,\n        \"onUpdate:vocabulary\": _cache[5] || (_cache[5] = function ($event) {\n          return _ctx.formData.vocabulary = $event;\n        }),\n        \"onUpdate:conceptType\": _cache[6] || (_cache[6] = function ($event) {\n          return _ctx.formData.conceptType.value = $event;\n        }),\n        \"onUpdate:primaryPrefLabel\": _cache[7] || (_cache[7] = function ($event) {\n          return _ctx.formData.prefLabel.primary = $event;\n        }),\n        \"onUpdate:secondaryPrefLabel\": _cache[8] || (_cache[8] = function ($event) {\n          return _ctx.formData.prefLabel.secondary = $event;\n        }),\n        \"onUpdate:enPrefLabel\": _cache[9] || (_cache[9] = function ($event) {\n          return _ctx.formData.prefLabel.en = $event;\n        }),\n        \"onUpdate:altLabels\": _cache[10] || (_cache[10] = function ($event) {\n          return _ctx.formData.altLabels = $event;\n        }),\n        \"onUpdate:broaderLabels\": _cache[11] || (_cache[11] = function ($event) {\n          return _ctx.formData.broaderLabels = $event;\n        }),\n        \"onUpdate:narrowerLabels\": _cache[12] || (_cache[12] = function ($event) {\n          return _ctx.formData.narrowerLabels = $event;\n        }),\n        \"onUpdate:relatedLabels\": _cache[13] || (_cache[13] = function ($event) {\n          return _ctx.formData.relatedLabels = $event;\n        }),\n        \"onUpdate:groups\": _cache[14] || (_cache[14] = function ($event) {\n          return _ctx.formData.groups.selectedGroups = $event;\n        }),\n        \"onUpdate:exactMatches\": _cache[15] || (_cache[15] = function ($event) {\n          return _ctx.formData.exactMatches = $event;\n        }),\n        \"onUpdate:scopeNote\": _cache[16] || (_cache[16] = function ($event) {\n          return _ctx.formData.scopeNote = $event;\n        }),\n        \"onUpdate:explanation\": _cache[17] || (_cache[17] = function ($event) {\n          return _ctx.formData.explanation = $event;\n        }),\n        \"onUpdate:neededFor\": _cache[18] || (_cache[18] = function ($event) {\n          return _ctx.formData.neededFor = $event;\n        }),\n        \"onUpdate:fromOrg\": _cache[19] || (_cache[19] = function ($event) {\n          return _ctx.formData.fromOrg = $event;\n        }),\n        onSubmitForm: _cache[20] || (_cache[20] = function ($event) {\n          return _ctx.submitForm();\n        })\n      }, null, 8 /* PROPS */, [\"conceptTypeIsSelected\", \"prefLabelOkay\", \"explanationOkay\", \"neededForOkay\", \"sending\", \"d\"])) : createCommentVNode(\"v-if\", true), _ctx.showSuccessMessage ? (openBlock(), createBlock(_component_success_message, {\n        key: 1,\n        suggestionUrl: _ctx.suggestionUrl,\n        url: _ctx.url\n      }, null, 8 /* PROPS */, [\"suggestionUrl\", \"url\"])) : createCommentVNode(\"v-if\", true), _ctx.showFailureMessage ? (openBlock(), createBlock(_component_failure_message, {\n        key: 2\n      })) : createCommentVNode(\"v-if\", true)];\n    }),\n    _: 1 /* STABLE */\n  })) : createCommentVNode(\"v-if\", true)]);\n}\n;// CONCATENATED MODULE: ./src/components/SuggestNewButton.vue?vue&type=template&id=150727ae\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/BasicDropDown.vue?vue&type=template&id=eafbc960&scoped=true\n\nvar _withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-eafbc960\"), n = n(), _popScopeId(), n;\n};\nvar BasicDropDownvue_type_template_id_eafbc960_scoped_true_hoisted_1 = {\n  class: \"input-container\"\n};\nvar BasicDropDownvue_type_template_id_eafbc960_scoped_true_hoisted_2 = [\"for\"];\nvar _hoisted_3 = {\n  class: \"select-content\"\n};\nvar _hoisted_4 = {\n  key: 0\n};\nvar _hoisted_5 = {\n  key: 1,\n  class: \"selected\"\n};\nvar _hoisted_6 = {\n  key: 0,\n  class: \"drop-down-options empty-options\"\n};\nvar _hoisted_7 = {\n  class: \"option\",\n  style: {\n    \"padding-left\": \"16px\"\n  }\n};\nvar _hoisted_8 = {\n  key: 1,\n  class: \"drop-down-options\"\n};\nvar _hoisted_9 = [\"onClick\"];\nfunction BasicDropDownvue_type_template_id_eafbc960_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_icon_triangle = resolveComponent(\"icon-triangle\");\n  var _component_svg_icon = resolveComponent(\"svg-icon\");\n  var _component_icon_check = resolveComponent(\"icon-check\");\n  var _directive_on_click_away = resolveDirective(\"on-click-away\");\n  return openBlock(), createElementBlock(\"div\", BasicDropDownvue_type_template_id_eafbc960_scoped_true_hoisted_1, [createBaseVNode(\"label\", {\n    for: $props.label.for\n  }, toDisplayString($props.label.text), 9 /* TEXT, PROPS */, BasicDropDownvue_type_template_id_eafbc960_scoped_true_hoisted_2), createBaseVNode(\"div\", {\n    onClick: _cache[0] || (_cache[0] = function ($event) {\n      return $setup.isOpened = !$setup.isOpened;\n    }),\n    class: normalizeClass([$setup.isOpened ? 'opened' : '', 'select-button'])\n  }, [createBaseVNode(\"div\", _hoisted_3, [!$props.value ? (openBlock(), createElementBlock(\"span\", _hoisted_4, toDisplayString(_ctx.$t('new.conceptType.placeholder')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), $props.value && $props.value.length > 0 ? (openBlock(), createElementBlock(\"span\", _hoisted_5, toDisplayString($props.value), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true)]), runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n    \"icon-name\": \"triangle\"\n  }, {\n    default: withCtx(function () {\n      return [runtime_core_esm_bundler_createVNode(_component_icon_triangle)];\n    }),\n    _: 1 /* STABLE */\n  })], 2 /* CLASS */), $setup.isOpened && $props.options.length === 0 ? withDirectives((openBlock(), createElementBlock(\"div\", _hoisted_6, [createBaseVNode(\"div\", _hoisted_7, [createBaseVNode(\"span\", null, toDisplayString($setup.noOptionsMessage), 1 /* TEXT */)])])), [[_directive_on_click_away, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true), $setup.isOpened && $props.options.length > 0 ? withDirectives((openBlock(), createElementBlock(\"div\", _hoisted_8, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($props.options, function (option, i) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: option.id,\n      onClick: function onClick($event) {\n        return $setup.selectOption(i);\n      },\n      class: normalizeClass([$setup.isSelected(i) ? 'selected' : '', 'option'])\n    }, [runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n      class: normalizeClass([$setup.isSelected(i) ? '' : 'hidden-checkmark']),\n      \"icon-name\": \"check\"\n    }, {\n      default: withCtx(function () {\n        return [runtime_core_esm_bundler_createVNode(_component_icon_check)];\n      }),\n      _: 2 /* DYNAMIC */\n    }, 1032 /* PROPS, DYNAMIC_SLOTS */, [\"class\"]), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t(option.value)), 1 /* TEXT */)], 10 /* CLASS, PROPS */, _hoisted_9);\n  }), 128 /* KEYED_FRAGMENT */))])), [[_directive_on_click_away, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true)]);\n}\n;// CONCATENATED MODULE: ./src/components/form/BasicDropDown.vue?vue&type=template&id=eafbc960&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/SvgIcon.vue?vue&type=template&id=2fda14c1&scoped=true\n\nvar SvgIconvue_type_template_id_2fda14c1_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-2fda14c1\"), n = n(), _popScopeId(), n;\n};\nvar SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_1 = [\"width\", \"height\", \"aria-labelledby\"];\nvar SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_2 = [\"id\"];\nvar SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_3 = [\"fill\"];\nfunction SvgIconvue_type_template_id_2fda14c1_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"svg\", {\n    width: $props.width,\n    height: $props.height,\n    viewBox: \"0 0 24 24\",\n    \"aria-labelledby\": $props.iconName,\n    role: \"presentation\",\n    stroke: \"currentColor\"\n  }, [createBaseVNode(\"title\", {\n    id: $props.iconName,\n    lang: \"en\"\n  }, toDisplayString($props.iconName) + \" icon\", 9 /* TEXT, PROPS */, SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_2), createBaseVNode(\"g\", {\n    fill: $props.iconColor\n  }, [renderSlot(_ctx.$slots, \"default\", {}, undefined, true)], 8 /* PROPS */, SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_3)], 8 /* PROPS */, SvgIconvue_type_template_id_2fda14c1_scoped_true_hoisted_1);\n}\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/SvgIcon.vue?vue&type=script&lang=js\n/* harmony default export */ var SvgIconvue_type_script_lang_js = ({\n  props: {\n    iconName: {\n      type: String,\n      default: ''\n    },\n    width: {\n      type: [Number, String],\n      default: 24\n    },\n    height: {\n      type: [Number, String],\n      default: 24\n    },\n    iconColor: {\n      type: String,\n      default: 'currentColor'\n    }\n  }\n});\n;// CONCATENATED MODULE: ./src/components/icons/SvgIcon.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/SvgIcon.vue?vue&type=style&index=0&id=2fda14c1&scoped=true&lang=css\nvar SvgIconvue_type_style_index_0_id_2fda14c1_scoped_true_lang_css = __webpack_require__(4549);\n;// CONCATENATED MODULE: ./src/components/icons/SvgIcon.vue?vue&type=style&index=0&id=2fda14c1&scoped=true&lang=css\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/dist/exportHelper.js\nvar exportHelper = __webpack_require__(3744);\n;// CONCATENATED MODULE: ./src/components/icons/SvgIcon.vue\n\n\n\n\n;\n\n\nconst __exports__ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SvgIconvue_type_script_lang_js, [['render',SvgIconvue_type_template_id_2fda14c1_scoped_true_render],['__scopeId',\"data-v-2fda14c1\"]])\n\n/* harmony default export */ var SvgIcon = (__exports__);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/IconTriangle.vue?vue&type=template&id=5c3d63bc\n\nvar IconTrianglevue_type_template_id_5c3d63bc_hoisted_1 = {\n  \"stroke-width\": \"2\"\n};\nvar IconTrianglevue_type_template_id_5c3d63bc_hoisted_2 = /*#__PURE__*/createBaseVNode(\"path\", {\n  d: \"M4.08301 5.83334H9.91634L6.99967 8.75L4.08301 5.83334Z\"\n}, null, -1 /* HOISTED */);\nvar IconTrianglevue_type_template_id_5c3d63bc_hoisted_3 = [IconTrianglevue_type_template_id_5c3d63bc_hoisted_2];\nfunction IconTrianglevue_type_template_id_5c3d63bc_render(_ctx, _cache) {\n  return openBlock(), createElementBlock(\"g\", IconTrianglevue_type_template_id_5c3d63bc_hoisted_1, IconTrianglevue_type_template_id_5c3d63bc_hoisted_3);\n}\n;// CONCATENATED MODULE: ./src/components/icons/IconTriangle.vue?vue&type=template&id=5c3d63bc\n\n;// CONCATENATED MODULE: ./src/components/icons/IconTriangle.vue\n\nconst script = {}\n\n;\nconst IconTriangle_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(script, [['render',IconTrianglevue_type_template_id_5c3d63bc_render]])\n\n/* harmony default export */ var IconTriangle = (IconTriangle_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/IconCheck.vue?vue&type=template&id=27f2cf6e\n\nvar IconCheckvue_type_template_id_27f2cf6e_hoisted_1 = /*#__PURE__*/createBaseVNode(\"path\", {\n  d: \"M21 6L9 18\",\n  stroke: \"currentColor\",\n  \"stroke-width\": \"3\",\n  \"stroke-linecap\": \"round\"\n}, null, -1 /* HOISTED */);\nvar IconCheckvue_type_template_id_27f2cf6e_hoisted_2 = /*#__PURE__*/createBaseVNode(\"path\", {\n  d: \"M4 13L9 18\",\n  stroke: \"currentColor\",\n  \"stroke-width\": \"3\",\n  \"stroke-linecap\": \"round\"\n}, null, -1 /* HOISTED */);\nvar IconCheckvue_type_template_id_27f2cf6e_hoisted_3 = [IconCheckvue_type_template_id_27f2cf6e_hoisted_1, IconCheckvue_type_template_id_27f2cf6e_hoisted_2];\nfunction IconCheckvue_type_template_id_27f2cf6e_render(_ctx, _cache) {\n  return openBlock(), createElementBlock(\"g\", null, IconCheckvue_type_template_id_27f2cf6e_hoisted_3);\n}\n;// CONCATENATED MODULE: ./src/components/icons/IconCheck.vue?vue&type=template&id=27f2cf6e\n\n;// CONCATENATED MODULE: ./src/components/icons/IconCheck.vue\n\nconst IconCheck_script = {}\n\n;\nconst IconCheck_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IconCheck_script, [['render',IconCheckvue_type_template_id_27f2cf6e_render]])\n\n/* harmony default export */ var IconCheck = (IconCheck_exports_);\n;// CONCATENATED MODULE: ./node_modules/vue3-click-away/dist/module.js\nconst clickEventType = function () {\n  return document.ontouchstart !== null ? \"click\" : \"touchstart\";\n};\n\nconst UNIQUE_ID = \"__vue_click_away__\";\n\nconst module_onMounted = function (el, binding, vnode) {\n  module_onUnmounted(el);\n  let vm = vnode.context;\n  let callback = binding.value;\n  let nextTick = false;\n  setTimeout(function () {\n    nextTick = true;\n  }, 0);\n\n  el[UNIQUE_ID] = function (event) {\n    if ((!el || !el.contains(event.target)) && callback && nextTick && typeof callback === \"function\") {\n      return callback.call(vm, event);\n    }\n  };\n\n  document.addEventListener(clickEventType(), el[UNIQUE_ID], false);\n};\n\nconst module_onUnmounted = function (el) {\n  document.removeEventListener(clickEventType(), el[UNIQUE_ID], false);\n  delete el[UNIQUE_ID];\n};\n\nconst module_onUpdated = function (el, binding, vnode) {\n  if (binding.value === binding.oldValue) {\n    return;\n  }\n\n  module_onMounted(el, binding, vnode);\n};\n\nconst module_plugin = {\n  install: function (app) {\n    app.directive('click-away', directive);\n  }\n};\nconst directive = {\n  mounted: module_onMounted,\n  updated: module_onUpdated,\n  unmounted: module_onUnmounted\n};\nconst mixin = {\n  directives: {\n    ClickAway: directive\n  }\n};\n\n/* harmony default export */ var dist_module = ((/* unused pure expression or super */ null && (module_plugin)));\n\n//# sourceMappingURL=module.js.map\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/BasicDropDown.vue?vue&type=script&lang=js\n\n\n\n\n\n/* harmony default export */ var BasicDropDownvue_type_script_lang_js = ({\n  components: {\n    SvgIcon: SvgIcon,\n    IconTriangle: IconTriangle,\n    IconCheck: IconCheck\n  },\n  directives: {\n    onClickAway: directive\n  },\n  props: {\n    value: String,\n    options: Array,\n    label: Object\n  },\n  setup: function setup(props, context) {\n    var $t = inject('$t');\n    var selectedIndex = reactivity_esm_bundler_ref(-1);\n    var isOpened = reactivity_esm_bundler_ref(false);\n    var count = reactivity_esm_bundler_ref(0);\n    var noOptionsMessage = context.attrs['onUpdate:noOptionsMessage'] || 'No options available';\n    var selectOption = function selectOption(index) {\n      selectedIndex.value = index;\n      isOpened.value = false;\n      context.emit('changeVocabulary', props.options[index].vocab);\n      context.emit('select', $t(props.options[index].value)); // path\n    };\n\n    var handleClick = function handleClick() {\n      console.log('BEFORE: Clicked! isOpened:', isOpened.value);\n      isOpened.value = !isOpened.value;\n      console.log('AFTER: Clicked! isOpened:', isOpened.value);\n    };\n\n    // const isSelected = (index) => selectedIndex.value === index;\n    var isSelected = function isSelected(index) {\n      return selectedIndex.value === index;\n    };\n    var closeDropDown = function closeDropDown() {\n      isOpened.value = false;\n    };\n    return {\n      isOpened: isOpened,\n      noOptionsMessage: noOptionsMessage,\n      count: count,\n      selectOption: selectOption,\n      isSelected: isSelected,\n      closeDropDown: closeDropDown,\n      handleClick: handleClick\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/BasicDropDown.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/BasicDropDown.vue?vue&type=style&index=0&id=eafbc960&scoped=true&lang=css\nvar BasicDropDownvue_type_style_index_0_id_eafbc960_scoped_true_lang_css = __webpack_require__(1199);\n;// CONCATENATED MODULE: ./src/components/form/BasicDropDown.vue?vue&type=style&index=0&id=eafbc960&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/BasicDropDown.vue\n\n\n\n\n;\n\n\nconst BasicDropDown_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(BasicDropDownvue_type_script_lang_js, [['render',BasicDropDownvue_type_template_id_eafbc960_scoped_true_render],['__scopeId',\"data-v-eafbc960\"]])\n\n/* harmony default export */ var BasicDropDown = (BasicDropDown_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchInput.vue?vue&type=template&id=e062b0ac&scoped=true\n\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-e062b0ac\"), n = n(), _popScopeId(), n;\n};\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_1 = [\"for\"];\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_2 = {\n  key: 0\n};\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_3 = {\n  key: 0\n};\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_4 = [\"href\"];\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_5 = {\n  key: 1\n};\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_6 = [\"href\"];\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_7 = {\n  key: 2\n};\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_8 = [\"href\"];\nvar SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_9 = {\n  class: \"input-container\"\n};\nvar _hoisted_10 = {\n  class: \"auto-complete\"\n};\nfunction SearchInputvue_type_template_id_e062b0ac_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_icon_cross = resolveComponent(\"icon-cross\");\n  var _component_svg_icon = resolveComponent(\"svg-icon\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"label\", {\n    for: $props.label.for\n  }, toDisplayString($props.label.text), 9 /* TEXT, PROPS */, SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_1), $setup.searchResult && $setup.searchResult.uri.length > 0 && $setup.searchString.toLowerCase() === $setup.searchResult.prefLabel.toLowerCase() ? (openBlock(), createElementBlock(\"div\", SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_2, [$setup.searchResult.vocab === 'yse' ? (openBlock(), createElementBlock(\"div\", SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_3, [createBaseVNode(\"p\", null, [createTextVNode(toDisplayString(_ctx.$t('new.common.ifyse1')) + \" \", 1 /* TEXT */), createBaseVNode(\"strong\", null, [createBaseVNode(\"a\", {\n    target: \"_blank\",\n    href: $setup.searchResult.uri\n  }, toDisplayString($setup.searchResult.lang === $props.language ? $setup.searchResult.prefLabel : ''), 9 /* TEXT, PROPS */, SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_4)]), createTextVNode(\" \" + toDisplayString(_ctx.$t('new.common.ifyse2')), 1 /* TEXT */)])])) : createCommentVNode(\"v-if\", true), $setup.searchResult.vocab === 'yso' ? (openBlock(), createElementBlock(\"div\", SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_5, [createBaseVNode(\"p\", null, [createTextVNode(toDisplayString(_ctx.$t('new.common.ifyso')) + \" \", 1 /* TEXT */), createBaseVNode(\"strong\", null, [createBaseVNode(\"a\", {\n    target: \"_blank\",\n    href: $setup.searchResult.uri\n  }, toDisplayString($setup.searchResult.lang === $props.language ? $setup.searchResult.prefLabel : ''), 9 /* TEXT, PROPS */, SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_6)])])])) : createCommentVNode(\"v-if\", true), $setup.searchResult.vocab === 'yso-paikat' ? (openBlock(), createElementBlock(\"div\", SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_7, [createBaseVNode(\"p\", null, [createTextVNode(toDisplayString(_ctx.$t('new.common.ifysopaikat')) + \" \", 1 /* TEXT */), createBaseVNode(\"strong\", null, [createBaseVNode(\"a\", {\n    target: \"_blank\",\n    href: $setup.searchResult.uri\n  }, toDisplayString($setup.searchResult.lang === $props.language ? $setup.searchResult.prefLabel : ''), 9 /* TEXT, PROPS */, SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_8)])])])) : createCommentVNode(\"v-if\", true)])) : createCommentVNode(\"v-if\", true), createBaseVNode(\"div\", SearchInputvue_type_template_id_e062b0ac_scoped_true_hoisted_9, [createBaseVNode(\"div\", _hoisted_10, [withDirectives(createBaseVNode(\"input\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $setup.searchString = $event;\n    }),\n    class: \"auto-complete-input\",\n    type: \"text\"\n  }, null, 512 /* NEED_PATCH */), [[vModelText, $setup.searchString, void 0, {\n    trim: true\n  }]]), createBaseVNode(\"div\", {\n    onClick: _cache[1] || (_cache[1] = function ($event) {\n      return $setup.searchString = '';\n    }),\n    class: \"clear-input\"\n  }, [$setup.searchString.length > 0 ? (openBlock(), createBlock(_component_svg_icon, {\n    key: 0,\n    \"icon-name\": \"cross\"\n  }, {\n    default: withCtx(function () {\n      return [runtime_core_esm_bundler_createVNode(_component_icon_cross)];\n    }),\n    _: 1 /* STABLE */\n  })) : createCommentVNode(\"v-if\", true)])])])]);\n}\n;// CONCATENATED MODULE: ./src/components/form/SearchInput.vue?vue&type=template&id=e062b0ac&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/icons/IconCross.vue?vue&type=template&id=66f843c2\n\nvar IconCrossvue_type_template_id_66f843c2_hoisted_1 = {\n  \"stroke-width\": \"2\"\n};\nvar IconCrossvue_type_template_id_66f843c2_hoisted_2 = /*#__PURE__*/createBaseVNode(\"path\", {\n  d: \"M19,5 L5,19\"\n}, null, -1 /* HOISTED */);\nvar IconCrossvue_type_template_id_66f843c2_hoisted_3 = /*#__PURE__*/createBaseVNode(\"path\", {\n  d: \"M19,5 L5,19\",\n  transform: \"translate(12.000000, 12.000000) scale(-1, 1) translate(-12.000000, -12.000000)\"\n}, null, -1 /* HOISTED */);\n\nfunction IconCrossvue_type_template_id_66f843c2_render(_ctx, _cache) {\n  return openBlock(), createElementBlock(\"g\", IconCrossvue_type_template_id_66f843c2_hoisted_1, [IconCrossvue_type_template_id_66f843c2_hoisted_2, createCommentVNode(\" eslint-disable-next-line \"), IconCrossvue_type_template_id_66f843c2_hoisted_3]);\n}\n;// CONCATENATED MODULE: ./src/components/icons/IconCross.vue?vue&type=template&id=66f843c2\n\n;// CONCATENATED MODULE: ./src/components/icons/IconCross.vue\n\nconst IconCross_script = {}\n\n;\nconst IconCross_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(IconCross_script, [['render',IconCrossvue_type_template_id_66f843c2_render]])\n\n/* harmony default export */ var IconCross = (IconCross_exports_);\n// EXTERNAL MODULE: ./node_modules/axios/index.js\nvar axios = __webpack_require__(9669);\nvar axios_default = /*#__PURE__*/__webpack_require__.n(axios);\n// EXTERNAL MODULE: ./node_modules/lodash/debounce.js\nvar debounce = __webpack_require__(3279);\nvar debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchInput.vue?vue&type=script&lang=js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n// import { directive as onClickaway } from 'vue-clickaway';\n// import { onClickaway } from \"vue3-click-away\";\n\n\n/* harmony default export */ var SearchInputvue_type_script_lang_js = ({\n  components: {\n    SvgIcon: SvgIcon,\n    IconCross: IconCross,\n    IconCheck: IconCheck\n  },\n  props: {\n    values: Array,\n    vocabulary: String,\n    label: Object,\n    // vocabulary: String,\n    language: String,\n    conceptType: String\n  },\n  setup: function setup(props, context) {\n    var $t = inject('$t');\n    var searchString = reactivity_esm_bundler_ref('');\n    var searchResult = reactivity_esm_bundler_ref(null);\n    watch(searchString, function () {\n      searchLabel();\n    });\n    var searchLabel = debounce_default()(function () {\n      if (searchString.value.length >= 2) {\n        handleResult(checkCapitalization(searchString.value));\n      } else {\n        context.emit('input', searchString.value);\n      }\n    }, 1500);\n    var handleResult = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputValue) {\n        var vocs, i, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              vocs = [\"yso-paikat\", \"yso\", \"yse\"];\n              i = 0;\n            case 2:\n              if (!(i < vocs.length)) {\n                _context.next = 14;\n                break;\n              }\n              _context.next = 5;\n              return axios_default()({\n                method: 'get',\n                url: 'https://api.finto.fi/rest/v1/search',\n                params: {\n                  vocab: vocs[i],\n                  lang: props.language,\n                  query: inputValue\n                }\n              }).catch(function (error) {\n                return console.log(error);\n              });\n            case 5:\n              response = _context.sent;\n              // For the future: this is assigned only if the term is found and is null otherwise\n              searchResult.value = response.data.results[0];\n              context.emit('input', searchString.value);\n              if (!searchResult.value) {\n                _context.next = 11;\n                break;\n              }\n              context.emit('input', '');\n              return _context.abrupt(\"break\", 14);\n            case 11:\n              i++;\n              _context.next = 2;\n              break;\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function handleResult(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var capitalizeFirstLetter = function capitalizeFirstLetter(string) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    };\n    var checkCapitalization = function checkCapitalization(inputValue) {\n      if (inputValue && props.vocabulary === $t('new.common.places')) {\n        return inputValue.charAt(0).toUpperCase() + inputValue.substr(1);\n      }\n      return inputValue;\n    };\n    return {\n      searchLabel: searchLabel,\n      searchString: searchString,\n      searchResult: searchResult,\n      capitalizeFirstLetter: capitalizeFirstLetter,\n      checkCapitalization: checkCapitalization,\n      handleResult: handleResult\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/SearchInput.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchInput.vue?vue&type=style&index=0&id=e062b0ac&scoped=true&lang=css\nvar SearchInputvue_type_style_index_0_id_e062b0ac_scoped_true_lang_css = __webpack_require__(2305);\n;// CONCATENATED MODULE: ./src/components/form/SearchInput.vue?vue&type=style&index=0&id=e062b0ac&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/SearchInput.vue\n\n\n\n\n;\n\n\nconst SearchInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SearchInputvue_type_script_lang_js, [['render',SearchInputvue_type_template_id_e062b0ac_scoped_true_render],['__scopeId',\"data-v-e062b0ac\"]])\n\n/* harmony default export */ var SearchInput = (SearchInput_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchAutoComplete.vue?vue&type=template&id=7eae7b93&scoped=true\n\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-7eae7b93\"), n = n(), _popScopeId(), n;\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_1 = [\"for\"];\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_2 = {\n  key: 0,\n  class: \"chip-list\"\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_3 = [\"onClick\"];\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_4 = {\n  class: \"input-container\"\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_5 = {\n  class: \"auto-complete\"\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_6 = {\n  key: 0,\n  class: \"drop-down-options\"\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_7 = [\"onClick\"];\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_8 = {\n  key: 1,\n  class: \"drop-down-options empty-options\"\n};\nvar SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_9 = {\n  class: \"option\",\n  style: {\n    \"padding-left\": \"16px\"\n  }\n};\nfunction SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_icon_cross = resolveComponent(\"icon-cross\");\n  var _component_svg_icon = resolveComponent(\"svg-icon\");\n  var _directive_on_clickaway = resolveDirective(\"on-clickaway\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"label\", {\n    for: $props.label.for\n  }, toDisplayString($props.label.text), 9 /* TEXT, PROPS */, SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_1), $setup.selectedOptions && $setup.selectedOptions.length > 0 ? (openBlock(), createElementBlock(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_2, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($setup.selectedOptions, function (option) {\n    return openBlock(), createElementBlock(\"div\", {\n      onClick: function onClick($event) {\n        return $setup.removeLabelSelection(option);\n      },\n      key: option.id,\n      class: \"chip\"\n    }, [createBaseVNode(\"span\", null, toDisplayString(option.value), 1 /* TEXT */), runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n      \"icon-name\": \"cross\"\n    }, {\n      default: withCtx(function () {\n        return [runtime_core_esm_bundler_createVNode(_component_icon_cross)];\n      }),\n      _: 1 /* STABLE */\n    })], 8 /* PROPS */, SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_3);\n  }), 128 /* KEYED_FRAGMENT */))])) : createCommentVNode(\"v-if\", true), createBaseVNode(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_4, [createBaseVNode(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_5, [withDirectives(createBaseVNode(\"input\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $setup.searchString = $event;\n    }),\n    class: \"auto-complete-input\",\n    type: \"text\"\n  }, null, 512 /* NEED_PATCH */), [[vModelText, $setup.searchString, void 0, {\n    trim: true\n  }]]), createBaseVNode(\"div\", {\n    onClick: _cache[1] || (_cache[1] = function () {\n      return $setup.clearInput && $setup.clearInput.apply($setup, arguments);\n    }),\n    class: \"clear-input\"\n  }, [$setup.searchString.length > 0 ? (openBlock(), createBlock(_component_svg_icon, {\n    key: 0,\n    \"icon-name\": \"cross\"\n  }, {\n    default: withCtx(function () {\n      return [runtime_core_esm_bundler_createVNode(_component_icon_cross)];\n    }),\n    _: 1 /* STABLE */\n  })) : createCommentVNode(\"v-if\", true)])]), $setup.isOpened && $setup.options.length > 0 ? withDirectives((openBlock(), createElementBlock(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_6, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($setup.options, function (option) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: option.id,\n      onClick: function onClick($event) {\n        return $setup.addLabelSelection(option);\n      },\n      class: \"option\"\n    }, [createBaseVNode(\"p\", null, toDisplayString(option.prefLabel), 1 /* TEXT */)], 8 /* PROPS */, SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_7);\n  }), 128 /* KEYED_FRAGMENT */))])), [[_directive_on_clickaway, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true), $setup.options.length == 0 && $setup.isOpened ? withDirectives((openBlock(), createElementBlock(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_8, [createBaseVNode(\"div\", SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_hoisted_9, [createBaseVNode(\"span\", null, toDisplayString($setup.noOptionsMessage), 1 /* TEXT */)])])), [[_directive_on_clickaway, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true)])]);\n}\n;// CONCATENATED MODULE: ./src/components/form/SearchAutoComplete.vue?vue&type=template&id=7eae7b93&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchAutoComplete.vue?vue&type=script&lang=js\nfunction SearchAutoCompletevue_type_script_lang_js_typeof(obj) { \"@babel/helpers - typeof\"; return SearchAutoCompletevue_type_script_lang_js_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, SearchAutoCompletevue_type_script_lang_js_typeof(obj); }\nfunction SearchAutoCompletevue_type_script_lang_js_regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ SearchAutoCompletevue_type_script_lang_js_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == SearchAutoCompletevue_type_script_lang_js_typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction SearchAutoCompletevue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction SearchAutoCompletevue_type_script_lang_js_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { SearchAutoCompletevue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { SearchAutoCompletevue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n/* harmony default export */ var SearchAutoCompletevue_type_script_lang_js = ({\n  components: {\n    SvgIcon: SvgIcon,\n    IconCross: IconCross,\n    IconCheck: IconCheck\n  },\n  directives: {\n    onClickaway: directive\n  },\n  props: {\n    values: Array,\n    vocabulary: String,\n    language: String,\n    label: Object,\n    hasUniqueValue: Boolean\n  },\n  setup: function setup(props, context) {\n    var $t = inject('$t');\n    var isOpened = reactivity_esm_bundler_ref(false);\n    var noOptionsMessage = $t('new.common.none'); // Provide the translation key\n    var options = reactivity_esm_bundler_ref([]);\n    var searchString = reactivity_esm_bundler_ref('');\n    var selectedOptions = reactivity_esm_bundler_ref([]);\n    var searchLabel = debounce_default()(function () {\n      if (searchString.value.length >= 3) {\n        fetchResults(checkCapitalization(searchString.value));\n      } else {\n        isOpened.value = false;\n        options.value = [];\n      }\n    }, 200);\n    var fetchResults = /*#__PURE__*/function () {\n      var _ref = SearchAutoCompletevue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SearchAutoCompletevue_type_script_lang_js_regeneratorRuntime().mark(function _callee(inputValue) {\n        var response;\n        return SearchAutoCompletevue_type_script_lang_js_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return axios_default().get('https://api.finto.fi/rest/v1/search', {\n                params: {\n                  vocab: props.vocabulary,\n                  lang: props.language,\n                  query: inputValue + '*'\n                }\n              });\n            case 3:\n              response = _context.sent;\n              options.value = response.data.results;\n              isOpened.value = true;\n              _context.next = 11;\n              break;\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](0);\n              console.error(_context.t0);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 8]]);\n      }));\n      return function fetchResults(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var checkCapitalization = function checkCapitalization(inputValue) {\n      if (inputValue && props.vocabulary === 'new.common.places') {\n        return inputValue.charAt(0).toUpperCase() + inputValue.substring(1);\n      }\n      return inputValue;\n    };\n    var addLabelSelection = function addLabelSelection(option) {\n      isOpened.value = false;\n      var o = {\n        value: option.prefLabel,\n        uri: option.uri\n      };\n      if (props.hasUniqueValue) {\n        selectedOptions.value = [];\n      }\n      if (!selectedOptions.value.some(function (item) {\n        return item.value === o.value;\n      })) {\n        selectedOptions.value.push(o);\n      }\n      searchString.value = '';\n      context.emit('update:selectedOptions', selectedOptions.value);\n    };\n    var removeLabelSelection = function removeLabelSelection(option) {\n      var index = selectedOptions.value.findIndex(function (item) {\n        return item.uri === option.uri;\n      });\n      if (index >= 0) {\n        selectedOptions.value.splice(index, 1);\n      }\n      context.emit('update:selectedOptions', selectedOptions.value); // Emit the event\n    };\n\n    var closeDropDown = function closeDropDown() {\n      isOpened.value = false;\n    };\n    var clearInput = function clearInput() {\n      searchString.value = '';\n    };\n    watch(searchString, searchLabel);\n    runtime_core_esm_bundler_onMounted(function () {\n      // Initialize data or perform actions after initial render\n    });\n    return {\n      isOpened: isOpened,\n      noOptionsMessage: noOptionsMessage,\n      options: options,\n      searchString: searchString,\n      selectedOptions: selectedOptions,\n      addLabelSelection: addLabelSelection,\n      removeLabelSelection: removeLabelSelection,\n      closeDropDown: closeDropDown,\n      clearInput: clearInput\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/SearchAutoComplete.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SearchAutoComplete.vue?vue&type=style&index=0&id=7eae7b93&scoped=true&lang=css\nvar SearchAutoCompletevue_type_style_index_0_id_7eae7b93_scoped_true_lang_css = __webpack_require__(8618);\n;// CONCATENATED MODULE: ./src/components/form/SearchAutoComplete.vue?vue&type=style&index=0&id=7eae7b93&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/SearchAutoComplete.vue\n\n\n\n\n;\n\n\nconst SearchAutoComplete_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SearchAutoCompletevue_type_script_lang_js, [['render',SearchAutoCompletevue_type_template_id_7eae7b93_scoped_true_render],['__scopeId',\"data-v-7eae7b93\"]])\n\n/* harmony default export */ var SearchAutoComplete = (SearchAutoComplete_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/BasicInput.vue?vue&type=script&setup=true&lang=js\n\nvar BasicInputvue_type_script_setup_true_lang_js_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-6c396249\"), n = n(), _popScopeId(), n;\n};\nvar BasicInputvue_type_script_setup_true_lang_js_hoisted_1 = {\n  class: \"input-container\"\n};\nvar BasicInputvue_type_script_setup_true_lang_js_hoisted_2 = [\"for\"];\nvar BasicInputvue_type_script_setup_true_lang_js_hoisted_3 = [\"value\"];\nvar BasicInputvue_type_script_setup_true_lang_js_hoisted_4 = [\"value\"];\n/* harmony default export */ var BasicInputvue_type_script_setup_true_lang_js = ({\n  name: 'BasicInput',\n  props: {\n    value: String,\n    label: {\n      type: Object,\n      required: true,\n      default: function _default() {\n        return {\n          text: '',\n          for: ''\n        };\n      }\n    },\n    isTextArea: Boolean\n  },\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var emitEvent = function emitEvent(eventName, payload) {\n      emit(eventName, payload);\n    };\n    expose({\n      emitEvent: emitEvent\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", BasicInputvue_type_script_setup_true_lang_js_hoisted_1, [createBaseVNode(\"label\", {\n        for: __props.label.for\n      }, toDisplayString(__props.label.text), 9 /* TEXT, PROPS */, BasicInputvue_type_script_setup_true_lang_js_hoisted_2), !__props.isTextArea ? (openBlock(), createElementBlock(\"input\", {\n        key: 0,\n        value: __props.value,\n        onInput: _cache[0] || (_cache[0] = function ($event) {\n          return emitEvent('input:basic', $event.target.value);\n        }),\n        type: \"text\"\n      }, null, 40 /* PROPS, HYDRATE_EVENTS */, BasicInputvue_type_script_setup_true_lang_js_hoisted_3)) : createCommentVNode(\"v-if\", true), __props.isTextArea ? (openBlock(), createElementBlock(\"textarea\", {\n        key: 1,\n        value: __props.value,\n        onInput: _cache[1] || (_cache[1] = function ($event) {\n          return emitEvent('input:basic', $event.target.value);\n        }),\n        rows: \"3\"\n      }, \"\\n    \", 40 /* PROPS, HYDRATE_EVENTS */, BasicInputvue_type_script_setup_true_lang_js_hoisted_4)) : createCommentVNode(\"v-if\", true)]);\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/BasicInput.vue?vue&type=script&setup=true&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/BasicInput.vue?vue&type=style&index=0&id=6c396249&scoped=true&lang=css\nvar BasicInputvue_type_style_index_0_id_6c396249_scoped_true_lang_css = __webpack_require__(7173);\n;// CONCATENATED MODULE: ./src/components/form/BasicInput.vue?vue&type=style&index=0&id=6c396249&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/BasicInput.vue\n\n\n\n;\n\n\nconst BasicInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(BasicInputvue_type_script_setup_true_lang_js, [['__scopeId',\"data-v-6c396249\"]])\n\n/* harmony default export */ var BasicInput = (BasicInput_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/TheMultipleBasicInput.vue?vue&type=template&id=438acc87&scoped=true\n\nvar TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-438acc87\"), n = n(), _popScopeId(), n;\n};\nvar TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_1 = {\n  class: \"input-container\"\n};\nvar TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_2 = [\"for\"];\nvar TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_3 = [\"onUpdate:modelValue\", \"onInput\"];\nfunction TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_1, [createBaseVNode(\"label\", {\n    for: $props.label.for\n  }, toDisplayString($props.label.text), 9 /* TEXT, PROPS */, TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_2), (openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($props.values, function (item, i) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: item.id,\n      class: \"inputs\"\n    }, [withDirectives(createBaseVNode(\"input\", {\n      \"onUpdate:modelValue\": function onUpdateModelValue($event) {\n        return item.value = $event;\n      },\n      onInput: function onInput($event) {\n        return $setup.handleInput($event.target.value, i);\n      },\n      type: \"text\"\n    }, null, 40 /* PROPS, HYDRATE_EVENTS */, TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_hoisted_3), [[vModelText, item.value]])]);\n  }), 128 /* KEYED_FRAGMENT */))]);\n}\n;// CONCATENATED MODULE: ./src/components/form/TheMultipleBasicInput.vue?vue&type=template&id=438acc87&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/TheMultipleBasicInput.vue?vue&type=script&lang=js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/* harmony default export */ var TheMultipleBasicInputvue_type_script_lang_js = ({\n  props: {\n    values: Array,\n    label: {\n      text: String,\n      for: String\n    }\n  },\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var handleInput = function handleInput(inputValue, index) {\n      if (index === props.values.length - 1 && inputValue !== '') {\n        props.values.push({\n          value: '',\n          isTouched: false\n        });\n      }\n      emit('update:values', _toConsumableArray(props.values));\n    };\n    return {\n      handleInput: handleInput\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/TheMultipleBasicInput.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/TheMultipleBasicInput.vue?vue&type=style&index=0&id=438acc87&scoped=true&lang=css\nvar TheMultipleBasicInputvue_type_style_index_0_id_438acc87_scoped_true_lang_css = __webpack_require__(2982);\n;// CONCATENATED MODULE: ./src/components/form/TheMultipleBasicInput.vue?vue&type=style&index=0&id=438acc87&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/TheMultipleBasicInput.vue\n\n\n\n\n;\n\n\nconst TheMultipleBasicInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(TheMultipleBasicInputvue_type_script_lang_js, [['render',TheMultipleBasicInputvue_type_template_id_438acc87_scoped_true_render],['__scopeId',\"data-v-438acc87\"]])\n\n/* harmony default export */ var TheMultipleBasicInput = (TheMultipleBasicInput_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SelectWithChips.vue?vue&type=template&id=e34bb30e&scoped=true\n\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-e34bb30e\"), n = n(), _popScopeId(), n;\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_1 = [\"for\"];\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_2 = {\n  key: 0,\n  class: \"chip-list\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_3 = [\"onClick\"];\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_4 = {\n  class: \"input-container\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_5 = {\n  class: \"select-content\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_6 = {\n  key: 0,\n  class: \"selected\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_7 = {\n  key: 0,\n  class: \"drop-down-options empty-options\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_8 = {\n  class: \"option\",\n  style: {\n    \"padding-left\": \"16px\"\n  }\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_9 = {\n  key: 1,\n  class: \"drop-down-options\"\n};\nvar SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_10 = [\"onClick\"];\nfunction SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_icon_cross = resolveComponent(\"icon-cross\");\n  var _component_svg_icon = resolveComponent(\"svg-icon\");\n  var _component_icon_triangle = resolveComponent(\"icon-triangle\");\n  var _directive_on_clickaway = resolveDirective(\"on-clickaway\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"label\", {\n    for: $props.label.for\n  }, toDisplayString($props.label.text), 9 /* TEXT, PROPS */, SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_1), $setup.selectedOptions && $setup.selectedOptions.length > 0 ? (openBlock(), createElementBlock(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_2, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($setup.selectedOptions, function (option) {\n    return openBlock(), createElementBlock(\"div\", {\n      onClick: function onClick($event) {\n        return $setup.removeOption(option);\n      },\n      key: option.id,\n      class: \"chip\"\n    }, [createBaseVNode(\"span\", null, toDisplayString(option.prefLabel), 1 /* TEXT */), runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n      \"icon-name\": \"cross\"\n    }, {\n      default: withCtx(function () {\n        return [runtime_core_esm_bundler_createVNode(_component_icon_cross)];\n      }),\n      _: 1 /* STABLE */\n    })], 8 /* PROPS */, SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_3);\n  }), 128 /* KEYED_FRAGMENT */))])) : createCommentVNode(\"v-if\", true), createBaseVNode(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_4, [createBaseVNode(\"div\", {\n    onClick: _cache[0] || (_cache[0] = function ($event) {\n      return $setup.isOpened = !$setup.isOpened;\n    }),\n    class: normalizeClass([$setup.isOpened ? 'opened' : '', 'select-button'])\n  }, [createBaseVNode(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_5, [$props.value && $props.value.length > 0 ? (openBlock(), createElementBlock(\"span\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_6, toDisplayString($props.value), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true)]), runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n    \"icon-name\": \"triangle\"\n  }, {\n    default: withCtx(function () {\n      return [runtime_core_esm_bundler_createVNode(_component_icon_triangle)];\n    }),\n    _: 1 /* STABLE */\n  })], 2 /* CLASS */), $setup.isOpened && $setup.selectableOptions.length === 0 ? withDirectives((openBlock(), createElementBlock(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_7, [createBaseVNode(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_8, [createBaseVNode(\"span\", null, toDisplayString($setup.noOptionsMessage), 1 /* TEXT */)])])), [[_directive_on_clickaway, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true), $setup.isOpened && $setup.selectableOptions.length > 0 ? withDirectives((openBlock(), createElementBlock(\"div\", SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_9, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList($setup.selectableOptions, function (option) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: option.id,\n      onClick: function onClick($event) {\n        return $setup.selectOption(option);\n      },\n      class: \"option\"\n    }, [createBaseVNode(\"p\", null, toDisplayString(option.prefLabel), 1 /* TEXT */)], 8 /* PROPS */, SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_hoisted_10);\n  }), 128 /* KEYED_FRAGMENT */))])), [[_directive_on_clickaway, $setup.closeDropDown]]) : createCommentVNode(\"v-if\", true)])]);\n}\n;// CONCATENATED MODULE: ./src/components/form/SelectWithChips.vue?vue&type=template&id=e34bb30e&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SelectWithChips.vue?vue&type=script&lang=js\n\n\n\n\n // almost working\n\n/* harmony default export */ var SelectWithChipsvue_type_script_lang_js = ({\n  components: {\n    SvgIcon: SvgIcon,\n    IconTriangle: IconTriangle,\n    IconCross: IconCross,\n    IconCheck: IconCheck\n  },\n  directives: {\n    onClickaway: directive\n  },\n  props: {\n    value: String,\n    options: Array,\n    label: Object\n  },\n  setup: function setup(props, context) {\n    var $t = inject('$t');\n    var isOpened = reactivity_esm_bundler_ref(false);\n    var noOptionsMessage = reactivity_esm_bundler_ref($t('new.groups.none'));\n    var selectableOptions = reactivity_esm_bundler_ref([]);\n    var selectedOptions = reactivity_esm_bundler_ref([]);\n    runtime_core_esm_bundler_onMounted(function () {\n      selectableOptions.value = props.options;\n    });\n    var selectOption = function selectOption(option) {\n      selectedOptions.value.push(option);\n      // if (selectableOptions && selectableOptions.length > 0) {\n      if (selectableOptions) {\n        selectableOptions.value.splice(findOptionIndex(option, selectableOptions.value), 1);\n      }\n      isOpened.value = false;\n      context.emit('select', selectedOptions);\n    };\n    var removeOption = function removeOption(option) {\n      var index = selectedOptions.value.findIndex(function (item) {\n        return item.id === option.id;\n      });\n      if (index !== -1) {\n        selectableOptions.value.push(selectedOptions.value[index]);\n        selectedOptions.value.splice(index, 1);\n      }\n      context.emit('select', selectedOptions);\n    };\n    var findOptionIndex = function findOptionIndex(option, optionList) {\n      return optionList.indexOf(option);\n    };\n    var closeDropDown = function closeDropDown() {\n      isOpened.value = false;\n    };\n    return {\n      isOpened: isOpened,\n      noOptionsMessage: noOptionsMessage,\n      selectableOptions: selectableOptions,\n      selectedOptions: selectedOptions,\n      // onClickAwayDirective,\n      selectOption: selectOption,\n      removeOption: removeOption,\n      closeDropDown: closeDropDown\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/SelectWithChips.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/SelectWithChips.vue?vue&type=style&index=0&id=e34bb30e&scoped=true&lang=css\nvar SelectWithChipsvue_type_style_index_0_id_e34bb30e_scoped_true_lang_css = __webpack_require__(7344);\n;// CONCATENATED MODULE: ./src/components/form/SelectWithChips.vue?vue&type=style&index=0&id=e34bb30e&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/SelectWithChips.vue\n\n\n\n\n;\n\n\nconst SelectWithChips_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SelectWithChipsvue_type_script_lang_js, [['render',SelectWithChipsvue_type_template_id_e34bb30e_scoped_true_render],['__scopeId',\"data-v-e34bb30e\"]])\n\n/* harmony default export */ var SelectWithChips = (SelectWithChips_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/TheExactMatchesInput.vue?vue&type=script&setup=true&lang=js\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_toConsumableArray(arr) { return TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayWithoutHoles(arr) || TheExactMatchesInputvue_type_script_setup_true_lang_js_iterableToArray(arr) || TheExactMatchesInputvue_type_script_setup_true_lang_js_unsupportedIterableToArray(arr) || TheExactMatchesInputvue_type_script_setup_true_lang_js_nonIterableSpread(); }\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayLikeToArray(o, minLen); }\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayLikeToArray(arr); }\nfunction TheExactMatchesInputvue_type_script_setup_true_lang_js_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-3f1c254f\"), n = n(), _popScopeId(), n;\n};\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_1 = {\n  class: \"inputs-container\"\n};\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_2 = [\"for\"];\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_3 = {\n  key: 0\n};\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_4 = [\"value\", \"onInput\", \"placeholder\"];\nvar TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_5 = [\"value\", \"onInput\", \"placeholder\"];\n/* harmony default export */ var TheExactMatchesInputvue_type_script_setup_true_lang_js = ({\n  name: 'TheExactMatchesInput',\n  props: {\n    values: Array,\n    label: {\n      text: String,\n      for: String\n    }\n  },\n  setup: function setup(__props, _ref) {\n    var emit = _ref.emit;\n    var props = __props;\n    var handleVocabInput = function handleVocabInput(inputVocab, index) {\n      var updatedValues = TheExactMatchesInputvue_type_script_setup_true_lang_js_toConsumableArray(props.values);\n      if (!props.values[index].isTouched) {\n        updatedValues.push({\n          vocab: '',\n          value: '',\n          isTouched: false\n        });\n      }\n      updatedValues[index].vocab = inputVocab;\n      updatedValues[index].isTouched = true;\n      emit('inputexm', updatedValues);\n    };\n    var handleValueInput = function handleValueInput(inputValue, index) {\n      var updatedValues = TheExactMatchesInputvue_type_script_setup_true_lang_js_toConsumableArray(props.values);\n      if (!props.values[index].isTouched) {\n        updatedValues.push({\n          vocab: '',\n          value: '',\n          isTouched: false\n        });\n      }\n      updatedValues[index].value = inputValue;\n      updatedValues[index].isTouched = true;\n      emit('inputexm', updatedValues);\n    };\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_1, [createBaseVNode(\"label\", {\n        for: __props.label.for\n      }, toDisplayString(__props.label.text), 9 /* TEXT, PROPS */, TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_2), __props.values && __props.values.length > 0 ? (openBlock(), createElementBlock(\"div\", TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_3, [(openBlock(true), createElementBlock(runtime_core_esm_bundler_Fragment, null, renderList(__props.values, function (item, i) {\n        return openBlock(), createElementBlock(\"div\", {\n          key: item.id,\n          class: \"input-pair\"\n        }, [createBaseVNode(\"input\", {\n          value: item.vocab,\n          onInput: function onInput($event) {\n            return handleVocabInput($event.target.value, i);\n          },\n          placeholder: _ctx.$t('new.exactMatches.vocab'),\n          type: \"text\"\n        }, null, 40 /* PROPS, HYDRATE_EVENTS */, TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_4), createBaseVNode(\"input\", {\n          value: item.value,\n          onInput: function onInput($event) {\n            return handleValueInput($event.target.value, i);\n          },\n          placeholder: _ctx.$t('new.exactMatches.uri'),\n          type: \"text\"\n        }, null, 40 /* PROPS, HYDRATE_EVENTS */, TheExactMatchesInputvue_type_script_setup_true_lang_js_hoisted_5)]);\n      }), 128 /* KEYED_FRAGMENT */))])) : createCommentVNode(\"v-if\", true)]);\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/form/TheExactMatchesInput.vue?vue&type=script&setup=true&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/form/TheExactMatchesInput.vue?vue&type=style&index=0&id=3f1c254f&scoped=true&lang=css\nvar TheExactMatchesInputvue_type_style_index_0_id_3f1c254f_scoped_true_lang_css = __webpack_require__(4753);\n;// CONCATENATED MODULE: ./src/components/form/TheExactMatchesInput.vue?vue&type=style&index=0&id=3f1c254f&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/form/TheExactMatchesInput.vue\n\n\n\n;\n\n\nconst TheExactMatchesInput_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(TheExactMatchesInputvue_type_script_setup_true_lang_js, [['__scopeId',\"data-v-3f1c254f\"]])\n\n/* harmony default export */ var TheExactMatchesInput = (TheExactMatchesInput_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/NewSuggestion.vue?vue&type=script&setup=true&lang=js\n\nvar NewSuggestionvue_type_script_setup_true_lang_js_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-39288721\"), n = n(), _popScopeId(), n;\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_1 = {\n  class: \"suggestion-container\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_2 = {\n  class: \"suggestion-header\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_3 = {\n  key: 0\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_4 = {\n  key: 1\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_5 = {\n  class: \"suggestion-form\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_6 = {\n  class: \"form-inputs\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_7 = {\n  key: 0,\n  class: \"error\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_8 = {\n  key: 1\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_9 = {\n  key: 0,\n  class: \"error\"\n};\nvar NewSuggestionvue_type_script_setup_true_lang_js_hoisted_10 = {\n  key: 2\n};\nvar _hoisted_11 = {\n  key: 0,\n  class: \"error\"\n};\nvar _hoisted_12 = {\n  key: 3\n};\nvar _hoisted_13 = {\n  key: 0,\n  class: \"error\"\n};\nvar _hoisted_14 = {\n  key: 4,\n  class: \"error\"\n};\nvar _hoisted_15 = {\n  key: 5,\n  class: \"error\"\n};\nvar _hoisted_16 = {\n  class: \"form-submit\"\n};\n\n\n\n\n\n\n\n\n/* harmony default export */ var NewSuggestionvue_type_script_setup_true_lang_js = ({\n  name: 'NewSuggestion',\n  props: {\n    d: Object,\n    v: Object,\n    conceptTypeIsSelected: Boolean,\n    prefLabelOkay: Boolean,\n    explanationOkay: Boolean,\n    neededForOkay: Boolean,\n    sending: Boolean\n  },\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var vocab = window.vocab;\n    var testLang = reactivity_esm_bundler_ref(window.lang);\n    var emitEvent = function emitEvent(eventName, payload) {\n      emit(eventName, payload);\n    };\n    var handleSelect = function handleSelect(value) {\n      emitEvent('update:conceptType', value);\n      emitEvent('update:conceptTypeIsSelected', value);\n    };\n    var handlePrefLabel = function handlePrefLabel(value) {\n      emitEvent('update:primaryPrefLabel', value);\n      emitEvent('update:prefLabelOkay', value);\n    };\n    var handleExplanation = function handleExplanation(value) {\n      emitEvent('update:explanation', value);\n      emitEvent('update:explanationOkay', value);\n    };\n    var handleNeededFor = function handleNeededFor(value) {\n      emitEvent('update:neededFor', value);\n      emitEvent('update:neededForOkay', value);\n    };\n    var submitForm = function submitForm() {\n      emit('submitForm');\n    };\n    expose({\n      emitEvent: emitEvent,\n      submitForm: submitForm\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_1, [createCommentVNode(\" <button onclick=\\\"navigator.clipboard.writeText(window.location.href)\\\">Kopioi leikepöydälle</button> \"), createBaseVNode(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_2, [unref(vocab) === 'yso' ? (openBlock(), createElementBlock(\"h4\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_3, toDisplayString(_ctx.$t('new.header')), 1 /* TEXT */)) : unref(vocab) === 'yso-paikat' ? (openBlock(), createElementBlock(\"h4\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_4, toDisplayString(_ctx.$t('new.header-geo')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('new.p1')), 1 /* TEXT */), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('new.p2')), 1 /* TEXT */)]), createBaseVNode(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_5, [createBaseVNode(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_6, [runtime_core_esm_bundler_createVNode(BasicDropDown, {\n        value: __props.d.conceptType.value,\n        options: __props.d.conceptType.options,\n        onChangeVocabulary: _cache[0] || (_cache[0] = function ($event) {\n          return _ctx.$emit('update:vocabulary', $event);\n        }),\n        onSelect: _cache[1] || (_cache[1] = function ($event) {\n          return handleSelect($event);\n        }),\n        label: {\n          text: _ctx.$t('new.conceptType.label'),\n          for: _ctx.$t('new.conceptType.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"options\", \"label\"]), !__props.conceptTypeIsSelected && __props.sending ? (openBlock(), createElementBlock(\"p\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_7, toDisplayString(_ctx.$t('new.conceptType.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), _ctx.$i18n.locale === 'fi' ? (openBlock(), createElementBlock(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_8, [runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.primary,\n        conceptType: __props.d.conceptType.value,\n        vocabulary: __props.d.vocabulary,\n        language: 'fi',\n        onInput: _cache[2] || (_cache[2] = function ($event) {\n          return handlePrefLabel($event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.fi.label'),\n          for: _ctx.$t('new.prefLabel.fi.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"conceptType\", \"vocabulary\", \"label\"]), !__props.prefLabelOkay && __props.sending ? (openBlock(), createElementBlock(\"p\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_9, toDisplayString(_ctx.$t('new.prefLabel.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.secondary,\n        conceptType: __props.d.conceptType.value,\n        vocabulary: __props.d.vocabulary,\n        language: 'sv',\n        onInput: _cache[3] || (_cache[3] = function ($event) {\n          return emitEvent('update:secondaryPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.sv.label'),\n          for: _ctx.$t('new.prefLabel.sv.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"conceptType\", \"vocabulary\", \"label\"]), createCommentVNode(\"lisätty 2023-09-18\"), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.prefLabel.en,\n        \"onInput:basic\": _cache[4] || (_cache[4] = function ($event) {\n          return emitEvent('update:enPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.en.label'),\n          for: _ctx.$t('new.prefLabel.en.for')\n        },\n        isTextArea: false\n      }, null, 8 /* PROPS */, [\"value\", \"label\"])])) : createCommentVNode(\"v-if\", true), _ctx.$i18n.locale === 'sv' ? (openBlock(), createElementBlock(\"div\", NewSuggestionvue_type_script_setup_true_lang_js_hoisted_10, [runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.primary,\n        vocabulary: __props.d.vocabulary,\n        conceptType: __props.d.conceptType.value,\n        language: 'sv',\n        onInput: _cache[5] || (_cache[5] = function ($event) {\n          return handlePrefLabel($event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.sv.label'),\n          for: _ctx.$t('new.prefLabel.sv.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"vocabulary\", \"conceptType\", \"label\"]), !__props.prefLabelOkay && __props.sending ? (openBlock(), createElementBlock(\"p\", _hoisted_11, toDisplayString(_ctx.$t('new.prefLabel.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.secondary,\n        vocabulary: __props.d.vocabulary,\n        conceptType: __props.d.conceptType.value,\n        language: 'fi',\n        onInput: _cache[6] || (_cache[6] = function ($event) {\n          return emitEvent('update:secondaryPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.fi.label'),\n          for: _ctx.$t('new.prefLabel.fi.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"vocabulary\", \"conceptType\", \"label\"]), createCommentVNode(\"lisätty 2023-09-18\"), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.prefLabel.en,\n        \"onInput:basic\": _cache[7] || (_cache[7] = function ($event) {\n          return emitEvent('update:enPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.en.label'),\n          for: _ctx.$t('new.prefLabel.en.for')\n        },\n        isTextArea: false\n      }, null, 8 /* PROPS */, [\"value\", \"label\"])])) : createCommentVNode(\"v-if\", true), _ctx.$i18n.locale === 'se' || _ctx.$i18n.locale === 'en' ? (openBlock(), createElementBlock(\"div\", _hoisted_12, [runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.prefLabel.en,\n        \"onInput:basic\": _cache[8] || (_cache[8] = function ($event) {\n          return emitEvent('update:enPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.en.label'),\n          for: _ctx.$t('new.prefLabel.en.for')\n        },\n        isTextArea: false\n      }, null, 8 /* PROPS */, [\"value\", \"label\"]), runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.primary,\n        conceptType: __props.d.conceptType.value,\n        vocabulary: __props.d.vocabulary,\n        language: 'fi',\n        onInput: _cache[9] || (_cache[9] = function ($event) {\n          return handlePrefLabel($event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.fi.label'),\n          for: _ctx.$t('new.prefLabel.fi.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"conceptType\", \"vocabulary\", \"label\"]), !__props.prefLabelOkay && __props.sending ? (openBlock(), createElementBlock(\"p\", _hoisted_13, toDisplayString(_ctx.$t('new.prefLabel.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(SearchInput, {\n        value: __props.d.prefLabel.secondary,\n        conceptType: __props.d.conceptType.value,\n        vocabulary: __props.d.vocabulary,\n        language: 'sv',\n        onInput: _cache[10] || (_cache[10] = function ($event) {\n          return emitEvent('update:secondaryPrefLabel', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.prefLabel.sv.label'),\n          for: _ctx.$t('new.prefLabel.sv.for')\n        }\n      }, null, 8 /* PROPS */, [\"value\", \"conceptType\", \"vocabulary\", \"label\"])])) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(TheMultipleBasicInput, {\n        values: __props.d.altLabels,\n        onInputMulti: _cache[11] || (_cache[11] = function ($event) {\n          return emitEvent('update:altLabels', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.altLabels.label'),\n          for: _ctx.$t('new.altLabels.for')\n        }\n      }, null, 8 /* PROPS */, [\"values\", \"label\"]), runtime_core_esm_bundler_createVNode(SearchAutoComplete, {\n        values: __props.d.broaderLabels,\n        vocabulary: __props.d.vocabulary,\n        language: _ctx.$i18n.locale,\n        \"onUpdate:selectedOptions\": _cache[12] || (_cache[12] = function ($event) {\n          return emitEvent('update:broaderLabels', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.broaderLabels.label'),\n          for: _ctx.$t('new.broaderLabels.for')\n        },\n        hasUniqueValue: false\n      }, null, 8 /* PROPS */, [\"values\", \"vocabulary\", \"language\", \"label\"]), runtime_core_esm_bundler_createVNode(SearchAutoComplete, {\n        values: __props.d.narrowerLabels,\n        vocabulary: __props.d.vocabulary,\n        language: _ctx.$i18n.locale,\n        \"onUpdate:selectedOptions\": _cache[13] || (_cache[13] = function ($event) {\n          return emitEvent('update:narrowerLabels', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.narrowerLabels.label'),\n          for: _ctx.$t('new.narrowerLabels.for')\n        },\n        hasUniqueValue: false\n      }, null, 8 /* PROPS */, [\"values\", \"vocabulary\", \"language\", \"label\"]), runtime_core_esm_bundler_createVNode(SearchAutoComplete, {\n        values: __props.d.relatedLabels,\n        vocabulary: __props.d.vocabulary,\n        language: _ctx.$i18n.locale,\n        \"onUpdate:selectedOptions\": _cache[14] || (_cache[14] = function ($event) {\n          return emitEvent('update:relatedLabels', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.relatedLabels.label'),\n          for: _ctx.$t('new.relatedLabels.for')\n        },\n        hasUniqueValue: false\n      }, null, 8 /* PROPS */, [\"values\", \"vocabulary\", \"language\", \"label\"]), createCommentVNode(\" :class=\\\"{'hidden': d.vocabulary === $t('new.common.places')}\\\" \"), runtime_core_esm_bundler_createVNode(SelectWithChips, {\n        class: normalizeClass({\n          'hidden': __props.d.vocabulary === 'yso-paikat'\n        }),\n        value: _ctx.$t('new.groups.placeholder'),\n        options: __props.d.groups.allGroups,\n        onSelect: _cache[15] || (_cache[15] = function ($event) {\n          return emitEvent('update:groups', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.groups.label'),\n          for: _ctx.$t('new.groups.for')\n        }\n      }, null, 8 /* PROPS */, [\"class\", \"value\", \"options\", \"label\"]), runtime_core_esm_bundler_createVNode(TheExactMatchesInput, {\n        values: __props.d.exactMatches,\n        onInputexm: _cache[16] || (_cache[16] = function ($event) {\n          return emitEvent('update:exactMatches', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.exactMatches.label'),\n          for: _ctx.$t('new.exactMatches.for')\n        }\n      }, null, 8 /* PROPS */, [\"values\", \"label\"]), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.scopeNote,\n        \"onInput:basic\": _cache[17] || (_cache[17] = function ($event) {\n          return emitEvent('update:scopeNote', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.scopeNote.label'),\n          for: _ctx.$t('new.scopeNote.for')\n        },\n        isTextArea: true\n      }, null, 8 /* PROPS */, [\"value\", \"label\"]), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.explanation,\n        \"onInput:basic\": _cache[18] || (_cache[18] = function ($event) {\n          return handleExplanation($event);\n        }),\n        label: {\n          text: _ctx.$t('new.explanation.label'),\n          for: _ctx.$t('new.explanation.label')\n        },\n        isTextArea: true\n      }, null, 8 /* PROPS */, [\"value\", \"label\"]), !__props.explanationOkay && __props.sending ? (openBlock(), createElementBlock(\"p\", _hoisted_14, toDisplayString(_ctx.$t('new.explanation.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.neededFor,\n        \"onInput:basic\": _cache[19] || (_cache[19] = function ($event) {\n          return handleNeededFor($event);\n        }),\n        label: {\n          text: _ctx.$t('new.neededFor.label'),\n          for: _ctx.$t('new.neededFor.for')\n        },\n        isTextArea: true\n      }, null, 8 /* PROPS */, [\"value\", \"label\"]), !__props.neededForOkay && __props.sending ? (openBlock(), createElementBlock(\"p\", _hoisted_15, toDisplayString(_ctx.$t('new.neededFor.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(BasicInput, {\n        value: __props.d.fromOrg,\n        \"onInput:basic\": _cache[20] || (_cache[20] = function ($event) {\n          return emitEvent('update:fromOrg', $event);\n        }),\n        label: {\n          text: _ctx.$t('new.fromOrg.label'),\n          for: _ctx.$t('new.fromOrg.for')\n        },\n        isTextArea: false\n      }, null, 8 /* PROPS */, [\"value\", \"label\"])]), createBaseVNode(\"div\", _hoisted_16, [createBaseVNode(\"a\", {\n        onClick: _cache[21] || (_cache[21] = function ($event) {\n          return submitForm();\n        })\n      }, toDisplayString(_ctx.$t('new.submit')), 1 /* TEXT */)])])]);\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/NewSuggestion.vue?vue&type=script&setup=true&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/NewSuggestion.vue?vue&type=style&index=0&id=39288721&scoped=true&lang=css\nvar NewSuggestionvue_type_style_index_0_id_39288721_scoped_true_lang_css = __webpack_require__(3675);\n;// CONCATENATED MODULE: ./src/components/NewSuggestion.vue?vue&type=style&index=0&id=39288721&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/NewSuggestion.vue\n\n\n\n;\n\n\nconst NewSuggestion_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(NewSuggestionvue_type_script_setup_true_lang_js, [['__scopeId',\"data-v-39288721\"]])\n\n/* harmony default export */ var NewSuggestion = (NewSuggestion_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/CenteredDialog.vue?vue&type=template&id=8ddfc880&scoped=true\n\nvar CenteredDialogvue_type_template_id_8ddfc880_scoped_true_withScopeId = function _withScopeId(n) {\n  return pushScopeId(\"data-v-8ddfc880\"), n = n(), popScopeId(), n;\n};\nvar CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_1 = {\n  class: \"template\"\n};\nvar CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_2 = /*#__PURE__*/CenteredDialogvue_type_template_id_8ddfc880_scoped_true_withScopeId(function () {\n  return /*#__PURE__*/createBaseVNode(\"div\", {\n    class: \"dialog-overlay\"\n  }, null, -1 /* HOISTED */);\n});\nvar CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_3 = {\n  class: \"dialog-modal\"\n};\nvar CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_4 = {\n  class: \"dialog-content\"\n};\nfunction CenteredDialogvue_type_template_id_8ddfc880_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_icon_cross = resolveComponent(\"icon-cross\");\n  var _component_svg_icon = resolveComponent(\"svg-icon\");\n  return openBlock(), createElementBlock(\"div\", CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_1, [CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_2, createBaseVNode(\"div\", CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_3, [createBaseVNode(\"div\", CenteredDialogvue_type_template_id_8ddfc880_scoped_true_hoisted_4, [createBaseVNode(\"div\", {\n    class: \"dialog-close\",\n    onClick: _cache[0] || (_cache[0] = function () {\n      return $setup.close && $setup.close.apply($setup, arguments);\n    })\n  }, [runtime_core_esm_bundler_createVNode(_component_svg_icon, {\n    \"icon-name\": \"cross\"\n  }, {\n    default: withCtx(function () {\n      return [runtime_core_esm_bundler_createVNode(_component_icon_cross)];\n    }),\n    _: 1 /* STABLE */\n  })]), renderSlot(_ctx.$slots, \"default\", {}, undefined, true)])])]);\n}\n;// CONCATENATED MODULE: ./src/components/common/CenteredDialog.vue?vue&type=template&id=8ddfc880&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/CenteredDialog.vue?vue&type=script&lang=js\n\n\n\n/* harmony default export */ var CenteredDialogvue_type_script_lang_js = ({\n  components: {\n    SvgIcon: SvgIcon,\n    IconCross: IconCross\n  },\n  setup: function setup(_, _ref) {\n    var emit = _ref.emit;\n    var close = function close() {\n      emit('close');\n    };\n    var handleEscKey = function handleEscKey(e) {\n      if (e.keyCode === 27) {\n        close();\n      }\n    };\n    runtime_core_esm_bundler_onMounted(function () {\n      document.addEventListener('keydown', handleEscKey);\n    });\n    onBeforeUnmount(function () {\n      document.removeEventListener('keydown', handleEscKey);\n    });\n    return {\n      close: close\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/common/CenteredDialog.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/CenteredDialog.vue?vue&type=style&index=0&id=8ddfc880&scoped=true&lang=css\nvar CenteredDialogvue_type_style_index_0_id_8ddfc880_scoped_true_lang_css = __webpack_require__(3867);\n;// CONCATENATED MODULE: ./src/components/common/CenteredDialog.vue?vue&type=style&index=0&id=8ddfc880&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/common/CenteredDialog.vue\n\n\n\n\n;\n\n\nconst CenteredDialog_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(CenteredDialogvue_type_script_lang_js, [['render',CenteredDialogvue_type_template_id_8ddfc880_scoped_true_render],['__scopeId',\"data-v-8ddfc880\"]])\n\n/* harmony default export */ var CenteredDialog = (CenteredDialog_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/SuccessMessage.vue?vue&type=template&id=5ab5b3da&scoped=true\n\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-5ab5b3da\"), n = n(), _popScopeId(), n;\n};\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_1 = {\n  key: 0\n};\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_2 = [\"href\"];\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_3 = /*#__PURE__*/createTextVNode(\". \");\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_4 = {\n  key: 1\n};\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_5 = [\"href\"];\nvar SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_6 = /*#__PURE__*/createTextVNode(\". \");\nfunction SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"h2\", null, toDisplayString(_ctx.$t('messages.success.h2')), 1 /* TEXT */), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('messages.success.p_1')), 1 /* TEXT */), !$props.suggestionUrl || $props.suggestionUrl.length === 0 ? (openBlock(), createElementBlock(\"p\", SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_1, [createTextVNode(toDisplayString(_ctx.$t('messages.success.p_2a')) + \" \", 1 /* TEXT */), createBaseVNode(\"a\", {\n    href: $props.url\n  }, toDisplayString(_ctx.$t('messages.success.p_2b')), 9 /* TEXT, PROPS */, SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_2), SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_3])) : createCommentVNode(\"v-if\", true), $props.suggestionUrl && $props.suggestionUrl.length > 0 ? (openBlock(), createElementBlock(\"p\", SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_4, [createTextVNode(toDisplayString(_ctx.$t('messages.success.p_2a')) + \" \", 1 /* TEXT */), createBaseVNode(\"a\", {\n    target: \"_blank\",\n    href: $props.suggestionUrl\n  }, toDisplayString(_ctx.$t('messages.success.p_2b')), 9 /* TEXT, PROPS */, SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_5), SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_hoisted_6])) : createCommentVNode(\"v-if\", true)]);\n}\n;// CONCATENATED MODULE: ./src/components/common/SuccessMessage.vue?vue&type=template&id=5ab5b3da&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/SuccessMessage.vue?vue&type=script&lang=js\n/* harmony default export */ var SuccessMessagevue_type_script_lang_js = ({\n  props: {\n    suggestionUrl: String,\n    url: String\n  }\n});\n;// CONCATENATED MODULE: ./src/components/common/SuccessMessage.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/SuccessMessage.vue?vue&type=style&index=0&id=5ab5b3da&scoped=true&lang=css\nvar SuccessMessagevue_type_style_index_0_id_5ab5b3da_scoped_true_lang_css = __webpack_require__(8130);\n;// CONCATENATED MODULE: ./src/components/common/SuccessMessage.vue?vue&type=style&index=0&id=5ab5b3da&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/common/SuccessMessage.vue\n\n\n\n\n;\n\n\nconst SuccessMessage_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SuccessMessagevue_type_script_lang_js, [['render',SuccessMessagevue_type_template_id_5ab5b3da_scoped_true_render],['__scopeId',\"data-v-5ab5b3da\"]])\n\n/* harmony default export */ var SuccessMessage = (SuccessMessage_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/FailureMessage.vue?vue&type=template&id=bb99f552&scoped=true\n\nfunction FailureMessagevue_type_template_id_bb99f552_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"h2\", null, toDisplayString(_ctx.$t('messages.failed.h2')), 1 /* TEXT */), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('messages.failed.p_1a')), 1 /* TEXT */), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('messages.failed.p_1b')), 1 /* TEXT */)]);\n}\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/FailureMessage.vue?vue&type=script&lang=js\n/* harmony default export */ var FailureMessagevue_type_script_lang_js = ({});\n;// CONCATENATED MODULE: ./src/components/common/FailureMessage.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/common/FailureMessage.vue?vue&type=style&index=0&id=bb99f552&scoped=true&lang=css\nvar FailureMessagevue_type_style_index_0_id_bb99f552_scoped_true_lang_css = __webpack_require__(8565);\n;// CONCATENATED MODULE: ./src/components/common/FailureMessage.vue?vue&type=style&index=0&id=bb99f552&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/common/FailureMessage.vue\n\n\n\n\n;\n\n\nconst FailureMessage_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(FailureMessagevue_type_script_lang_js, [['render',FailureMessagevue_type_template_id_bb99f552_scoped_true_render],['__scopeId',\"data-v-bb99f552\"]])\n\n/* harmony default export */ var FailureMessage = (FailureMessage_exports_);\n// EXTERNAL MODULE: ./src/prx.json\nvar prx = __webpack_require__(3421);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestNewButton.vue?vue&type=script&lang=js\nfunction SuggestNewButtonvue_type_script_lang_js_typeof(obj) { \"@babel/helpers - typeof\"; return SuggestNewButtonvue_type_script_lang_js_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, SuggestNewButtonvue_type_script_lang_js_typeof(obj); }\nfunction SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == SuggestNewButtonvue_type_script_lang_js_typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction SuggestNewButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction SuggestNewButtonvue_type_script_lang_js_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { SuggestNewButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { SuggestNewButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n/* harmony default export */ var SuggestNewButtonvue_type_script_lang_js = (runtime_core_esm_bundler_defineComponent({\n  components: {\n    NewSuggestion: NewSuggestion,\n    CenteredDialog: CenteredDialog,\n    SuccessMessage: SuccessMessage,\n    FailureMessage: FailureMessage\n  },\n  props: {\n    lang: String,\n    vocab: String\n  },\n  setup: function setup(props) {\n    setTimeout(function () {}, 500);\n\n    // Inject the i18n $t function and pageUrl variable\n    var $t = inject('$t');\n    var testi = inject('testi');\n    var pageUrl = inject('pageUrl');\n    var isOpened = reactivity_esm_bundler_ref(false);\n    var showSuccessMessage = reactivity_esm_bundler_ref(false);\n    var showFailureMessage = reactivity_esm_bundler_ref(false);\n    var suggestionUrl = reactivity_esm_bundler_ref('');\n    var conceptTypeIsSelected = reactivity_esm_bundler_ref(false);\n    var prefLabelOkay = reactivity_esm_bundler_ref(false);\n    var explanationOkay = reactivity_esm_bundler_ref(false);\n    var neededForOkay = reactivity_esm_bundler_ref(false);\n    var dataCanBeSentArray = reactivity_esm_bundler_ref([]);\n    var sending = reactivity_esm_bundler_ref(false);\n    var formData = reactive({\n      vocabulary: 'yso',\n      conceptType: {\n        value: '',\n        options: [{\n          value: '',\n          vocab: 'yso'\n        }, {\n          value: '',\n          vocab: 'yso-paikat'\n        }]\n      },\n      prefLabel: {\n        primary: '',\n        secondary: '',\n        fi: {\n          value: ''\n        },\n        sv: {\n          value: ''\n        },\n        en: ''\n      },\n      altLabels: [{\n        value: '',\n        isTouched: false\n      }],\n      broaderLabels: [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }],\n      narrowerLabels: [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }],\n      relatedLabels: [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }],\n      groups: {\n        allGroups: [],\n        selectedGroups: []\n      },\n      exactMatches: [{\n        vocab: '',\n        value: '',\n        isTouched: false\n      }],\n      scopeNote: '',\n      explanation: '',\n      neededFor: '',\n      fromOrg: '',\n      tags: []\n    });\n    watch(function () {\n      return [formData.conceptType.value, formData.conceptType.value.length];\n    }, function (newValues, oldValues) {\n      var conceptTypeLength = newValues[1];\n      if (conceptTypeLength > 0) {\n        conceptTypeIsSelected.value = true;\n        dataCanBeSentArray.value[0] = true;\n      } else {\n        conceptTypeIsSelected.value = false;\n        dataCanBeSentArray.value[0] = false;\n      }\n    }, {\n      deep: true\n    });\n    watch(function () {\n      return [formData.prefLabel.primary, formData.prefLabel.primary.length];\n    }, function (newValues, oldValues) {\n      var primaryLabelLength = newValues[1];\n      if (primaryLabelLength > 2) {\n        prefLabelOkay.value = true;\n        dataCanBeSentArray.value[1] = true;\n      } else {\n        prefLabelOkay.value = false;\n        dataCanBeSentArray.value[1] = false;\n      }\n    }, {\n      deep: true\n    });\n    watch(function () {\n      return [formData.explanation, formData.explanation.length];\n    }, function (newValues, oldValues) {\n      var explanationLength = newValues[1];\n      if (explanationLength > 2) {\n        explanationOkay.value = true;\n        dataCanBeSentArray.value[2] = true;\n      } else {\n        explanationOkay.value = false;\n        dataCanBeSentArray.value[2] = false;\n      }\n    }, {\n      deep: true\n    });\n    watch(function () {\n      return [formData.neededFor, formData.neededFor.length];\n    }, function (newValues, oldValues) {\n      var needdForLength = newValues[1];\n      if (needdForLength > 2) {\n        neededForOkay.value = true;\n        dataCanBeSentArray.value[3] = true;\n      } else {\n        neededForOkay.value = false;\n        dataCanBeSentArray.value[3] = false;\n      }\n    }, {\n      deep: true\n    });\n\n    // Methods\n    var setDropDown = function setDropDown() {\n      formData.conceptType.options[0].value = 'new.common.concept';\n      formData.conceptType.options[1].value = 'new.common.geo';\n    };\n    var addHTTPOrHTTPS = function addHTTPOrHTTPS(str) {\n      if (!/^(http(s?)):\\/\\//.test(str)) {\n        return \"http://\".concat(str);\n      } else {\n        return \"\".concat(str);\n      }\n    };\n    var submitForm = function submitForm() {\n      // $v.$touch();\n      sending.value = true;\n      var countTrueValues = dataCanBeSentArray.value.reduce(function (count, currentValue) {\n        if (currentValue === true) {\n          return count + 1;\n        } else {\n          return count;\n        }\n      }, 0);\n      if (countTrueValues === 4) {\n        sendData();\n      } else {\n        console.log('Data not sent: required data of the form was not provided.');\n      }\n    };\n    var sendData = /*#__PURE__*/function () {\n      var _ref = SuggestNewButtonvue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().mark(function _callee() {\n        var ontTypeInTargetSuggestionSystem, labelsInTargetSuggestionSystem, altTerms, brdLabls, groups, nrrLabls, rltdLabls, exctLabls, data, dataBundle, payload, headers, urlToPrx;\n        return SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              handlePrefLabelLanguages();\n              ontTypeInTargetSuggestionSystem = '';\n              labelsInTargetSuggestionSystem = [];\n              if (formData.vocabulary === 'yso-paikat') {\n                labelsInTargetSuggestionSystem.push('uusi');\n                labelsInTargetSuggestionSystem.push('MAANTIETEELLINEN');\n                ontTypeInTargetSuggestionSystem = 'GEO';\n              } else {\n                labelsInTargetSuggestionSystem.push('uusi');\n                ontTypeInTargetSuggestionSystem = 'CONCEPT';\n              }\n              altTerms = [];\n              formData.altLabels.forEach(function (item) {\n                return item.value !== '' ? altTerms.push(\" \".concat(item.value)) : null;\n              });\n              brdLabls = [];\n              formData.broaderLabels.forEach(function (item) {\n                return item.value !== '' ? brdLabls.push(\" [\".concat(item.value, \"](\").concat(item.uri, \")\")) : null;\n              });\n              groups = [];\n              formData.groups.selectedGroups.forEach(function (item) {\n                return item.prefLabel !== '' ? groups.push(\" [\".concat(item.prefLabel, \"](\").concat(item.uri, \")\")) : null;\n              });\n              nrrLabls = [];\n              formData.narrowerLabels.forEach(function (item) {\n                return item.value !== '' ? nrrLabls.push(\" [\".concat(item.value, \"](\").concat(item.uri, \")\")) : null;\n              });\n              rltdLabls = [];\n              formData.relatedLabels.forEach(function (item) {\n                return item.value !== '' ? rltdLabls.push(\" [\".concat(item.value, \"](\").concat(item.uri, \")\")) : null;\n              });\n              exctLabls = [];\n              formData.exactMatches.forEach(function (item) {\n                return item.value !== '' ? exctLabls.push(\" [\".concat(item.vocab, \"](\").concat(addHTTPOrHTTPS(item.value), \")\")) : null;\n              });\n              data = \"\\n**K\\xE4sitteen tyyppi**\\n\\n\".concat(ontTypeInTargetSuggestionSystem, \"\\n\\n**Ehdotettu termi suomeksi**\\n\\n\").concat(formData.prefLabel.fi.value, \"\\n\\n**Ehdotettu termi ruotsiksi**\\n\\n\").concat(formData.prefLabel.sv.value, \"\\n\\n**Ehdotettu termi englanniksi**\\n\\n\").concat(formData.prefLabel.en, \"\\n\\n**Tarkoitusta t\\xE4sment\\xE4v\\xE4 selite**\\n\\n\").concat(formData.scopeNote, \"\\n\\n**Perustelut ehdotukselle**\\n\\n\").concat(formData.explanation, \"\\n\\n**Ehdotettu yl\\xE4k\\xE4site YSOssa (LT)**\\n\\n\").concat(brdLabls, \"\\n\\n**Ehdotetut temaattiset ryhm\\xE4t**\\n\\n\").concat(groups, \"\\n\\n**Vaihtoehtoiset termit**\\n\\n\").concat(altTerms, \"\\n\\n**Alak\\xE4sitteet (RT)**\\n\\n\").concat(nrrLabls, \"\\n\\n**Assosiatiiviset (RT)**\\n\\n\").concat(rltdLabls, \"\\n\\n**Vastaava k\\xE4site muussa sanastossa**\\n\\n\").concat(exctLabls, \"\\n\\n**Aineisto jonka kuvailussa k\\xE4sitett\\xE4 tarvitaan (esim. nimeke tai URL)**\\n\\n\").concat(formData.neededFor, \"\\n\\n**Ehdottajan organisaatio**\\n\\n\").concat(formData.fromOrg, \"\\n\");\n              dataBundle = {\n                // title: formData.prefLabel.sv.value !== '' ? formData.prefLabel.sv.value : formData.prefLabel.fi.value,\n                title: window.lang === 'sv' ? formData.prefLabel.sv.value : formData.prefLabel.fi.value,\n                body: data,\n                state: 'open',\n                labels: labelsInTargetSuggestionSystem\n              };\n              payload = encodeURIComponent(JSON.stringify(dataBundle)); // console.log(\"payload\", payload)\n              headers = {\n                'Access-Control-Allow-Origin': '*'\n              };\n              urlToPrx = __webpack_require__(3421);\n              _context.next = 23;\n              return axios_default().post(\"\".concat(urlToPrx[0].url, \"?payload=\").concat(payload), {}, {\n                headers: headers\n              }).then(function (response) {\n                // console.log('Response:', response)\n                // toggleSuccessMessage(`https://github.com/Finto-ehdotus/YSE`);\n                toggleSuccessMessage(\"\".concat(response.data.url.replace('/repos', '').replace('api.', '')));\n              }).catch(function (error) {\n                toggleFailureMessage();\n              });\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function sendData() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var toggleSuccessMessage = function toggleSuccessMessage(responseUrl) {\n      if (responseUrl && responseUrl.length > 0) {\n        suggestionUrl.value = responseUrl;\n        showSuccessMessage.value = true;\n      }\n      showSuccessMessage.value = true;\n    };\n    var toggleFailureMessage = function toggleFailureMessage() {\n      showFailureMessage.value = true;\n    };\n    var handlePrefLabelLanguages = function handlePrefLabelLanguages() {\n      formData.prefLabel.fi.value = formData.prefLabel.primary;\n      if (window.lang === 'fi' || window.lang === 'en') {\n        // muutos 2023-09-18 lisättiin en ehto\n        formData.prefLabel.fi.value = formData.prefLabel.primary;\n        formData.prefLabel.sv.value = formData.prefLabel.secondary;\n      } else if (window.lang === 'sv') {\n        formData.prefLabel.sv.value = formData.prefLabel.primary;\n        formData.prefLabel.fi.value = formData.prefLabel.secondary;\n      }\n      // formData.prefLabel.fi.value ? console.log(\"formData.prefLabel.fi.value\", formData.prefLabel.fi.value) : console.log(\"formData.prefLabel.fi.value X\")\n      // formData.prefLabel.sv.value ? console.log(\"formData.prefLabel.sv.value\", formData.prefLabel.sv.value) : console.log(\"formData.prefLabel.sv.value X\")\n    };\n\n    var closeDialog = function closeDialog() {\n      isOpened.value = !isOpened.value;\n      showSuccessMessage.value = false;\n      showFailureMessage.value = false;\n      suggestionUrl.value = '';\n      formData.vocabulary = 'yso';\n      formData.conceptType.value = '';\n      formData.prefLabel.primary = '';\n      formData.prefLabel.secondary = '';\n      formData.prefLabel.fi.value = '';\n      formData.prefLabel.sv.value = '';\n      formData.prefLabel.en = '';\n      formData.altLabels = [{\n        value: '',\n        isTouched: false\n      }];\n      formData.broaderLabels = [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }];\n      formData.narrowerLabels = [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }];\n      formData.relatedLabels = [{\n        value: '',\n        uri: '',\n        isTouched: false\n      }];\n      formData.groups.selectedGroups = [];\n      formData.exactMatches = [{\n        vocab: '',\n        value: '',\n        isTouched: false\n      }];\n      formData.scopeNote = '';\n      formData.explanation = '';\n      formData.neededFor = '';\n      formData.fromOrg = '';\n      setDropDown();\n      // $v.$reset();\n      getGroups();\n      sending.value = false;\n    };\n    var getUrl = /*#__PURE__*/function () {\n      var _ref2 = SuggestNewButtonvue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().mark(function _callee2() {\n        return SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              pageUrl.value = window.location.href;\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function getUrl() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    var getGroups = /*#__PURE__*/function () {\n      var _ref3 = SuggestNewButtonvue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().mark(function _callee3() {\n        return SuggestNewButtonvue_type_script_lang_js_regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return axios_default().get(\"https://api.finto.fi/rest/v1/\".concat(formData.vocabulary, \"/groups\"), {\n                params: {\n                  // lang: props.lang,\n                  lang: window.lang === 'en' ? 'fi' : window.lang\n                }\n              }).then(function (response) {\n                return formData.groups.allGroups = response.data.groups;\n              });\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      return function getGroups() {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    // Lifecycle hooks\n    watchEffect(function () {\n      /*    if (props.lang === 'sv') {\n            // Note: 'this' is not available in the setup function.\n            // Instead, you can use 'props' directly.\n          }*/\n      setDropDown();\n      getGroups();\n    });\n    getGroups();\n\n    // Return the variables and methods you want to expose to the template\n    return {\n      pageUrl: pageUrl,\n      isOpened: isOpened,\n      showSuccessMessage: showSuccessMessage,\n      showFailureMessage: showFailureMessage,\n      suggestionUrl: suggestionUrl,\n      formData: formData,\n      conceptTypeIsSelected: conceptTypeIsSelected,\n      prefLabelOkay: prefLabelOkay,\n      explanationOkay: explanationOkay,\n      neededForOkay: neededForOkay,\n      setDropDown: setDropDown,\n      addHTTPOrHTTPS: addHTTPOrHTTPS,\n      submitForm: submitForm,\n      sendData: sendData,\n      toggleSuccessMessage: toggleSuccessMessage,\n      toggleFailureMessage: toggleFailureMessage,\n      handlePrefLabelLanguages: handlePrefLabelLanguages,\n      closeDialog: closeDialog,\n      getUrl: getUrl,\n      getGroups: getGroups,\n      dataCanBeSentArray: dataCanBeSentArray,\n      sending: sending,\n      testi: testi\n    };\n  }\n}));\n;// CONCATENATED MODULE: ./src/components/SuggestNewButton.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestNewButton.vue?vue&type=style&index=0&id=150727ae&lang=css\nvar SuggestNewButtonvue_type_style_index_0_id_150727ae_lang_css = __webpack_require__(2249);\n;// CONCATENATED MODULE: ./src/components/SuggestNewButton.vue?vue&type=style&index=0&id=150727ae&lang=css\n\n;// CONCATENATED MODULE: ./src/components/SuggestNewButton.vue\n\n\n\n\n;\n\n\nconst SuggestNewButton_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SuggestNewButtonvue_type_script_lang_js, [['render',SuggestNewButtonvue_type_template_id_150727ae_render]])\n\n/* harmony default export */ var SuggestNewButton = (SuggestNewButton_exports_);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestChangeButton.vue?vue&type=template&id=0e5bd7a5&scoped=true\n\nvar SuggestChangeButtonvue_type_template_id_0e5bd7a5_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-0e5bd7a5\"), n = n(), _popScopeId(), n;\n};\nvar SuggestChangeButtonvue_type_template_id_0e5bd7a5_scoped_true_hoisted_1 = [\"href\"];\nfunction SuggestChangeButtonvue_type_template_id_0e5bd7a5_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_edit_suggestion = resolveComponent(\"edit-suggestion\");\n  var _component_success_message = resolveComponent(\"success-message\");\n  var _component_failure_message = resolveComponent(\"failure-message\");\n  var _component_centered_dialog = resolveComponent(\"centered-dialog\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"a\", {\n    role: \"button\",\n    onClick: _cache[0] || (_cache[0] = function ($event) {\n      return $setup.isOpened = !$setup.isOpened;\n    }),\n    id: \"fordirectmodify\",\n    href: \"\".concat($setup.pageUrl.split('#')[0], \"#suggestion\")\n  }, [createBaseVNode(\"span\", null, toDisplayString(_ctx.$t('edit.button')), 1 /* TEXT */)], 8 /* PROPS */, SuggestChangeButtonvue_type_template_id_0e5bd7a5_scoped_true_hoisted_1), $setup.isOpened ? (openBlock(), createBlock(_component_centered_dialog, {\n    key: 0,\n    onClose: _cache[6] || (_cache[6] = function ($event) {\n      return $setup.closeDialog();\n    })\n  }, {\n    default: withCtx(function () {\n      return [!$setup.showSuccessMessage && !$setup.showFailureMessage ? (openBlock(), createBlock(_component_edit_suggestion, {\n        key: 0,\n        d: $setup.formData,\n        label: $setup.labelX,\n        uri: _ctx.uriX,\n        \"onUpdate:conceptType\": _cache[1] || (_cache[1] = function ($event) {\n          return $setup.formData.conceptType.value = $event;\n        }),\n        \"onUpdate:primaryPrefLabel\": _cache[2] || (_cache[2] = function ($event) {\n          return $setup.formData.prefLabel.primary = $event;\n        }),\n        \"onUpdate:description\": _cache[3] || (_cache[3] = function ($event) {\n          return $setup.formData.description = $event;\n        }),\n        \"onUpdate:reason\": _cache[4] || (_cache[4] = function ($event) {\n          return $setup.formData.reason = $event;\n        }),\n        \"onUpdate:fromOrg\": _cache[5] || (_cache[5] = function ($event) {\n          return $setup.formData.fromOrg = $event;\n        }),\n        onSubmitForm: $setup.submitForm\n      }, null, 8 /* PROPS */, [\"d\", \"label\", \"uri\", \"onSubmitForm\"])) : createCommentVNode(\"v-if\", true), $setup.showSuccessMessage ? (openBlock(), createBlock(_component_success_message, {\n        key: 1,\n        suggestionUrl: $setup.suggestionUrl,\n        url: $props.url\n      }, null, 8 /* PROPS */, [\"suggestionUrl\", \"url\"])) : createCommentVNode(\"v-if\", true), $setup.showFailureMessage ? (openBlock(), createBlock(_component_failure_message, {\n        key: 2\n      })) : createCommentVNode(\"v-if\", true)];\n    }),\n    _: 1 /* STABLE */\n  })) : createCommentVNode(\"v-if\", true)]);\n}\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/EditSuggestion.vue?vue&type=template&id=32d31e5a&scoped=true\n\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_withScopeId = function _withScopeId(n) {\n  return _pushScopeId(\"data-v-32d31e5a\"), n = n(), _popScopeId(), n;\n};\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_1 = {\n  class: \"suggestion-header\"\n};\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_2 = [\"href\"];\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_3 = {\n  class: \"suggestion-form\"\n};\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_4 = {\n  key: 0,\n  class: \"error\"\n};\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_5 = {\n  key: 1,\n  class: \"error\"\n};\nvar EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_6 = {\n  class: \"form-submit\"\n};\nfunction EditSuggestionvue_type_template_id_32d31e5a_scoped_true_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_basic_input = resolveComponent(\"basic-input\");\n  return openBlock(), createElementBlock(\"div\", null, [createBaseVNode(\"div\", EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_1, [createBaseVNode(\"h4\", null, [createTextVNode(toDisplayString(_ctx.$t('edit.header')) + \" \", 1 /* TEXT */), createBaseVNode(\"a\", {\n    href: $props.uri\n  }, toDisplayString($props.label), 9 /* TEXT, PROPS */, EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_2)]), createBaseVNode(\"p\", null, toDisplayString(_ctx.$t('edit.paragraph')), 1 /* TEXT */)]), createBaseVNode(\"div\", EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_3, [createBaseVNode(\"div\", null, [runtime_core_esm_bundler_createVNode(_component_basic_input, {\n    value: $setup.formData.description,\n    \"onInput:basic\": $setup.updateDescription,\n    label: {\n      text: _ctx.$t('edit.description.label'),\n      for: _ctx.$t('edit.description.label')\n    },\n    isTextArea: true\n  }, null, 8 /* PROPS */, [\"value\", \"onInput:basic\", \"label\"]), !$setup.descriptionCanBeSent && $setup.submitted ? (openBlock(), createElementBlock(\"p\", EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_4, toDisplayString(_ctx.$t('edit.description.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(_component_basic_input, {\n    value: $setup.formData.reason,\n    \"onInput:basic\": $setup.updateReason,\n    label: {\n      text: _ctx.$t('edit.reason.label'),\n      for: _ctx.$t('edit.reason.for')\n    },\n    isTextArea: true\n  }, null, 8 /* PROPS */, [\"value\", \"onInput:basic\", \"label\"]), !$setup.reasonCanBeSent && $setup.submitted ? (openBlock(), createElementBlock(\"p\", EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_5, toDisplayString(_ctx.$t('edit.reason.error')), 1 /* TEXT */)) : createCommentVNode(\"v-if\", true), runtime_core_esm_bundler_createVNode(_component_basic_input, {\n    value: $setup.formData.fromOrg,\n    \"onInput:basic\": $setup.updateFromOrg,\n    label: {\n      text: _ctx.$t('edit.fromOrg.label'),\n      for: _ctx.$t('edit.fromOrg.for')\n    },\n    isTextArea: false\n  }, null, 8 /* PROPS */, [\"value\", \"onInput:basic\", \"label\"])]), createBaseVNode(\"div\", EditSuggestionvue_type_template_id_32d31e5a_scoped_true_hoisted_6, [createBaseVNode(\"a\", {\n    onClick: _cache[0] || (_cache[0] = function () {\n      return $setup.submitForm && $setup.submitForm.apply($setup, arguments);\n    })\n  }, toDisplayString(_ctx.$t('edit.submit')), 1 /* TEXT */)])])]);\n}\n;// CONCATENATED MODULE: ./src/components/EditSuggestion.vue?vue&type=template&id=32d31e5a&scoped=true\n\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/EditSuggestion.vue?vue&type=script&lang=js\n\n\n/* harmony default export */ var EditSuggestionvue_type_script_lang_js = ({\n  components: {\n    BasicInput: BasicInput\n  },\n  props: {\n    d: Object,\n    label: String,\n    uri: String\n  },\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var formData = reactivity_esm_bundler_ref(props.d);\n    var descriptionCanBeSent = reactivity_esm_bundler_ref(false);\n    var reasonCanBeSent = reactivity_esm_bundler_ref(false);\n    var submitted = reactivity_esm_bundler_ref(false);\n    var updateDescription = function updateDescription(value) {\n      formData.value.description = value;\n    };\n    var updateReason = function updateReason(value) {\n      formData.value.reason = value;\n    };\n    var updateFromOrg = function updateFromOrg(value) {\n      formData.value.fromOrg = value;\n    };\n    watch(function () {\n      return [formData.value.description, formData.value.description.length];\n    }, function (newValues, oldValues) {\n      var descriptionLength = newValues[1];\n      if (descriptionLength > 2) {\n        descriptionCanBeSent.value = true;\n      } else {\n        descriptionCanBeSent.value = false;\n      }\n    }, {\n      deep: true\n    });\n    watch(function () {\n      return [formData.value.reason, formData.value.reason.length];\n    }, function (newValues, oldValues) {\n      var reasonLength = newValues[1];\n      if (reasonLength > 2) {\n        reasonCanBeSent.value = true;\n      } else {\n        reasonCanBeSent.value = false;\n      }\n    }, {\n      deep: true\n    });\n    var submitForm = function submitForm() {\n      submitted.value = true;\n      if (descriptionCanBeSent.value == true && reasonCanBeSent.value == true) {\n        emit('submitForm');\n      }\n    };\n    return {\n      formData: formData,\n      updateDescription: updateDescription,\n      updateReason: updateReason,\n      updateFromOrg: updateFromOrg,\n      submitForm: submitForm,\n      descriptionCanBeSent: descriptionCanBeSent,\n      reasonCanBeSent: reasonCanBeSent,\n      submitted: submitted\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/EditSuggestion.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/EditSuggestion.vue?vue&type=style&index=0&id=32d31e5a&scoped=true&lang=css\nvar EditSuggestionvue_type_style_index_0_id_32d31e5a_scoped_true_lang_css = __webpack_require__(2254);\n;// CONCATENATED MODULE: ./src/components/EditSuggestion.vue?vue&type=style&index=0&id=32d31e5a&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/EditSuggestion.vue\n\n\n\n\n;\n\n\nconst EditSuggestion_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(EditSuggestionvue_type_script_lang_js, [['render',EditSuggestionvue_type_template_id_32d31e5a_scoped_true_render],['__scopeId',\"data-v-32d31e5a\"]])\n\n/* harmony default export */ var EditSuggestion = (EditSuggestion_exports_);\n// EXTERNAL MODULE: ./node_modules/vuelidate/lib/index.js\nvar lib = __webpack_require__(8620);\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestChangeButton.vue?vue&type=script&lang=js\nfunction SuggestChangeButtonvue_type_script_lang_js_typeof(obj) { \"@babel/helpers - typeof\"; return SuggestChangeButtonvue_type_script_lang_js_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, SuggestChangeButtonvue_type_script_lang_js_typeof(obj); }\nfunction SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == SuggestChangeButtonvue_type_script_lang_js_typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction SuggestChangeButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction SuggestChangeButtonvue_type_script_lang_js_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { SuggestChangeButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { SuggestChangeButtonvue_type_script_lang_js_asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n/* harmony default export */ var SuggestChangeButtonvue_type_script_lang_js = ({\n  components: {\n    EditSuggestion: EditSuggestion,\n    CenteredDialog: CenteredDialog,\n    SuccessMessage: SuccessMessage,\n    FailureMessage: FailureMessage\n  },\n  props: {\n    lang: String,\n    vocab: String,\n    label: String,\n    uri: String,\n    url: String,\n    moikkelis: String\n  },\n  setup: function setup(props) {\n    var testi = inject('testi');\n    var labelX = inject('labelX', null);\n    var uriX = inject('uriX', null);\n    var pageUrlX = inject('pageUrlX', null);\n    var $t = inject('$t');\n    var pageUrl = reactivity_esm_bundler_ref(pageUrlX);\n    // console.log('pageUrl at refs', pageUrl)\n    var isOpened = reactivity_esm_bundler_ref(false);\n    var showSuccessMessage = reactivity_esm_bundler_ref(false);\n    var showFailureMessage = reactivity_esm_bundler_ref(false);\n    var suggestionUrl = reactivity_esm_bundler_ref('');\n    var formData = reactive({\n      description: '',\n      reason: '',\n      fromOrg: ''\n    });\n    var getUrl = /*#__PURE__*/function () {\n      var _ref = SuggestChangeButtonvue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime().mark(function _callee() {\n        return SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              pageUrl.value = window.location.href;\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function getUrl() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var submitForm = function submitForm() {\n      if (true) {\n        sendData();\n      } else {}\n    };\n    var sendData = /*#__PURE__*/function () {\n      var _ref2 = SuggestChangeButtonvue_type_script_lang_js_asyncToGenerator( /*#__PURE__*/SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime().mark(function _callee2() {\n        var data, dataBundle, payload, urlToPrx;\n        return SuggestChangeButtonvue_type_script_lang_js_regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              data = \"\\n**K\\xE4sitteen tyyppi**\\n\\nMuutos olemassa olevaan k\\xE4sitteeseen\\n\\n**prefabel**\\n\\n[\".concat(labelX, \"](\").concat(uriX, \")\\n\\n**Tila**\\n\\nK\\xE4sittelyss\\xE4\\n\\n**Ehdotettu muutos**\\n\\n\").concat(formData.description, \"\\n\\n**Perustelut ehdotukselle**\\n\\n\").concat(formData.reason, \"\\n\\n**Ehdottajan organisaatio**\\n\\n\").concat(formData.fromOrg, \"\\n\");\n              dataBundle = {\n                title: labelX,\n                body: data,\n                state: 'open',\n                labels: ['muutos']\n              };\n              payload = encodeURIComponent(JSON.stringify(dataBundle));\n              urlToPrx = __webpack_require__(3421);\n              _context2.next = 6;\n              return axios_default().post(\"\".concat(urlToPrx[0].url, \"?payload=\").concat(payload)).then(function (response) {\n                toggleSuccessMessage(\"\".concat(response.data.url.replace('/repos', '').replace('api.', '')));\n              }).catch(function (error) {\n                toggleFailureMessage();\n              });\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function sendData() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    var toggleSuccessMessage = function toggleSuccessMessage(responseUrl) {\n      if (responseUrl && responseUrl.length > 0) {\n        suggestionUrl.value = responseUrl;\n        showSuccessMessage.value = true;\n      }\n      showSuccessMessage.value = true;\n    };\n    var toggleFailureMessage = function toggleFailureMessage() {\n      showFailureMessage.value = true;\n    };\n    var handlePrefLabelLanguages = function handlePrefLabelLanguages() {\n      if (lang === 'sv') {\n        return {\n          sv: {\n            value: labelX,\n            uri: uriX\n          },\n          en: '',\n          fi: {\n            value: '',\n            uri: ''\n          }\n        };\n      }\n      return {\n        fi: {\n          value: labelX,\n          uri: uriX\n        },\n        en: '',\n        sv: {\n          value: '',\n          uri: ''\n        }\n      };\n    };\n    var closeDialog = function closeDialog() {\n      isOpened.value = !isOpened.value;\n      showSuccessMessage.value = false;\n      showFailureMessage.value = false;\n      suggestionUrl.value = '';\n      // $v.formData.$reset();\n      formData.description = '';\n      formData.reason = '';\n      formData.fromOrg = '';\n    };\n    return {\n      pageUrl: pageUrl,\n      pageUrlX: pageUrlX,\n      isOpened: isOpened,\n      showSuccessMessage: showSuccessMessage,\n      showFailureMessage: showFailureMessage,\n      suggestionUrl: suggestionUrl,\n      formData: formData,\n      getUrl: getUrl,\n      submitForm: submitForm,\n      toggleFailureMessage: toggleFailureMessage,\n      handlePrefLabelLanguages: handlePrefLabelLanguages,\n      closeDialog: closeDialog,\n      labelX: labelX,\n      testi: testi\n    };\n  },\n  validations: function validations() {\n    return {\n      formData: {\n        description: {\n          required: lib.required\n        },\n        reason: {\n          required: lib.required\n        }\n      }\n    };\n  }\n});\n;// CONCATENATED MODULE: ./src/components/SuggestChangeButton.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestChangeButton.vue?vue&type=style&index=0&id=0e5bd7a5&lang=css\nvar SuggestChangeButtonvue_type_style_index_0_id_0e5bd7a5_lang_css = __webpack_require__(4722);\n;// CONCATENATED MODULE: ./src/components/SuggestChangeButton.vue?vue&type=style&index=0&id=0e5bd7a5&lang=css\n\n// EXTERNAL MODULE: ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[6].use[0]!./src/components/SuggestChangeButton.vue?vue&type=style&index=1&id=0e5bd7a5&scoped=true&lang=css\nvar SuggestChangeButtonvue_type_style_index_1_id_0e5bd7a5_scoped_true_lang_css = __webpack_require__(6839);\n;// CONCATENATED MODULE: ./src/components/SuggestChangeButton.vue?vue&type=style&index=1&id=0e5bd7a5&scoped=true&lang=css\n\n;// CONCATENATED MODULE: ./src/components/SuggestChangeButton.vue\n\n\n\n\n;\n\n\n\nconst SuggestChangeButton_exports_ = /*#__PURE__*/(0,exportHelper/* default */.Z)(SuggestChangeButtonvue_type_script_lang_js, [['render',SuggestChangeButtonvue_type_template_id_0e5bd7a5_scoped_true_render],['__scopeId',\"data-v-0e5bd7a5\"]])\n\n/* harmony default export */ var SuggestChangeButton = (SuggestChangeButton_exports_);\n;// CONCATENATED MODULE: ./src/main.js\nfunction main_typeof(obj) { \"@babel/helpers - typeof\"; return main_typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, main_typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return main_typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (main_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (main_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (main_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n// import Vuelidate from 'vuelidate';\n\n\nvar main_i18n = createI18n({\n  locale: window.lang,\n  messages: i18n\n});\nvar app = createApp(SuggestNewButton);\nvar app2 = createApp(SuggestChangeButton);\napp.provide('$t', main_i18n.global.t);\napp.provide('pageUrl', window.location.href);\napp2.provide('$t', main_i18n.global.t);\napp2.provide('pageUrlX', window.location.href);\nvar testi = reactivity_esm_bundler_ref('This is a ref variable');\napp.provide('testi', testi);\ndocument.addEventListener('DOMContentLoaded', function () {\n  var element = document.getElementById('uri-input-box');\n  if (element) {\n    var uriText = element.textContent;\n    app2.provide('uriX', uriText);\n  }\n});\n\n// Register global i18n\napp.use(main_i18n);\napp2.use(main_i18n);\n\n// Define the custom elements\ncustomElements.define('suggest-new-button', /*#__PURE__*/function (_HTMLElement) {\n  _inherits(_class, _HTMLElement);\n  var _super = _createSuper(_class);\n  function _class() {\n    _classCallCheck(this, _class);\n    return _super.apply(this, arguments);\n  }\n  _createClass(_class, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      var element = app.mount(document.createElement('div'));\n      if (element) {\n        this.appendChild(element.$el);\n      } else {\n        console.log(\"The element not found\");\n      }\n    }\n  }]);\n  return _class;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement)));\ndocument.addEventListener('DOMContentLoaded', function () {\n  var element = document.getElementById('uri-input-box');\n  if (element) {\n    var uriText = element.textContent;\n    app2.provide('uriX', uriText);\n  }\n});\nvar main_element;\ncustomElements.define('suggest-change-button', /*#__PURE__*/function (_HTMLElement2) {\n  _inherits(_class2, _HTMLElement2);\n  var _super2 = _createSuper(_class2);\n  function _class2() {\n    _classCallCheck(this, _class2);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(_class2, [{\n    key: \"connectedCallback\",\n    value:\n    // Kustoimoiduille elementeille tarkoitettu Lifecycle-metodi, joka hyödyntää Web Components APIa. Sitä kutsutaan kun customoitu elementti\n    // (suggest-change-button) liitetään DOMiin, käytännössä lisätty dokumenttiin (window.document).\n    // Tässä vaiheessa olisi mahdollista toteuttaa alustavia toimenpiteitä tai vaikka asettaa\n    // event listenereitä, joiden halutaan olevan aktiivisia, kun elementti on dokumentissa.\n    function connectedCallback() {\n      var elementABC = document.getElementById('pref-label');\n\n      // Aiemmin luotiin app2 eli const app2 = createApp(SuggestChangeButton);\n      // Alla siihen liitetään div-elementti, johon sovellus, SuggestChangeButtoniin perustuva app2 implementoi kaikki toimintonsa\n      // const element = app2.mount(document.createElement('div'));\n      var app3 = createApp(SuggestChangeButton);\n      var elementUri = document.getElementById('uri-input-box');\n      var prefElement = document.getElementById('pref-label');\n      if (prefElement) {\n        var labelText = prefElement.textContent;\n        app3.provide('labelX', labelText);\n        app3.provide('testi', testi.value);\n      }\n      if (elementUri) {\n        var uriText = elementUri.textContent;\n        app3.provide('uriX', uriText);\n      }\n      app3.provide('$t', main_i18n.global.t);\n      app3.provide('pageUrlX', window.location.href);\n      app3.use(main_i18n); // Register global i18n\n      main_element = app3.mount(document.createElement('div'));\n      // }\n\n      if (main_element) {\n        this.appendChild(main_element.$el);\n      } else {\n        console.log(\"The element not found\");\n      }\n      if (typeof main_element == 'undefined') {\n        /*            customElements.define('suggest-change-button', class extends HTMLElement {\n                        connectedCallback() {\n                            console.log(\"E - main.js, suggest-change-button\")\n                            const element = app2.mount(document.createElement('div'));\n                            console.log(\"element in main.js\", element)\n                            this.appendChild(element.$el)\n                        }\n                    });*/\n      }\n    }\n  }]);\n  return _class2;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement)));\n\n// Säiliö melkein toimivasta\n/*customElements.define('suggest-change-button', class extends HTMLElement {\n    connectedCallback() {\n        console.log(\"E - main.js, suggest-change-button\")\n        // console.log(prefLabels) AAA\n        // const element = createApp(SuggestChangeButton).mount(document.createElement('div')); // case 1: swäpätty alla olevan kanssa\n\n\n        // if (customElements.get('suggest-change-button')) {\n        //     console.log(\"toimii\");\n        // } else {\n        //     console.log(\"ei toimi\");\n        // }\n\n        // document.getElementsByName('suggest-change-button') ? \"suggest-change-button löytyi\" : \"suggest-change-button ei löytynyt\"\n\n        const element = app2.mount(document.createElement('div'));\n        console.log(\"element in main.js\", element)\n                // if (element) {\n\n\n        this.appendChild(element.$el);\n                // } else {\n                //     console.log(\"The element not found\")\n                // }\n\n        // setTimeout(() => {\n        //     // if (element) {\n        //     //     this.appendChild(element.$el);\n        //     // location.reload();\n        //     // } else {\n        //     //     console.log(\"The element not found\")\n        //     // }\n        // }, 5000); // 5000 milliseconds = 5 seconds\n    }\n});*/\n\n// Check if 'suggest-new-button' is registered\nif (customElements.get('suggest-new-button')) {\n  console.log(\"'suggest-new-button' is registered.\");\n} else {\n  console.log(\"'suggest-new-button' is NOT registered.\");\n}\nif (customElements.get('suggest-change-button')) {\n  console.log(\"'suggest-change-button' is registered.\");\n} else {\n  console.log(\"'suggest-change-button' is NOT registered.\");\n}\n\n// Tämä on koodi, jossa uuden lähettäminen toimii kokonaan\n/*\nimport { createApp } from 'vue';\nimport { createI18n } from 'vue-i18n';\nimport translations from './i18n/i18n';\n// import Vuelidate from 'vuelidate';\nimport { useVuelidate } from '@vuelidate/core'; // Import useVuelidate function\nimport SuggestNewButton from '@/components/SuggestNewButton.vue';\nimport SuggestChangeButton from '@/components/SuggestChangeButton.vue';\n\nconst i18n = createI18n({\n    // locale: 'fi',\n    locale: window.lang,\n    messages: translations,\n});\n\nconst app = createApp(SuggestNewButton);\n\n// Provide i18n instance to components\n// app.provide('$t', i18n.global.t);\napp.provide('$t', i18n.global.t);\napp.provide('pageUrl', window.location.href);\n// app.provide('useVuelidate', useVuelidate);\n\napp.use(i18n); // Register global i18n\n// app.use(useVuelidate); // Use Vuelidate plugin\n\n// Define the custom elements\ncustomElements.define('suggest-new-button', class extends HTMLElement {\n    connectedCallback() {\n        const element = app.mount(document.createElement('div'));\n        this.appendChild(element.$el);\n    }\n});\n\ncustomElements.define('suggest-change-button', class extends HTMLElement {\n    connectedCallback() {\n        const element = createApp(SuggestChangeButton).mount(document.createElement('div'));\n        this.appendChild(element.$el);\n    }\n});\n\n// Check if 'suggest-new-button' is registered\nif (customElements.get('suggest-new-button')) {\n    console.log(\"'suggest-new-button' is registered.\");\n} else {\n    console.log(\"'suggest-new-button' is NOT registered.\");\n}*/\n\n/*\n// support for older browsers\nimport 'document-register-element/build/document-register-element';\nimport \"core-js/stable\";\nimport \"regenerator-runtime/runtime\";\n\nimport { createApp } from 'vue'\nimport { createI18n } from 'vue-i18n';\nimport translations from './i18n/i18n';\n\n// import your component(s)\nimport SuggestNewButton from '@/components/SuggestNewButton.vue';\nimport SuggestChangeButton from '@/components/SuggestChangeButton.vue';\n\nconst i18n = createI18n({\n    locale: 'fi',\n    messages: translations,\n});\n\nconst app = createApp(SuggestNewButton);\n\n// Register global i18n\napp.use(i18n);\n\n// Register components globally if needed\napp.component('suggest-new-button', SuggestNewButton);\napp.component('suggest-change-button', SuggestChangeButton);\n\nconsole.log('Vue app:', app);\n\napp.mount('#app'); // Replace '#app' with your root element ID\n// app.mount('#suggestions-new');\n*/\n\n// The original before vue3\n/*\n// support for older browsers\nimport 'document-register-element/build/document-register-element';\nimport \"core-js/stable\";\nimport \"regenerator-runtime/runtime\";\n\nimport Vue from 'vue';\n\nimport Vuelidate from 'vuelidate';\nVue.use(Vuelidate);\n\nimport VueI18n from 'vue-i18n';\nVue.use(VueI18n);\nimport translations from './i18n/i18n';\n\n// include vue-custom-element plugin to Vue\nimport VueCustomElement from 'vue-custom-element';\nVue.use(VueCustomElement);\n\n// import and register your component(s)\nimport SuggestNewButton from '@/components/SuggestNewButton.vue';\nSuggestNewButton.i18n = new VueI18n({ locale: 'fi', messages: translations });\nVue.customElement('suggest-new-button', SuggestNewButton);\n\n// import and register your component(s)\nimport SuggestChangeButton from '@/components/SuggestChangeButton.vue';\nSuggestChangeButton.i18n = new VueI18n({ locale: 'fi', messages: translations });\nVue.customElement('suggest-change-button', SuggestChangeButton);\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxFQUUxRDtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEJBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUFJLHNDQUFzQyxrQ0FBa0MsY0FBYyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBcUMsR0FBRyxFQU01QztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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YUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDLEdBQUcsRUFFNUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQWE7QUFDL0I7QUFDQSxRQUFRLDBCQUFPO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsMkJBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBVztBQUNmLFFBQVEsTUFBTTtBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Qjs7O0FDbmxCM2I7QUFDM1Y7QUFDdVA7O0FBRXpSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1Q0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNDQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0NBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlDQUFVO0FBQ3JCLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQW9CO0FBQzlDLDRDQUE0QywwQ0FBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxvQkFBb0IsMENBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDLEdBQUcsRUFHNUM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2QkFBSztBQUNYO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdDQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0NBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1DQUFJO0FBQ2pCO0FBQ0EsYUFBYSx1Q0FBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCx5QkFBeUIseURBQVM7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBMEQsRUFBRSxFQUcvRDtBQUNiLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQixrQkFBa0I7QUFDN0M7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQyxHQUFHLEVBZ0I1QztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUMsR0FBRyxFQUU1QztBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDLEtBQUssQ0FBa0Q7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDLEtBQUssQ0FBNEQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXFDO0FBQ2xELGdCQUFnQixDQUFrRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQXFDO0FBQzlDLFlBQVksQ0FBdUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLEtBQUssQ0FBQyxDQUFDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFDQUFNLEdBQUcsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBUTtBQUNkLFFBQVEsc0NBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNDQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRCxLQUFLLG9DQUFvQyxLQUFLLGtDQUFrQyxLQUFLLHNJQUFzSSxLQUFLLG9DQUFvQyxLQUFLLGtDQUFrQyxLQUFLLGFBQWE7QUFDelg7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnS0FBZ0s7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxxQ0FBTTtBQUNqQjtBQUNBLFlBQVksZ0NBQVE7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksZ0NBQVE7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLGdDQUFRO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWSxnQ0FBUTtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksZ0NBQVE7QUFDcEIsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZLGdDQUFRO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVDQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQVE7QUFDeEIsU0FBUyxLQUFxQztBQUM5QyxRQUFRLEVBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBTSxHQUFHO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLE9BQU87QUFDMUIseUJBQXlCLDJDQUFrQjtBQUMzQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsNEJBQUs7QUFDbEM7QUFDQSxzQ0FBc0MsaUNBQVE7QUFDOUM7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsUUFBUSxzQkFBc0I7QUFDcEU7QUFDQSwwQkFBMEIsS0FBcUMsR0FBRyxFQUVqRDtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBLG9CQUFvQixrQkFBa0IsUUFBUSxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsR0FBRyxLQUFLLEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFPLGdCQUFnQixzQ0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVDQUFRO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLG9CQUFvQixzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1Q0FBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBTztBQUN2Qiw4QkFBOEIsMkNBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQSxRQUFRLHNDQUFPO0FBQ2YscUJBQXFCLDJDQUFZO0FBQ2pDO0FBQ0EsYUFBYSxvQ0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIscUJBQXFCLHlDQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0EseUJBQXlCLHlDQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0IsVUFBVTtBQUNoRCwyQkFBMkIsb0NBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVDQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBTyxZQUFZLG9DQUFLO0FBQy9DLFNBQVMsTUFBcUM7QUFDOUMsWUFBWSxDQUNxRTtBQUNqRjtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFPO0FBQ3ZCLGtDQUFrQywyQ0FBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTyxRQUFRLE9BQU87QUFDdEQsaUNBQWlDLE9BQU87QUFDeEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEVBQUU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU8sSUFBSSxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixPQUFPLElBQUksWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLGlCQUFpQixJQUFJLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxxQ0FBTSxHQUFHLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxTQUFTLEtBQXFDLEdBQUcsRUFHNUM7QUFDTCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUNBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVMsS0FBcUMsR0FBRyxFQUc1QztBQUNMLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQVE7QUFDaEI7QUFDQSxZQUFZLEtBQStDLEVBQUUsRUFFcEQ7QUFDVDtBQUNBO0FBQ0EsUUFBUSxLQUcyQixFQUFFLEVBRWhDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ1M7OztBQ2pxRGhTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBcUMsR0FBRyxFQWlCNUM7QUFDRCxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsU0FBUyxhQUFNO0FBQ2YsNkJBQTZCLGVBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdGQUFnRiw4QkFBOEI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBTSxZQUFZLG1CQUFZO0FBQ3BDLDBCQUEwQixtQkFBWTtBQUN0QywrQkFBK0Isb0JBQWE7QUFDNUMsU0FBUyxXQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBTTtBQUNaLElBQUksaUJBQVc7QUFDZixNQUFNLG9CQUFhO0FBQ25CO0FBQ0EsWUFBWSxpQkFBVztBQUN2QixTQUFTLGlCQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTLGlCQUFVO0FBQ25CO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsTUFBTSxxQkFBYztBQUNwQixTQUFTLGFBQU07QUFDZixXQUFXLHFCQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBTztBQUNiLE1BQU0saUJBQVU7QUFDaEIsTUFBTSxlQUFRO0FBQ2QsTUFBTSxnQkFBUztBQUNmLE1BQU0sZUFBUTtBQUNkO0FBQ0EsTUFBTSxlQUFRO0FBQ2Q7QUFDQSxNQUFNLGdCQUFTO0FBQ2YsV0FBVyxlQUFRLFNBQVMsaUJBQVUsY0FBYyxpQkFBVTtBQUM5RDtBQUNBLE1BQU0scUJBQWM7QUFDcEIsTUFBTSxtQkFBWSxjQUFjLHFCQUFjO0FBQzlDLE1BQU0sb0JBQWE7QUFDbkIsU0FBUyxlQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNCQUFlO0FBQ3JCO0FBQ0E7QUFDQSxVQUFVLGNBQU8sVUFBVSxvQkFBYSwwQkFBMEIscUJBQWM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsb0NBQW9DLEtBQUssU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa1g7OztBQzFNbFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQ0FBTyxNQUFNLGdCQUFnQjtBQUNuQztBQUNBLFNBQVMsbUNBQU07QUFDZiw2QkFBNkIscUNBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBTztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0sbUNBQU07QUFDWixNQUFNLHFDQUFRO0FBQ2Q7QUFDQSxNQUFNLHFDQUFRO0FBQ2QsU0FBUyxpQ0FBSTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsRUFBRTtBQUM3RCx1RkFBdUYsRUFBRTtBQUN6RjtBQUNBLDhFQUE4RSxFQUFFO0FBQ2hGLDRGQUE0RixFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixFQUFFO0FBQ2hHO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVkseUJBQXlCO0FBQ3JDLGdCQUFnQixtQ0FBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckMsTUFBTSwwQ0FBYTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQSx3R0FBd0csUUFBUSxFQUFFLFNBQVMsRUFBRSxtQkFBbUI7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxFQUFFLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFLGtCQUFrQixFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdDQUF3QyxXQUFXO0FBQ25FO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0MsV0FBVztBQUNuRTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDLFdBQVc7QUFDbkU7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1DQUFNLEdBQUc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGlFQUFpRSxJQUFJO0FBQ3JFLDRCQUE0QixzQkFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEseUJBQXlCLFFBQVE7QUFDdEUsVUFBVSxRQUFRO0FBQ2xCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLGVBQVE7QUFDL0IsUUFBUSxlQUFRO0FBQ2hCLFFBQVEsaUJBQVU7QUFDbEI7QUFDQTtBQUNBLDBCQUEwQixlQUFRO0FBQ2xDLFFBQVEsZUFBUTtBQUNoQixRQUFRLGlCQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksUUFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBVTtBQUM5QjtBQUNBLGNBQWMsZUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFhLHVCQUF1QixpQkFBVTtBQUNwRTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFhO0FBQ3JDLFFBQVEsaUJBQVU7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQixvQkFBYSx1QkFBdUIsZUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQVE7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQixlQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksa0JBQVE7QUFDWjtBQUNBLElBQUksa0JBQVE7QUFDWjtBQUNBO0FBQ0EsV0FBVyxrQkFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFRO0FBQ1osUUFBUSxrQkFBUSxNQUFNLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDREQUE0RCxvQkFBb0I7QUFDaEY7QUFDQSx5QkFBeUIsa0JBQVEsSUFBSSxrQkFBUTtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUksV0FBVyxPQUFPO0FBQ3RFLHFFQUFxRSxJQUFJLGFBQWEsT0FBTztBQUM3RjtBQUNBLDZFQUE2RSxJQUFJLGFBQWEsT0FBTztBQUNyRztBQUNBLDZFQUE2RSxJQUFJLGFBQWEsT0FBTztBQUNyRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBTztBQUN2QjtBQUNBLGtCQUFrQixlQUFRO0FBQzFCO0FBQ0Esc0JBQXNCLGVBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBTyxlQUFlLG9CQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBUTtBQUN4QixZQUFZLGNBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0IsZ0JBQVMsVUFBVTtBQUMzRDtBQUNBLFlBQVksZUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBTyxZQUFZLG9CQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9CQUFVLGVBQWUsa0NBQWtDLEVBQUUsY0FBYztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFRO0FBQzlDO0FBQ0Esc0NBQXNDLGVBQVE7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDLGVBQVE7QUFDOUM7QUFDQSxzQ0FBc0MsZUFBUTtBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBUTtBQUMvQyxrQkFBa0Isb0JBQVU7QUFDNUIsc0NBQXNDLGVBQVE7QUFDOUMsc0JBQXNCLG9CQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0Esb0JBQW9CLGVBQVE7QUFDNUIsbUJBQW1CLGVBQVE7QUFDM0IsMkJBQTJCLGNBQU87QUFDbEMsUUFBUSxvQkFBYTtBQUNyQixRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFhO0FBQ2xDO0FBQ0EsWUFBWTtBQUNaLDRCQUE0QixvQkFBYTtBQUN6QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDBCQUEwQixvQkFBYTtBQUN2QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHNCQUFzQixhQUFNLEdBQUcseUJBQXlCO0FBQ3hEO0FBQ0Esb0JBQW9CLGlCQUFVO0FBQzlCLHdCQUF3QixnQkFBUyx5QkFBeUIsUUFBUTtBQUNsRTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFTLDBCQUEwQixRQUFRO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFVO0FBQ3RDO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQWE7QUFDbkMsNEJBQTRCLGdCQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLGlCQUFVO0FBQ3RDO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQVU7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QixlQUFRO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQVUsb0NBQW9DLFdBQUk7QUFDckU7QUFDQTtBQUNBLGlDQUFpQyxlQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDLEdBQUcsRUFLNUM7QUFDTDtBQUNBLFNBQVMsTUFBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsU0FBUyxLQUFxQyxHQUFHLEVBVTVDO0FBQ0w7QUFDQTtBQUNBLGVBQWUsZUFBUTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSxLQUFtRixFQUFFLEVBRXhGO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQTs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQixjQUFjLE1BQXFDLElBQUksQ0FBMkIsQ0FBQztBQUNoSDtBQUNBO0FBQ0EsTUFBTSx1QkFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG9FQUFvQixPQUFPLDJEQUEyRDtBQUMzRztBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFXLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyxXQUFhO0FBQzdCO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVMsZUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBcUMsS0FBSyxDQUEwQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQixFQUFFLHFCQUFXO0FBQ2pEO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBTyxzQkFBc0I7QUFDdEMsUUFBUSxlQUFRO0FBQ2hCO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFxQyxLQUFLLENBQTBDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CLEVBQUUscUJBQVc7QUFDaEQ7QUFDQSx1QkFBdUIsWUFBb0I7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsZ0JBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFNO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGlCQUFVO0FBQzdDLDhCQUE4QixlQUFRO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZLDBGQUEwRjtBQUN0RztBQUNBLHdCQUF3QixnQkFBUztBQUNqQztBQUNBO0FBQ0EseUJBQXlCLGdCQUFTO0FBQ2xDO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBUSxxQkFBcUIsZ0JBQVM7QUFDbEUsV0FBVyxnQkFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYSxlQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBOEYsRUFBRSxFQU1uRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFNLEdBQUcsMkNBQTJDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQU87QUFDZixnREFBZ0QsZUFBUSxTQUFTLGlCQUFVO0FBQzNFO0FBQ0EsYUFBYSxlQUFRO0FBQ3JCO0FBQ0EsZ0JBQWdCLGVBQVE7QUFDeEIscUNBQXFDLGlCQUFVO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0VBQW9FO0FBQ2hGLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsWUFBWSxLQUUwQyxFQUFFLEVBSy9DO0FBQ1Q7QUFDQSxZQUFZLEtBQWtFLEVBQUUsRUFXdkU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQW9ELEVBQUUsRUFLekQ7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxZQUFZLEtBQW9ELEVBQUUsRUFnQnpEO0FBQ1QsWUFBWSxlQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFvRCxFQUFFLEVBS3pEO0FBQ0w7QUFDQTtBQUNBLFFBQVEsS0FBb0QsRUFBRSxFQWV6RDtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFvRCxFQUFFLEVBS3pEO0FBQ0w7QUFDQTtBQUNBLFFBQVEsS0FBb0QsRUFBRSxFQWV6RDtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBUTtBQUNqQixTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLGVBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsb0JBQWEsV0FBVyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhLGNBQU87QUFDcEI7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0EsYUFBYSxlQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLG9CQUFhO0FBQzFCLFFBQVEsYUFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBcUMsR0FBRyxFQWlCNUM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvSEFBb0g7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHlFQUF5RTtBQUNyRixZQUFZLHVCQUF1QjtBQUNuQyxRQUFRLEtBQXlFLEVBQUUsRUFHOUU7QUFDTDtBQUNBLHdCQUF3QixnQkFBUztBQUNqQztBQUNBO0FBQ0EseUJBQXlCLGdCQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFRO0FBQzNCO0FBQ0E7QUFDQSxTQUFTLGVBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLFlBQVksS0FFMEMsRUFBRSxFQUsvQztBQUNUO0FBQ0EsWUFBWSxLQUFrRSxFQUFFLEVBV3ZFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBYTtBQUN6QjtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFhLGFBQWEsZUFBUTtBQUMzQztBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsSUFBSSxJQUFJO0FBQ3JDLFNBQVMsYUFBYTtBQUN0QixnQkFBZ0IsR0FBRyxJQUFJLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBTSxHQUFHO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZUFBUTtBQUNoQjtBQUNBO0FBQ0Esd0NBQXdDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0IsRUFBRSxrQkFBa0I7QUFDM0QscUJBQXFCLGtCQUFrQixHQUFHLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBLGFBQWEsb0JBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBLGFBQWEsb0JBQWE7QUFDMUI7QUFDQTtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLElBQUksSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GLFlBQVkscUJBQXFCO0FBQ2pDLFFBQVEsS0FBdUUsRUFBRSxFQUc1RTtBQUNMO0FBQ0Esd0JBQXdCLGdCQUFTO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQVE7QUFDM0I7QUFDQTtBQUNBLFNBQVMsZUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsWUFBWSxLQUUwQyxFQUFFLEVBSy9DO0FBQ1Q7QUFDQSxZQUFZLEtBQWtFLEVBQUUsRUFXdkU7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFhO0FBQ3pCO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQWEsYUFBYSxlQUFRO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxJQUFJLElBQUk7QUFDckMsU0FBUyxhQUFhO0FBQ3RCLGdCQUFnQixHQUFHLElBQUksMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFNLEdBQUc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBLGFBQWEsb0JBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBLGFBQWEsb0JBQWE7QUFDMUI7QUFDQTtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLElBQUksSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDBCQUFnQjtBQUNwQjs7QUFFaTJCOzs7QUN6ckQxMUI7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQU07QUFDdkIsY0FBYyxxQkFBTTtBQUNwQjtBQUNBO0FBQ087OztBQ1hBO0FBQ0E7OztBQ0RQLElBQUksY0FBUztBQUNiLElBQUksU0FBSTtBQUNEO0FBQ1A7QUFDQSxRQUFRLGNBQVM7QUFDakIsZUFBZSxjQUFTO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLGNBQVM7QUFDakIsUUFBUSxTQUFJO0FBQ1o7QUFDQSxvQkFBb0IscUJBQU0sMkJBQTJCLHFCQUFNO0FBQzNELFFBQVEsY0FBUztBQUNqQixRQUFRLFNBQUksR0FBRyxxQkFBTTtBQUNyQjtBQUNBO0FBQ0EsUUFBUSxjQUFTO0FBQ2pCO0FBQ0EsV0FBVyxjQUFTO0FBQ3BCO0FBQ087QUFDUCxzQ0FBc0MsU0FBSTtBQUMxQzs7O0FDdEJzRDtBQUN0QjtBQUN6QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakYsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QixHQUFHO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRzhFO0FBQ3RDO0FBQ0Y7QUFDUDtBQUNIO0FBQ0Y7QUFDbkI7QUFDUDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLGlCQUFpQixxQkFBcUI7QUFDdEMsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlGOzs7QUNqQmpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDME47QUFDK2E7QUFDMWM7QUFDdkk7QUFDc0Q7O0FBRTlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUFnQjtBQUN6QjtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTs7QUFFQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUJBQVk7QUFDbEIscURBQXFELE1BQU0sRUFBRSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLEtBQUs7QUFDaEc7QUFDQSxrRUFBa0UsSUFBSTtBQUN0RTtBQUNBLFNBQVMsdUJBQWM7QUFDdkIsa0JBQWtCLHFCQUFZO0FBQzlCOztBQUVBLElBQUksYUFBSSxHQUFHLGlCQUFpQjtBQUM1QixNQUFNLFlBQUcsV0FBVyxhQUFJO0FBQ3hCO0FBQ0E7QUFDQSw0QkFBNEIsYUFBSTtBQUNoQztBQUNBLHNCQUFzQixZQUFHO0FBQ3pCO0FBQ0EsNEJBQTRCLFlBQUc7QUFDL0IsbUJBQW1CLFlBQUc7QUFDdEIsa0NBQWtDLFlBQUc7QUFDckM7QUFDQSxvQkFBb0IsWUFBRztBQUN2QixtQkFBbUIsWUFBRztBQUN0QjtBQUNBLHNDQUFzQyxZQUFHO0FBQ3pDLGdDQUFnQyxZQUFHO0FBQ25DO0FBQ0Esc0JBQXNCLFlBQUc7QUFDekI7QUFDQSxvQ0FBb0MsWUFBRztBQUN2QztBQUNBLCtCQUErQixZQUFHO0FBQ2xDO0FBQ0Esa0RBQWtELFlBQUc7QUFDckQ7QUFDQSx5Q0FBeUMsWUFBRztBQUM1QztBQUNBLHNCQUFzQixZQUFHO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQixjQUFjLE1BQXFDLElBQUksQ0FBaUMsQ0FBQztBQUN0SDtBQUNBLE1BQU0sc0JBQWE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsVUFBVTtBQUN6QiwyQ0FBMkMsVUFBVTtBQUNyRCx5Q0FBeUMsVUFBVTtBQUNuRCxxQ0FBcUMsVUFBVTtBQUMvQyxzQ0FBc0MsVUFBVTtBQUNoRCw2QkFBNkIsVUFBVTtBQUN2QyxVQUFVO0FBQ1Ysd0NBQXdDLFVBQVU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFRO0FBQzdCLHFCQUFxQixNQUFxQztBQUMxRCx3QkFBd0IsQ0FFRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBLGlCQUFpQixvQkFBYTtBQUM5QjtBQUNBLFVBQVUsY0FBTztBQUNqQjtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsUUFBUSxjQUFPO0FBQ2Y7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQVE7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBUSxTQUFTLGNBQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBVyxDQUFDLElBQUk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQ0FBa0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBa0I7QUFDdkMscUJBQXFCO0FBQ3JCO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxZQUFZLFNBQVM7QUFDckI7QUFDQSx5QkFBeUIsZ0JBQVM7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQiwwQkFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQVE7QUFDbEI7QUFDQSxjQUFjLGNBQWM7QUFDNUIsNEJBQTRCLDBCQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBUTtBQUNsQixZQUFZLGNBQU87QUFDbkIsWUFBWSxvQkFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQUc7QUFDekI7QUFDQSw2QkFBNkIsMEJBQUcsQ0FBQyxvQkFBYTtBQUM5QztBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBLDJCQUEyQiwwQkFBRyxDQUFDLG9CQUFhO0FBQzVDO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUyx5QkFBeUIsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUywwQkFBMEIsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFVO0FBQzdCLDBCQUEwQixpQkFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0EscUJBQXFCLGdCQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQWE7QUFDM0Q7QUFDQTtBQUNBLDRDQUE0QyxvQkFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDLEdBQUcsRUFJNUM7QUFDVCxvQkFBb0IsaUJBQWlCO0FBQ3JDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsaUNBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixpQ0FBUTtBQUM3QjtBQUNBLDJDQUEyQyxpQ0FBUTtBQUNuRDtBQUNBLHlDQUF5QyxpQ0FBUTtBQUNqRDtBQUNBO0FBQ0EsZUFBZSxpQkFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFxQztBQUN0RCxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFxQztBQUN0RCxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVEsaUJBQWlCLFlBQVk7QUFDakQ7QUFDQSxnQkFBZ0IsS0FHMEMsRUFBRSxFQXFCL0M7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVMsbUNBQW1DLGtCQUFrQiwyRkFBMkYsZUFBUTtBQUN0TjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFRO0FBQzdCO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBTSxHQUFHLHVCQUF1QixZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRLG1DQUFtQyxpQkFBaUIsb0ZBQW9GLHFCQUFxQixTQUFTLGVBQVE7QUFDM087QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU0sbUNBQW1DLGVBQWUsa0ZBQWtGLHFCQUFxQixTQUFTLGVBQVE7QUFDck87QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQVEsU0FBUyxRQUFRLFNBQVMsZ0JBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLGtCQUFrQjtBQUNuQztBQUNBLDBGQUEwRixjQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNLG1DQUFtQyxlQUFlO0FBQzdHO0FBQ0EsbUVBQW1FLGVBQVEsU0FBUyxjQUFPO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRLG1DQUFtQyxpQkFBaUI7QUFDakg7QUFDQSxxRUFBcUUsZUFBUSxTQUFTLGNBQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQyx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQU0scUNBQXFDO0FBQ3BGO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQU0sbUNBQW1DO0FBQ2hGO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsU0FBUztBQUNULFFBQVEsS0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUMsR0FBRyxFQU81QztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFRLG9DQUFvQyxjQUFjO0FBQzdFLDJCQUEyQixlQUFRO0FBQ25DLFFBQVEsY0FBTztBQUNmLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFVO0FBQzlCLHdCQUF3QixnQkFBUztBQUNqQyxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBLHlCQUF5QixnQkFBUztBQUNsQyxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBLHlCQUF5QixnQkFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQWE7QUFDbkM7QUFDQSw0QkFBNEIsaUJBQVU7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixlQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBUztBQUNuQyxRQUFRLEtBQTRELEVBQUUsRUFFakU7QUFDTCxRQUFRLEtBQTJFLEVBQUUsRUFFaEY7QUFDTDtBQUNBLFFBQVEsb0JBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLFlBQVksYUFBTTtBQUNsQjtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLE1BQXFDLEtBQUssQ0FBMkQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCLE1BQXFDLEtBQUssQ0FBMkQ7QUFDdEgsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQVM7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QyxnQkFBUztBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixnQkFBUztBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLGdCQUFTO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQixNQUFxQztBQUN0RCxvQkFBb0IsQ0FBb0U7QUFDeEY7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUIsTUFBcUM7QUFDdEQsb0JBQW9CLENBQW9FO0FBQ3hGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFRO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsY0FBTztBQUNoQztBQUNBO0FBQ0EseUJBQXlCLG9CQUFhO0FBQ3RDO0FBQ0E7QUFDQSxvQkFBb0IsY0FBTztBQUMzQjtBQUNBO0FBQ0EseUJBQXlCLG9CQUFhO0FBQ3RDO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUIsZUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBUTtBQUM1QjtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHlCQUF5QixjQUFPO0FBQ2hDO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQWE7QUFDdEM7QUFDQTtBQUNBLG9CQUFvQixlQUFRO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsY0FBTztBQUNoQztBQUNBO0FBQ0EseUJBQXlCLG9CQUFhO0FBQ3RDO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBcUM7QUFDdEQsb0JBQW9CLENBQWtFO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUMsR0FBRyxFQVM1QztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBUTtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBUTtBQUNuQjs7QUFFQSxzQ0FBc0Msd0NBQWU7QUFDckQ7QUFDQTtBQUNBLFdBQVcsYUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQU0sR0FBRztBQUMzQyx3QkFBd0IsZUFBUSxlQUFlLGVBQVE7QUFDdkQ7QUFDQTtBQUNBLG1CQUFtQixDQUFDO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQVc7O0FBRXpCLFNBQVMsZ0JBQU87QUFDaEIsV0FBVyxjQUFPLGFBQWEsZUFBUTtBQUN2QztBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFRO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUIsZUFBUTtBQUN6QjtBQUNBLGdCQUFnQixlQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFNLEdBQUcsYUFBYSw0QkFBNEI7QUFDeEU7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQSxvQkFBb0IsZ0JBQU87QUFDM0IscUNBQXFDLFVBQVUsR0FBRyxNQUFNO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUIsZUFBUTtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCLGFBQU0sR0FBRztBQUN2QyxvQkFBb0IsZUFBUSxlQUFlLGVBQVE7QUFDbkQ7QUFDQTtBQUNBLGVBQWUsQ0FBQztBQUNoQjtBQUNBOztBQUVBLHVDQUF1Qyx3Q0FBZTtBQUN0RDtBQUNBO0FBQ0EsV0FBVyxhQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDREQUFZOztBQUUxQiwwQ0FBMEMsd0NBQWU7QUFDekQ7QUFDQTtBQUNBLFdBQVcsYUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLCtDQUErQyw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQWM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQTZELEVBQUUsRUFFbEU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQVE7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYSxvQkFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQSxRQUFRLGVBQVE7QUFDaEI7QUFDQTtBQUNBLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG9CQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBUztBQUNuQztBQUNBO0FBQ0EsUUFBUSxLQUFnRixFQUFFLEVBSXJGO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBLGlCQUFpQjtBQUNqQiwyQ0FBMkMsaUNBQWlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDLDJCQUEyQix5QkFBeUI7QUFDcEQsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFVO0FBQ3RCO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLGVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Y7QUFDQSxTQUFTLGVBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFNLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFRO0FBQ3JCLGdCQUFnQixjQUFPO0FBQ3ZCLGdCQUFnQixlQUFRO0FBQ3hCO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkNBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQixNQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsMkNBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG9EQUFvRCxnQkFBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEVBQUUsTUFBcUMsSUFBSSxDQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IscUJBQXFCLDJDQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDLEdBQUcsRUFFNUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFNLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVksdUJBQXVCLDZDQUE2QztBQUNsSTtBQUNBLGlDQUFpQztBQUNqQyxnREFBZ0QsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQ0FBUztBQUNqQjtBQUNBLGtCQUFrQixNQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsb0NBQVc7QUFDbkI7QUFDQSxrQkFBa0IsTUFBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBUztBQUNwQztBQUNBLFdBQVcsZUFBUTtBQUNuQixvQkFBb0IsMEJBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFRO0FBQ2xCO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLDRCQUE0QiwwQkFBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQVE7QUFDbEIsWUFBWSxjQUFPO0FBQ25CLFlBQVksb0JBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUFHO0FBQ3pCO0FBQ0EsNkJBQTZCLDBCQUFHLENBQUMsb0JBQWE7QUFDOUM7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLDJCQUEyQiwwQkFBRyxDQUFDLG9CQUFhO0FBQzVDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUyx5QkFBeUIsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUywwQkFBMEIsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFVO0FBQy9CO0FBQ0EsNkJBQTZCLGlCQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0JBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFRO0FBQzNCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLGlDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixpQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QixpQ0FBUTtBQUNwQywwQkFBMEIsaUNBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FB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QUFDQTtBQUNBOztBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/NjY5MCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/NDRiMiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanM/YTFlOSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzPzVjNDAiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcz8zYmZkIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzPzgzMGYiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AaW50bGlmeS9zaGFyZWQvZGlzdC9zaGFyZWQubWpzP2YxMWUiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AaW50bGlmeS9tZXNzYWdlLWNvbXBpbGVyL2Rpc3QvbWVzc2FnZS1jb21waWxlci5lc20tYnJvd3Nlci5qcz84ODkxIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvQGludGxpZnkvZGV2dG9vbHMtaWYvZGlzdC9kZXZ0b29scy1pZi5tanM/YmUyNiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0BpbnRsaWZ5L2NvcmUtYmFzZS9kaXN0L2NvcmUtYmFzZS5tanM/OWRlNyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vZW52LmpzP2FiYzUiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2NvbnN0LmpzP2I3NzQiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL3RpbWUuanM/NTEzNCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vcHJveHkuanM/ZjMwYSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vaW5kZXguanM/M2Y0ZSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL0BpbnRsaWZ5L3Z1ZS1kZXZ0b29scy9kaXN0L3Z1ZS1kZXZ0b29scy5tanM/MWIzYiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL3Z1ZS1pMThuL2Rpc3QvdnVlLWkxOG4ubWpzP2Q2MzAiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9pMThuL2kxOG4uanM/MDY5MiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/YTQ5NiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/NjEzMyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9CYXNpY0Ryb3BEb3duLnZ1ZT9jOWZlIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL0Jhc2ljRHJvcERvd24udnVlP2FlN2QiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL1N2Z0ljb24udnVlP2ZiN2EiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL1N2Z0ljb24udnVlPzJmMWIiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL1N2Z0ljb24udnVlPzZmYWIiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL1N2Z0ljb24udnVlP2IyYjciLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL0ljb25UcmlhbmdsZS52dWU/MmQ0MyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvaWNvbnMvSWNvblRyaWFuZ2xlLnZ1ZT9mZDQ1Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9pY29ucy9JY29uVHJpYW5nbGUudnVlPzhjMDUiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL0ljb25DaGVjay52dWU/ZTc5NyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvaWNvbnMvSWNvbkNoZWNrLnZ1ZT9hOGUxIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9pY29ucy9JY29uQ2hlY2sudnVlPzhlOWEiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy92dWUzLWNsaWNrLWF3YXkvZGlzdC9tb2R1bGUuanM/M2ViZCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9CYXNpY0Ryb3BEb3duLnZ1ZT9mZmIxIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL0Jhc2ljRHJvcERvd24udnVlP2JkZDYiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vQmFzaWNEcm9wRG93bi52dWU/NWMzYiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hJbnB1dC52dWU/ZDRjOCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hJbnB1dC52dWU/MzVkMSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvaWNvbnMvSWNvbkNyb3NzLnZ1ZT84NjI1Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9pY29ucy9JY29uQ3Jvc3MudnVlPzM2YjMiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL0ljb25Dcm9zcy52dWU/ODhiMCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hJbnB1dC52dWU/YTI0NCIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hJbnB1dC52dWU/N2JhNiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hJbnB1dC52dWU/ZTMxMSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hBdXRvQ29tcGxldGUudnVlPzY5NTciLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT83MmJjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/MWQwZSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWFyY2hBdXRvQ29tcGxldGUudnVlP2U1NzEiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT9jOGU2Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL0Jhc2ljSW5wdXQudnVlPzg2ZWIiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vQmFzaWNJbnB1dC52dWU/OGU0YSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9CYXNpY0lucHV0LnZ1ZT80MmNjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL0Jhc2ljSW5wdXQudnVlPzM2ZGYiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZT9kOWNkIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/MDdjYyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlPzliZDAiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZT83ZjhjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/NzY2NSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWxlY3RXaXRoQ2hpcHMudnVlPzJhYjkiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0V2l0aENoaXBzLnZ1ZT9mMjNiIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1NlbGVjdFdpdGhDaGlwcy52dWU/M2Y1MyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWxlY3RXaXRoQ2hpcHMudnVlPzVlNjEiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0V2l0aENoaXBzLnZ1ZT82Yzk3Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT9jYWI1Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT85MjgwIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT8xNWM1Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT9iZGYyIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9OZXdTdWdnZXN0aW9uLnZ1ZT8wYmNjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9OZXdTdWdnZXN0aW9uLnZ1ZT8wNGI0Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9OZXdTdWdnZXN0aW9uLnZ1ZT9hZWQxIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9OZXdTdWdnZXN0aW9uLnZ1ZT9jOWEzIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlPzk2MDQiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9DZW50ZXJlZERpYWxvZy52dWU/NmVmOSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL0NlbnRlcmVkRGlhbG9nLnZ1ZT80NWRjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlP2U5NzMiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9DZW50ZXJlZERpYWxvZy52dWU/ODBkYSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL1N1Y2Nlc3NNZXNzYWdlLnZ1ZT9mZmU0Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlPzBjNzMiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9TdWNjZXNzTWVzc2FnZS52dWU/YTZhNiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL1N1Y2Nlc3NNZXNzYWdlLnZ1ZT84NGVlIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlPzFjZDkiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWU/NGQxNyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL0ZhaWx1cmVNZXNzYWdlLnZ1ZT8zNTc3Iiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vRmFpbHVyZU1lc3NhZ2UudnVlPzA0Y2YiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWU/NTRiZSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/NTk4MSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/OTNlYSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/ZTg5NiIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/YWNhZSIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvRWRpdFN1Z2dlc3Rpb24udnVlPzExOGEiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL0VkaXRTdWdnZXN0aW9uLnZ1ZT8wNzdiIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9FZGl0U3VnZ2VzdGlvbi52dWU/MWEzMyIsIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvRWRpdFN1Z2dlc3Rpb24udnVlPzI5MGUiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL0VkaXRTdWdnZXN0aW9uLnZ1ZT8xYjhjIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT9jZjcyIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT8zMDQyIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT81MjFmIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT8yNWRmIiwid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvbWFpbi5qcz81NmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXHJcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXHJcbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXHJcbiAqL1xyXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcclxuICAgIFsxIC8qIFRFWFQgKi9dOiBgVEVYVGAsXHJcbiAgICBbMiAvKiBDTEFTUyAqL106IGBDTEFTU2AsXHJcbiAgICBbNCAvKiBTVFlMRSAqL106IGBTVFlMRWAsXHJcbiAgICBbOCAvKiBQUk9QUyAqL106IGBQUk9QU2AsXHJcbiAgICBbMTYgLyogRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcclxuICAgIFszMiAvKiBIWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXHJcbiAgICBbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXHJcbiAgICBbMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFsyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFs1MTIgLyogTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcclxuICAgIFsxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXHJcbiAgICBbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXHJcbiAgICBbLTEgLyogSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcclxuICAgIFstMiAvKiBCQUlMICovXTogYEJBSUxgXHJcbn07XG5cbi8qKlxyXG4gKiBEZXYgb25seVxyXG4gKi9cclxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcclxuICAgIFsxIC8qIFNUQUJMRSAqL106ICdTVEFCTEUnLFxyXG4gICAgWzIgLyogRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcclxuICAgIFszIC8qIEZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXHJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXHJcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcclxuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XHJcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxyXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcclxuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XHJcbiAgICAvLyBjb21wYXJpc29uXHJcbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xyXG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXHJcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xyXG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY291bnQgKz1cclxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG59XG5cbi8qKlxyXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxyXG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XHJcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxyXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cclxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxyXG4gKiAtIGlzbWFwIC0+IGlzTWFwXHJcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcclxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcclxuICogLSByZWFkb25seSAtPiByZWFkT25seVxyXG4gKi9cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcclxuLyoqXHJcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cclxuICovXHJcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXHJcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcclxuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xyXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcclxuLyoqXHJcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cclxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxyXG4gKi9cclxuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XHJcbn1cclxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xyXG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XHJcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcclxuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcclxuICAgIGlmIChpc1Vuc2FmZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcclxufVxyXG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcclxuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXHJcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXHJcbiAgICBodG1sRm9yOiAnZm9yJyxcclxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXHJcbn07XHJcbi8qKlxyXG4gKiBDU1MgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBwbGFpbiBudW1iZXJzXHJcbiAqL1xyXG5jb25zdCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsYm9yZGVyLWltYWdlLW91dHNldCxib3JkZXItaW1hZ2Utc2xpY2UsYCArXHJcbiAgICBgYm9yZGVyLWltYWdlLXdpZHRoLGJveC1mbGV4LGJveC1mbGV4LWdyb3VwLGJveC1vcmRpbmFsLWdyb3VwLGNvbHVtbi1jb3VudCxgICtcclxuICAgIGBjb2x1bW5zLGZsZXgsZmxleC1ncm93LGZsZXgtcG9zaXRpdmUsZmxleC1zaHJpbmssZmxleC1uZWdhdGl2ZSxmbGV4LW9yZGVyLGAgK1xyXG4gICAgYGdyaWQtcm93LGdyaWQtcm93LWVuZCxncmlkLXJvdy1zcGFuLGdyaWQtcm93LXN0YXJ0LGdyaWQtY29sdW1uLGAgK1xyXG4gICAgYGdyaWQtY29sdW1uLWVuZCxncmlkLWNvbHVtbi1zcGFuLGdyaWQtY29sdW1uLXN0YXJ0LGZvbnQtd2VpZ2h0LGxpbmUtY2xhbXAsYCArXHJcbiAgICBgbGluZS1oZWlnaHQsb3BhY2l0eSxvcmRlcixvcnBoYW5zLHRhYi1zaXplLHdpZG93cyx6LWluZGV4LHpvb20sYCArXHJcbiAgICAvLyBTVkdcclxuICAgIGBmaWxsLW9wYWNpdHksZmxvb2Qtb3BhY2l0eSxzdG9wLW9wYWNpdHksc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGhgKTtcclxuLyoqXHJcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXHJcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXHJcbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcclxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXHJcbiAqL1xyXG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlXHJcbiAqL1xyXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxgICtcclxuICAgIGBhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxgICtcclxuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcclxuICAgIGBjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGAgK1xyXG4gICAgYGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxgICtcclxuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXHJcbiAgICBgZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsYCArXHJcbiAgICBgZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxgICtcclxuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xyXG4gICAgYGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGAgK1xyXG4gICAgYGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGAgK1xyXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXHJcbiAgICBgZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGAgK1xyXG4gICAgYGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsYCArXHJcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcclxuICAgIGBsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxgICtcclxuICAgIGBtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxgICtcclxuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xyXG4gICAgYG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLGAgK1xyXG4gICAgYG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLGAgK1xyXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xyXG4gICAgYHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLGAgK1xyXG4gICAgYHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxgICtcclxuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcclxuICAgIGByZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxgICtcclxuICAgIGBzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LGAgK1xyXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcclxuICAgIGBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2UsYCArXHJcbiAgICBgc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcclxuICAgIGBzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLGAgK1xyXG4gICAgYHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLGAgK1xyXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXHJcbiAgICBgdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLGAgK1xyXG4gICAgYHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LGAgK1xyXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcclxuICAgIGB3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSxgICtcclxuICAgIGB4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLGAgK1xyXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcclxuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XHJcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XHJcbiAgICBsZXQgcmV0ID0gJyc7XHJcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcclxuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXHJcbiAgICAnZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsJyArXHJcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcclxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XHJcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcclxufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcclxuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xyXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcclxufVxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcclxuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcclxufVxuXG4vKipcclxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxyXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xyXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcclxuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xyXG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XHJcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XHJcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcclxuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXHJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcclxuICAgIGtleSAhPT0gJ05hTicgJiZcclxuICAgIGtleVswXSAhPT0gJy0nICYmXHJcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXHJcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xyXG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxyXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcclxuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcclxuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xyXG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxyXG4gICAgICAgID8gYF9fcHJvcHMuJHtuYW1lfWBcclxuICAgICAgICA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XHJcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsIi8qKlxyXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcclxuICogaXMgaW4gdGhhdCBtYXAuXHJcbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXHJcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXHJcbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXHJcbiAqL1xyXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcclxuICAgIFsxIC8qIFRFWFQgKi9dOiBgVEVYVGAsXHJcbiAgICBbMiAvKiBDTEFTUyAqL106IGBDTEFTU2AsXHJcbiAgICBbNCAvKiBTVFlMRSAqL106IGBTVFlMRWAsXHJcbiAgICBbOCAvKiBQUk9QUyAqL106IGBQUk9QU2AsXHJcbiAgICBbMTYgLyogRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcclxuICAgIFszMiAvKiBIWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXHJcbiAgICBbNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXHJcbiAgICBbMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFsyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcclxuICAgIFs1MTIgLyogTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcclxuICAgIFsxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXHJcbiAgICBbMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXHJcbiAgICBbLTEgLyogSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcclxuICAgIFstMiAvKiBCQUlMICovXTogYEJBSUxgXHJcbn07XG5cbi8qKlxyXG4gKiBEZXYgb25seVxyXG4gKi9cclxuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcclxuICAgIFsxIC8qIFNUQUJMRSAqL106ICdTVEFCTEUnLFxyXG4gICAgWzIgLyogRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcclxuICAgIFszIC8qIEZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXHJcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXHJcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcclxuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XHJcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcclxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxyXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcclxuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XHJcbiAgICAvLyBjb21wYXJpc29uXHJcbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xyXG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXHJcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xyXG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY291bnQgKz1cclxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG59XG5cbi8qKlxyXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxyXG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XHJcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxyXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cclxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxyXG4gKiAtIGlzbWFwIC0+IGlzTWFwXHJcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcclxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcclxuICogLSByZWFkb25seSAtPiByZWFkT25seVxyXG4gKi9cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcclxuLyoqXHJcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cclxuICovXHJcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXHJcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcclxuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xyXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcclxuLyoqXHJcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cclxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxyXG4gKi9cclxuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XHJcbn1cclxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xyXG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XHJcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcclxuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcclxuICAgIGlmIChpc1Vuc2FmZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcclxufVxyXG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcclxuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXHJcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXHJcbiAgICBodG1sRm9yOiAnZm9yJyxcclxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXHJcbn07XHJcbi8qKlxyXG4gKiBDU1MgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBwbGFpbiBudW1iZXJzXHJcbiAqL1xyXG5jb25zdCBpc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsYm9yZGVyLWltYWdlLW91dHNldCxib3JkZXItaW1hZ2Utc2xpY2UsYCArXHJcbiAgICBgYm9yZGVyLWltYWdlLXdpZHRoLGJveC1mbGV4LGJveC1mbGV4LWdyb3VwLGJveC1vcmRpbmFsLWdyb3VwLGNvbHVtbi1jb3VudCxgICtcclxuICAgIGBjb2x1bW5zLGZsZXgsZmxleC1ncm93LGZsZXgtcG9zaXRpdmUsZmxleC1zaHJpbmssZmxleC1uZWdhdGl2ZSxmbGV4LW9yZGVyLGAgK1xyXG4gICAgYGdyaWQtcm93LGdyaWQtcm93LWVuZCxncmlkLXJvdy1zcGFuLGdyaWQtcm93LXN0YXJ0LGdyaWQtY29sdW1uLGAgK1xyXG4gICAgYGdyaWQtY29sdW1uLWVuZCxncmlkLWNvbHVtbi1zcGFuLGdyaWQtY29sdW1uLXN0YXJ0LGZvbnQtd2VpZ2h0LGxpbmUtY2xhbXAsYCArXHJcbiAgICBgbGluZS1oZWlnaHQsb3BhY2l0eSxvcmRlcixvcnBoYW5zLHRhYi1zaXplLHdpZG93cyx6LWluZGV4LHpvb20sYCArXHJcbiAgICAvLyBTVkdcclxuICAgIGBmaWxsLW9wYWNpdHksZmxvb2Qtb3BhY2l0eSxzdG9wLW9wYWNpdHksc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGhgKTtcclxuLyoqXHJcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXHJcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXHJcbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcclxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXHJcbiAqL1xyXG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcclxuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcclxuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcclxuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXHJcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXHJcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xyXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXHJcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xyXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcclxuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xyXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcclxuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xyXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcclxuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcclxuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlXHJcbiAqL1xyXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxgICtcclxuICAgIGBhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxgICtcclxuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcclxuICAgIGBjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGAgK1xyXG4gICAgYGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxgICtcclxuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXHJcbiAgICBgZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsYCArXHJcbiAgICBgZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxgICtcclxuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xyXG4gICAgYGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGAgK1xyXG4gICAgYGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGAgK1xyXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXHJcbiAgICBgZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGAgK1xyXG4gICAgYGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsYCArXHJcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcclxuICAgIGBsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxgICtcclxuICAgIGBtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxgICtcclxuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xyXG4gICAgYG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLGAgK1xyXG4gICAgYG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLGAgK1xyXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xyXG4gICAgYHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLGAgK1xyXG4gICAgYHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxgICtcclxuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcclxuICAgIGByZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxgICtcclxuICAgIGBzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LGAgK1xyXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcclxuICAgIGBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2UsYCArXHJcbiAgICBgc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sYCArXHJcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcclxuICAgIGBzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLGAgK1xyXG4gICAgYHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLGAgK1xyXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXHJcbiAgICBgdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLGAgK1xyXG4gICAgYHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LGAgK1xyXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcclxuICAgIGB3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSxgICtcclxuICAgIGB4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLGAgK1xyXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcclxuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlclJFKS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XHJcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XHJcbiAgICBsZXQgcmV0ID0gJyc7XHJcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcclxuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgIH1cclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzO1xyXG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxyXG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcclxuICAgICdoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXHJcbiAgICAnZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsJyArXHJcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcclxuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xyXG59XHJcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcclxuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcclxuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XHJcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcclxufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcclxuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xyXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcclxufVxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcclxuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcclxufVxuXG4vKipcclxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxyXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xyXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcclxuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xyXG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XHJcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XHJcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcclxuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXHJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcclxuICAgIGtleSAhPT0gJ05hTicgJiZcclxuICAgIGtleVswXSAhPT0gJy0nICYmXHJcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXHJcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xyXG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxyXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcclxuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcclxuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xyXG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxyXG4gICAgICAgID8gYF9fcHJvcHMuJHtuYW1lfWBcclxuICAgICAgICA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XHJcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsImltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaGFzT3duLCBpc1N5bWJvbCwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnfWAsIC4uLmFyZ3MpO1xyXG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcclxuY2xhc3MgRWZmZWN0U2NvcGUge1xyXG4gICAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsZWFudXBzID0gW107XHJcbiAgICAgICAgaWYgKCFkZXRhY2hlZCAmJiBhY3RpdmVFZmZlY3RTY29wZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4ID1cclxuICAgICAgICAgICAgICAgIChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaCh0aGlzKSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcnVuKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgb24oKSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgb2ZmKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBzdG9wKGZyb21QYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgbGV0IGksIGw7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbmVzdGVkIHNjb3BlLCBkZXJlZmVyZW5jZSBmcm9tIHBhcmVudCB0byBhdm9pZCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcclxuICAgIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlY29yZEVmZmVjdFNjb3BlKGVmZmVjdCwgc2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZSkge1xyXG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcclxuICAgIHJldHVybiBhY3RpdmVFZmZlY3RTY29wZTtcclxufVxyXG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbikge1xyXG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVgICtcclxuICAgICAgICAgICAgYCB0byBiZSBhc3NvY2lhdGVkIHdpdGguYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcclxuICAgIGNvbnN0IGRlcCA9IG5ldyBTZXQoZWZmZWN0cyk7XHJcbiAgICBkZXAudyA9IDA7XHJcbiAgICBkZXAubiA9IDA7XHJcbiAgICByZXR1cm4gZGVwO1xyXG59O1xyXG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xyXG5jb25zdCBuZXdUcmFja2VkID0gKGRlcCkgPT4gKGRlcC5uICYgdHJhY2tPcEJpdCkgPiAwO1xyXG5jb25zdCBpbml0RGVwTWFya2VycyA9ICh7IGRlcHMgfSkgPT4ge1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0udyB8PSB0cmFja09wQml0OyAvLyBzZXQgd2FzIHRyYWNrZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHB0ciA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlcCA9IGRlcHNbaV07XHJcbiAgICAgICAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwLmRlbGV0ZShlZmZlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwc1twdHIrK10gPSBkZXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2xlYXIgYml0c1xyXG4gICAgICAgICAgICBkZXAudyAmPSB+dHJhY2tPcEJpdDtcclxuICAgICAgICAgICAgZGVwLm4gJj0gfnRyYWNrT3BCaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gcHRyO1xyXG4gICAgfVxyXG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4vLyBUaGUgbnVtYmVyIG9mIGVmZmVjdHMgY3VycmVudGx5IGJlaW5nIHRyYWNrZWQgcmVjdXJzaXZlbHkuXHJcbmxldCBlZmZlY3RUcmFja0RlcHRoID0gMDtcclxubGV0IHRyYWNrT3BCaXQgPSAxO1xyXG4vKipcclxuICogVGhlIGJpdHdpc2UgdHJhY2sgbWFya2VycyBzdXBwb3J0IGF0IG1vc3QgMzAgbGV2ZWxzIG9mIHJlY3Vyc2lvbi5cclxuICogVGhpcyB2YWx1ZSBpcyBjaG9zZW4gdG8gZW5hYmxlIG1vZGVybiBKUyBlbmdpbmVzIHRvIHVzZSBhIFNNSSBvbiBhbGwgcGxhdGZvcm1zLlxyXG4gKiBXaGVuIHJlY3Vyc2lvbiBkZXB0aCBpcyBncmVhdGVyLCBmYWxsIGJhY2sgdG8gdXNpbmcgYSBmdWxsIGNsZWFudXAuXHJcbiAqL1xyXG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XHJcbmxldCBhY3RpdmVFZmZlY3Q7XHJcbmNvbnN0IElURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdpdGVyYXRlJyA6ICcnKTtcclxuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcclxuY2xhc3MgUmVhY3RpdmVFZmZlY3Qge1xyXG4gICAgY29uc3RydWN0b3IoZm4sIHNjaGVkdWxlciA9IG51bGwsIHNjb3BlKSB7XHJcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBzY29wZSk7XHJcbiAgICB9XHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGFyZW50ID0gYWN0aXZlRWZmZWN0O1xyXG4gICAgICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcclxuICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcclxuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCArK2VmZmVjdFRyYWNrRGVwdGg7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICAgICAgICAgIGluaXREZXBNYXJrZXJzKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xlYW51cEVmZmVjdCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgICAgICAgICAgZmluYWxpemVEZXBNYXJrZXJzKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gbGFzdFNob3VsZFRyYWNrO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmZXJTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgLy8gc3RvcHBlZCB3aGlsZSBydW5uaW5nIGl0c2VsZiAtIGRlZmVyIHRoZSBjbGVhbnVwXHJcbiAgICAgICAgaWYgKGFjdGl2ZUVmZmVjdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwRWZmZWN0KGVmZmVjdCkge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucykge1xyXG4gICAgaWYgKGZuLmVmZmVjdCkge1xyXG4gICAgICAgIGZuID0gZm4uZWZmZWN0LmZuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XHJcbiAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgIGV4dGVuZChfZWZmZWN0LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSlcclxuICAgICAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUoX2VmZmVjdCwgb3B0aW9ucy5zY29wZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xyXG4gICAgICAgIF9lZmZlY3QucnVuKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5uZXIgPSBfZWZmZWN0LnJ1bi5iaW5kKF9lZmZlY3QpO1xyXG4gICAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XHJcbiAgICByZXR1cm4gcnVubmVyO1xyXG59XHJcbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XHJcbiAgICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcclxufVxyXG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG5jb25zdCB0cmFja1N0YWNrID0gW107XHJcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xyXG4gICAgICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFkZXApIHtcclxuICAgICAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gY3JlYXRlRGVwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcclxuICAgIGxldCBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG4gICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XHJcbiAgICAgICAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7IC8vIHNldCBuZXdseSB0cmFja2VkXHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gIXdhc1RyYWNrZWQoZGVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBGdWxsIGNsZWFudXAgbW9kZS5cclxuICAgICAgICBzaG91bGRUcmFjayA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkVHJhY2spIHtcclxuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYWN0aXZlRWZmZWN0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogYWN0aXZlRWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcclxuICAgIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwcyA9IFtdO1xyXG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIiAvKiBDTEVBUiAqLykge1xyXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxyXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxyXG4gICAgICAgIGRlcHMgPSBbLi4uZGVwc01hcC52YWx1ZXMoKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXHJcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogQUREICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFNFVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IHsgdGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0IH1cclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGlmIChkZXBzWzBdKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXApIHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaCguLi5kZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpLCBldmVudEluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICAvLyBzcHJlYWQgaW50byBhcnJheSBmb3Igc3RhYmlsaXphdGlvblxyXG4gICAgY29uc3QgZWZmZWN0cyA9IGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xyXG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xyXG4gICAgICAgIGlmIChlZmZlY3QuY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcclxuICAgICAgICBpZiAoIWVmZmVjdC5jb21wdXRlZCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9uVHJpZ2dlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdCB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3Quc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5zY2hlZHVsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcclxuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxyXG4vKiNfX1BVUkVfXyovXHJcbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcclxuICAgIC8vIGlvczEwLnggT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKSBjYW4gZW51bWVyYXRlICdhcmd1bWVudHMnIGFuZCAnY2FsbGVyJ1xyXG4gICAgLy8gYnV0IGFjY2Vzc2luZyB0aGVtIG9uIFN5bWJvbCBsZWFkcyB0byBUeXBlRXJyb3IgYmVjYXVzZSBTeW1ib2wgaXMgYSBzdHJpY3QgbW9kZVxyXG4gICAgLy8gZnVuY3Rpb25cclxuICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ2FyZ3VtZW50cycgJiYga2V5ICE9PSAnY2FsbGVyJylcclxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxyXG4gICAgLmZpbHRlcihpc1N5bWJvbCkpO1xyXG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xyXG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xyXG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcclxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyojX19QVVJFX18qLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xyXG4gICAgWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovICYmXHJcbiAgICAgICAgICAgIHJlY2VpdmVyID09PVxyXG4gICAgICAgICAgICAgICAgKGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFjdGl2ZU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIHNraXAgdW53cmFwIGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXHJcbiAgICAgICAgICAgIC8vIGhlcmUgdG8gYXZvaWQgaW52YWxpZCB2YWx1ZSB3YXJuaW5nLiBBbHNvIG5lZWQgdG8gbGF6eSBhY2Nlc3MgcmVhZG9ubHlcclxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuY29uc3Qgc2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd1NldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxyXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxyXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcclxuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcclxuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQsXHJcbiAgICBzZXQsXHJcbiAgICBkZWxldGVQcm9wZXJ0eSxcclxuICAgIGhhcyxcclxuICAgIG93bktleXNcclxufTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcclxuICAgIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd0dldCxcclxuICAgIHNldDogc2hhbGxvd1NldFxyXG59KTtcclxuLy8gUHJvcHMgaGFuZGxlcnMgYXJlIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2hvdWxkIG5vdCB1bndyYXAgdG9wLWxldmVsXHJcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcclxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcclxuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcclxuZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIC8vICMxNzcyOiByZWFkb25seShyZWFjdGl2ZShNYXApKSBzaG91bGQgcmV0dXJuIHJlYWRvbmx5ICsgcmVhY3RpdmUgdmVyc2lvblxyXG4gICAgLy8gb2YgdGhlIHZhbHVlXHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIHJhd0tleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcclxuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgICAgIC8vICMzNjAyIHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5lc3RlZCByZWFjdGl2ZSBgTWFwYCBjYW4gZG8gdHJhY2tpbmcgZm9yIGl0c2VsZlxyXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywgcmF3S2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxyXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXHJcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgJ3NpemUnLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgIGlmIChoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xyXG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgID8gbmV3IE1hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XHJcbiAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiIC8qIENMRUFSICovLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG1ha2Ugc3VyZSB0aGUgY2FsbGJhY2sgaXNcclxuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXHJcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcclxuICAgICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09ICdrZXlzJyAmJiB0YXJnZXRJc01hcDtcclxuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJlxyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxyXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJywgU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICBdO1xyXG59XHJcbmNvbnN0IFttdXRhYmxlSW5zdHJ1bWVudGF0aW9ucywgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc10gPSAvKiAjX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgIDogaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgICAgICAgPyBpbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xyXG4gICAgICAgICAgICBgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcclxuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xyXG4gICAgICAgICAgICBgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgICAgICBjYXNlICdPYmplY3QnOlxyXG4gICAgICAgIGNhc2UgJ0FycmF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xyXG4gICAgICAgIGNhc2UgJ01hcCc6XHJcbiAgICAgICAgY2FzZSAnU2V0JzpcclxuICAgICAgICBjYXNlICdXZWFrTWFwJzpcclxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcclxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXHJcbiAgICAgICAgPyAwIC8qIElOVkFMSUQgKi9cclxuICAgICAgICA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxyXG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxyXG4gKiByb290IGxldmVsKS5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycywgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcclxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxyXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XHJcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5LCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBzcGVjaWZpYyB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXHJcbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XHJcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUkFXICovXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcblxuZnVuY3Rpb24gdHJhY2tSZWZWYWx1ZShyZWYpIHtcclxuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcclxuICAgICAgICByZWYgPSB0b1JhdyhyZWYpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSksIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBHRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWZWYWx1ZShyZWYsIG5ld1ZhbCkge1xyXG4gICAgcmVmID0gdG9SYXcocmVmKTtcclxuICAgIGlmIChyZWYuZGVwKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhyZWYuZGVwLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogU0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKHJlZi5kZXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcclxufVxyXG5jbGFzcyBSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBfX3ZfaXNTaGFsbG93KSB7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNTaGFsbG93ID0gX192X2lzU2hhbGxvdztcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1JlYWN0aXZlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICBuZXdWYWwgPSB0aGlzLl9fdl9pc1NoYWxsb3cgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyA/IG5ld1ZhbCA6IHRvUmVhY3RpdmUobmV3VmFsKTtcclxuICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XHJcbiAgICB0cmlnZ2VyUmVmVmFsdWUocmVmLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVmKHJlZikge1xyXG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XHJcbn1cclxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcclxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXHJcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xyXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrUmVmVmFsdWUodGhpcyksICgpID0+IHRyaWdnZXJSZWZWYWx1ZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xyXG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xyXG4gICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcclxuICAgIHJldHVybiBpc1JlZih2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpO1xyXG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHksIGlzU1NSKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gX3NldHRlcjtcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWlzU1NSO1xyXG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcclxuICAgICAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xyXG4gICAgICAgICAgICBzZWxmLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLl92YWx1ZSA9IHNlbGYuZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZi5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICBpZiAob25seUdldHRlcikge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIG9ubHlHZXR0ZXIgfHwgIXNldHRlciwgaXNTU1IpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xyXG4gICAgICAgIGNSZWYuZWZmZWN0Lm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY1JlZjtcclxufVxuXG52YXIgX2E7XHJcbmNvbnN0IHRpY2sgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgcXVldWVkID0gZmFsc2U7XHJcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xyXG4gICAgcXVldWUucHVzaChmbik7XHJcbiAgICBpZiAoIXF1ZXVlZCkge1xyXG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgdGljay50aGVuKGZsdXNoKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZmx1c2ggPSAoKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcXVldWVbaV0oKTtcclxuICAgIH1cclxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICBxdWV1ZWQgPSBmYWxzZTtcclxufTtcclxuY2xhc3MgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0dGVyKSB7XHJcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzW19hXSA9IHRydWU7XHJcbiAgICAgICAgbGV0IGNvbXBhcmVUYXJnZXQ7XHJcbiAgICAgICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoY29tcHV0ZWRUcmlnZ2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVUYXJnZXQgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlZHVsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWZmZWN0LmFjdGl2ZSAmJiB0aGlzLl9nZXQoKSAhPT0gdmFsdWVUb0NvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgdXBzdHJlYW0gY29tcHV0ZWRzIGFyZSBub3RpZmllZCBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZVxyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgaW52YWxpZGF0aW9uIGluIGNhc2Ugb2Ygc3luYyBhY2Nlc3M7IG5vcm1hbCBlZmZlY3RzIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQgdG8gYmUgdHJpZ2dlcmVkIGluIHNjaGVkdWxlci5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmRlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNvbXB1dGVkIGluc3RhbmNlb2YgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY2hlZHVsZXIodHJ1ZSAvKiBjb21wdXRlZFRyaWdnZXIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgX2dldCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9IHRoaXMuZWZmZWN0LnJ1bigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xyXG4gICAgfVxyXG59XHJcbl9hID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovO1xyXG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xyXG4gICAgcmV0dXJuIG5ldyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbChnZXR0ZXIpO1xyXG59XG5cbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIGNvbXB1dGVkLCBjdXN0b21SZWYsIGRlZmVycmVkQ29tcHV0ZWQsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGVuYWJsZVRyYWNraW5nLCBnZXRDdXJyZW50U2NvcGUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uU2NvcGVEaXNwb3NlLCBwYXVzZVRyYWNraW5nLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyYWNrLCB0cmlnZ2VyLCB0cmlnZ2VyUmVmLCB1bnJlZiB9O1xuIiwiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBpc1NoYWxsb3cgYXMgaXNTaGFsbG93JDEsIGlzUmVhY3RpdmUsIFJlYWN0aXZlRWZmZWN0LCByZWYsIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIEVmZmVjdFNjb3BlLCBtYXJrUmF3LCBwcm94eVJlZnMsIGNvbXB1dGVkIGFzIGNvbXB1dGVkJDEsIGlzUmVhZG9ubHkgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuZXhwb3J0IHsgRWZmZWN0U2NvcGUsIFJlYWN0aXZlRWZmZWN0LCBjdXN0b21SZWYsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRTY29wZSwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIGlzU2hhbGxvdywgbWFya1Jhdywgb25TY29wZURpc3Bvc2UsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgTk9PUCwgZ2V0R2xvYmFsVGhpcywgZXh0ZW5kLCBFTVBUWV9PQkosIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIGh5cGhlbmF0ZSwgY2FtZWxpemUsIGlzT24sIGhhc093biwgaXNNb2RlbExpc3RlbmVyLCBoYXNDaGFuZ2VkLCByZW1vdmUsIGlzT2JqZWN0LCBpc1NldCwgaXNNYXAsIGlzUGxhaW5PYmplY3QsIGludm9rZUFycmF5Rm5zLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGNhcGl0YWxpemUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIE5PLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XHJcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xyXG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcG9wV2FybmluZ0NvbnRleHQoKSB7XHJcbiAgICBzdGFjay5wb3AoKTtcclxufVxyXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xyXG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcclxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XHJcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xyXG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogQVBQX1dBUk5fSEFORExFUiAqLywgW1xyXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcclxuICAgICAgICAgICAgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XHJcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xyXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXHJcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXHJcbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xyXG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gICAgY29uc3QgbG9ncyA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb2dzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcclxuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcclxuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XHJcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XHJcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcclxuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxyXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICByZXMucHVzaChgIC4uLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcclxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XHJcbiAgICBbXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqL106ICdzZXJ2ZXJQcmVmZXRjaCBob29rJyxcclxuICAgIFtcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXHJcbiAgICBbXCJjXCIgLyogQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxyXG4gICAgW1wiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXHJcbiAgICBbXCJtXCIgLyogTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcclxuICAgIFtcInVcIiAvKiBVUERBVEVEICovXTogJ3VwZGF0ZWQnLFxyXG4gICAgW1wiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcclxuICAgIFtcInVtXCIgLyogVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcclxuICAgIFtcImFcIiAvKiBBQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZGFcIiAvKiBERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcclxuICAgIFtcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXHJcbiAgICBbXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcclxuICAgIFswIC8qIFNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcclxuICAgIFsxIC8qIFJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxyXG4gICAgWzIgLyogV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcclxuICAgIFszIC8qIFdBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxyXG4gICAgWzQgLyogV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxyXG4gICAgWzUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzcgLyogVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcclxuICAgIFs4IC8qIERJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcclxuICAgIFs5IC8qIFRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxyXG4gICAgWzEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxyXG4gICAgWzExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcclxuICAgIFsxMiAvKiBGVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcclxuICAgIFsxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxyXG4gICAgWzE0IC8qIFNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xyXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZSdcclxufTtcclxuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgbGV0IHJlcztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcclxuICAgICAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcclxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgZmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQcmVGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcHJlRmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcclxuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcclxuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcclxuICAgIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XHJcbn1cclxuLy8gIzI3NjhcclxuLy8gVXNlIGJpbmFyeS1zZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHBvc2l0aW9uIGluIHRoZSBxdWV1ZSxcclxuLy8gc28gdGhhdCB0aGUgcXVldWUgbWFpbnRhaW5zIHRoZSBpbmNyZWFzaW5nIG9yZGVyIG9mIGpvYidzIGlkLFxyXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXHJcbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xyXG4gICAgLy8gdGhlIHN0YXJ0IGluZGV4IHNob3VsZCBiZSBgZmx1c2hJbmRleCArIDFgXHJcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcclxuICAgIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XHJcbiAgICAgICAgbWlkZGxlSm9iSWQgPCBpZCA/IChzdGFydCA9IG1pZGRsZSArIDEpIDogKGVuZCA9IG1pZGRsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhcnQ7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XHJcbiAgICAvLyB0aGUgZGVkdXBlIHNlYXJjaCB1c2VzIHRoZSBzdGFydEluZGV4IGFyZ3VtZW50IG9mIEFycmF5LmluY2x1ZGVzKClcclxuICAgIC8vIGJ5IGRlZmF1bHQgdGhlIHNlYXJjaCBpbmRleCBpbmNsdWRlcyB0aGUgY3VycmVudCBqb2IgdGhhdCBpcyBiZWluZyBydW5cclxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cclxuICAgIC8vIGlmIHRoZSBqb2IgaXMgYSB3YXRjaCgpIGNhbGxiYWNrLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgd2l0aCBhICsxIGluZGV4IHRvXHJcbiAgICAvLyBhbGxvdyBpdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiAtIGl0IGlzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG9cclxuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxyXG4gICAgaWYgKCghcXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgIXF1ZXVlLmluY2x1ZGVzKGpvYiwgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4KSkgJiZcclxuICAgICAgICBqb2IgIT09IGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYikge1xyXG4gICAgICAgIGlmIChqb2IuaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlRmx1c2goKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xyXG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xyXG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xyXG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcclxuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwcmVGbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsdXNoIHVudGlsIGl0IGRyYWluc1xyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XHJcbiAgICAvLyBmbHVzaCBhbnkgcHJlIGNicyBxdWV1ZWQgZHVyaW5nIHRoZSBmbHVzaCAoZS5nLiBwcmUgd2F0Y2hlcnMpXHJcbiAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XHJcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXHJcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIC8vIGNvbmRpdGlvbmFsIHVzYWdlIG9mIGNoZWNrUmVjdXJzaXZlVXBkYXRlIG11c3QgYmUgZGV0ZXJtaW5lZCBvdXQgb2ZcclxuICAgIC8vIHRyeSAuLi4gY2F0Y2ggYmxvY2sgc2luY2UgUm9sbHVwIGJ5IGRlZmF1bHQgZGUtb3B0aW1pemVzIHRyZWVzaGFraW5nXHJcbiAgICAvLyBpbnNpZGUgdHJ5LWNhdGNoLiBUaGlzIGNhbiBsZWF2ZSBhbGwgd2FybmluZyBjb2RlIHVuc2hha2VkLiBBbHRob3VnaFxyXG4gICAgLy8gdGhleSB3b3VsZCBnZXQgZXZlbnR1YWxseSBzaGFrZW4gYnkgYSBtaW5pZmllciBsaWtlIHRlcnNlciwgc29tZSBtaW5pZmllcnNcclxuICAgIC8vIHdvdWxkIGZhaWwgdG8gZG8gdGhhdCAoZS5nLiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZXNidWlsZC9pc3N1ZXMvMTYxMClcclxuICAgIGNvbnN0IGNoZWNrID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKVxyXG4gICAgICAgIDogTk9PUDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrKGpvYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBydW5uaW5nOmAsIGpvYi5pZClcclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhqb2IsIG51bGwsIDE0IC8qIFNDSEVEVUxFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBmbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pO1xyXG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvLyBzb21lIHBvc3RGbHVzaENiIHF1ZXVlZCBqb2JzIVxyXG4gICAgICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZHJhaW5zLlxyXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xyXG4gICAgaWYgKCFzZWVuLmhhcyhmbikpIHtcclxuICAgICAgICBzZWVuLnNldChmbiwgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcclxuICAgICAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBmbi5vd25lckluc3RhbmNlO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICAgICAgd2FybihgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoaXMgbWVhbnMgeW91IGhhdmUgYSByZWFjdGl2ZSBlZmZlY3QgdGhhdCBpcyBtdXRhdGluZyBpdHMgb3duIGAgK1xyXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcclxuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2hlciBzb3VyY2UgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XHJcbi8vIEV4cG9zZSB0aGUgSE1SIHJ1bnRpbWUgb24gdGhlIGdsb2JhbCBvYmplY3RcclxuLy8gVGhpcyBtYWtlcyBpdCBlbnRpcmVseSB0cmVlLXNoYWthYmxlIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBleHBvcnRzIGFuZCBtYWtlc1xyXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcclxuLy8gTm90ZTogZm9yIGEgY29tcG9uZW50IHRvIGJlIGVsaWdpYmxlIGZvciBITVIgaXQgYWxzbyBuZWVkcyB0aGUgX19obXJJZCBvcHRpb25cclxuLy8gdG8gYmUgc2V0IHNvIHRoYXQgaXRzIGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCAvIHJlbW92ZWQuXHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxyXG4gICAgICAgIHJlcmVuZGVyOiB0cnlXcmFwKHJlcmVuZGVyKSxcclxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxyXG4gICAgfTtcclxufVxyXG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpZCA9IGluc3RhbmNlLnR5cGUuX19obXJJZDtcclxuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkKGlkLCBpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIH1cclxuICAgIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XHJcbiAgICBtYXAuZ2V0KGluc3RhbmNlLnR5cGUuX19obXJJZCkuaW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XHJcbiAgICBpZiAobWFwLmhhcyhpZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtYXAuc2V0KGlkLCB7XHJcbiAgICAgICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXHJcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcclxufVxyXG5mdW5jdGlvbiByZXJlbmRlcihpZCwgbmV3UmVuZGVyKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdXBkYXRlIGluaXRpYWwgcmVjb3JkIChmb3Igbm90LXlldC1yZW5kZXJlZCBjb21wb25lbnQpXHJcbiAgICByZWNvcmQuaW5pdGlhbERlZi5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyQ2FjaGUgPSBbXTtcclxuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XHJcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcclxuICAgIGlmICghcmVjb3JkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcclxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIGRlZiAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50cylcclxuICAgIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XHJcbiAgICAvLyBjcmVhdGUgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZyB1cGRhdGVzXHJcbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XHJcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcclxuICAgICAgICBpZiAoIWhtckRpcnR5Q29tcG9uZW50cy5oYXMob2xkQ29tcCkpIHtcclxuICAgICAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXHJcbiAgICAgICAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDIuIG1hcmsgZGVmaW5pdGlvbiBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBvbiBwYXRjaC5cclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gaW52YWxpZGF0ZSBvcHRpb25zIHJlc29sdXRpb24gY2FjaGVcclxuICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgLy8gNC4gYWN0dWFsbHkgdXBkYXRlXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBlbGVtZW50XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIDQuIEZvcmNlIHRoZSBwYXJlbnQgaW5zdGFuY2UgdG8gcmUtcmVuZGVyLiBUaGlzIHdpbGwgY2F1c2UgYWxsIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gY29tcG9uZW50cyB0byBiZSB1bm1vdW50ZWQgYW5kIHJlLW1vdW50ZWQuIFF1ZXVlIHRoZSB1cGRhdGUgc28gdGhhdCB3ZVxyXG4gICAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgZm9yY2luZyB0aGUgc2FtZSBwYXJlbnQgdG8gcmUtcmVuZGVyIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcclxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgdGhlIGlubmVyIGNvbXBvbmVudCBvZiBhbiBhc3luYyBjdXN0b20gZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBpbnZva2UgdG8gcmVzZXQgc3R5bGVzXHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2FzeW5jTG9hZGVyICYmXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQuY2VSZWxvYWQpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBtb3VudGVkIHZpYSBjcmVhdGVBcHAoKSBoYXMgYSByZWxvYWQgbWV0aG9kXHJcbiAgICAgICAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgaW5zaWRlIHRyZWUgY3JlYXRlZCB2aWEgcmF3IHJlbmRlcigpLiBGb3JjZSByZWxvYWQuXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW0hNUl0gUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyA1LiBtYWtlIHN1cmUgdG8gY2xlYW51cCBkaXJ0eSBobXIgY29tcG9uZW50cyBhZnRlciB1cGRhdGVcclxuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUobm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XHJcbiAgICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ5V3JhcChmbikge1xyXG4gICAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGlkLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtITVJdIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxubGV0IGRldnRvb2xzO1xyXG5sZXQgYnVmZmVyID0gW107XHJcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xyXG4gICAgICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2ssIHRhcmdldCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxuICAgIGlmIChkZXZ0b29scykge1xyXG4gICAgICAgIGRldnRvb2xzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcclxuICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKFxyXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcclxuICAgIC8vIGJyb3dzZXIgZW52aXJvbm1lbnQgdG8gYXZvaWQgdGhlIHRpbWVyIGhhbmRsZSBzdGFsbGluZyB0ZXN0IHJ1bm5lciBleGl0XHJcbiAgICAvLyAoIzQ4MTUpXHJcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIHNvbWUgZW52cyBtb2NrIHdpbmRvdyBidXQgbm90IGZ1bGx5XHJcbiAgICAgICAgd2luZG93LkhUTUxFbGVtZW50ICYmXHJcbiAgICAgICAgLy8gYWxzbyBleGNsdWRlIGpzZG9tXHJcbiAgICAgICAgISgoX2IgPSAoX2EgPSB3aW5kb3cubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXNlckFnZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoJ2pzZG9tJykpKSB7XHJcbiAgICAgICAgY29uc3QgcmVwbGF5ID0gKHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID1cclxuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pO1xyXG4gICAgICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XHJcbiAgICAgICAgICAgIHNldERldnRvb2xzSG9vayhuZXdIb29rLCB0YXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNsZWFyIGJ1ZmZlciBhZnRlciAzcyAtIHRoZSB1c2VyIHByb2JhYmx5IGRvZXNuJ3QgaGF2ZSBkZXZ0b29scyBpbnN0YWxsZWRcclxuICAgICAgICAvLyBhdCBhbGwsIGFuZCBrZWVwaW5nIHRoZSBidWZmZXIgd2lsbCBjYXVzZSBtZW1vcnkgbGVha3MgKCM0NzM4KVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRldnRvb2xzKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDMwMDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gbm9uLWJyb3dzZXIgZW52LCBhc3N1bWUgbm90IGluc3RhbGxlZFxyXG4gICAgICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICBlbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50LFxyXG4gICAgICAgIFN0YXRpY1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xyXG4gICAgZW1pdChcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGFwcCk7XHJcbn1cclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovKTtcclxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gXHJcbi8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IFxyXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogQ09NUE9ORU5UX1JFTU9WRUQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcclxuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgICAgIGVtaXQoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XHJcbiAgICBlbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmZ1bmN0aW9uIGVtaXQkMShpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcclxuICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCB7IGVtaXRzT3B0aW9ucywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IGFyZ3MgPSByYXdBcmdzO1xyXG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXHJcbiAgICBjb25zdCBtb2RlbEFyZyA9IGlzTW9kZWxMaXN0ZW5lciAmJiBldmVudC5zbGljZSg3KTtcclxuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcclxuICAgICAgICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gcHJvcHNbbW9kaWZpZXJzS2V5XSB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gYS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCh0b051bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xyXG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXHJcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBoYW5kbGVyTmFtZTtcclxuICAgIGxldCBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KSldIHx8XHJcbiAgICAgICAgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxyXG4gICAgICAgIHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpKV07XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxyXG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxyXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xyXG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSkpXTtcclxuICAgIH1cclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XHJcbiAgICBpZiAob25jZUhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhvbmNlSGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XHJcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICByYXcuZm9yRWFjaChrZXkgPT4gKG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xyXG4gICAgfVxyXG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxyXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcclxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xyXG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcclxufVxuXG4vKipcclxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cclxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxyXG4gKi9cclxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbi8qKlxyXG4gKiBOb3RlOiByZW5kZXJpbmcgY2FsbHMgbWF5YmUgbmVzdGVkLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFyZW50IHJlbmRlcmluZ1xyXG4gKiBpbnN0YW5jZSBpZiBwcmVzZW50LCB3aGljaCBzaG91bGQgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBpcyBkb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGkpXHJcbiAqIC8vIC4uLnJlbmRlclxyXG4gKiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldilcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkKSB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHByZXY7XHJcbn1cclxuLyoqXHJcbiAqIFNldCBzY29wZSBpZCB3aGVuIGNyZWF0aW5nIGhvaXN0ZWQgdm5vZGVzLlxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IGlkO1xyXG59XHJcbi8qKlxyXG4gKiBUZWNobmljYWxseSB3ZSBubyBsb25nZXIgbmVlZCB0aGlzIGFmdGVyIDMuMC44IGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHNhbWVcclxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcclxuLyoqXHJcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCAvLyBmYWxzZSBvbmx5XHJcbikge1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgLy8gYWxyZWFkeSBub3JtYWxpemVkXHJcbiAgICBpZiAoZm4uX24pIHtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcclxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGFuZFxyXG4gICAgICAgIC8vIGZvcmNlIGJhaWwgb3V0IHdoZW4gaW52b2tpbmcgYSBjb21waWxlZCBzbG90IChpbmRpY2F0ZWQgYnkgdGhlIC5fZCBmbGFnKS5cclxuICAgICAgICAvLyBUaGlzIGlzbid0IG5lY2Vzc2FyeSBpZiByZW5kZXJpbmcgYSBjb21waWxlZCBgPHNsb3Q+YCwgc28gd2UgZmxpcCB0aGVcclxuICAgICAgICAvLyAuX2QgZmxhZyBvZmYgd2hlbiBpbnZva2luZyB0aGUgd3JhcHBlZCBmbiBpbnNpZGUgYHJlbmRlclNsb3RgLlxyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcclxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvLyBtYXJrIG5vcm1hbGl6ZWQgdG8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGluZ1xyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XHJcbiAgICAvLyBtYXJrIHRoaXMgYXMgY29tcGlsZWQgYnkgZGVmYXVsdFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGluIHZub2RlLnRzIC0+IG5vcm1hbGl6ZUNoaWxkcmVuKCkgdG8gc2V0IHRoZSBzbG90XHJcbiAgICAvLyByZW5kZXJpbmcgZmxhZy5cclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xyXG4gICAgLy8gZGlzYWJsZSBibG9jayB0cmFja2luZyBieSBkZWZhdWx0XHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXHJcbiAqIElmICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyIHRoZW4gdGhlIHdhcm5pbmcgZm9yIGZhaWxlZCBhdHRyc1xyXG4gKiBmYWxsdGhyb3VnaCBjYW4gYmUgc3VwcHJlc3NlZC5cclxuICovXHJcbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xyXG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHgsIGluaGVyaXRBdHRycyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgbGV0IGZhbGx0aHJvdWdoQXR0cnM7XHJcbiAgICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAvLyB3aXRoUHJveHkgaXMgYSBwcm94eSB3aXRoIGEgZGlmZmVyZW50IGBoYXNgIHRyYXAgb25seSBmb3JcclxuICAgICAgICAgICAgLy8gcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9jay5cclxuICAgICAgICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmNhbGwocHJveHlUb1VzZSwgcHJveHlUb1VzZSwgcmVuZGVyQ2FjaGUsIHByb3BzLCBzZXR1cFN0YXRlLCBkYXRhLCBjdHgpKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbFxyXG4gICAgICAgICAgICBjb25zdCByZW5kZXIgPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIC8vIGluIGRldiwgbWFyayBhdHRycyBhY2Nlc3NlZCBpZiBvcHRpb25hbCBwcm9wcyAoYXR0cnMgPT09IHByb3BzKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGF0dHJzID09PSBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyByZW5kZXIocHJvcHMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH0pXHJcbiAgICAgICAgICAgICAgICA6IHJlbmRlcihwcm9wcywgbnVsbCAvKiB3ZSBrbm93IGl0IGRvZXNuJ3QgbmVlZCBpdCAqLykpO1xyXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzXHJcbiAgICAgICAgICAgICAgICA/IGF0dHJzXHJcbiAgICAgICAgICAgICAgICA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxIC8qIFJFTkRFUl9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBhdHRyIG1lcmdpbmdcclxuICAgIC8vIGluIGRldiBtb2RlLCBjb21tZW50cyBhcmUgcHJlc2VydmVkLCBhbmQgaXQncyBwb3NzaWJsZSBmb3IgYSB0ZW1wbGF0ZVxyXG4gICAgLy8gdG8gaGF2ZSBjb21tZW50cyBhbG9uZyBzaWRlIHRoZSByb290IGVsZW1lbnQgd2hpY2ggbWFrZXMgaXQgYSBmcmFnbWVudFxyXG4gICAgbGV0IHJvb3QgPSByZXN1bHQ7XHJcbiAgICBsZXQgc2V0Um9vdCA9IHVuZGVmaW5lZDtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSByb290O1xyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgKDEgLyogRUxFTUVOVCAqLyB8IDYgLyogQ09NUE9ORU5UICovKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgdi1tb2RlbCBsaXN0ZW5lciAob25VcGRhdGU6eHh4KSBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY2xhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcCwgaXQgaW5kaWNhdGVzIHRoaXMgY29tcG9uZW50IGV4cGVjdHMgdG8gaGFuZGxlIHYtbW9kZWwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBmYWxsdGhyb3VnaC5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkOiAjMTU0MywgIzE2NDMsICMxOTg5XHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKGZhbGx0aHJvdWdoQXR0cnMsIHByb3BzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYG9uYCwgbG93ZXJjYXNlIGZpcnN0IGxldHRlciB0byByZWZsZWN0IGV2ZW50IGNhc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFBdHRycy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgaWYgKHZub2RlLmRpcnMpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGUgZGlyZWN0aXZlcyB3aWxsIG5vdCBmdW5jdGlvbiBhcyBpbnRlbmRlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2xvbmUgYmVmb3JlIG11dGF0aW5nIHNpbmNlIHRoZSByb290IG1heSBiZSBhIGhvaXN0ZWQgdm5vZGVcclxuICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290KTtcclxuICAgICAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcclxuICAgIH1cclxuICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICBgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcclxuICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCB8fCBjaGlsZC5jaGlsZHJlbiA9PT0gJ3YtaWYnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzaW5nbGVSb290O1xyXG59XHJcbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xyXG4gICAgbGV0IHJlcztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIChyZXMgfHwgKHJlcyA9IHt9KSlba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIHJldHVybiAodm5vZGUuc2hhcGVGbGFnICYgKDYgLyogQ09NUE9ORU5UICovIHwgMSAvKiBFTEVNRU5UICovKSB8fFxyXG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQgLy8gcG90ZW50aWFsIHYtaWYgYnJhbmNoIHN3aXRjaFxyXG4gICAgKTtcclxufTtcclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHM6IHByZXZQcm9wcywgY2hpbGRyZW46IHByZXZDaGlsZHJlbiwgY29tcG9uZW50IH0gPSBwcmV2Vk5vZGU7XHJcbiAgICBjb25zdCB7IHByb3BzOiBuZXh0UHJvcHMsIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sIHBhdGNoRmxhZyB9ID0gbmV4dFZOb2RlO1xyXG4gICAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xyXG4gICAgLy8gUGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiB3YXMgaG90LXVwZGF0ZWQuIFNpbmNlIHRoaXMgbWF5IGhhdmVcclxuICAgIC8vIGNhdXNlZCB0aGUgY2hpbGQgY29tcG9uZW50J3Mgc2xvdHMgY29udGVudCB0byBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG9cclxuICAgIC8vIGZvcmNlIHRoZSBjaGlsZCB0byB1cGRhdGUgYXMgd2VsbC5cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGZvcmNlIGNoaWxkIHVwZGF0ZSBmb3IgcnVudGltZSBkaXJlY3RpdmUgb3IgdHJhbnNpdGlvbiBvbiBjb21wb25lbnQgdm5vZGUuXHJcbiAgICBpZiAobmV4dFZOb2RlLmRpcnMgfHwgbmV4dFZOb2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovKSB7XHJcbiAgICAgICAgICAgIC8vIHNsb3QgY29udGVudCB0aGF0IHJlZmVyZW5jZXMgdmFsdWVzIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLFxyXG4gICAgICAgICAgICAvLyBlLmcuIGluIGEgdi1mb3JcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgdGhpcyBmbGFnIGluZGljYXRlcyBwcm9wcyBhcmUgYWx3YXlzIG5vbi1udWxsXHJcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljUHJvcHMgPSBuZXh0Vk5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNQcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0cywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgdGFrZW4gYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXHJcbiAgICAgICAgLy8gc28gcHJlc2VuY2Ugb2YgYW55IGNoaWxkcmVuIGxlYWRzIHRvIGEgZm9yY2VkIHVwZGF0ZVxyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXZQcm9wcyA9PT0gbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHNPcHRpb25zKSB7XHJcbiAgICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XHJcbiAgICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5leHRLZXlzW2ldO1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlSE9DSG9zdEVsKHsgdm5vZGUsIHBhcmVudCB9LCBlbCAvLyBIb3N0Tm9kZVxyXG4pIHtcclxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcclxuLy8gU3VzcGVuc2UgZXhwb3NlcyBhIGNvbXBvbmVudC1saWtlIEFQSSwgYW5kIGlzIHRyZWF0ZWQgbGlrZSBhIGNvbXBvbmVudFxyXG4vLyBpbiB0aGUgY29tcGlsZXIsIGJ1dCBpbnRlcm5hbGx5IGl0J3MgYSBzcGVjaWFsIGJ1aWx0LWluIHR5cGUgdGhhdCBob29rc1xyXG4vLyBkaXJlY3RseSBpbnRvIHRoZSByZW5kZXJlci5cclxuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xyXG4gICAgbmFtZTogJ1N1c3BlbnNlJyxcclxuICAgIC8vIEluIG9yZGVyIHRvIG1ha2UgU3VzcGVuc2UgdHJlZS1zaGFrYWJsZSwgd2UgbmVlZCB0byBhdm9pZCBpbXBvcnRpbmcgaXRcclxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXHJcbiAgICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcclxuICAgIC8vIGludGVybmFscy5cclxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcclxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBcclxuICAgIC8vIHBsYXRmb3JtLXNwZWNpZmljIGltcGwgcGFzc2VkIGZyb20gcmVuZGVyZXJcclxuICAgIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRTdXNwZW5zZShuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3VzcGVuc2UsXHJcbiAgICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXHJcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cclxufTtcclxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcclxuY29uc3QgU3VzcGVuc2UgPSAoU3VzcGVuc2VJbXBsICk7XHJcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xyXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZlbnRMaXN0ZW5lcikpIHtcclxuICAgICAgICBldmVudExpc3RlbmVyKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XHJcbiAgICAvLyBzdGFydCBtb3VudGluZyB0aGUgY29udGVudCBzdWJ0cmVlIGluIGFuIG9mZi1kb20gY29udGFpbmVyXHJcbiAgICBwYXRjaChudWxsLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIGhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XHJcbiAgICAgICAgLy8gaGFzIGFzeW5jXHJcbiAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUGVuZGluZycpO1xyXG4gICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcclxuICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxyXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLnNzRmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFN1c3BlbnNlIGhhcyBubyBhc3luYyBkZXBzLiBKdXN0IHJlc29sdmUuXHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgcDogcGF0Y2gsIHVtOiB1bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9KSB7XHJcbiAgICBjb25zdCBzdXNwZW5zZSA9IChuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlKTtcclxuICAgIHN1c3BlbnNlLnZub2RlID0gbjI7XHJcbiAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgY29uc3QgbmV3QnJhbmNoID0gbjIuc3NDb250ZW50O1xyXG4gICAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xyXG4gICAgY29uc3QgeyBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIGlzSW5GYWxsYmFjaywgaXNIeWRyYXRpbmcgfSA9IHN1c3BlbnNlO1xyXG4gICAgaWYgKHBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xyXG4gICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBwZW5kaW5nQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyBzYW1lIHJvb3QgdHlwZSBidXQgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICBwYXRjaChwZW5kaW5nQnJhbmNoLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9nZ2xlZCBiZWZvcmUgcGVuZGluZyB0cmVlIGlzIHJlc29sdmVkXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xyXG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRvZ2dsZWQgYmVmb3JlIGh5ZHJhdGlvbiBpcyBmaW5pc2hlZCwgdGhlIGN1cnJlbnQgRE9NIHRyZWUgaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB2YWxpZC4gc2V0IGl0IGFzIHRoZSBhY3RpdmUgYnJhbmNoIHNvIGl0IHdpbGwgYmUgdW5tb3VudGVkXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IHBlbmRpbmcgSUQuIHRoaXMgaXMgdXNlZCB0byBpbnZhbGlkYXRlIGFzeW5jIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAvLyByZXNldCBzdXNwZW5zZSBzdGF0ZVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5kZXBzID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBlZmZlY3RzIGZyb20gcGVuZGluZyBicmFuY2hcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIHByZXZpb3VzIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBpbiBmYWxsYmFjayBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGVkIFwiYmFja1wiIHRvIGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcmVzb2x2ZVxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGVkIHRvIGEgM3JkIGJyYW5jaFxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgZGlkIG5vdCBjaGFuZ2UsIGp1c3Qgbm9ybWFsIHBhdGNoXHJcbiAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdCcmFuY2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBub2RlIHRvZ2dsZWRcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBwZW5kaW5nIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChuMiwgJ29uUGVuZGluZycpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBwZW5kaW5nIGJyYW5jaCBpbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjb25zb2xlLmluZm9gIGNhbm5vdCBiZSBudWxsIGVycm9yXHJcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IHVubW91bnQsIG46IG5leHQsIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHRvTnVtYmVyKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnRpbWVvdXQpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBpc1NWRyxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBkZXBzOiAwLFxyXG4gICAgICAgIHBlbmRpbmdJZDogMCxcclxuICAgICAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgPyB0aW1lb3V0IDogLTEsXHJcbiAgICAgICAgYWN0aXZlQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgaXNJbkZhbGxiYWNrOiB0cnVlLFxyXG4gICAgICAgIGlzSHlkcmF0aW5nLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBlZmZlY3RzOiBbXSxcclxuICAgICAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIHBlbmRpbmdJZCwgZWZmZWN0cywgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGluaXRpYWwgYW5jaG9yIG9uIG1vdW50XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSB0cmVlXHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBwYXJ0IG9mIGEgcGFyZW50IHN1c3BlbnNlLiBnZXQgdGhlIGxhdGVzdCBhbmNob3IgZm9yIGluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBidWZmZXJlZCBlZmZlY3RzXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2VcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcclxuICAgICAgICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBtZXJnZSBidWZmZXJlZCBwb3N0IGpvYnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoYXQgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcclxuICAgICAgICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHJlc29sdmUgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25SZXNvbHZlJyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgY29uc3QgbW91bnRGYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbiAmJiBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxyXG4gICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBubyBzdXNwZW5zZSBzbyB1bm1vdW50IGhvb2tzIGZpcmUgbm93XHJcbiAgICAgICAgICAgIHRydWUgLy8gc2hvdWxkUmVtb3ZlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgbW91bnRGYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcclxuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAuYXN5bmNEZXAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmNTZXR1cFJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSB3aGVuIHRoZSBzZXR1cCgpIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2bm9kZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaHlkcmF0ZWRFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWQgaWYgYW4gdXBkYXRlIGhhcHBlbmVkIGJlZm9yZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBkZXAgaXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBoeWRyYXRlZEVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIHZub2RlLCBcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIGNvbW1lbnQgcGxhY2Vob2xkZXIgY2FzZS5cclxuICAgICAgICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSwgc3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUuZWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRlY3JlYXNlIGRlcHMgY291bnQgaWYgc3VzcGVuc2UgaXMgbm90IGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBzdXNwZW5zZTtcclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcclxuICAgIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zIGZvciBzZXJ2ZXItcmVuZGVyZWQgc3VzcGVuc2U6XHJcbiAgICAvLyAtIHN1Y2Nlc3M6IHNzciBjb250ZW50IHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxyXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cclxuICAgIC8vIGhvd2V2ZXIsIG9uIHRoZSBjbGllbnQgd2UgZG9uJ3QgcmVhbGx5IGtub3cgaWYgaXQgaGFzIGZhaWxlZCBvciBub3RcclxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgRE9NIGFzc3VtaW5nIGl0IGhhcyBzdWNjZWVkZWQsIGJ1dCB3ZSBzdGlsbFxyXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxyXG4gICAgY29uc3QgcmVzdWx0ID0gaHlkcmF0ZU5vZGUobm9kZSwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgdm5vZGUuc3NDb250ZW50ID0gbm9ybWFsaXplU3VzcGVuc2VTbG90KGlzU2xvdENoaWxkcmVuID8gY2hpbGRyZW4uZGVmYXVsdCA6IGNoaWxkcmVuKTtcclxuICAgIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlblxyXG4gICAgICAgID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcclxuICAgIGxldCBibG9jaztcclxuICAgIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tCbG9jayA9IGlzQmxvY2tUcmVlRW5hYmxlZCAmJiBzLl9jO1xyXG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGVUcmFja2luZzogZmFsc2VcclxuICAgICAgICAgICAgLy8gYWxsb3cgYmxvY2sgdHJhY2tpbmcgZm9yIGNvbXBpbGVkIHNsb3RzXHJcbiAgICAgICAgICAgIC8vIChzZWUgLi9jb21wb25lbnRSZW5kZXJDb250ZXh0LnRzKVxyXG4gICAgICAgICAgICBzLl9kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9wZW5CbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gcygpO1xyXG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIHMuX2QgPSB0cnVlO1xyXG4gICAgICAgICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcclxuICAgICAgICAgICAgY2xvc2VCbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHMpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gICAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcclxuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XHJcbiAgICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xyXG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xyXG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxyXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRoZSBIT0MgZWxcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXHJcbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnN0YW5jZSBpcyBhdCByb290XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xyXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlLnByb3h5KVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3N5bmMnIH0pIDogeyBmbHVzaDogJ3N5bmMnIH0pKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcclxuICAgICAgICB3YXJuKGBcXGB3YXRjaChmbiwgb3B0aW9ucz8pXFxgIHNpZ25hdHVyZSBoYXMgYmVlbiBtb3ZlZCB0byBhIHNlcGFyYXRlIEFQSS4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcclxuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIHsgaW1tZWRpYXRlLCBkZWVwLCBmbHVzaCwgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBFTVBUWV9PQkopIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCwgcywgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGAgK1xyXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcclxuICAgIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XHJcbiAgICBpZiAoaXNSZWYoc291cmNlKSkge1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBpc1NoYWxsb3ckMShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xyXG4gICAgICAgIGRlZXAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUocyA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyQxKHMpKTtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbb25DbGVhbnVwXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNsZWFudXA7XHJcbiAgICBsZXQgb25DbGVhbnVwID0gKGZuKSA9PiB7XHJcbiAgICAgICAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQgLyogV0FUQ0hfQ0xFQU5VUCAqLyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcclxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyXHJcbiAgICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XHJcbiAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5vdCBjYWxsIHRoZSBpbnZhbGlkYXRlIGNhbGxiYWNrICgrIHJ1bm5lciBpcyBub3Qgc2V0IHVwKVxyXG4gICAgICAgIG9uQ2xlYW51cCA9IE5PT1A7XHJcbiAgICAgICAgaWYgKCFjYikge1xyXG4gICAgICAgICAgICBnZXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgZ2V0dGVyKCksXHJcbiAgICAgICAgICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOT09QO1xyXG4gICAgfVxyXG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcclxuICAgICAgICAgICAgaWYgKGRlZXAgfHxcclxuICAgICAgICAgICAgICAgIGZvcmNlVHJpZ2dlciB8fFxyXG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGltcG9ydGFudDogbWFyayB0aGUgam9iIGFzIGEgd2F0Y2hlciBjYWxsYmFjayBzbyB0aGF0IHNjaGVkdWxlciBrbm93c1xyXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxyXG4gICAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XHJcbiAgICBsZXQgc2NoZWR1bGVyO1xyXG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSBqb2I7IC8vIHRoZSBzY2hlZHVsZXIgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZGlyZWN0bHlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUHJlRmx1c2hDYihqb2IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XHJcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBlZmZlY3Quc3RvcCgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zY29wZSkge1xyXG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHRoaXMuJHdhdGNoXHJcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXHJcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKVxyXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBsZXQgY2I7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICBjYiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xyXG4gICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcclxuICAgIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xyXG4gICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGluZzogZmFsc2UsXHJcbiAgICAgICAgbGVhdmluZ1ZOb2RlczogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XHJcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxyXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcclxuICAgICAgICAvLyBlbnRlclxyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gbGVhdmVcclxuICAgICAgICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGFwcGVhclxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1jb21tZW50IGNoaWxkXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaGFzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gbW9yZSB0aGFuIG9uZSBub24tY29tbWVudCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhY2sgcmVhY3Rpdml0eSBmb3IgdGhlc2UgcHJvcHMgc28gdXNlIHRoZSByYXdcclxuICAgICAgICAgICAgLy8gcHJvcHMgZm9yIGEgYml0IGJldHRlciBwZXJmXHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBtb2RlXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdpbi1vdXQnICYmXHJcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnb3V0LWluJyAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzTGVhdmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIDx0cmFuc2l0aW9uPjxrZWVwLWFsaXZlLz48L3RyYW5zaXRpb24+LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIHR5cGUgb2YgdGhlIGtlcHQtYWxpdmUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIGlmICghaW5uZXJDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGVySG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgZW50ZXJIb29rcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkSW5uZXJDaGlsZCA9IG9sZENoaWxkICYmIGdldEtlZXBBbGl2ZUNoaWxkKG9sZENoaWxkKTtcclxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xyXG4gICAgICAgICAgICBpZiAoZ2V0VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0VHJhbnNpdGlvbktleSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2VHJhbnNpdGlvbktleSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaGFuZGxlIG1vZGVcclxuICAgICAgICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiZcclxuICAgICAgICAgICAgICAgIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0JyAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xyXG4gICAgICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgICAgIGlmIChob29rLmV2ZXJ5KGhvb2sgPT4gaG9vay5sZW5ndGggPD0gMSkpXHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBob29rcyA9IHtcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIHBlcnNpc3RlZCxcclxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHNhbWUgZWxlbWVudCAodi1zaG93KVxyXG4gICAgICAgICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3IgdG9nZ2xlZCBlbGVtZW50IHdpdGggc2FtZSBrZXkgKHYtaWYpXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgZWFybHkgcmVtb3ZhbCAobm90IGNhbmNlbGxlZClcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxBc3luY0hvb2soaG9vaywgW2VsLCBkb25lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcclxuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lKHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG59XHJcbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxyXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXHJcbi8vIHBsYWNlaG9sZGVyIHdpdGggZW1wdHkgY29udGVudCB0byBhdm9pZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGZyb20gYmVpbmdcclxuLy8gdW5tb3VudGVkLlxyXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XHJcbiAgICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XHJcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEtlZXBBbGl2ZUNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXHJcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA/IHZub2RlLmNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgOiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XHJcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vICM1MzYwIGluaGVyaXQgcGFyZW50IGtleSBpbiBjYXNlIG9mIDx0ZW1wbGF0ZSB2LWZvcj5cclxuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGNoaWxkLmtleVxyXG4gICAgICAgICAgICA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXHJcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uLCBjbG9zZSB0byBuby1vcFxyXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XHJcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XHJcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgbGV0IHJlc29sdmVkQ29tcDtcclxuICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cclxuICAgICAgICAgICAgICAgIGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiAke2NvbXB9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xyXG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxyXG4gICAgICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXHJcbiAgICAgICAgZ2V0IF9fYXN5bmNSZXNvbHZlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHVwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbnNlLWNvbnRyb2xsZWQgb3IgU1NSLlxyXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkKClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlcnJvckNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHJlZihmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ZWQgPSByZWYoISFkZWxheSk7XHJcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZC52YWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQgJiYgaXNLZWVwQWxpdmUoaW5zdGFuY2UucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBrZWVwLWFsaXZlLCBmb3JjZSB1cGRhdGUgc28gdGhlIGxvYWRlZCBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgdGFrZW4gaW50byBhY2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgeyB2bm9kZTogeyByZWYsIHByb3BzLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0sIHBhcmVudCB9KSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICAvLyBlbnN1cmUgaW5uZXIgY29tcG9uZW50IGluaGVyaXRzIHRoZSBhc3luYyB3cmFwcGVyJ3MgcmVmIG93bmVyXHJcbiAgICB2bm9kZS5yZWYgPSByZWY7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcclxuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcclxuICAgIG5hbWU6IGBLZWVwQWxpdmVgLFxyXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cclxuICAgIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XHJcbiAgICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXHJcbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXHJcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcclxuICAgICAgICAvLyBhbmQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBleHBvc2VzIGFjdGl2YXRlL2RlYWN0aXZhdGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXHJcbiAgICAgICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcclxuICAgICAgICAvLyBpZiB0aGUgaW50ZXJuYWwgcmVuZGVyZXIgaXMgbm90IHJlZ2lzdGVyZWQsIGl0IGluZGljYXRlcyB0aGF0IHRoaXMgaXMgc2VydmVyLXNpZGUgcmVuZGVyaW5nLFxyXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRTdXNwZW5zZSA9IGluc3RhbmNlLnN1c3BlbnNlO1xyXG4gICAgICAgIGNvbnN0IHsgcmVuZGVyZXI6IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiBfdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSB9ID0gc2hhcmVkQ29udGV4dDtcclxuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5hY3RpdmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2UgcHJvcHMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIHBhdGNoKGluc3RhbmNlLnZub2RlLCB2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHZub2RlLnNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuZGVhY3RpdmF0ZSA9ICh2bm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSAvKiBMRUFWRSAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuZGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSkge1xyXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgc2hhcGVGbGFnIHNvIGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICBfdW5tb3VudCh2bm9kZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodm5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xyXG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50IHx8IGNhY2hlZC50eXBlICE9PSBjdXJyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSBpbnN0YW5jZSBzaG91bGQgbm8gbG9uZ2VyIGJlIGtlcHQtYWxpdmUuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1bm1vdW50IGl0IG5vdyBidXQgaXQgbWlnaHQgYmUgbGF0ZXIsIHNvIHJlc2V0IGl0cyBmbGFnIG5vdy5cclxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcnVuZSBjYWNoZSBvbiBpbmNsdWRlL2V4Y2x1ZGUgcHJvcCBjaGFuZ2VcclxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcclxuICAgICAgICAgICAgaW5jbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+ICFtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICB9LCBcclxuICAgICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxyXG4gICAgICAgIHsgZmx1c2g6ICdwb3N0JywgZGVlcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcclxuICAgICAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ2FjaGVLZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHBlbmRpbmdDYWNoZUtleSwgZ2V0SW5uZXJDaGlsZChpbnN0YW5jZS5zdWJUcmVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9uTW91bnRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xyXG4gICAgICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goY2FjaGVkID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZC50eXBlID09PSB2bm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpbnN0YW5jZSB3aWxsIGJlIHVubW91bnRlZCBhcyBwYXJ0IG9mIGtlZXAtYWxpdmUncyB1bm1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnQoY2FjaGVkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFzbG90cy5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3Vk5vZGUgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBLZWVwQWxpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgY29tcG9uZW50IGNoaWxkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVk5vZGUocmF3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAoIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHJhd1ZOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBjb21wb25lbnRzLCBuYW1lIGNoZWNrIHNob3VsZCBiZSBiYXNlZCBpbiBpdHMgbG9hZGVkXHJcbiAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpZiBhdmFpbGFibGVcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9XHJcbiAgICAgICAgICAgICAgICA6IGNvbXApO1xyXG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGlmICgoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICAgICAgLy8gY2xvbmUgdm5vZGUgaWYgaXQncyByZXVzZWQgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gbXV0YXRlIGl0XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdWTm9kZS5zc0NvbnRlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAjMTUxMyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgcmV0dXJuZWQgdm5vZGUgdG8gYmUgY2xvbmVkIGR1ZSB0byBhdHRyXHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgbW91bnRlZC4gSW5zdGVhZCBvZiBjYWNoaW5nIGl0IGRpcmVjdGx5LCB3ZSBzdG9yZSB0aGUgcGVuZGluZ1xyXG4gICAgICAgICAgICAvLyBrZXkgYW5kIGNhY2hlIGBpbnN0YW5jZS5zdWJUcmVlYCAodGhlIG5vcm1hbGl6ZWQgdm5vZGUpIGluXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cclxuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gY2FjaGVkVk5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdHJhbnNpdGlvbiBob29rcyBvbiBzdWJUcmVlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHZub2RlIGJlaW5nIG1vdW50ZWQgYXMgZnJlc2hcclxuICAgICAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMga2V5IHRoZSBmcmVzaGVzdFxyXG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleXMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyB1bm1vdW50ZWRcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbi8vIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxyXG4vLyBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xyXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5jbHVkZXMobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXR0ZXJuLnRlc3QpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcclxuICAgIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImFcIiAvKiBBQ1RJVkFURUQgKi8sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcclxuICAgIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCBcImRhXCIgLyogREVBQ1RJVkFURUQgKi8sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgLy8gY2FjaGUgdGhlIGRlYWN0aXZhdGUgYnJhbmNoIGNoZWNrIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lXHJcbiAgICAvLyBob29rIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZGNcIiBzdGFuZHMgZm9yIFwid2l0aFxyXG4gICAgLy8gZGVhY3RpdmF0aW9uIGNoZWNrXCIuXHJcbiAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHxcclxuICAgICAgICAoaG9vay5fX3dkYyA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gb25seSBmaXJlIHRoZSBob29rIGlmIHRoZSB0YXJnZXQgaW5zdGFuY2UgaXMgTk9UIGluIGEgZGVhY3RpdmF0ZWQgYnJhbmNoLlxyXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldDtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgIGluamVjdEhvb2sodHlwZSwgd3JhcHBlZEhvb2ssIHRhcmdldCk7XHJcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcclxuICAgIC8vIGNoYWluIGFuZCByZWdpc3RlciBpdCBvbiBhbGwgYW5jZXN0b3IgaW5zdGFuY2VzIHRoYXQgYXJlIGtlZXAtYWxpdmUgcm9vdHMuXHJcbiAgICAvLyBUaGlzIGF2b2lkcyB0aGUgbmVlZCB0byB3YWxrIHRoZSBlbnRpcmUgY29tcG9uZW50IHRyZWUgd2hlbiBpbnZva2luZyB0aGVzZVxyXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxyXG4gICAgLy8gYXJyYXlzLlxyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZWVwQWxpdmUoY3VycmVudC5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XHJcbiAgICAvLyBpbmplY3RIb29rIHdyYXBzIHRoZSBvcmlnaW5hbCBmb3IgZXJyb3IgaGFuZGxpbmcsIHNvIG1ha2Ugc3VyZSB0byByZW1vdmVcclxuICAgIC8vIHRoZSB3cmFwcGVkIHZlcnNpb24uXHJcbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcclxuICAgIG9uVW5tb3VudGVkKCgpID0+IHtcclxuICAgICAgICByZW1vdmUoa2VlcEFsaXZlUm9vdFt0eXBlXSwgaW5qZWN0ZWQpO1xyXG4gICAgfSwgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFNoYXBlRmxhZyh2bm9kZSkge1xyXG4gICAgbGV0IHNoYXBlRmxhZyA9IHZub2RlLnNoYXBlRmxhZztcclxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgc2hhcGVGbGFnIC09IDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLztcclxuICAgIH1cclxuICAgIHZub2RlLnNoYXBlRmxhZyA9IHNoYXBlRmxhZztcclxufVxyXG5mdW5jdGlvbiBnZXRJbm5lckNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovID8gdm5vZGUuc3NDb250ZW50IDogdm5vZGU7XHJcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGFyZ2V0W3R5cGVdIHx8ICh0YXJnZXRbdHlwZV0gPSBbXSk7XHJcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcclxuICAgICAgICAvLyBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2VoXCIgc3RhbmRzIGZvciBcIndpdGggZXJyb3JcclxuICAgICAgICAvLyBoYW5kbGluZ1wiLlxyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxyXG4gICAgICAgICAgICAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRJbnN0YW5jZSBkdXJpbmcgaG9vayBpbnZvY2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcclxuICAgICAgICAgICAgICAgIC8vIGNhbiBvbmx5IGJlIGZhbHNlIHdoZW4gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgcmVhbGx5IGZ1bmt5LlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcclxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKSAmJlxyXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsIGhvb2ssIHRhcmdldCk7XHJcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi8pO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiIC8qIE1PVU5URUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi8pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIFVQREFURUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi8pO1xyXG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIFVOTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn1cblxuLyoqXHJcblJ1bnRpbWUgaGVscGVyIGZvciBhcHBseWluZyBkaXJlY3RpdmVzIHRvIGEgdm5vZGUuIEV4YW1wbGUgdXNhZ2U6XHJcblxuY29uc3QgY29tcCA9IHJlc29sdmVDb21wb25lbnQoJ2NvbXAnKVxyXG5jb25zdCBmb28gPSByZXNvbHZlRGlyZWN0aXZlKCdmb28nKVxyXG5jb25zdCBiYXIgPSByZXNvbHZlRGlyZWN0aXZlKCdiYXInKVxyXG5cbnJldHVybiB3aXRoRGlyZWN0aXZlcyhoKGNvbXApLCBbXHJcbiAgW2ZvbywgdGhpcy54XSxcclxuICBbYmFyLCB0aGlzLnldXHJcbl0pXHJcbiovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRFeHBvc2VQcm94eShpbnRlcm5hbEluc3RhbmNlKSB8fFxyXG4gICAgICAgIGludGVybmFsSW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgW2RpciwgdmFsdWUsIGFyZywgbW9kaWZpZXJzID0gRU1QVFlfT0JKXSA9IGRpcmVjdGl2ZXNbaV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyKSkge1xyXG4gICAgICAgICAgICBkaXIgPSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkOiBkaXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpci5kZWVwKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmluZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGRpcixcclxuICAgICAgICAgICAgaW5zdGFuY2UsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdm9pZCAwLFxyXG4gICAgICAgICAgICBhcmcsXHJcbiAgICAgICAgICAgIG1vZGlmaWVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIHByZXZWTm9kZSwgaW5zdGFuY2UsIG5hbWUpIHtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycztcclxuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcclxuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcclxuICAgICAgICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCBDT01QT05FTlRTID0gJ2NvbXBvbmVudHMnO1xyXG5jb25zdCBESVJFQ1RJVkVTID0gJ2RpcmVjdGl2ZXMnO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcclxufVxyXG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXHJcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICAgICAgLy8gZXhwbGljaXQgc2VsZiBuYW1lIGhhcyBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZk5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBcclxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcclxuICAgICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHxcclxuICAgICAgICAgICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpO1xyXG4gICAgICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZVxyXG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTXHJcbiAgICAgICAgICAgICAgICA/IGBcXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gXHJcbiAgICAgICAgICAgICAgICA6IGBgO1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXHJcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxyXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XHJcbn1cblxuLyoqXHJcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGNvbnN0IGNhY2hlZCA9IChjYWNoZSAmJiBjYWNoZVtpbmRleF0pO1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShpICsgMSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XHJcbiAgICAgICAgICAgIHJldCA9IEFycmF5LmZyb20oc291cmNlLCAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldCA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgY2FjaGVbaW5kZXhdID0gcmV0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIGNyZWF0aW5nIGR5bmFtaWMgc2xvdHMgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNsb3QgPSBkeW5hbWljU2xvdHNbaV07XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZHluYW1pYyBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiAjWy4uLl0+XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbG90Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1tzbG90W2pdLm5hbWVdID0gc2xvdFtqXS5mbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XHJcbiAgICAgICAgICAgIHNsb3RzW3Nsb3QubmFtZV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzbG90cztcclxufVxuXG4vKipcclxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBgPHNsb3QvPmBcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIFxyXG4vLyB0aGlzIGlzIG5vdCBhIHVzZXItZmFjaW5nIGZ1bmN0aW9uLCBzbyB0aGUgZmFsbGJhY2sgaXMgYWx3YXlzIGdlbmVyYXRlZCBieVxyXG4vLyB0aGUgY29tcGlsZXIgYW5kIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXlcclxuZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xyXG4gICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8XHJcbiAgICAgICAgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQgJiZcclxuICAgICAgICAgICAgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiZcclxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSgnc2xvdCcsIG5hbWUgPT09ICdkZWZhdWx0JyA/IG51bGwgOiB7IG5hbWUgfSwgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XHJcbiAgICAgICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyAnLXMnXTtcclxuICAgIH1cclxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcclxuICAgICAgICBzbG90Ll9kID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcclxuICAgICAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pXHJcbiAgICAgICAgPyB2bm9kZXNcclxuICAgICAgICA6IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEZvciBwcmVmaXhpbmcga2V5cyBpbiB2LW9uPVwib2JqXCIgd2l0aCBcIm9uXCJcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRvSGFuZGxlcnMob2JqKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICB3YXJuKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldFt0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqICMyNDM3IEluIFZ1ZSAzLCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgZG8gbm90IGhhdmUgYSBwdWJsaWMgaW5zdGFuY2UgcHJveHkgYnV0XHJcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xyXG4gKiBwdWJsaWMgJHBhcmVudCBjaGFpbnMsIHNraXAgZnVuY3Rpb25hbCBvbmVzIGFuZCBnbyB0byB0aGUgcGFyZW50IGluc3RlYWQuXHJcbiAqL1xyXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XHJcbiAgICBpZiAoIWkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcclxuICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkoaSkgfHwgaS5wcm94eTtcclxuICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XHJcbn07XHJcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSBcclxuLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcclxuLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxyXG4vKiNfX1BVUkVfXyovIGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG5jb25zdCBpc1Jlc2VydmVkUHJlZml4ID0gKGtleSkgPT4ga2V5ID09PSAnXycgfHwga2V5ID09PSAnJCc7XHJcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcclxuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5ncyBkdXJpbmcgZGV2LlxyXG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIGV2ZW4gcHJvcGVydGllcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkIHRvIGJlIHVzZWQgLSBzbyB0aGF0XHJcbiAgICAgICAgLy8gaXQgYWxpZ25zIHdpdGggdGhlIHByb2R1Y3Rpb24gYmVoYXZpb3Igd2hlcmUgdGhlIHJlbmRlciBmbiBpcyBpbmxpbmVkIGFuZFxyXG4gICAgICAgIC8vIGluZGVlZCBoYXMgYWNjZXNzIHRvIGFsbCBkZWNsYXJlZCB2YXJpYWJsZXMuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiZcclxuICAgICAgICAgICAgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAoIWlzU3RyaW5nKGtleSkgfHxcclxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oaW5zdGFuY2UucHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgaGFzKHsgXzogeyBkYXRhLCBzZXR1cFN0YXRlLCBhY2Nlc3NDYWNoZSwgY3R4LCBhcHBDb250ZXh0LCBwcm9wc09wdGlvbnMgfSB9LCBrZXkpIHtcclxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xyXG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NDYWNoZVtrZXldIHx8XHJcbiAgICAgICAgICAgIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHx8XHJcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oY3R4LCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihwdWJsaWNQcm9wZXJ0aWVzTWFwLCBrZXkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcclxuICAgIH0sXHJcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIGludmFsaWRhdGUga2V5IGNhY2hlIG9mIGEgZ2V0dGVyIGJhc2VkIHByb3BlcnR5ICM1NDE3XHJcbiAgICAgICAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoYXNPd24oZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IudmFsdWUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbn07XHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlKSB7XHJcbiAgICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcclxuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXHJcbiAgICAgICAgICAgIGBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gKTtcclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcclxuICAgICAgICBpZiAoa2V5ID09PSBTeW1ib2wudW5zY29wYWJsZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmdldCh0YXJnZXQsIGtleSwgdGFyZ2V0KTtcclxuICAgIH0sXHJcbiAgICBoYXMoXywga2V5KSB7XHJcbiAgICAgICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSAnXycgJiYgIWlzR2xvYmFsbHlXaGl0ZWxpc3RlZChrZXkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcclxuICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhcztcclxuICAgIH1cclxufSk7XHJcbi8vIGRldiBvbmx5XHJcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxyXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXHJcbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXHJcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xyXG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBzZXR1cFN0YXRlW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XHJcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcclxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXHJcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSwgaW5oZXJpdEF0dHJzLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIGluaXRpYWxpemF0aW9uIG9yZGVyICh0byBiZSBjb25zaXN0ZW50IHdpdGggVnVlIDIpOlxyXG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcclxuICAgIC8vIC0gaW5qZWN0XHJcbiAgICAvLyAtIG1ldGhvZHNcclxuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICAvLyAtIGNvbXB1dGVkXHJcbiAgICAvLyAtIHdhdGNoIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnVud3JhcEluamVjdGVkUmVmKTtcclxuICAgIH1cclxuICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZVxyXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LCBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXRcclxuICAgICAgICAgICAgICAgIC8vIHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihkYXRhT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICBgUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNQcm9taXNlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2UgZGF0YSBvbiBjdHggZHVyaW5nIGRldlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN0YXRlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIGF0IHRoaXMgcG9pbnQgLSBzdGFydCBjYWNoaW5nIGFjY2Vzc1xyXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBvcHQgPSBjb21wdXRlZE9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24ob3B0LmdldClcclxuICAgICAgICAgICAgICAgICAgICA/IG9wdC5nZXQuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IE5PT1ApIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhaXNGdW5jdGlvbihvcHQpICYmIGlzRnVuY3Rpb24ob3B0LnNldClcclxuICAgICAgICAgICAgICAgID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XHJcbiAgICAgICAgICAgICAgICBnZXQsXHJcbiAgICAgICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uKHByb3ZpZGVPcHRpb25zKVxyXG4gICAgICAgICAgICA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcylcclxuICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9ucztcclxuICAgICAgICBSZWZsZWN0Lm93bktleXMocHJvdmlkZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGNyZWF0ZWQpIHtcclxuICAgICAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIgLyogQ1JFQVRFRCAqLyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcclxuICAgICAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgICAgICBob29rLmZvckVhY2goX2hvb2sgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcclxuICAgIGlmIChpc0FycmF5KGV4cG9zZSkpIHtcclxuICAgICAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcclxuICAgICAgICAgICAgZXhwb3NlLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1RoaXNba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHZhbCA9PiAocHVibGljVGhpc1trZXldID0gdmFsKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIHdoZW4gY3JlYXRpbmcgdGhlIGluc3RhbmNlIGJ1dCBhbHNvIG5lZWQgdG8gYmVcclxuICAgIC8vIGFwcGxpZWQgZnJvbSBtaXhpbnNcclxuICAgIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgfVxyXG4gICAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XHJcbiAgICAgICAgaW5zdGFuY2UuaW5oZXJpdEF0dHJzID0gaW5oZXJpdEF0dHJzO1xyXG4gICAgfVxyXG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cclxuICAgIGlmIChjb21wb25lbnRzKVxyXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xyXG4gICAgaWYgKGRpcmVjdGl2ZXMpXHJcbiAgICAgICAgaW5zdGFuY2UuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QLCB1bndyYXBSZWYgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcclxuICAgICAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9wdCA9IGluamVjdE9wdGlvbnNba2V5XTtcclxuICAgICAgICBsZXQgaW5qZWN0ZWQ7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhlIGNoZWNrIGluIDMuM1xyXG4gICAgICAgICAgICBpZiAodW53cmFwUmVmKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDogdiA9PiAoaW5qZWN0ZWQudmFsdWUgPSB2KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgaW5qZWN0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhIHJlZiBhbmQgd2lsbCBiZSBhdXRvLXVud3JhcHBlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGFuZCBubyBsb25nZXIgbmVlZHMgXFxgLnZhbHVlXFxgIGluIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgVG8gb3B0LWluIHRvIHRoZSBuZXcgYmVoYXZpb3Igbm93LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNldCBcXGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmID0gdHJ1ZVxcYCAodGhpcyBjb25maWcgaXMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0ZW1wb3JhcnkgYW5kIHdpbGwgbm90IGJlIG5lZWRlZCBpbiB0aGUgZnV0dXJlLilgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxyXG4gICAgICAgID8gaG9vay5tYXAoaCA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKVxyXG4gICAgICAgIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlIG1lcmdlZCBvcHRpb25zIGFuZCBjYWNoZSBpdCBvbiB0aGUgY29tcG9uZW50LlxyXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XHJcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XHJcbiAgICBsZXQgcmVzb2x2ZWQ7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmVkID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCAoc3RyYXRzICYmIHN0cmF0c1trZXldKTtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG87XHJcbn1cclxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcclxuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxyXG4gICAgcHJvcHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGVtaXRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBvYmplY3RzXHJcbiAgICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXHJcbiAgICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxyXG4gICAgLy8gYXNzZXRzXHJcbiAgICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyB3YXRjaFxyXG4gICAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxyXG4gICAgLy8gcHJvdmlkZSAvIGluamVjdFxyXG4gICAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXHJcbiAgICBpbmplY3Q6IG1lcmdlSW5qZWN0XHJcbn07XHJcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIWZyb20pIHtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcbiAgICBpZiAoIXRvKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgIHJldHVybiAoZXh0ZW5kKShpc0Z1bmN0aW9uKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0bywgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb20pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUluamVjdCh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChyYXcpIHtcclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBjb25zdCByZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHJldHVybiByYXc7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gdG8gPyBbLi4ubmV3IFNldChbXS5jb25jYXQodG8sIGZyb20pKV0gOiBmcm9tO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xyXG4gICAgcmV0dXJuIHRvID8gZXh0ZW5kKGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byksIGZyb20pIDogZnJvbTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xyXG4gICAgaWYgKCF0bylcclxuICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgIGlmICghZnJvbSlcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICBjb25zdCBtZXJnZWQgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIG1lcmdlZFtrZXldID0gbWVyZ2VBc0FycmF5KHRvW2tleV0sIGZyb21ba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxyXG5pc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xyXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcclxuICAgIGRlZihhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG4gICAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xyXG4gICAgLy8gZW5zdXJlIGFsbCBkZWNsYXJlZCBwcm9wIGtleXMgYXJlIHByZXNlbnRcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB2YWxpZGF0aW9uXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXRlZnVsKSB7XHJcbiAgICAgICAgLy8gc3RhdGVmdWxcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcclxuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgKGluc3RhbmNlLnR5cGUuX19obXJJZCB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLl9faG1ySWQpKSkgJiZcclxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXHJcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXJcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGNhbWVsaXplZEtleSwgdmFsdWUsIGluc3RhbmNlLCBmYWxzZSAvKiBpc0Fic2VudCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cclxuICAgICAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xyXG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmYWxzZSApKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcclxuICAgIGlmIChoYXNBdHRyc0NoYW5nZWQpIHtcclxuICAgICAgICB0cmlnZ2VyKGluc3RhbmNlLCBcInNldFwiIC8qIFNFVCAqLywgJyRhdHRycycpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XHJcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGxldCByYXdDYXN0VmFsdWVzO1xyXG4gICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGtleSwgcmVmIGFyZSByZXNlcnZlZCBhbmQgbmV2ZXIgcGFzc2VkIGRvd25cclxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxyXG4gICAgICAgICAgICAvLyBrZWJhYiAtPiBjYW1lbCBjb252ZXJzaW9uIGhlcmUgd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUga2V5LlxyXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGF0dHJzKSB8fCB2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRDYXN0S2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgY2FzdFZhbHVlc1trZXldLCBpbnN0YW5jZSwgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKG51bGwsIHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICAgICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcclxuICAgICAgICAgICAgaWYgKGtleXMpXHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYXcpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IG9wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xyXG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XHJcbiAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogY3RvciA9PT0gbnVsbCA/ICdudWxsJyA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KHQgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIGlmIChvcHQgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wKGtleSwgcmVzb2x2ZWRWYWx1ZXNba2V5XSwgb3B0LCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmICFoYXNPd24ocmF3UHJvcHMsIGh5cGhlbmF0ZShrZXkpKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XHJcbiAgICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IgfSA9IHByb3A7XHJcbiAgICAvLyByZXF1aXJlZCFcclxuICAgIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xyXG4gICAgICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIG1pc3NpbmcgYnV0IG9wdGlvbmFsXHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHR5cGUgY2hlY2tcclxuICAgIGlmICh0eXBlICE9IG51bGwgJiYgdHlwZSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcclxuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XHJcbiAgICAgICAgLy8gdmFsdWUgaXMgdmFsaWQgYXMgbG9uZyBhcyBvbmUgb2YgdGhlIHNwZWNpZmllZCB0eXBlcyBtYXRjaFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChleHBlY3RlZFR5cGUgfHwgJycpO1xyXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB3YXJuKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIHZhbGlkYXRvclxyXG4gICAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlKSkge1xyXG4gICAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ1N0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50Jyk7XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgbGV0IHZhbGlkO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcclxuICAgIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ251bGwnKSB7XHJcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZCxcclxuICAgICAgICBleHBlY3RlZFR5cGVcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXHJcbiAgICAgICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJyB8ICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxyXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXHJcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xyXG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XHJcbiAgICBpZiAocmF3U2xvdC5fbikge1xyXG4gICAgICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZCAtICM1MzUzXHJcbiAgICAgICAgcmV0dXJuIHJhd1Nsb3Q7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXHJcbiAgICAgICAgICAgICAgICBgdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gYCArXHJcbiAgICAgICAgICAgICAgICBgSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XHJcbiAgICB9LCBjdHgpO1xyXG4gICAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcclxuICAgIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xyXG4gICAgICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmXHJcbiAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIGAgK1xyXG4gICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcclxuICAgIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyB1c2VycyBjYW4gZ2V0IHRoZSBzaGFsbG93IHJlYWRvbmx5IHZlcnNpb24gb2YgdGhlIHNsb3RzIG9iamVjdCB0aHJvdWdoIGB0aGlzLiRzbG90c2AsXHJcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhdm9pZCB0aGUgcHJveHkgb2JqZWN0IHBvbGx1dGluZyB0aGUgc2xvdHMgb2YgdGhlIGludGVybmFsIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNsb3RzID0gdG9SYXcoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGNvbXBpbGVyIG1hcmtlciBub24tZW51bWVyYWJsZVxyXG4gICAgICAgICAgICBkZWYoY2hpbGRyZW4sICdfJywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgKGluc3RhbmNlLnNsb3RzID0ge30pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9O1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbn07XHJcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xyXG4gICAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBpbGVkIHNsb3RzLlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB1cGRhdGUgc2xvdHMgYW5kIG1hcmsgaW5zdGFuY2UgZm9yIGhtciBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIEFORCBzdGFibGUuXHJcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSwgYW5kIHNraXAgc3RhbGUgc2xvdHMgcmVtb3ZhbC5cclxuICAgICAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBidXQgZHluYW1pYyAodi1pZi92LWZvciBvbiBzbG90cykgLSB1cGRhdGUgc2xvdHMsIGJ1dCBza2lwXHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjg5M1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgdGhlIG9wdGltaXplZCBzbG90cyBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBgc2xvdHMuX2AgZmxhZyBpZiBuZWNlc3NhcnkgdG8gbWFrZSBzdWJzZXF1ZW50IHVwZGF0ZXMgcmVsaWFibGUsXHJcbiAgICAgICAgICAgICAgICAvLyBpLmUuIGxldCB0aGUgYHJlbmRlclNsb3RgIGNyZWF0ZSB0aGUgYmFpbGVkIEZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFwcDogbnVsbCxcclxuICAgICAgICBjb25maWc6IHtcclxuICAgICAgICAgICAgaXNOYXRpdmVUYWc6IE5PLFxyXG4gICAgICAgICAgICBwZXJmb3JtYW5jZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxyXG4gICAgICAgICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxyXG4gICAgICAgICAgICBlcnJvckhhbmRsZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgd2FybkhhbmRsZXI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWl4aW5zOiBbXSxcclxuICAgICAgICBjb21wb25lbnRzOiB7fSxcclxuICAgICAgICBkaXJlY3RpdmVzOiB7fSxcclxuICAgICAgICBwcm92aWRlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgICBvcHRpb25zQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgcHJvcHNDYWNoZTogbmV3IFdlYWtNYXAoKSxcclxuICAgICAgICBlbWl0c0NhY2hlOiBuZXcgV2Vha01hcCgpXHJcbiAgICB9O1xyXG59XHJcbmxldCB1aWQgPSAwO1xyXG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocm9vdENvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgcm9vdENvbXBvbmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHJvb3RDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm9vdFByb3BzICE9IG51bGwgJiYgIWlzT2JqZWN0KHJvb3RQcm9wcykpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IChjb250ZXh0LmFwcCA9IHtcclxuICAgICAgICAgICAgX3VpZDogdWlkKyssXHJcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICAgICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgX2luc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICB2ZXJzaW9uLFxyXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWl4aW4obWl4aW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgaXNTVkcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU1NzFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhcHAgaW5zdGFuY2UgbW91bnRlZCBvbiB0aGUgaG9zdCBjb250YWluZXIuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRFeHBvc2VQcm94eSh2bm9kZS5jb21wb25lbnQpIHx8IHZub2RlLmNvbXBvbmVudC5wcm94eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgYWxyZWFkeSBwcm92aWRlcyBwcm9wZXJ0eSB3aXRoIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogRnVuY3Rpb24gZm9yIGhhbmRsaW5nIGEgdGVtcGxhdGUgcmVmXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcclxuICAgICAgICByYXdSZWYuZm9yRWFjaCgociwgaSkgPT4gc2V0UmVmKHIsIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcclxuICAgICAgICAvLyB3aGVuIG1vdW50aW5nIGFzeW5jIGNvbXBvbmVudHMsIG5vdGhpbmcgbmVlZHMgdG8gYmUgZG9uZSxcclxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB0ZW1wbGF0ZSByZWYgaXMgZm9yd2FyZGVkIHRvIGlubmVyIGNvbXBvbmVudFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi9cclxuICAgICAgICA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5XHJcbiAgICAgICAgOiB2bm9kZS5lbDtcclxuICAgIGNvbnN0IHZhbHVlID0gaXNVbm1vdW50ID8gbnVsbCA6IHJlZlZhbHVlO1xyXG4gICAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFvd25lcikge1xyXG4gICAgICAgIHdhcm4oYE1pc3NpbmcgcmVmIG93bmVyIGNvbnRleHQuIHJlZiBjYW5ub3QgYmUgdXNlZCBvbiBob2lzdGVkIHZub2Rlcy4gYCArXHJcbiAgICAgICAgICAgIGBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XHJcbiAgICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gRU1QVFlfT0JKID8gKG93bmVyLnJlZnMgPSB7fSkgOiBvd25lci5yZWZzO1xyXG4gICAgY29uc3Qgc2V0dXBTdGF0ZSA9IG93bmVyLnNldHVwU3RhdGU7XHJcbiAgICAvLyBkeW5hbWljIHJlZiBjaGFuZ2VkLiB1bnNldCBvbGQgcmVmXHJcbiAgICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcob2xkUmVmKSkge1xyXG4gICAgICAgICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIG9sZFJlZikpIHtcclxuICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xyXG4gICAgICAgICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XHJcbiAgICAgICAgY29uc3QgX2lzUmVmID0gaXNSZWYocmVmKTtcclxuICAgICAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xyXG4gICAgICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VubW91bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5wdXNoKHJlZlZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgcmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZihyZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRvU2V0LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb1NldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5sZXQgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIENPTU1FTlQgKi87XHJcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcclxuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXHJcbi8vIGl0IG91dCBjcmVhdGVzIGEgdG9uIG9mIHVubmVjZXNzYXJ5IGNvbXBsZXhpdHkuXHJcbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxyXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cclxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBjcmVhdGVUZXh0LCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICBoeWRyYXRlTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCwgdm5vZGUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBjb25zdCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgICAgICB2bm9kZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM1NzI4IGVtcHR5IHRleHQgbm9kZSBpbnNpZGUgYSBzbG90IGNhbiBjYXVzZSBoeWRyYXRpb24gZmFpbHVyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIHdvbid0IGNvbnRhaW4gYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCgodm5vZGUuZWwgPSBjcmVhdGVUZXh0KCcnKSksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUub3V0ZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHNldHRpbmcgdXAgdGhlIHJlbmRlciBlZmZlY3QsIGlmIHRoZSBpbml0aWFsIHZub2RlIGFscmVhZHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgLmVsIHNldCwgdGhlIGNvbXBvbmVudCB3aWxsIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpdHMgc3ViLXRyZWUuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQodm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGJlIGFzeW5jLCBzbyBpbiB0aGUgY2FzZSBvZiBmcmFnbWVudHMgd2UgY2Fubm90IHJlbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzQyOTMgdGVsZXBvcnQgYXMgY29tcG9uZW50IHJvb3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21tZW50KG5leHROb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5kYXRhID09PSAndGVsZXBvcnQgZW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM3ODdcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb21wb25lbnQgaXMgYXN5bmMsIGl0IG1heSBnZXQgbW92ZWQgLyB1bm1vdW50ZWQgYmVmb3JlIGl0c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpcyBsb2FkZWQsIHNvIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgdGhhdCBtYXRjaGVzIGl0cyBhZG9wdGVkIERPTS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXIubGFzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZSgnJykgOiBjcmVhdGVWTm9kZSgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihwYXJlbnROb2RlKG5vZGUpKSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gIzQwMDYgZm9yIGZvcm0gZWxlbWVudHMgd2l0aCBub24tc3RyaW5nIHYtbW9kZWwgdmFsdWUgYmluZGluZ3NcclxuICAgICAgICAvLyBlLmcuIDxvcHRpb24gOnZhbHVlPVwib2JqXCI+LCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgOnRydWUtdmFsdWU9XCIxXCI+XHJcbiAgICAgICAgY29uc3QgZm9yY2VQYXRjaFZhbHVlID0gKHR5cGUgPT09ICdpbnB1dCcgJiYgZGlycykgfHwgdHlwZSA9PT0gJ29wdGlvbic7XHJcbiAgICAgICAgLy8gc2tpcCBwcm9wcyAmIGNoaWxkcmVuIGlmIHRoaXMgaXMgaG9pc3RlZCBzdGF0aWMgbm9kZXNcclxuICAgICAgICAvLyAjNTQwNSBpbiBkZXYsIGFsd2F5cyBoeWRyYXRlIGNoaWxkcmVuIGZvciBITVJcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3B0aW1pemVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgKDE2IC8qIEZVTExfUFJPUFMgKi8gfCAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZvcmNlUGF0Y2hWYWx1ZSAmJiBrZXkuZW5kc1dpdGgoJ3ZhbHVlJykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGZhbHNlLCB1bmRlZmluZWQsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggcHJvcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCAnb25DbGljaycsIG51bGwsIHByb3BzLm9uQ2xpY2ssIGZhbHNlLCB1bmRlZmluZWQsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFNTUmVkIERPTSBjb250YWlucyBtb3JlIG5vZGVzIHRoYW4gaXQgc2hvdWxkLiBSZW1vdmUgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBDbGllbnQ6ICR7ZWwudGV4dENvbnRlbnR9XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFRleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFNTUmVkIERPTSBkaWRuJ3QgY29udGFpbiBlbm91Z2ggbm9kZXMuIE1vdW50IHRoZSBtaXNzaW5nIG9uZXMuXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcclxuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxcbi0gQ2xpZW50IHZub2RlOmAsIHZub2RlLnR5cGUsIGBcXG4tIFNlcnZlciByZW5kZXJlZCBET006YCwgbm9kZSwgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBURVhUICovXHJcbiAgICAgICAgICAgICAgICA/IGAodGV4dClgXHJcbiAgICAgICAgICAgICAgICA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgYCk7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGNlc3NpdmUgZnJhZ21lbnQgbm9kZXNcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG5leHQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSAwO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2grKztcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IHN1cHBvcnRlZDtcclxubGV0IHBlcmY7XHJcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWA7XHJcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XHJcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5tZWFzdXJlKGA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0+ICR7dHlwZX1gLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcclxufVxuXG4vKipcclxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXHJcbiAqIEl0IGlzIGNhbGxlZCB3aGVuIGEgcmVuZGVyZXIgaXMgY3JlYXRlZCwgaW4gYGJhc2VDcmVhdGVSZW5kZXJlcmAgc28gdGhhdFxyXG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxyXG4gKlxyXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcclxuICAgIGNvbnN0IG5lZWRXYXJuID0gW107XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKCcsICcpfSAke211bHRpID8gYGFyZWAgOiBgaXNgfSBub3QgZXhwbGljaXRseSBkZWZpbmVkLiBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZSwgYCArXHJcbiAgICAgICAgICAgIGB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIGAgK1xyXG4gICAgICAgICAgICBgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uIGJ1bmRsZS5cXG5cXG5gICtcclxuICAgICAgICAgICAgYEZvciBtb3JlIGRldGFpbHMsIHNlZSBodHRwczovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuLyoqXHJcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcclxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXHJcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cclxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XHJcbiAqICAgcGF0Y2hQcm9wLFxyXG4gKiAgIC4uLm5vZGVPcHNcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xyXG59XHJcbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXHJcbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxyXG4vLyB0cmVlLXNoYWthYmxlLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcclxuICAgIHtcclxuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XHJcbiAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgaW5zZXJ0OiBob3N0SW5zZXJ0LCByZW1vdmU6IGhvc3RSZW1vdmUsIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCwgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCwgc2V0VGV4dDogaG9zdFNldFRleHQsIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLCBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLCBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsIGNsb25lTm9kZTogaG9zdENsb25lTm9kZSwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XHJcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcclxuICAgIC8vIHN0eWxlIGluIG9yZGVyIHRvIHByZXZlbnQgYmVpbmcgaW5saW5lZCBieSBtaW5pZmllcnMuXHJcbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcclxuICAgICAgICBpZiAobjEgPT09IG4yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGF0Y2hpbmcgJiBub3Qgc2FtZSB0eXBlLCB1bm1vdW50IG9sZCB0cmVlXHJcbiAgICAgICAgaWYgKG4xICYmICFpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xyXG4gICAgICAgICAgICB1bm1vdW50KG4xLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgbjEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjIucGF0Y2hGbGFnID09PSAtMiAvKiBCQUlMICovKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBuMi5keW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1RleHQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbikpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgbjIuZWwsIG4yLmFuY2hvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXYgLyBITVIgb25seVxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgLy8gc3RhdGljIG5vZGVzIGFyZSBvbmx5IHBhdGNoZWQgZHVyaW5nIGRldiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xyXG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKHZub2RlLmNoaWxkcmVuLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcgJiYgdHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3ZhbHVlJyAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBmb3Igc2V0dGluZyB2YWx1ZSBvbiBET00gZWxlbWVudHM6XHJcbiAgICAgICAgICAgICAgICAgKiAtIGl0IGNhbiBiZSBvcmRlci1zZW5zaXRpdmUgKGUuZy4gc2hvdWxkIGJlIHNldCAqYWZ0ZXIqIG1pbi9tYXgsICMyMzI1LCAjNDAyNClcclxuICAgICAgICAgICAgICAgICAqIC0gaXQgbmVlZHMgdG8gYmUgZm9yY2VkICgjMTQ3MSlcclxuICAgICAgICAgICAgICAgICAqICMyMzUzIHByb3Bvc2VzIGFkZGluZyBhbm90aGVyIHJlbmRlcmVyIG9wdGlvbiB0byBjb25maWd1cmUgdGhpcywgYnV0XHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgcHJvcGVydGllcyBhZmZlY3RzIGFyZSBzbyBmaW5pdGUgaXQgaXMgd29ydGggc3BlY2lhbCBjYXNpbmcgaXRcclxuICAgICAgICAgICAgICAgICAqIGhlcmUgdG8gcmVkdWNlIHRoZSBjb21wbGV4aXR5LiAoU3BlY2lhbCBjYXNpbmcgaXQgYWxzbyBzaG91bGQgbm90XHJcbiAgICAgICAgICAgICAgICAgKiBhZmZlY3Qgbm9uLURPTSByZW5kZXJlcnMpXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgbnVsbCwgcHJvcHMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2NvcGVJZFxyXG4gICAgICAgICAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Zub2RlJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZub2RlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdnVlUGFyZW50Q29tcG9uZW50Jywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAjMTU4MyBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2Ugbm90IHJlc29sdmVkIGNhc2UsIGVudGVyIGhvb2sgc2hvdWxkIGNhbGwgd2hlbiBzdXNwZW5zZSByZXNvbHZlZFxyXG4gICAgICAgIC8vICMxNjg5IEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSByZXNvbHZlZCBjYXNlLCBqdXN0IGNhbGwgaXRcclxuICAgICAgICBjb25zdCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyA9ICghcGFyZW50U3VzcGVuc2UgfHwgKHBhcmVudFN1c3BlbnNlICYmICFwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSkgJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XHJcbiAgICAgICAgaWYgKG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHxcclxuICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHxcclxuICAgICAgICAgICAgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgJiYgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcclxuICAgICAgICBpZiAoc2NvcGVJZCkge1xyXG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbGV0IHN1YlRyZWUgPSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlLnBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xyXG4gICAgICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgcGFyZW50Vk5vZGUsIHBhcmVudFZOb2RlLnNjb3BlSWQsIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgc3RhcnQgPSAwKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xyXG4gICAgICAgIC8vICMxNDI2IHRha2UgdGhlIG9sZCB2bm9kZSdzIHBhdGNoIGZsYWcgaW50byBhY2NvdW50IHNpbmNlIHVzZXIgbWF5IGNsb25lIGFcclxuICAgICAgICAvLyBjb21waWxlci1nZW5lcmF0ZWQgdm5vZGUsIHdoaWNoIGRlLW9wdHMgdG8gRlVMTF9QUk9QU1xyXG4gICAgICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovO1xyXG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgLy8gZGlzYWJsZSByZWN1cnNlIGluIGJlZm9yZVVwZGF0ZSBob29rc1xyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlIHByZXNlbmNlIG9mIGEgcGF0Y2hGbGFnIG1lYW5zIHRoaXMgZWxlbWVudCdzIHJlbmRlciBjb2RlIHdhc1xyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIGFuZCBjYW4gdGFrZSB0aGUgZmFzdCBwYXRoLlxyXG4gICAgICAgICAgICAvLyBpbiB0aGlzIHBhdGggb2xkIG5vZGUgYW5kIG5ldyBub2RlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcclxuICAgICAgICAgICAgLy8gKGkuZS4gYXQgdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSB0ZW1wbGF0ZSlcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcHMgY29udGFpbiBkeW5hbWljIGtleXMsIGZ1bGwgZGlmZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsYXNzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIGNsYXNzIGJpbmRpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIgLyogQ0xBU1MgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdjbGFzcycsIG51bGwsIG5ld1Byb3BzLmNsYXNzLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3R5bGVcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgc3R5bGUgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA0IC8qIFNUWUxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3N0eWxlJywgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBwcm9wL2F0dHIgYmluZGluZ3NcclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHRoYW4gY2xhc3MgYW5kIHN0eWxlLiBUaGUga2V5cyBvZiBkeW5hbWljIHByb3AvYXR0cnMgYXJlIHNhdmVkIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gZmFzdGVyIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgZHluYW1pYyBrZXlzIGxpa2UgOltmb29dPVwiYmFyXCIgd2lsbCBjYXVzZSB0aGlzIG9wdGltaXphdGlvbiB0b1xyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBvdXQgYW5kIGdvIHRocm91Z2ggYSBmdWxsIGRpZmYgYmVjYXVzZSB3ZSBuZWVkIHRvIHVuc2V0IHRoZSBvbGQga2V5XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmbGFnIGlzIHByZXNlbnQgdGhlbiBkeW5hbWljUHJvcHMgbXVzdCBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NzEgZm9yY2UgcGF0Y2ggdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXHJcbiAgICBjb25zdCBwYXRjaEJsb2NrQ2hpbGRyZW4gPSAob2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBmYWxsYmFja0NvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Vk5vZGUgPSBuZXdDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb250YWluZXIgKHBhcmVudCBlbGVtZW50KSBmb3IgdGhlIHBhdGNoLlxyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBcclxuICAgICAgICAgICAgLy8gb2xkVk5vZGUgbWF5IGJlIGFuIGVycm9yZWQgYXN5bmMgc2V0dXAoKSBjb21wb25lbnQgaW5zaWRlIFN1c3BlbnNlXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcclxuICAgICAgICAgICAgb2xkVk5vZGUuZWwgJiZcclxuICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBDT01QT05FTlQgKi8gfCA2NCAvKiBURUxFUE9SVCAqLykpXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIC8vIGRlZmVyIHBhdGNoaW5nIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiAmJiBrZXkgIT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IEVNUFRZX09CSikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgb2xkUHJvcHNba2V5XSwgbnVsbCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRnJhZ21lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IChuMi5lbCA9IG4xID8gbjEuZWwgOiBob3N0Q3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi8pKSB7XHJcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkIC8gRGV2IHJvb3QgZnJhZ21lbnQgKHcvIGNvbW1lbnRzKSwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgc2xvdCBmcmFnbWVudCB3aXRoIDpzbG90dGVkIHNjb3BlIGlkc1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRTdGFydEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50RW5kQW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciwgb3IgaW1wbGljaXRseSBjcmVhdGVkXHJcbiAgICAgICAgICAgIC8vIGZyb20gYXJyYXlzLlxyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMjcxNSB0aGUgcHJldmlvdXMgZnJhZ21lbnQgY291bGQndmUgYmVlbiBhIEJBSUxlZCBvbmUgYXMgYSByZXN1bHRcclxuICAgICAgICAgICAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIGEgc3RhYmxlIGZyYWdtZW50ICh0ZW1wbGF0ZSByb290IG9yIDx0ZW1wbGF0ZSB2LWZvcj4pIGRvZXNuJ3QgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggY2hpbGRyZW4gb3JkZXIsIGJ1dCBpdCBtYXkgY29udGFpbiBkeW5hbWljQ2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcclxuICAgICAgICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXHJcbiAgICAgICAgICAgICAgICAvLyAjMjEzNCBvciBpZiBpdCdzIGEgY29tcG9uZW50IHJvb3QsIGl0IG1heSBhbHNvIGdldCBtb3ZlZCBhcm91bmRcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXHJcbiAgICAgICAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8ga2V5ZWQgLyB1bmtleWVkLCBvciBtYW51YWwgZnJhZ21lbnRzLlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGtleWVkICYgdW5rZXllZCwgc2luY2UgdGhleSBhcmUgY29tcGlsZXIgZ2VuZXJhdGVkIGZyb20gdi1mb3IsXHJcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGNoaWxkIGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBibG9jayBzbyB0aGUgZnJhZ21lbnQgd2lsbCBuZXZlclxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBkeW5hbWljQ2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG4yLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoaW5pdGlhbFZOb2RlLmNvbXBvbmVudCA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKGluaXRpYWxWTm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSkpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcclxuICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJlbmRlcmVyIGludGVybmFscyBmb3Iga2VlcEFsaXZlXHJcbiAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGluaXRpYWxWTm9kZSkpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNvbHZlIHByb3BzIGFuZCBzbG90cyBmb3Igc2V0dXAgY29udGV4dFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcclxuICAgICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZ1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xyXG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgcGxhY2Vob2xkZXIgaWYgdGhpcyBpcyBub3QgaHlkcmF0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIHNlbGYtZGVmaW5lZCBmYWxsYmFja1xyXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jICYgc3RpbGwgcGVuZGluZyAtIGp1c3QgdXBkYXRlIHByb3BzIGFuZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSB1cGRhdGluZyB0aGUgc2FtZSBjaGlsZCBjb21wb25lbnQgaW4gdGhlIHNhbWUgZmx1c2guXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdC5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyB1cGRhdGUgbmVlZGVkLiBqdXN0IGNvcHkgb3ZlciBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlclZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGVkSW5pdGlhbFZOb2RlID0gaW5pdGlhbFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFjdGl2YXRlZCBob29rIGZvciBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gIzE3NDIgYWN0aXZhdGVkIGhvb2sgbXVzdCBiZSBhY2Nlc3NlZCBhZnRlciBmaXJzdCByZW5kZXJcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBob29rIG1heSBiZSBpbmplY3RlZCBieSBhIGNoaWxkIGtlZXAtYWxpdmVcclxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsVk5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWxsb3cgY29tcG9uZW50IGVmZmVjdCByZWN1cnNpb24gZHVyaW5nIHByZS1saWZlY3ljbGUgaG9va3MuXHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVVcGRhdGUgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gocHJldlRyZWUsIG5leHRUcmVlLCBcclxuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxyXG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgZ2V0TmV4dEhvc3ROb2RlKHByZXZUcmVlKSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYtdHJpZ2dlcmVkIHVwZGF0ZS4gSW4gY2FzZSBvZiBIT0MsIHVwZGF0ZSBwYXJlbnQgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgZWwuIEhPQyBpcyBpbmRpY2F0ZWQgYnkgcGFyZW50IGluc3RhbmNlJ3Mgc3ViVHJlZSBwb2ludGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoaWxkIGNvbXBvbmVudCdzIHZub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCBuZXh0VHJlZS5lbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmICh1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVVcGRhdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBjb25zdCBlZmZlY3QgPSAoaW5zdGFuY2UuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGNvbXBvbmVudFVwZGF0ZUZuLCAoKSA9PiBxdWV1ZUpvYih1cGRhdGUpLCBpbnN0YW5jZS5zY29wZSAvLyB0cmFjayBpdCBpbiBjb21wb25lbnQncyBlZmZlY3Qgc2NvcGVcclxuICAgICAgICApKTtcclxuICAgICAgICBjb25zdCB1cGRhdGUgPSAoaW5zdGFuY2UudXBkYXRlID0gKCkgPT4gZWZmZWN0LnJ1bigpKTtcclxuICAgICAgICB1cGRhdGUuaWQgPSBpbnN0YW5jZS51aWQ7XHJcbiAgICAgICAgLy8gYWxsb3dSZWN1cnNlXHJcbiAgICAgICAgLy8gIzE4MDEsICMyMDQzIGNvbXBvbmVudCByZW5kZXIgZWZmZWN0cyBzaG91bGQgYWxsb3cgcmVjdXJzaXZlIHVwZGF0ZXNcclxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjXHJcbiAgICAgICAgICAgICAgICA/IGUgPT4gaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UucnRjLCBlKVxyXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBpbnN0YW5jZS5ydGdcclxuICAgICAgICAgICAgICAgID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpXHJcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcclxuICAgICAgICAgICAgdXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmtleWVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXHJcbiAgICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgbGV0IGUyID0gbDIgLSAxOyAvLyBuZXh0IGVuZGluZyBpbmRleFxyXG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKSBkIGVcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZTEtLTtcclxuICAgICAgICAgICAgZTItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGMgKGEgYilcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXHJcbiAgICAgICAgaWYgKGkgPiBlMSkge1xyXG4gICAgICAgICAgICBpZiAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMyBtb3ZlIGFuZCBtb3VudFxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxyXG4gICAgICAgICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkXHJcbiAgICAgICAgICAgICAgICA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcClcclxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xyXG4gICAgICAgICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gbG9vcGluZyBiYWNrd2FyZHMgc28gdGhhdCB3ZSBjYW4gdXNlIGxhc3QgcGF0Y2hlZCBub2RlIGFzIGFuY2hvclxyXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIGRpcnM7XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiZcclxuICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xyXG4gICAgICAgICAgICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYmxvY2sgbm9kZXM6IG9ubHkgbmVlZCB0byB1bm1vdW50IGR5bmFtaWMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJlxyXG4gICAgICAgICAgICAgICAgICAgICgxMjggLyogS0VZRURfRlJBR01FTlQgKi8gfCAyNTYgLyogVU5LRVlFRF9GUkFHTUVOVCAqLykpIHx8XHJcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUodm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXHJcbiAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlVW5tb3VudGVkKSkgfHxcclxuICAgICAgICAgICAgc2hvdWxkSW52b2tlRGlycykge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ3VubW91bnRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZSA9IHZub2RlID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIGVsLCBhbmNob3IsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RSZW1vdmUoY2hpbGQuZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIHVwZGF0ZSwgc3ViVHJlZSwgdW0gfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xyXG4gICAgICAgIGlmIChidW0pIHtcclxuICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RvcCBlZmZlY3RzIGluIGNvbXBvbmVudCBzY29wZVxyXG4gICAgICAgIHNjb3BlLnN0b3AoKTtcclxuICAgICAgICAvLyB1cGRhdGUgbWF5IGJlIG51bGwgaWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBpdHMgYXN5bmNcclxuICAgICAgICAvLyBzZXR1cCBoYXMgcmVzb2x2ZWQuXHJcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHNjaGVkdWxlciB3aWxsIG5vIGxvbmdlciBpbnZva2UgaXRcclxuICAgICAgICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xyXG59XHJcbi8qKlxyXG4gKiAjMTE1NlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIEhNUi1lbmFibGVkLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBzdGF0aWMgbm9kZXNcclxuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcclxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXHJcbiAqXHJcbiAqICMyMDgwXHJcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcclxuICogdGhlIGNoaWxkcmVuIHdpbGwgYWx3YXlzIGJlIG1vdmVkLiBUaGVyZWZvcmUsIGluIG9yZGVyIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVcclxuICogcG9zaXRpb24sIGVsIHNob3VsZCBiZSBpbmhlcml0ZWQgZnJvbSBwcmV2aW91cyBub2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHZub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlIHJlY2VpdmVkIC5lbCBkdXJpbmcgYmxvY2sgcGF0Y2gpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfSB9LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgdGVsZXBvcnRzIHJlbmRlcmVkIHRvIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBsb29rYWhlYWQgdW50aWwgd2UgZmluZCB0aGUgdGFyZ2V0IGFuY2hvclxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlbHkgb24gcmV0dXJuIHZhbHVlIG9mIGh5ZHJhdGVDaGlsZHJlbigpIGJlY2F1c2UgdGhlcmVcclxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlIG5lc3RlZCB0ZWxlcG9ydHNcclxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvciA9IG5leHRTaWJsaW5nKHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEFuY2hvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLmRhdGEgPT09ICd0ZWxlcG9ydCBhbmNob3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlbih0YXJnZXROb2RlLCB2bm9kZSwgdGFyZ2V0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGUuYW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLmFuY2hvcik7XHJcbn1cclxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcclxuY29uc3QgVGVsZXBvcnQgPSBUZWxlcG9ydEltcGw7XG5cbmNvbnN0IEZyYWdtZW50ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdGcmFnbWVudCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBUZXh0ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdUZXh0JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0NvbW1lbnQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgU3RhdGljID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdTdGF0aWMnIDogdW5kZWZpbmVkKTtcclxuLy8gU2luY2Ugdi1pZiBhbmQgdi1mb3IgYXJlIHRoZSB0d28gcG9zc2libGUgd2F5cyBub2RlIHN0cnVjdHVyZSBjYW4gZHluYW1pY2FsbHlcclxuLy8gY2hhbmdlLCBvbmNlIHdlIGNvbnNpZGVyIHYtaWYgYnJhbmNoZXMgYW5kIGVhY2ggdi1mb3IgZnJhZ21lbnQgYSBibG9jaywgd2VcclxuLy8gY2FuIGRpdmlkZSBhIHRlbXBsYXRlIGludG8gbmVzdGVkIGJsb2NrcywgYW5kIHdpdGhpbiBlYWNoIGJsb2NrIHRoZSBub2RlXHJcbi8vIHN0cnVjdHVyZSB3b3VsZCBiZSBzdGFibGUuIFRoaXMgYWxsb3dzIHVzIHRvIHNraXAgbW9zdCBjaGlsZHJlbiBkaWZmaW5nXHJcbi8vIGFuZCBvbmx5IHdvcnJ5IGFib3V0IHRoZSBkeW5hbWljIG5vZGVzIChpbmRpY2F0ZWQgYnkgcGF0Y2ggZmxhZ3MpLlxyXG5jb25zdCBibG9ja1N0YWNrID0gW107XHJcbmxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xyXG4vKipcclxuICogT3BlbiBhIGJsb2NrLlxyXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgLiBJdCBjYW5ub3QgYmUgcGFydCBvZiBgY3JlYXRlQmxvY2tgXHJcbiAqIGJlY2F1c2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBibG9jayBhcmUgZXZhbHVhdGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgIGl0c2VsZlxyXG4gKiBpcyBjYWxsZWQuIFRoZSBnZW5lcmF0ZWQgY29kZSB0eXBpY2FsbHkgbG9va3MgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAqICAgcmV0dXJuIChvcGVuQmxvY2soKSxjcmVhdGVCbG9jaygnZGl2JywgbnVsbCwgWy4uLl0pKVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKiBkaXNhYmxlVHJhY2tpbmcgaXMgdHJ1ZSB3aGVuIGNyZWF0aW5nIGEgdi1mb3IgZnJhZ21lbnQgYmxvY2ssIHNpbmNlIGEgdi1mb3JcclxuICogZnJhZ21lbnQgYWx3YXlzIGRpZmZzIGl0cyBjaGlsZHJlbi5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xyXG4gICAgYmxvY2tTdGFjay5wdXNoKChjdXJyZW50QmxvY2sgPSBkaXNhYmxlVHJhY2tpbmcgPyBudWxsIDogW10pKTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xyXG4gICAgYmxvY2tTdGFjay5wb3AoKTtcclxuICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xyXG59XHJcbi8vIFdoZXRoZXIgd2Ugc2hvdWxkIGJlIHRyYWNraW5nIGR5bmFtaWMgY2hpbGQgbm9kZXMgaW5zaWRlIGEgYmxvY2suXHJcbi8vIE9ubHkgdHJhY2tzIHdoZW4gdGhpcyB2YWx1ZSBpcyA+IDBcclxuLy8gV2UgYXJlIG5vdCB1c2luZyBhIHNpbXBsZSBib29sZWFuIGJlY2F1c2UgdGhpcyB2YWx1ZSBtYXkgbmVlZCB0byBiZVxyXG4vLyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZCBieSBuZXN0ZWQgdXNhZ2Ugb2Ygdi1vbmNlIChzZWUgYmVsb3cpXHJcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xyXG4vKipcclxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXHJcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcclxuICogY29kZSBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBfY2FjaGVbMV0gfHwgKFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxyXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygxKSxcclxuICogICBfY2FjaGVbMV1cclxuICogKVxyXG4gKiBgYGBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcclxuICAgIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBzZXR1cEJsb2NrKHZub2RlKSB7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXHJcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPVxyXG4gICAgICAgIGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgPyBjdXJyZW50QmxvY2sgfHwgRU1QVFlfQVJSIDogbnVsbDtcclxuICAgIC8vIGNsb3NlIGJsb2NrXHJcbiAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICAvLyBhIGJsb2NrIGlzIGFsd2F5cyBnb2luZyB0byBiZSBwYXRjaGVkLCBzbyB0cmFjayBpdCBhcyBhIGNoaWxkIG9mIGl0c1xyXG4gICAgLy8gcGFyZW50IGJsb2NrXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XHJcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCB0cnVlIC8qIGlzQmxvY2sgKi8pKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYmxvY2sgcm9vdCB2bm9kZS4gVGFrZXMgdGhlIHNhbWUgZXhhY3QgYXJndW1lbnRzIGFzIGBjcmVhdGVWTm9kZWAuXHJcbiAqIEEgYmxvY2sgcm9vdCBrZWVwcyB0cmFjayBvZiBkeW5hbWljIG5vZGVzIHdpdGhpbiB0aGUgYmxvY2sgaW4gdGhlXHJcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xyXG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pKTtcclxufVxyXG5mdW5jdGlvbiBpc1ZOb2RlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICBuMi5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcclxuICAgICAgICAvLyBITVIgb25seTogaWYgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBob3QtdXBkYXRlZCwgZm9yY2UgYSByZWxvYWQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XHJcbn1cclxubGV0IHZub2RlQXJnc1RyYW5zZm9ybWVyO1xyXG4vKipcclxuICogSW50ZXJuYWwgQVBJIGZvciByZWdpc3RlcmluZyBhbiBhcmd1bWVudHMgdHJhbnNmb3JtIGZvciBjcmVhdGVWTm9kZVxyXG4gKiB1c2VkIGZvciBjcmVhdGluZyBzdHVicyBpbiB0aGUgdGVzdC11dGlsc1xyXG4gKiBJdCBpcyAqaW50ZXJuYWwqIGJ1dCBuZWVkcyB0byBiZSBleHBvc2VkIGZvciB0ZXN0LXV0aWxzIHRvIHBpY2sgdXAgcHJvcGVyXHJcbiAqIHR5cGluZ3NcclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xyXG4gICAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcclxufVxyXG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcclxuICAgIHJldHVybiBfY3JlYXRlVk5vZGUoLi4uKHZub2RlQXJnc1RyYW5zZm9ybWVyXHJcbiAgICAgICAgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpXHJcbiAgICAgICAgOiBhcmdzKSk7XHJcbn07XHJcbmNvbnN0IEludGVybmFsT2JqZWN0S2V5ID0gYF9fdkludGVybmFsYDtcclxuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcclxuY29uc3Qgbm9ybWFsaXplUmVmID0gKHsgcmVmLCByZWZfa2V5LCByZWZfZm9yIH0pID0+IHtcclxuICAgIHJldHVybiAocmVmICE9IG51bGxcclxuICAgICAgICA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZilcclxuICAgICAgICAgICAgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfVxyXG4gICAgICAgICAgICA6IHJlZlxyXG4gICAgICAgIDogbnVsbCk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgc2hhcGVGbGFnID0gdHlwZSA9PT0gRnJhZ21lbnQgPyAwIDogMSAvKiBFTEVNRU5UICovLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcclxuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBzdXNwZW5zZSBjaGlsZHJlblxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gY29tcGlsZWQgZWxlbWVudCB2bm9kZSAtIGlmIGNoaWxkcmVuIGlzIHBhc3NlZCwgb25seSBwb3NzaWJsZSB0eXBlcyBhcmVcclxuICAgICAgICAvLyBzdHJpbmcgb3IgQXJyYXkuXHJcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA/IDggLyogVEVYVF9DSElMRFJFTiAqL1xyXG4gICAgICAgICAgICA6IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGUga2V5XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XHJcbiAgICAgICAgd2FybihgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgLy8gdHJhY2sgdm5vZGUgZm9yIGJsb2NrIHRyZWVcclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmXHJcbiAgICAgICAgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXHJcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXHJcbiAgICAgICAgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXHJcbiAgICAgICAgY3VycmVudEJsb2NrICYmXHJcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cclxuICAgICAgICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cclxuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXHJcbiAgICAgICAgKHZub2RlLnBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXHJcbiAgICAgICAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cclxuICAgICAgICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gOiBfY3JlYXRlVk5vZGUpO1xyXG5mdW5jdGlvbiBfY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIGlzQmxvY2tOb2RlID0gZmFsc2UpIHtcclxuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdHlwZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHZub2RlIHR5cGUgd2hlbiBjcmVhdGluZyB2bm9kZTogJHt0eXBlfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHlwZSA9IENvbW1lbnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgICAvLyA8Y29tcG9uZW50IDppcz1cInZub2RlXCIvPlxyXG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgIWlzQmxvY2tOb2RlICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICAgICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yIC8qIEJBSUwgKi87XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIC8vIGNsYXNzIGNvbXBvbmVudCBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXHJcbiAgICAgICAgICAgIC8vIG11dGF0ZWRcclxuICAgICAgICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbmNvZGUgdGhlIHZub2RlIHR5cGUgaW5mb3JtYXRpb24gaW50byBhIGJpdG1hcFxyXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcclxuICAgICAgICA/IDEgLyogRUxFTUVOVCAqL1xyXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxyXG4gICAgICAgICAgICA/IDEyOCAvKiBTVVNQRU5TRSAqL1xyXG4gICAgICAgICAgICA6IGlzVGVsZXBvcnQodHlwZSlcclxuICAgICAgICAgICAgICAgID8gNjQgLyogVEVMRVBPUlQgKi9cclxuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICA/IDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBgICtcclxuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcclxuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgaXNCbG9ja05vZGUsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xyXG4gICAgaWYgKCFwcm9wcylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiBpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wc1xyXG4gICAgICAgID8gZXh0ZW5kKHt9LCBwcm9wcylcclxuICAgICAgICA6IHByb3BzO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcclxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBOT1QgdXNpbmcgc3ByZWFkIG9yIGV4dGVuZCB0byBhdm9pZCB0aGUgcnVudGltZVxyXG4gICAgLy8ga2V5IGVudW1lcmF0aW9uIGNvc3QuXHJcbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcclxuICAgIGNvbnN0IGNsb25lZCA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlOiB2bm9kZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcclxuICAgICAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXHJcbiAgICAgICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmXHJcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXHJcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcclxuICAgICAgICAgICAgICAgICAgICA/IGlzQXJyYXkocmVmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxyXG4gICAgICAgICAgICA6IHJlZixcclxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIGNoaWxkcmVuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovICYmIGlzQXJyYXkoY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKVxyXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxyXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcclxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXHJcbiAgICAgICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGZhc3QgcGF0aHMgb25seS5cclxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcclxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPyAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgICAgICA6IHBhdGNoRmxhZyB8IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgOiBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XHJcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xyXG4gICAgICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxyXG4gICAgICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXHJcbiAgICAgICAgZWw6IHZub2RlLmVsLFxyXG4gICAgICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogRGV2IG9ubHksIGZvciBITVIgb2YgaG9pc3RlZCB2bm9kZXMgcmV1c2VkIGluIHYtZm9yXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvMjAyMlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcclxuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9ICcgJywgZmxhZyA9IDApIHtcclxuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcclxuICAgIC8vIEEgc3RhdGljIHZub2RlIGNhbiBjb250YWluIG11bHRpcGxlIHN0cmluZ2lmaWVkIGVsZW1lbnRzLCBhbmQgdGhlIG51bWJlclxyXG4gICAgLy8gb2YgZWxlbWVudHMgaXMgbmVjZXNzYXJ5IGZvciBoeWRyYXRpb24uXHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XHJcbiAgICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9ICcnLCBcclxuLy8gd2hlbiB1c2VkIGFzIHRoZSB2LWVsc2UgYnJhbmNoLCB0aGUgY29tbWVudCBub2RlIG11c3QgYmUgY3JlYXRlZCBhcyBhXHJcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXHJcbmFzQmxvY2sgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGFzQmxvY2tcclxuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpXHJcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAvLyBlbXB0eSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgLy8gZnJhZ21lbnRcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoRnJhZ21lbnQsIG51bGwsIFxyXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxyXG4gICAgICAgIGNoaWxkLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcclxuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXHJcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcclxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCB8fCBjaGlsZC5tZW1vID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIEVMRU1FTlQgKi8gfCA2NCAvKiBURUxFUE9SVCAqLykpIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAxIC8qIFNUQUJMRSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIERZTkFNSUMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcclxuICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XHJcbiAgICAgICAgLy8gZm9yY2UgdGVsZXBvcnQgY2hpbGRyZW4gdG8gYXJyYXkgc28gaXQgY2FuIGJlIG1vdmVkIGFyb3VuZFxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDggLyogVEVYVF9DSElMRFJFTiAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmNvbWluZyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEoaXNBcnJheShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBWTk9ERV9IT09LICovLCBbXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICBdKTtcclxufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcclxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcclxuICAgICAgICB1aWQ6IHVpZCQxKyssXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgYXBwQ29udGV4dCxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcclxuICAgICAgICBlZmZlY3Q6IG51bGwsXHJcbiAgICAgICAgdXBkYXRlOiBudWxsLFxyXG4gICAgICAgIHNjb3BlOiBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyksXHJcbiAgICAgICAgcmVuZGVyOiBudWxsLFxyXG4gICAgICAgIHByb3h5OiBudWxsLFxyXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlUHJveHk6IG51bGwsXHJcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxyXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxyXG4gICAgICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxyXG4gICAgICAgIHJlbmRlckNhY2hlOiBbXSxcclxuICAgICAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcclxuICAgICAgICBjb21wb25lbnRzOiBudWxsLFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXHJcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcclxuICAgICAgICBwcm9wc09wdGlvbnM6IG5vcm1hbGl6ZVByb3BzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcclxuICAgICAgICAvLyBlbWl0XHJcbiAgICAgICAgZW1pdDogbnVsbCxcclxuICAgICAgICBlbWl0dGVkOiBudWxsLFxyXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcclxuICAgICAgICBwcm9wc0RlZmF1bHRzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgLy8gaW5oZXJpdEF0dHJzXHJcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcclxuICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxyXG4gICAgICAgIGRhdGE6IEVNUFRZX09CSixcclxuICAgICAgICBwcm9wczogRU1QVFlfT0JKLFxyXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2xvdHM6IEVNUFRZX09CSixcclxuICAgICAgICByZWZzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcclxuICAgICAgICAvLyBzdXNwZW5zZSByZWxhdGVkXHJcbiAgICAgICAgc3VzcGVuc2UsXHJcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxyXG4gICAgICAgIGFzeW5jRGVwOiBudWxsLFxyXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxyXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xyXG4gICAgICAgIC8vIG5vdCB1c2luZyBlbnVtcyBoZXJlIGJlY2F1c2UgaXQgcmVzdWx0cyBpbiBjb21wdXRlZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNEZWFjdGl2YXRlZDogZmFsc2UsXHJcbiAgICAgICAgYmM6IG51bGwsXHJcbiAgICAgICAgYzogbnVsbCxcclxuICAgICAgICBibTogbnVsbCxcclxuICAgICAgICBtOiBudWxsLFxyXG4gICAgICAgIGJ1OiBudWxsLFxyXG4gICAgICAgIHU6IG51bGwsXHJcbiAgICAgICAgdW06IG51bGwsXHJcbiAgICAgICAgYnVtOiBudWxsLFxyXG4gICAgICAgIGRhOiBudWxsLFxyXG4gICAgICAgIGE6IG51bGwsXHJcbiAgICAgICAgcnRnOiBudWxsLFxyXG4gICAgICAgIHJ0YzogbnVsbCxcclxuICAgICAgICBlYzogbnVsbCxcclxuICAgICAgICBzcDogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcclxuICAgIH1cclxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQkMS5iaW5kKG51bGwsIGluc3RhbmNlKTtcclxuICAgIC8vIGFwcGx5IGN1c3RvbSBlbGVtZW50IHNwZWNpYWwgaGFuZGxpbmdcclxuICAgIGlmICh2bm9kZS5jZSkge1xyXG4gICAgICAgIHZub2RlLmNlKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIGluc3RhbmNlLnNjb3BlLm9uKCk7XHJcbn07XHJcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xyXG4gICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5zY29wZS5vZmYoKTtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbn07XHJcbmNvbnN0IGlzQnVpbHRJblRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnKTtcclxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbmZpZykge1xyXG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGFwcElzTmF0aXZlVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogJyArIG5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLztcclxufVxyXG5sZXQgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcclxuICAgIGNvbnN0IGlzU3RhdGVmdWwgPSBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcclxuICAgIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpc1N0YXRlZnVsXHJcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoQ29tcG9uZW50Lm5hbWUsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgYGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcclxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcclxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxyXG4gICAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxyXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XHJcbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIHNvIHNlcnZlci1yZW5kZXJlciBjYW4gd2FpdCBvbiBpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnQW5vbnltb3VzJztcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYDxTdXNwZW5zZT4gYm91bmRhcnkgd2FzIGZvdW5kIGluIHRoZSBwYXJlbnQgY29tcG9uZW50IHRyZWUuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGFuIGlubGluZSByZW5kZXIgZnVuY3Rpb25cclxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xyXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBmdW5jdGlvbidzIG5hbWUgaXMgYHNzclJlbmRlcmAgKGNvbXBpbGVkIGJ5IFNGQyBpbmxpbmUgbW9kZSksXHJcbiAgICAgICAgICAgIC8vIHNldCBpdCBhcyBzc3JSZW5kZXIgaW5zdGVhZC5cclxuICAgICAgICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzVk5vZGUoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXHJcbiAgICAgICAgICAgICAgICBgcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGJpbmRpbmdzLlxyXG4gICAgICAgIC8vIGFzc3VtaW5nIGEgcmVuZGVyIGZ1bmN0aW9uIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaXMgcHJlc2VudC5cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2Uuc2V0dXBTdGF0ZSA9IHByb3h5UmVmcyhzZXR1cFJlc3VsdCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xyXG4gICAgfVxyXG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxubGV0IGluc3RhbGxXaXRoUHJveHk7XHJcbi8qKlxyXG4gKiBGb3IgcnVudGltZS1kb20gdG8gcmVnaXN0ZXIgdGhlIGNvbXBpbGVyLlxyXG4gKiBOb3RlIHRoZSBleHBvcnRlZCBtZXRob2QgdXNlcyBhbnkgdG8gYXZvaWQgZC50cyByZWx5aW5nIG9uIHRoZSBjb21waWxlciB0eXBlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XHJcbiAgICBjb21waWxlID0gX2NvbXBpbGU7XHJcbiAgICBpbnN0YWxsV2l0aFByb3h5ID0gaSA9PiB7XHJcbiAgICAgICAgaWYgKGkucmVuZGVyLl9yYykge1xyXG4gICAgICAgICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcclxuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIC8vIHRlbXBsYXRlIC8gcmVuZGVyIGZ1bmN0aW9uIG5vcm1hbGl6YXRpb25cclxuICAgIC8vIGNvdWxkIGJlIGFscmVhZHkgc2V0IHdoZW4gcmV0dXJuZWQgZnJvbSBzZXR1cCgpXHJcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xyXG4gICAgICAgIC8vIG9ubHkgZG8gb24tdGhlLWZseSBjb21waWxlIGlmIG5vdCBpbiBTU1IgLSBTU1Igb24tdGhlLWZseSBjb21waWxhdGlvblxyXG4gICAgICAgIC8vIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlcmVyXHJcbiAgICAgICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKGV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcnNcclxuICAgICAgICAgICAgICAgIH0sIGNvbXBpbGVyT3B0aW9ucyksIGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gKENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUCk7XHJcbiAgICAgICAgLy8gZm9yIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2tzLCB0aGUgcmVuZGVyXHJcbiAgICAgICAgLy8gcHJveHkgdXNlZCBuZWVkcyBhIGRpZmZlcmVudCBgaGFzYCBoYW5kbGVyIHdoaWNoIGlzIG1vcmUgcGVyZm9ybWFudCBhbmRcclxuICAgICAgICAvLyBhbHNvIG9ubHkgYWxsb3dzIGEgd2hpdGVsaXN0IG9mIGdsb2JhbHMgdG8gZmFsbHRocm91Z2guXHJcbiAgICAgICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcclxuICAgICAgICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICEoZmFsc2UgKSkge1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICAvLyB3YXJuIG1pc3NpbmcgdGVtcGxhdGUvcmVuZGVyXHJcbiAgICAvLyB0aGUgcnVudGltZSBjb21waWxhdGlvbiBvZiB0ZW1wbGF0ZSBpbiBTU1IgaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgYHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICtcclxuICAgICAgICAgICAgICAgIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmBcclxuICAgICAgICAgICAgICAgICAgICApIC8qIHNob3VsZCBub3QgaGFwcGVuICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIEdFVCAqLywgJyRhdHRycycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiIC8qIEdFVCAqLywgJyRhdHRycycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBleHBvc2UgPSBleHBvc2VkID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgd2FybihgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSBleHBvc2VkIHx8IHt9O1xyXG4gICAgfTtcclxuICAgIGxldCBhdHRycztcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dSZWFkb25seShpbnN0YW5jZS5zbG90cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4cG9zZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxyXG4gICAgICAgICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEV4cG9zZVByb3h5KGluc3RhbmNlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgIHJldHVybiAoaW5zdGFuY2UuZXhwb3NlUHJveHkgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xyXG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcclxuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpXHJcbiAgICAgICAgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWVcclxuICAgICAgICA6IENvbXBvbmVudC5uYW1lO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcclxuICAgIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXHJcbiAgICAgICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW1lID1cclxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50cykgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcclxufVxuXG5jb25zdCBjb21wdXRlZCA9ICgoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJldHVybiBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xyXG59KTtcblxuLy8gZGV2IG9ubHlcclxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4oYCR7bWV0aG9kfSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYCArXHJcbiAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xyXG4gICAgYGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmApO1xyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVQcm9wc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lRW1pdHMoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgZGVjbGFyaW5nIGEgY29tcG9uZW50J3MgZXhwb3NlZFxyXG4gKiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gaXQgaXMgYWNjZXNzZWQgYnkgYSBwYXJlbnQgY29tcG9uZW50IHZpYSB0ZW1wbGF0ZVxyXG4gKiByZWZzLlxyXG4gKlxyXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGNvbXBvbmVudHMgYXJlIGNsb3NlZCBieSBkZWZhdWx0IC0gaS5lLiB2YXJpYWJsZXMgaW5zaWRlXHJcbiAqIHRoZSBgPHNjcmlwdCBzZXR1cD5gIHNjb3BlIGlzIG5vdCBleHBvc2VkIHRvIHBhcmVudCB1bmxlc3MgZXhwbGljaXRseSBleHBvc2VkXHJcbiAqIHZpYSBgZGVmaW5lRXhwb3NlYC5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGVcclxuICogb3V0cHV0IGFuZCBzaG91bGQgKipub3QqKiBiZSBhY3R1YWxseSBjYWxsZWQgYXQgcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUV4cG9zZShleHBvc2VkKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBwcm92aWRpbmcgcHJvcHMgZGVmYXVsdCB2YWx1ZXMgd2hlblxyXG4gKiB1c2luZyB0eXBlLWJhc2VkIGBkZWZpbmVQcm9wc2AgZGVjbGFyYXRpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGUgdXNhZ2U6XHJcbiAqIGBgYHRzXHJcbiAqIHdpdGhEZWZhdWx0cyhkZWZpbmVQcm9wczx7XHJcbiAqICAgc2l6ZT86IG51bWJlclxyXG4gKiAgIGxhYmVscz86IHN0cmluZ1tdXHJcbiAqIH0+KCksIHtcclxuICogICBzaXplOiAzLFxyXG4gKiAgIGxhYmVsczogKCkgPT4gWydkZWZhdWx0IGxhYmVsJ11cclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlIG91dHB1dFxyXG4gKiBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB1c2VTbG90cygpIHtcclxuICAgIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XHJcbn1cclxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XHJcbiAgICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpKSB7XHJcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xyXG59XHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyBkZWZhdWx0IGRlY2xhcmF0aW9ucy4gSW1wb3J0ZWQgYnkgY29tcGlsZWQgY29kZVxyXG4gKiBvbmx5LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xyXG4gICAgY29uc3QgcHJvcHMgPSBpc0FycmF5KHJhdylcclxuICAgICAgICA/IHJhdy5yZWR1Y2UoKG5vcm1hbGl6ZWQsIHApID0+ICgobm9ybWFsaXplZFtwXSA9IHt9KSwgbm9ybWFsaXplZCksIHt9KVxyXG4gICAgICAgIDogcmF3O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xyXG4gICAgICAgIGlmIChvcHQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uKG9wdCkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG4vKipcclxuICogVXNlZCB0byBjcmVhdGUgYSBwcm94eSBmb3IgdGhlIHJlc3QgZWxlbWVudCB3aGVuIGRlc3RydWN0dXJpbmcgcHJvcHMgd2l0aFxyXG4gKiBkZWZpbmVQcm9wcygpLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8qKlxyXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGhlbHBlciBmb3IgcGVyc2lzdGluZyB0aGUgY3VycmVudCBpbnN0YW5jZSBjb250ZXh0IG92ZXJcclxuICogYXN5bmMvYXdhaXQgZmxvd3MuXHJcbiAqXHJcbiAqIGBAdnVlL2NvbXBpbGVyLXNmY2AgY29udmVydHMgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogYGBgdHNcclxuICogY29uc3QgeCA9IGF3YWl0IGZvbygpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBpbnRvOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBsZXQgX190ZW1wLCBfX3Jlc3RvcmVcclxuICogY29uc3QgeCA9ICgoW19fdGVtcCwgX19yZXN0b3JlXSA9IHdpdGhBc3luY0NvbnRleHQoKCkgPT4gZm9vKCkpKSxfX3RlbXA9YXdhaXQgX190ZW1wLF9fcmVzdG9yZSgpLF9fdGVtcClcclxuICogYGBgXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcclxuICAgIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY3R4KSB7XHJcbiAgICAgICAgd2Fybihgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gYCArXHJcbiAgICAgICAgICAgIGBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5gKTtcclxuICAgIH1cclxuICAgIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcclxuICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcclxuICAgICAgICBhd2FpdGFibGUgPSBhd2FpdGFibGUuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcclxufVxuXG4vLyBBY3R1YWwgaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIGlmIChsID09PSAyKSB7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdm5vZGUgd2l0aG91dCBwcm9wc1xyXG4gICAgICAgICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIHdpdGhvdXQgY2hpbGRyZW5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvbWl0IHByb3BzXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChsID4gMykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XHJcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xyXG4gICAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYCArXHJcbiAgICAgICAgICAgICAgICBgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxufTtcblxuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogSVNfU0hBTExPVyAqL10pO1xyXG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcclxuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XHJcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xyXG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XHJcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcclxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxyXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xyXG4gICAgICAgIGhlYWRlcihvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYD5gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWN0aXZlJyA6ICdSZWFjdGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFkb25seScgOiAnUmVhZG9ubHknXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICAnPidcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNCb2R5KG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keShvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdwcm9wcycsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3NldHVwJywgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2RhdGEnLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnY29tcHV0ZWQnKTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnaW5qZWN0Jyk7XHJcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2luamVjdGVkJywgaW5qZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmxvY2tzLnB1c2goW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJyQgKGludGVybmFsKTogJ1xyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbJ29iamVjdCcsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiBibG9ja3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7fV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAncGFkZGluZy1sZWZ0OjEuMjVlbSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWydzcGFuJywga2V5d29yZFN0eWxlLCBrZXkgKyAnOiAnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIG51bWJlclN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydvYmplY3QnLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XHJcbiAgICAgICAgaWYgKChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSkgfHxcclxuICAgICAgICAgICAgKGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XHJcbiAgICAgICAgaWYgKGlzU2hhbGxvdyh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUmVmYDtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcclxuICAgIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IHJlbmRlcigpO1xyXG4gICAgLy8gc2hhbGxvdyBjbG9uZVxyXG4gICAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XHJcbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHJldCk7XHJcbn1cclxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcclxuICAgIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcclxuICAgIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gbGV0IHBhcmVudCBibG9jayB0cmFjayBpdCB3aGVuIHJldHVybmluZyBjYWNoZWRcclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vLyBDb3JlIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgdmVyc2lvbiA9IFwiMy4yLjM2XCI7XHJcbmNvbnN0IF9zc3JVdGlscyA9IHtcclxuICAgIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxyXG4gICAgc2V0dXBDb21wb25lbnQsXHJcbiAgICByZW5kZXJDb21wb25lbnRSb290LFxyXG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxyXG4gICAgaXNWTm9kZSxcclxuICAgIG5vcm1hbGl6ZVZOb2RlXHJcbn07XHJcbi8qKlxyXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBjanMgYnVpbGRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHNzclV0aWxzID0gKF9zc3JVdGlscyApO1xyXG4vKipcclxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cclxuICovXHJcbmNvbnN0IGNvbXBhdFV0aWxzID0gKG51bGwpO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQ29tbWVudCwgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBjYWxsV2l0aEVycm9ySGFuZGxpbmcsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTbG90cywgY3JlYXRlU3RhdGljVk5vZGUsIGNyZWF0ZVRleHRWTm9kZSwgY3JlYXRlVk5vZGUsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlZmluZUVtaXRzLCBkZWZpbmVFeHBvc2UsIGRlZmluZVByb3BzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNNZW1vU2FtZSwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QsIHdpdGhBc3luY0NvbnRleHQsIHdpdGhDdHgsIHdpdGhEZWZhdWx0cywgd2l0aERpcmVjdGl2ZXMsIHdpdGhNZW1vLCB3aXRoU2NvcGVJZCB9O1xuIiwiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXHJcbiAgICAvLyB0aGF0IHNlcGFyYXRlZCBlYWNoIGxpbmUuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGFjdHVhbCBzZXF1ZW5jZSBpc1xyXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcclxuICAgIC8vIGNvbXBhcmlzb25cclxuICAgIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XHJcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcclxuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XHJcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPVxyXG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgKChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoKSB8fCAwKTtcclxuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG4vKipcclxuICogQm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IG9yICcnLlxyXG4gKiBlLmcuIGA8c2VsZWN0IG11bHRpcGxlPmAgY29tcGlsZXMgdG8gYHsgbXVsdGlwbGU6ICcnIH1gXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcclxufVxyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xyXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xyXG4gICAgYGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGAgK1xyXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcclxuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcclxuICAgIGBkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sYCArXHJcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcclxuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXHJcbiAgICBgaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LGAgK1xyXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXHJcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xyXG4gICAgYHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsYCArXHJcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xyXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xyXG4gICAgYHZhbHVlLHdpZHRoLHdyYXBgKTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcclxuICovXHJcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGAgK1xyXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xyXG4gICAgYGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGAgK1xyXG4gICAgYGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sYCArXHJcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xyXG4gICAgYGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxgICtcclxuICAgIGBkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxgICtcclxuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xyXG4gICAgYGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksYCArXHJcbiAgICBgZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsYCArXHJcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXHJcbiAgICBgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixgICtcclxuICAgIGBncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsYCArXHJcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcclxuICAgIGBrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGAgK1xyXG4gICAgYGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLGAgK1xyXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xyXG4gICAgYG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsYCArXHJcbiAgICBgbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sYCArXHJcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXHJcbiAgICBgcGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcsYCArXHJcbiAgICBgcG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEsYCArXHJcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xyXG4gICAgYHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLGAgK1xyXG4gICAgYHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLGAgK1xyXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXHJcbiAgICBgc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LGAgK1xyXG4gICAgYHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxgICtcclxuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcclxuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLGAgK1xyXG4gICAgYHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsYCArXHJcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXHJcbiAgICBgdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSxgICtcclxuICAgIGB1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsYCArXHJcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXHJcbiAgICBgdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLGAgK1xyXG4gICAgYHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLGAgK1xyXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXHJcbiAgICBgeG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSlcclxuICAgICAgICAgICAgICAgID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXHJcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcclxuICAgIGxldCByZXMgPSAnJztcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMudHJpbSgpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XHJcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cblxuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XHJcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xyXG4gICAgJ2hlYWRlcixoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcclxuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xyXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcclxuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXHJcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcclxuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290JztcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcclxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xyXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXHJcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcclxuICAgICdmZURpc3RhbmNlTGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcclxuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xyXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXHJcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xyXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xyXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XHJcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XHJcbi8qKlxyXG4gKiBDb21waWxlciBvbmx5LlxyXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXHJcbiAqL1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XHJcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XHJcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcclxuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBsZXQgaHRtbCA9ICcnO1xyXG4gICAgbGV0IGVzY2FwZWQ7XHJcbiAgICBsZXQgaW5kZXg7XHJcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcclxuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcclxuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cclxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgIGh0bWwgKz0gZXNjYXBlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhID09PSBiO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc1N0cmluZyh2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IHZhbCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgOiBpc0FycmF5KHZhbCkgfHxcclxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkpXHJcbiAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXHJcbiAgICAgICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXHJcbiAgICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcclxuICAgICAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xuXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLHJlZl9mb3IscmVmX2tleSwnICtcclxuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkJyk7XHJcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtbycpO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XHJcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZuc1tpXShhcmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcclxuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xyXG59O1xyXG5sZXQgX2dsb2JhbFRoaXM7XHJcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XHJcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cclxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcclxuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xyXG59O1xyXG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xyXG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XHJcbiAgICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpXHJcbiAgICAgICAgPyBgX19wcm9wcy4ke25hbWV9YFxyXG4gICAgICAgIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcclxufVxuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIiwiaW1wb3J0IHsgY2FtZWxpemUsIHdhcm4sIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBkZWZpbmVDb21wb25lbnQsIG5leHRUaWNrLCBjcmVhdGVWTm9kZSwgZ2V0Q3VycmVudEluc3RhbmNlLCB3YXRjaFBvc3RFZmZlY3QsIG9uTW91bnRlZCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBjcmVhdGVSZW5kZXJlciwgaXNSdW50aW1lT25seSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNBcnJheSwgaHlwaGVuYXRlLCBjYXBpdGFsaXplLCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIHRvTnVtYmVyLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCBleHRlbmQsIEVNUFRZX09CSiwgaXNPYmplY3QsIGludm9rZUFycmF5Rm5zLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcclxuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyojX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcclxuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXHJcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAvLyAjMzA3MlxyXG4gICAgICAgIC8vIC0gaW4gYHBhdGNoRE9NUHJvcGAsIHdlIHN0b3JlIHRoZSBhY3R1YWwgdmFsdWUgaW4gdGhlIGBlbC5fdmFsdWVgIHByb3BlcnR5LlxyXG4gICAgICAgIC8vIC0gbm9ybWFsbHksIGVsZW1lbnRzIHVzaW5nIGA6dmFsdWVgIGJpbmRpbmdzIHdpbGwgbm90IGJlIGhvaXN0ZWQsIGJ1dCBpZlxyXG4gICAgICAgIC8vICAgdGhlIGJvdW5kIHZhbHVlIGlzIGEgY29uc3RhbnQsIGUuZy4gYDp2YWx1ZT1cInRydWVcImAgLSB0aGV5IGRvIGdldFxyXG4gICAgICAgIC8vICAgaG9pc3RlZC5cclxuICAgICAgICAvLyAtIGluIHByb2R1Y3Rpb24sIGhvaXN0ZWQgbm9kZXMgYXJlIGNsb25lZCB3aGVuIHN1YnNlcXVlbnQgaW5zZXJ0cywgYnV0XHJcbiAgICAgICAgLy8gICBjbG9uZU5vZGUoKSBkb2VzIG5vdCBjb3B5IHRoZSBjdXN0b20gcHJvcGVydHkgd2UgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gLSBUaGlzIG1heSBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIGN1c3RvbSBET00gcHJvcGVydGllcyB3ZSBhdHRhY2ggdG9cclxuICAgICAgICAvLyAgIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIGBfdmFsdWVgIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgaWYgKGBfdmFsdWVgIGluIGVsKSB7XHJcbiAgICAgICAgICAgIGNsb25lZC5fdmFsdWUgPSBlbC5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyA8cGFyZW50PiBiZWZvcmUgfCBmaXJzdCAuLi4gbGFzdCB8IGFuY2hvciA8L3BhcmVudD5cclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcclxuICAgICAgICAvLyAjNTMwOCBjYW4gb25seSB0YWtlIGNhY2hlZCBwYXRoIGlmOlxyXG4gICAgICAgIC8vIC0gaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxyXG4gICAgICAgIC8vIC0gbmV4dFNpYmxpbmcgaW5mbyBpcyBzdGlsbCBhdmFpbGFibGVcclxuICAgICAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIGNhY2hlZFxyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmVzaCBpbnNlcnRcclxuICAgICAgICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gaXNTVkcgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcclxuICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3V0ZXIgc3ZnIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBmaXJzdFxyXG4gICAgICAgICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcclxuICAgICAgICAgICAgLy8gbGFzdFxyXG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXHJcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xyXG4gICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXHJcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcclxuICAgIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAoaXNDc3NTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXYpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWBcclxuICAgICAgICAvLyB2YWx1ZSwgdGh1cyBoYW5kaW5nIG92ZXIgY29udHJvbCB0byBgdi1zaG93YC5cclxuICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIHZhbC5mb3JFYWNoKHYgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcclxuICAgICAgICAgICAgdmFsID0gJyc7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZG9tIHByb3Agb2YgdGhlIHNhbWUgbmFtZSBoZXJlLlxyXG4gICAgICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiZcclxuICAgICAgICBlbC50YWdOYW1lICE9PSAnUFJPR1JFU1MnICYmXHJcbiAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcclxuICAgICAgICAhZWwudGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSB8fFxyXG4gICAgICAgICAgICAvLyAjNDk1NjogYWx3YXlzIHNldCBmb3IgT1BUSU9OIGVsZW1lbnRzIGJlY2F1c2UgaXRzIHZhbHVlIGZhbGxzIGJhY2sgdG9cclxuICAgICAgICAgICAgLy8gdGV4dENvbnRlbnQgaWYgbm8gdmFsdWUgYXR0cmlidXRlIGlzIHByZXNlbnQuIEFuZCBzZXR0aW5nIC52YWx1ZSBmb3JcclxuICAgICAgICAgICAgLy8gT1BUSU9OIGhhcyBubyBzaWRlIGVmZmVjdFxyXG4gICAgICAgICAgICBlbC50YWdOYW1lID09PSAnT1BUSU9OJykge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8ZGl2IDppZD1cIm51bGxcIj5cclxuICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBzb21lIElETCBhdHRyIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIGUuZy4gaW5wdXQuc2l6ZSA9IDAgLT4gZXJyb3JcclxuICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgcGVyZm9ybSB2YWx1ZSB2YWxpZGF0aW9uIGFuZCB0aHJvdyxcclxuICAgIC8vIHNvbWUgcHJvcGVydGllcyBoYXMgZ2V0dGVyLCBubyBzZXR0ZXIsIHdpbGwgZXJyb3IgaW4gJ3VzZSBzdHJpY3QnXHJcbiAgICAvLyBlZy4gPHNlbGVjdCA6dHlwZT1cIm51bGxcIj48L3NlbGVjdD4gPHNlbGVjdCA6d2lsbFZhbGlkYXRlPVwibnVsbFwiPjwvc2VsZWN0PlxyXG4gICAgdHJ5IHtcclxuICAgICAgICBlbFtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxuY29uc3QgW19nZXROb3csIHNraXBUaW1lc3RhbXBDaGVja10gPSAvKiNfX1BVUkVfXyovICgoKSA9PiB7XHJcbiAgICBsZXQgX2dldE5vdyA9IERhdGUubm93O1xyXG4gICAgbGV0IHNraXBUaW1lc3RhbXBDaGVjayA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuICAgICAgICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xyXG4gICAgICAgIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxyXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgICAgICAgICAgX2dldE5vdyA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzM0ODU6IEZpcmVmb3ggPD0gNTMgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvIHNhZmUgdG8gZXhjbHVkZS5cclxuICAgICAgICBjb25zdCBmZk1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcclxuICAgICAgICBza2lwVGltZXN0YW1wQ2hlY2sgPSAhIShmZk1hdGNoICYmIE51bWJlcihmZk1hdGNoWzFdKSA8PSA1Myk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW19nZXROb3csIHNraXBUaW1lc3RhbXBDaGVja107XHJcbn0pKCk7XHJcbi8vIFRvIGF2b2lkIHRoZSBvdmVyaGVhZCBvZiByZXBlYXRlZGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCksIHdlIGNhY2hlXHJcbi8vIGFuZCB1c2UgdGhlIHNhbWUgdGltZXN0YW1wIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIGluIHRoZSBzYW1lIHRpY2suXHJcbmxldCBjYWNoZWROb3cgPSAwO1xyXG5jb25zdCBwID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICBjYWNoZWROb3cgPSAwO1xyXG59O1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbihyZXNldCksIChjYWNoZWROb3cgPSBfZ2V0Tm93KCkpKTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcclxuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xyXG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAvLyBwYXRjaFxyXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcclxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIGxldCBvcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpLCBvcHRpb25zXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcclxuICAgICAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IF9nZXROb3coKTtcclxuICAgICAgICBpZiAoc2tpcFRpbWVzdGFtcENoZWNrIHx8IHRpbWVTdGFtcCA+PSBpbnZva2VyLmF0dGFjaGVkIC0gMSkge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi8sIFtlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XHJcbiAgICByZXR1cm4gaW52b2tlcjtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xyXG4gICAgICAgICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZm4gPT4gKGUpID0+ICFlLl9zdG9wcGVkICYmIGZuICYmIGZuKGUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleVswXSA9PT0gJy4nXHJcbiAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIHRydWUpXHJcbiAgICAgICAgOiBrZXlbMF0gPT09ICdeJ1xyXG4gICAgICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgZmFsc2UpXHJcbiAgICAgICAgICAgIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxyXG4gICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgIC8vIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xyXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUwgJiB0ZXh0Q29udGVudFxyXG4gICAgICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcclxuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyB0aGVzZSBhcmUgZW51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpciBjb3JyZXNwb25kaW5nIERPTSBwcm9wZXJ0aWVzXHJcbiAgICAvLyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvIHNldHRpbmcgaXQgd2l0aCBhIHN0cmluZyBcImZhbHNlXCJcclxuICAgIC8vIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0byBgdHJ1ZWAsIHNvIHdlIG5lZWQgdG8gYWx3YXlzIHRyZWF0XHJcbiAgICAvLyB0aGVtIGFzIGF0dHJpYnV0ZXMuXHJcbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXHJcbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJyB8fCBrZXkgPT09ICd0cmFuc2xhdGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE3ODcsICMyODQwIGZvcm0gcHJvcGVydHkgb24gZm9ybSBlbGVtZW50cyBpcyByZWFkb25seSBhbmQgbXVzdCBiZSBzZXQgYXNcclxuICAgIC8vIGF0dHJpYnV0ZS5cclxuICAgIGlmIChrZXkgPT09ICdmb3JtJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNTI2IDxpbnB1dCBsaXN0PiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICdsaXN0JyAmJiBlbC50YWdOYW1lID09PSAnSU5QVVQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzI3NjYgPHRleHRhcmVhIHR5cGU+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ3R5cGUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgb25jbGljayB3aXRoIHN0cmluZyB2YWx1ZSwgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleSBpbiBlbDtcclxufVxuXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpIHtcclxuICAgIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucyk7XHJcbiAgICBjbGFzcyBWdWVDdXN0b21FbGVtZW50IGV4dGVuZHMgVnVlRWxlbWVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgaHlkcmF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xyXG4gICAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XHJcbn1cclxuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9ICgob3B0aW9ucykgPT4ge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZSk7XHJcbn0pO1xyXG5jb25zdCBCYXNlQ2xhc3MgPSAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xyXG59KTtcclxuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZGVmLCBfcHJvcHMgPSB7fSwgaHlkcmF0ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZGVmID0gX2RlZjtcclxuICAgICAgICB0aGlzLl9wcm9wcyA9IF9wcm9wcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgIGh5ZHJhdGUodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdGhpcy5zaGFkb3dSb290KSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcclxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICBuZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgdGhpcy5zaGFkb3dSb290KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiByZXNvbHZlIGlubmVyIGNvbXBvbmVudCBkZWZpbml0aW9uIChoYW5kbGUgcG9zc2libGUgYXN5bmMgY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBfcmVzb2x2ZURlZigpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgYXR0cnNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tpXS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2F0Y2ggZnV0dXJlIGF0dHIgY2hhbmdlc1xyXG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xyXG4gICAgICAgICAgICBjb25zdCBoYXNPcHRpb25zID0gIWlzQXJyYXkocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCByYXdLZXlzID0gcHJvcHMgPyAoaGFzT3B0aW9ucyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzKSA6IFtdO1xyXG4gICAgICAgICAgICAvLyBjYXN0IE51bWJlci10eXBlIHByb3BzIHNldCBiZWZvcmUgcmVzb2x2ZVxyXG4gICAgICAgICAgICBsZXQgbnVtYmVyUHJvcHM7XHJcbiAgICAgICAgICAgIGlmIChoYXNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9wcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdCA9PT0gTnVtYmVyIHx8IChvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRvTnVtYmVyKHRoaXMuX3Byb3BzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgcHJvcHMgc2V0IHByZS11cGdyYWRlIG9yIGNvbm5lY3RcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0sIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBkZWZpbmluZyBnZXR0ZXIvc2V0dGVycyBvbiBwcm90b3R5cGVcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmF3S2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFwcGx5IENTU1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhzdHlsZXMpO1xyXG4gICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XHJcbiAgICAgICAgaWYgKGFzeW5jRGVmKSB7XHJcbiAgICAgICAgICAgIGFzeW5jRGVmKCkudGhlbihyZXNvbHZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5fZGVmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0QXR0cihrZXkpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIGlmICh0aGlzLl9udW1iZXJQcm9wcyAmJiB0aGlzLl9udW1iZXJQcm9wc1trZXldKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXRQcm9wKGNhbWVsaXplJDEoa2V5KSwgdmFsdWUsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9nZXRQcm9wKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWZsZWN0XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlKCkge1xyXG4gICAgICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVZOb2RlKCkge1xyXG4gICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoe30sIHRoaXMuX3Byb3BzKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2bm9kZS5jZSA9IGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIEhNUlxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gbmV3U3R5bGVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaChzID0+IHRoaXMuc2hhZG93Um9vdC5yZW1vdmVDaGlsZChzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFzeW5jIGNvbXBvbmVudCwgY2VSZWxvYWQgaXMgY2FsbGVkIGZyb20gdGhlIGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBzbyBubyBuZWVkIHRvIHJlbG9hZCB0aGUgYXN5bmMgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBlbWl0XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIG5lYXJlc3QgVnVlIGN1c3RvbSBlbGVtZW50IHBhcmVudCBmb3IgcHJvdmlkZS9pbmplY3RcclxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5U3R5bGVzKHN0eWxlcykge1xyXG4gICAgICAgIGlmIChzdHlsZXMpIHtcclxuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goY3NzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICAgICAgcy50ZXh0Q29udGVudCA9IGNzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlY29yZCBmb3IgSE1SXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKCFtb2QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIGdldHRlcihpbnN0YW5jZS5wcm94eSkpO1xyXG4gICAgd2F0Y2hQb3N0RWZmZWN0KHNldFZhcnMpO1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHtcclxuICAgICAgICBjb25zdCBvYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHNldFZhcnMpO1xyXG4gICAgICAgIG9iLm9ic2VydmUoaW5zdGFuY2Uuc3ViVHJlZS5lbC5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcclxuICAgICAgICBvblVubW91bnRlZCgoKSA9PiBvYi5kaXNjb25uZWN0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xyXG4gICAgICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xyXG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcclxuICAgICAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xyXG4gICAgICAgIHdoaWxlIChlbCkge1xyXG4gICAgICAgICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcclxuICAgICAgICAgICAgaWYgKGVsID09PSBhbmNob3IpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xyXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXHJcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxyXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XHJcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XHJcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBjc3M6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxyXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9XHJcbiAgICAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgQmFzZVRyYW5zaXRpb24ucHJvcHMsIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKTtcclxuLyoqXHJcbiAqICMzMjI3IEluY29taW5nIGhvb2tzIG1heSBiZSBtZXJnZWQgaW50byBhcnJheXMgd2hlbiB3cmFwcGluZyBUcmFuc2l0aW9uXHJcbiAqIHdpdGggY3VzdG9tIEhPQ3MuXHJcbiAqL1xyXG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcclxuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgaG9vay5mb3JFYWNoKGggPT4gaCguLi5hcmdzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChob29rKSB7XHJcbiAgICAgICAgaG9vayguLi5hcmdzKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgaG9vayBleHBlY3RzIGEgY2FsbGJhY2sgKDJuZCBhcmcpLCB3aGljaCBtZWFucyB0aGUgdXNlclxyXG4gKiBpbnRlbmRzIHRvIGV4cGxpY2l0bHkgY29udHJvbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uLlxyXG4gKi9cclxuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XHJcbiAgICByZXR1cm4gaG9va1xyXG4gICAgICAgID8gaXNBcnJheShob29rKVxyXG4gICAgICAgICAgICA/IGhvb2suc29tZShoID0+IGgubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgOiBob29rLmxlbmd0aCA+IDFcclxuICAgICAgICA6IGZhbHNlO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XHJcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XHJcbiAgICAgICAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBiYXNlUHJvcHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG5hbWUgPSAndicsIHR5cGUsIGR1cmF0aW9uLCBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLCBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCwgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLCBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLCBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLCBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCwgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gIH0gPSByYXdQcm9wcztcclxuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xyXG4gICAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XHJcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcclxuICAgIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWwsIHJlc29sdmVdKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XHJcbiAgICAgICAgb25CZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUVudGVyLCBbZWxdKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcihlbCkge1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVudGVyOiBtYWtlRW50ZXJIb29rKGZhbHNlKSxcclxuICAgICAgICBvbkFwcGVhcjogbWFrZUVudGVySG9vayh0cnVlKSxcclxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XHJcbiAgICAgICAgICAgIGVsLl9pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZWwuX2lzTGVhdmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcclxuICAgICAgICBlbC5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcclxuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgaWYgKGVsLl92dGMpIHtcclxuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGUpO1xyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNsb25lKTtcclxuICAgIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XHJcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgcmV0dXJuIGhhc1RyYW5zZm9ybTtcclxufVxuXG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCBmbiA9IHZub2RlLnByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ10gfHxcclxuICAgICAgICAoZmFsc2UgKTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXHJcbi8vIGJlIHRyZWUtc2hha2VuIGluIGNhc2Ugdi1tb2RlbCBpcyBuZXZlciB1c2VkLlxyXG5jb25zdCB2TW9kZWxUZXh0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8ICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSAnbnVtYmVyJyk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhc3RUb051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSB0b051bWJlcihkb21WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFsYXp5KSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cclxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXHJcbiAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgLy8gYXZvaWQgY2xlYXJpbmcgdW5yZXNvbHZlZCB0ZXh0LiAjMjMwMlxyXG4gICAgICAgIGlmIChlbC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gJ3JhbmdlJykge1xyXG4gICAgICAgICAgICBpZiAobGF6eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICAgIGRlZXA6IHRydWUsXHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxyXG4gICAgZGVlcDogdHJ1ZSxcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY01vZGVsKHRhZ05hbWUsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxyXG4gICAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsQ2hlY2tib3g7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcclxuICAgIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKGVsLnRhZ05hbWUsIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpO1xyXG4gICAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xyXG4gICAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xyXG59XHJcbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcclxuLy8gZnVuY3Rpb24gaW4gU1NSXHJcbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XHJcbiAgICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XHJcbiAgICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlRXF1YWwodm5vZGUucHJvcHMudmFsdWUsIHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcclxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXHJcbiAgICAgICAgLy8gcmVzb2x2ZUR5bmFtaWNNb2RlbCBleHBlY3RzIGFuIHVwcGVyY2FzZSB0YWcgbmFtZSwgYnV0IHZub2RlLnR5cGUgaXMgbG93ZXJjYXNlXHJcbiAgICAgICAgdm5vZGUudHlwZS50b1VwcGVyQ2FzZSgpLCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKTtcclxuICAgICAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXTtcclxuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XHJcbiAgICBzdG9wOiBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXHJcbiAgICBwcmV2ZW50OiBlID0+IGUucHJldmVudERlZmF1bHQoKSxcclxuICAgIHNlbGY6IGUgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcclxuICAgIGN0cmw6IGUgPT4gIWUuY3RybEtleSxcclxuICAgIHNoaWZ0OiBlID0+ICFlLnNoaWZ0S2V5LFxyXG4gICAgYWx0OiBlID0+ICFlLmFsdEtleSxcclxuICAgIG1ldGE6IGUgPT4gIWUubWV0YUtleSxcclxuICAgIGxlZnQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCxcclxuICAgIG1pZGRsZTogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxyXG4gICAgcmlnaHQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcclxuICAgIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZShtID0+IGVbYCR7bX1LZXlgXSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKG0pKVxyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcclxuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGd1YXJkKGV2ZW50LCBtb2RpZmllcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuLy8gS2VwdCBmb3IgMi54IGNvbXBhdC5cclxuLy8gTm90ZTogSUUxMSBjb21wYXQgZm9yIGBzcGFjZWJhcmAgYW5kIGBkZWxgIGlzIHJlbW92ZWQgZm9yIG5vdy5cclxuY29uc3Qga2V5TmFtZXMgPSB7XHJcbiAgICBlc2M6ICdlc2NhcGUnLFxyXG4gICAgc3BhY2U6ICcgJyxcclxuICAgIHVwOiAnYXJyb3ctdXAnLFxyXG4gICAgbGVmdDogJ2Fycm93LWxlZnQnLFxyXG4gICAgcmlnaHQ6ICdhcnJvdy1yaWdodCcsXHJcbiAgICBkb3duOiAnYXJyb3ctZG93bicsXHJcbiAgICBkZWxldGU6ICdiYWNrc3BhY2UnXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xyXG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghKCdrZXknIGluIGV2ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50S2V5ID0gaHlwaGVuYXRlKGV2ZW50LmtleSk7XHJcbiAgICAgICAgaWYgKG1vZGlmaWVycy5zb21lKGsgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XG5cbmNvbnN0IHZTaG93ID0ge1xyXG4gICAgYmVmb3JlTW91bnQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcclxuICAgICAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcclxufVxyXG4vLyBTU1Igdm5vZGUgdHJhbnNmb3Jtcywgb25seSB1c2VkIHdoZW4gdXNlciBpbmNsdWRlcyBjbGllbnQtb3JpZW50ZWQgcmVuZGVyXHJcbi8vIGZ1bmN0aW9uIGluIFNTUlxyXG5mdW5jdGlvbiBpbml0VlNob3dGb3JTU1IoKSB7XHJcbiAgICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5jb25zdCByZW5kZXJlck9wdGlvbnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcclxuLy8gbGF6eSBjcmVhdGUgdGhlIHJlbmRlcmVyIC0gdGhpcyBtYWtlcyBjb3JlIHJlbmRlcmVyIGxvZ2ljIHRyZWUtc2hha2FibGVcclxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXHJcbmxldCByZW5kZXJlcjtcclxubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gKHJlbmRlcmVyIHx8XHJcbiAgICAgICAgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xyXG4gICAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uXHJcbiAgICAgICAgPyByZW5kZXJlclxyXG4gICAgICAgIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcclxuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlcmVyO1xyXG59XHJcbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcclxuY29uc3QgcmVuZGVyID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuaHlkcmF0ZSguLi5hcmdzKTtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIF9fVU5TQUZFX19cclxuICAgICAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzXHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cclxuICAgICAgICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2xlYXIgY29udGVudCBiZWZvcmUgbW91bnRpbmdcclxuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1hcHAnLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm94eTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gYXBwO1xyXG59KTtcclxuY29uc3QgY3JlYXRlU1NSQXBwID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gYXBwO1xyXG59KTtcclxuZnVuY3Rpb24gaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKSB7XHJcbiAgICAvLyBJbmplY3QgYGlzTmF0aXZlVGFnYFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciBjb21wb25lbnQgbmFtZSB2YWxpZGF0aW9uIChkZXYgb25seSlcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNOYXRpdmVUYWcnLCB7XHJcbiAgICAgICAgdmFsdWU6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApIHtcclxuICAgIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzQ3VzdG9tRWxlbWVudCcsIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGAgK1xyXG4gICAgICAgICAgICBgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gYCArXHJcbiAgICAgICAgICAgIGBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBgICtcclxuICAgICAgICAgICAgYG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1kb21gO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnY29tcGlsZXJPcHRpb25zJywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFyZXMpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICB3aW5kb3cuU2hhZG93Um9vdCAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxyXG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFzc3JEaXJlY3RpdmVJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGluaXRWTW9kZWxGb3JTU1IoKTtcclxuICAgICAgICAgICAgaW5pdFZTaG93Rm9yU1NSKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIFZ1ZUVsZW1lbnQsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVTU1JDdXN0b21FbGVtZW50LCBoeWRyYXRlLCBpbml0RGlyZWN0aXZlc0ZvclNTUiwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsIi8qIVxuICAqIHNoYXJlZCB2OS4zLjAtYmV0YS4yNVxuICAqIChjKSAyMDIzIGthenV5YSBrYXdhZ3VjaGlcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gICovXG4vKipcbiAqIE9yaWdpbmFsIFV0aWxpdGllc1xuICogd3JpdHRlbiBieSBrYXp1eWEga2F3YWd1Y2hpXG4gKi9cbmNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG1hcms7XG5sZXQgbWVhc3VyZTtcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICBjb25zdCBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICBpZiAocGVyZiAmJlxuICAgICAgICBwZXJmLm1hcmsgJiZcbiAgICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIGJyb3dzZXIgY29tcGF0XG4gICAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcykge1xuICAgICAgICBtYXJrID0gKHRhZykgPT4ge1xuICAgICAgICAgICAgcGVyZi5tYXJrKHRhZyk7XG4gICAgICAgIH07XG4gICAgICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IFJFX0FSR1MgPSAvXFx7KFswLTlhLXpBLVpdKylcXH0vZztcbi8qIGVzbGludC1kaXNhYmxlICovXG5mdW5jdGlvbiBmb3JtYXQobWVzc2FnZSwgLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICB9XG4gICAgaWYgKCFhcmdzIHx8ICFhcmdzLmhhc093blByb3BlcnR5KSB7XG4gICAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShSRV9BUkdTLCAobWF0Y2gsIGlkZW50aWZpZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFyZ3MuaGFzT3duUHJvcGVydHkoaWRlbnRpZmllcikgPyBhcmdzW2lkZW50aWZpZXJdIDogJyc7XG4gICAgfSk7XG59XG5jb25zdCBtYWtlU3ltYm9sID0gKG5hbWUsIHNoYXJlYWJsZSA9IGZhbHNlKSA9PiAhc2hhcmVhYmxlID8gU3ltYm9sKG5hbWUpIDogU3ltYm9sLmZvcihuYW1lKTtcbmNvbnN0IGdlbmVyYXRlRm9ybWF0Q2FjaGVLZXkgPSAobG9jYWxlLCBrZXksIHNvdXJjZSkgPT4gZnJpZW5kbHlKU09Oc3RyaW5naWZ5KHsgbDogbG9jYWxlLCBrOiBrZXksIHM6IHNvdXJjZSB9KTtcbmNvbnN0IGZyaWVuZGx5SlNPTnN0cmluZ2lmeSA9IChqc29uKSA9PiBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxuICAgIC5yZXBsYWNlKC9cXHUwMDI3L2csICdcXFxcdTAwMjcnKTtcbmNvbnN0IGlzTnVtYmVyID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKTtcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJztcbmNvbnN0IGlzRW1wdHlPYmplY3QgPSAodmFsKSA9PiBpc1BsYWluT2JqZWN0KHZhbCkgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDA7XG5mdW5jdGlvbiB3YXJuKG1zZywgZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtpbnRsaWZ5XSBgICsgbXNnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxuICAgICAgICAoX2dsb2JhbFRoaXMgPVxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XG59O1xuZnVuY3Rpb24gZXNjYXBlSHRtbChyYXdUZXh0KSB7XG4gICAgcmV0dXJuIHJhd1RleHRcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpO1xufVxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuLyogZXNsaW50LWVuYWJsZSAqL1xuLyoqXG4gKiBVc2VmdWwgVXRpbGl0aWVzIEJ5IEV2YW4geW91XG4gKiBNb2RpZmllZCBieSBrYXp1eWEga2F3YWd1Y2hpXG4gKiBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1uZXh0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9zcmMvaW5kZXgudHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtbmV4dC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvc3JjL2NvZGVmcmFtZS50c1xuICovXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbmNvbnN0IGlzQm9vbGVhbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICAgIHJldHVybiBwcm90byA9PT0gbnVsbCB8fCBwcm90by5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbi8vIGZvciBjb252ZXJ0aW5nIGxpc3QgYW5kIG5hbWVkIHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdmFsID09IG51bGxcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IGlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcpXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XG59O1xuZnVuY3Rpb24gam9pbihpdGVtcywgc2VwYXJhdG9yID0gJycpIHtcbiAgICByZXR1cm4gaXRlbXMucmVkdWNlKChzdHIsIGl0ZW0sIGluZGV4KSA9PiAoaW5kZXggPT09IDAgPyBzdHIgKyBpdGVtIDogc3RyICsgc2VwYXJhdG9yICsgaXRlbSksICcnKTtcbn1cbmNvbnN0IFJBTkdFID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIFJBTkdFOyBqIDw9IGkgKyBSQU5HRSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIEV2ZW50IGVtaXR0ZXIsIGZvcmtlZCBmcm9tIHRoZSBiZWxvdzpcbiAqIC0gb3JpZ2luYWwgcmVwb3NpdG9yeSB1cmw6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dFxuICogLSBjb2RlIHVybDogaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuICogLSBhdXRob3I6IEphc29uIE1pbGxlciAoaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdClcbiAqIC0gbGljZW5zZTogTUlUXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgZXZlbnQgZW1pdHRlclxuICpcbiAqIEByZXR1cm5zIEFuIGV2ZW50IGVtaXR0ZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBjb25zdCBldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZW1pdHRlciA9IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbihldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHMuZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudHMuc2V0KGV2ZW50LCBbaGFuZGxlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzLmdldChldmVudCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQoZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIChldmVudHMuZ2V0KGV2ZW50KSB8fCBbXSlcbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5tYXAoaGFuZGxlciA9PiBoYW5kbGVyKHBheWxvYWQpKTtcbiAgICAgICAgICAgIChldmVudHMuZ2V0KCcqJykgfHwgW10pXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAubWFwKGhhbmRsZXIgPT4gaGFuZGxlcihldmVudCwgcGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbn1cblxuZXhwb3J0IHsgYXNzaWduLCBjcmVhdGVFbWl0dGVyLCBlc2NhcGVIdG1sLCBmb3JtYXQsIGZyaWVuZGx5SlNPTnN0cmluZ2lmeSwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdlbmVyYXRlRm9ybWF0Q2FjaGVLZXksIGdldEdsb2JhbFRoaXMsIGhhc093biwgaW5Ccm93c2VyLCBpc0FycmF5LCBpc0Jvb2xlYW4sIGlzRGF0ZSwgaXNFbXB0eU9iamVjdCwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1N0cmluZywgaXNTeW1ib2wsIGpvaW4sIG1ha2VTeW1ib2wsIG1hcmssIG1lYXN1cmUsIG9iamVjdFRvU3RyaW5nLCB0b0Rpc3BsYXlTdHJpbmcsIHRvVHlwZVN0cmluZywgd2FybiB9O1xuIiwiLyohXG4gICogbWVzc2FnZS1jb21waWxlciB2OS4zLjAtYmV0YS4yNVxuICAqIChjKSAyMDIzIGthenV5YSBrYXdhZ3VjaGlcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gICovXG5jb25zdCBMT0NBVElPTl9TVFVCID0ge1xuICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXG4gICAgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbihsaW5lLCBjb2x1bW4sIG9mZnNldCkge1xuICAgIHJldHVybiB7IGxpbmUsIGNvbHVtbiwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihzdGFydCwgZW5kLCBzb3VyY2UpIHtcbiAgICBjb25zdCBsb2MgPSB7IHN0YXJ0LCBlbmQgfTtcbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbG9jLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYztcbn1cblxuLyoqXG4gKiBPcmlnaW5hbCBVdGlsaXRpZXNcbiAqIHdyaXR0ZW4gYnkga2F6dXlhIGthd2FndWNoaVxuICovXG5jb25zdCBSRV9BUkdTID0gL1xceyhbMC05YS16QS1aXSspXFx9L2c7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgaXNPYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgfVxuICAgIGlmICghYXJncyB8fCAhYXJncy5oYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgICBhcmdzID0ge307XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlLnJlcGxhY2UoUkVfQVJHUywgKG1hdGNoLCBpZGVudGlmaWVyKSA9PiB7XG4gICAgICAgIHJldHVybiBhcmdzLmhhc093blByb3BlcnR5KGlkZW50aWZpZXIpID8gYXJnc1tpZGVudGlmaWVyXSA6ICcnO1xuICAgIH0pO1xufVxuY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG5mdW5jdGlvbiBqb2luKGl0ZW1zLCBzZXBhcmF0b3IgPSAnJykge1xuICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKHN0ciwgaXRlbSwgaW5kZXgpID0+IChpbmRleCA9PT0gMCA/IHN0ciArIGl0ZW0gOiBzdHIgKyBzZXBhcmF0b3IgKyBpdGVtKSwgJycpO1xufVxuXG5jb25zdCBDb21waWxlRXJyb3JDb2RlcyA9IHtcbiAgICAvLyB0b2tlbml6ZXIgZXJyb3IgY29kZXNcbiAgICBFWFBFQ1RFRF9UT0tFTjogMSxcbiAgICBJTlZBTElEX1RPS0VOX0lOX1BMQUNFSE9MREVSOiAyLFxuICAgIFVOVEVSTUlOQVRFRF9TSU5HTEVfUVVPVEVfSU5fUExBQ0VIT0xERVI6IDMsXG4gICAgVU5LTk9XTl9FU0NBUEVfU0VRVUVOQ0U6IDQsXG4gICAgSU5WQUxJRF9VTklDT0RFX0VTQ0FQRV9TRVFVRU5DRTogNSxcbiAgICBVTkJBTEFOQ0VEX0NMT1NJTkdfQlJBQ0U6IDYsXG4gICAgVU5URVJNSU5BVEVEX0NMT1NJTkdfQlJBQ0U6IDcsXG4gICAgRU1QVFlfUExBQ0VIT0xERVI6IDgsXG4gICAgTk9UX0FMTE9XX05FU1RfUExBQ0VIT0xERVI6IDksXG4gICAgSU5WQUxJRF9MSU5LRURfRk9STUFUOiAxMCxcbiAgICAvLyBwYXJzZXIgZXJyb3IgY29kZXNcbiAgICBNVVNUX0hBVkVfTUVTU0FHRVNfSU5fUExVUkFMOiAxMSxcbiAgICBVTkVYUEVDVEVEX0VNUFRZX0xJTktFRF9NT0RJRklFUjogMTIsXG4gICAgVU5FWFBFQ1RFRF9FTVBUWV9MSU5LRURfS0VZOiAxMyxcbiAgICBVTkVYUEVDVEVEX0xFWElDQUxfQU5BTFlTSVM6IDE0LFxuICAgIC8vIFNwZWNpYWwgdmFsdWUgZm9yIGhpZ2hlci1vcmRlciBjb21waWxlcnMgdG8gcGljayB1cCB0aGUgbGFzdCBjb2RlXG4gICAgLy8gdG8gYXZvaWQgY29sbGlzaW9uIG9mIGVycm9yIGNvZGVzLiBUaGlzIHNob3VsZCBhbHdheXMgYmUga2VwdCBhcyB0aGUgbGFzdFxuICAgIC8vIGl0ZW0uXG4gICAgX19FWFRFTkRfUE9JTlRfXzogMTVcbn07XG4vKiogQGludGVybmFsICovXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIC8vIHRva2VuaXplciBlcnJvciBtZXNzYWdlc1xuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5FWFBFQ1RFRF9UT0tFTl06IGBFeHBlY3RlZCB0b2tlbjogJ3swfSdgLFxuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5JTlZBTElEX1RPS0VOX0lOX1BMQUNFSE9MREVSXTogYEludmFsaWQgdG9rZW4gaW4gcGxhY2Vob2xkZXI6ICd7MH0nYCxcbiAgICBbQ29tcGlsZUVycm9yQ29kZXMuVU5URVJNSU5BVEVEX1NJTkdMRV9RVU9URV9JTl9QTEFDRUhPTERFUl06IGBVbnRlcm1pbmF0ZWQgc2luZ2xlIHF1b3RlIGluIHBsYWNlaG9sZGVyYCxcbiAgICBbQ29tcGlsZUVycm9yQ29kZXMuVU5LTk9XTl9FU0NBUEVfU0VRVUVOQ0VdOiBgVW5rbm93biBlc2NhcGUgc2VxdWVuY2U6IFxcXFx7MH1gLFxuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5JTlZBTElEX1VOSUNPREVfRVNDQVBFX1NFUVVFTkNFXTogYEludmFsaWQgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2U6IHswfWAsXG4gICAgW0NvbXBpbGVFcnJvckNvZGVzLlVOQkFMQU5DRURfQ0xPU0lOR19CUkFDRV06IGBVbmJhbGFuY2VkIGNsb3NpbmcgYnJhY2VgLFxuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5VTlRFUk1JTkFURURfQ0xPU0lOR19CUkFDRV06IGBVbnRlcm1pbmF0ZWQgY2xvc2luZyBicmFjZWAsXG4gICAgW0NvbXBpbGVFcnJvckNvZGVzLkVNUFRZX1BMQUNFSE9MREVSXTogYEVtcHR5IHBsYWNlaG9sZGVyYCxcbiAgICBbQ29tcGlsZUVycm9yQ29kZXMuTk9UX0FMTE9XX05FU1RfUExBQ0VIT0xERVJdOiBgTm90IGFsbG93ZWQgbmVzdCBwbGFjZWhvbGRlcmAsXG4gICAgW0NvbXBpbGVFcnJvckNvZGVzLklOVkFMSURfTElOS0VEX0ZPUk1BVF06IGBJbnZhbGlkIGxpbmtlZCBmb3JtYXRgLFxuICAgIC8vIHBhcnNlciBlcnJvciBtZXNzYWdlc1xuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5NVVNUX0hBVkVfTUVTU0FHRVNfSU5fUExVUkFMXTogYFBsdXJhbCBtdXN0IGhhdmUgbWVzc2FnZXNgLFxuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0VNUFRZX0xJTktFRF9NT0RJRklFUl06IGBVbmV4cGVjdGVkIGVtcHR5IGxpbmtlZCBtb2RpZmllcmAsXG4gICAgW0NvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfRU1QVFlfTElOS0VEX0tFWV06IGBVbmV4cGVjdGVkIGVtcHR5IGxpbmtlZCBrZXlgLFxuICAgIFtDb21waWxlRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0xFWElDQUxfQU5BTFlTSVNdOiBgVW5leHBlY3RlZCBsZXhpY2FsIGFuYWx5c2lzIGluIHRva2VuOiAnezB9J2Bcbn07XG5mdW5jdGlvbiBjcmVhdGVDb21waWxlRXJyb3IoY29kZSwgbG9jLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRvbWFpbiwgbWVzc2FnZXMsIGFyZ3MgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgbXNnID0gZm9ybWF0KChtZXNzYWdlcyB8fCBlcnJvck1lc3NhZ2VzKVtjb2RlXSB8fCAnJywgLi4uKGFyZ3MgfHwgW10pKVxuICAgICAgICA7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoU3RyaW5nKG1zZykpO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIGlmIChsb2MpIHtcbiAgICAgICAgZXJyb3IubG9jYXRpb24gPSBsb2M7XG4gICAgfVxuICAgIGVycm9yLmRvbWFpbiA9IGRvbWFpbjtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuXG5jb25zdCBSRV9IVE1MX1RBRyA9IC88XFwvP1tcXHdcXHM9XCIvLic6OyMtXFwvXSs+LztcbmNvbnN0IGRldGVjdEh0bWxUYWcgPSAoc291cmNlKSA9PiBSRV9IVE1MX1RBRy50ZXN0KHNvdXJjZSk7XG5cbmNvbnN0IENIQVJfU1AgPSAnICc7XG5jb25zdCBDSEFSX0NSID0gJ1xccic7XG5jb25zdCBDSEFSX0xGID0gJ1xcbic7XG5jb25zdCBDSEFSX0xTID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDIwMjgpO1xuY29uc3QgQ0hBUl9QUyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHgyMDI5KTtcbmZ1bmN0aW9uIGNyZWF0ZVNjYW5uZXIoc3RyKSB7XG4gICAgY29uc3QgX2J1ZiA9IHN0cjtcbiAgICBsZXQgX2luZGV4ID0gMDtcbiAgICBsZXQgX2xpbmUgPSAxO1xuICAgIGxldCBfY29sdW1uID0gMTtcbiAgICBsZXQgX3BlZWtPZmZzZXQgPSAwO1xuICAgIGNvbnN0IGlzQ1JMRiA9IChpbmRleCkgPT4gX2J1ZltpbmRleF0gPT09IENIQVJfQ1IgJiYgX2J1ZltpbmRleCArIDFdID09PSBDSEFSX0xGO1xuICAgIGNvbnN0IGlzTEYgPSAoaW5kZXgpID0+IF9idWZbaW5kZXhdID09PSBDSEFSX0xGO1xuICAgIGNvbnN0IGlzUFMgPSAoaW5kZXgpID0+IF9idWZbaW5kZXhdID09PSBDSEFSX1BTO1xuICAgIGNvbnN0IGlzTFMgPSAoaW5kZXgpID0+IF9idWZbaW5kZXhdID09PSBDSEFSX0xTO1xuICAgIGNvbnN0IGlzTGluZUVuZCA9IChpbmRleCkgPT4gaXNDUkxGKGluZGV4KSB8fCBpc0xGKGluZGV4KSB8fCBpc1BTKGluZGV4KSB8fCBpc0xTKGluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9ICgpID0+IF9pbmRleDtcbiAgICBjb25zdCBsaW5lID0gKCkgPT4gX2xpbmU7XG4gICAgY29uc3QgY29sdW1uID0gKCkgPT4gX2NvbHVtbjtcbiAgICBjb25zdCBwZWVrT2Zmc2V0ID0gKCkgPT4gX3BlZWtPZmZzZXQ7XG4gICAgY29uc3QgY2hhckF0ID0gKG9mZnNldCkgPT4gaXNDUkxGKG9mZnNldCkgfHwgaXNQUyhvZmZzZXQpIHx8IGlzTFMob2Zmc2V0KSA/IENIQVJfTEYgOiBfYnVmW29mZnNldF07XG4gICAgY29uc3QgY3VycmVudENoYXIgPSAoKSA9PiBjaGFyQXQoX2luZGV4KTtcbiAgICBjb25zdCBjdXJyZW50UGVlayA9ICgpID0+IGNoYXJBdChfaW5kZXggKyBfcGVla09mZnNldCk7XG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgX3BlZWtPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoaXNMaW5lRW5kKF9pbmRleCkpIHtcbiAgICAgICAgICAgIF9saW5lKys7XG4gICAgICAgICAgICBfY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDUkxGKF9pbmRleCkpIHtcbiAgICAgICAgICAgIF9pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIF9pbmRleCsrO1xuICAgICAgICBfY29sdW1uKys7XG4gICAgICAgIHJldHVybiBfYnVmW19pbmRleF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIGlmIChpc0NSTEYoX2luZGV4ICsgX3BlZWtPZmZzZXQpKSB7XG4gICAgICAgICAgICBfcGVla09mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIF9wZWVrT2Zmc2V0Kys7XG4gICAgICAgIHJldHVybiBfYnVmW19pbmRleCArIF9wZWVrT2Zmc2V0XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF9pbmRleCA9IDA7XG4gICAgICAgIF9saW5lID0gMTtcbiAgICAgICAgX2NvbHVtbiA9IDE7XG4gICAgICAgIF9wZWVrT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRQZWVrKG9mZnNldCA9IDApIHtcbiAgICAgICAgX3BlZWtPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBUb1BlZWsoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IF9pbmRleCArIF9wZWVrT2Zmc2V0O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5tb2RpZmllZC1sb29wLWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodGFyZ2V0ICE9PSBfaW5kZXgpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBfcGVla09mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4LFxuICAgICAgICBsaW5lLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIHBlZWtPZmZzZXQsXG4gICAgICAgIGNoYXJBdCxcbiAgICAgICAgY3VycmVudENoYXIsXG4gICAgICAgIGN1cnJlbnRQZWVrLFxuICAgICAgICBuZXh0LFxuICAgICAgICBwZWVrLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRQZWVrLFxuICAgICAgICBza2lwVG9QZWVrXG4gICAgfTtcbn1cblxuY29uc3QgRU9GID0gdW5kZWZpbmVkO1xuY29uc3QgTElURVJBTF9ERUxJTUlURVIgPSBcIidcIjtcbmNvbnN0IEVSUk9SX0RPTUFJTiQxID0gJ3Rva2VuaXplcic7XG5mdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IG9wdGlvbnMubG9jYXRpb24gIT09IGZhbHNlO1xuICAgIGNvbnN0IF9zY25yID0gY3JlYXRlU2Nhbm5lcihzb3VyY2UpO1xuICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSAoKSA9PiBfc2Nuci5pbmRleCgpO1xuICAgIGNvbnN0IGN1cnJlbnRQb3NpdGlvbiA9ICgpID0+IGNyZWF0ZVBvc2l0aW9uKF9zY25yLmxpbmUoKSwgX3NjbnIuY29sdW1uKCksIF9zY25yLmluZGV4KCkpO1xuICAgIGNvbnN0IF9pbml0TG9jID0gY3VycmVudFBvc2l0aW9uKCk7XG4gICAgY29uc3QgX2luaXRPZmZzZXQgPSBjdXJyZW50T2Zmc2V0KCk7XG4gICAgY29uc3QgX2NvbnRleHQgPSB7XG4gICAgICAgIGN1cnJlbnRUeXBlOiAxNCAvKiBUb2tlblR5cGVzLkVPRiAqLyxcbiAgICAgICAgb2Zmc2V0OiBfaW5pdE9mZnNldCxcbiAgICAgICAgc3RhcnRMb2M6IF9pbml0TG9jLFxuICAgICAgICBlbmRMb2M6IF9pbml0TG9jLFxuICAgICAgICBsYXN0VHlwZTogMTQgLyogVG9rZW5UeXBlcy5FT0YgKi8sXG4gICAgICAgIGxhc3RPZmZzZXQ6IF9pbml0T2Zmc2V0LFxuICAgICAgICBsYXN0U3RhcnRMb2M6IF9pbml0TG9jLFxuICAgICAgICBsYXN0RW5kTG9jOiBfaW5pdExvYyxcbiAgICAgICAgYnJhY2VOZXN0OiAwLFxuICAgICAgICBpbkxpbmtlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6ICcnXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gX2NvbnRleHQ7XG4gICAgY29uc3QgeyBvbkVycm9yIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIGVtaXRFcnJvcihjb2RlLCBwb3MsIG9mZnNldCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0KCk7XG4gICAgICAgIHBvcy5jb2x1bW4gKz0gb2Zmc2V0O1xuICAgICAgICBwb3Mub2Zmc2V0ICs9IG9mZnNldDtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGxvY2F0aW9uID8gY3JlYXRlTG9jYXRpb24oY3R4LnN0YXJ0TG9jLCBwb3MpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNyZWF0ZUNvbXBpbGVFcnJvcihjb2RlLCBsb2MsIHtcbiAgICAgICAgICAgICAgICBkb21haW46IEVSUk9SX0RPTUFJTiQxLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRva2VuKGNvbnRleHQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnRleHQuZW5kTG9jID0gY3VycmVudFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFR5cGUgPSB0eXBlO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHsgdHlwZSB9O1xuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRva2VuLmxvYyA9IGNyZWF0ZUxvY2F0aW9uKGNvbnRleHQuc3RhcnRMb2MsIGNvbnRleHQuZW5kTG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGNvbnN0IGdldEVuZFRva2VuID0gKGNvbnRleHQpID0+IGdldFRva2VuKGNvbnRleHQsIDE0IC8qIFRva2VuVHlwZXMuRU9GICovKTtcbiAgICBmdW5jdGlvbiBlYXQoc2NuciwgY2gpIHtcbiAgICAgICAgaWYgKHNjbnIuY3VycmVudENoYXIoKSA9PT0gY2gpIHtcbiAgICAgICAgICAgIHNjbnIubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLkVYUEVDVEVEX1RPS0VOLCBjdXJyZW50UG9zaXRpb24oKSwgMCwgY2gpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZWtTcGFjZXMoc2Nucikge1xuICAgICAgICBsZXQgYnVmID0gJyc7XG4gICAgICAgIHdoaWxlIChzY25yLmN1cnJlbnRQZWVrKCkgPT09IENIQVJfU1AgfHwgc2Nuci5jdXJyZW50UGVlaygpID09PSBDSEFSX0xGKSB7XG4gICAgICAgICAgICBidWYgKz0gc2Nuci5jdXJyZW50UGVlaygpO1xuICAgICAgICAgICAgc2Nuci5wZWVrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2tpcFNwYWNlcyhzY25yKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHBlZWtTcGFjZXMoc2Nucik7XG4gICAgICAgIHNjbnIuc2tpcFRvUGVlaygpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICBpZiAoY2ggPT09IEVPRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNjID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuICgoY2MgPj0gOTcgJiYgY2MgPD0gMTIyKSB8fCAvLyBhLXpcbiAgICAgICAgICAgIChjYyA+PSA2NSAmJiBjYyA8PSA5MCkgfHwgLy8gQS1aXG4gICAgICAgICAgICBjYyA9PT0gOTUgLy8gX1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc051bWJlclN0YXJ0KGNoKSB7XG4gICAgICAgIGlmIChjaCA9PT0gRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2MgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gY2MgPj0gNDggJiYgY2MgPD0gNTc7IC8vIDAtOVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkSWRlbnRpZmllclN0YXJ0KHNjbnIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VHlwZSB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlICE9PSAyIC8qIFRva2VuVHlwZXMuQnJhY2VMZWZ0ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGVla1NwYWNlcyhzY25yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gaXNJZGVudGlmaWVyU3RhcnQoc2Nuci5jdXJyZW50UGVlaygpKTtcbiAgICAgICAgc2Nuci5yZXNldFBlZWsoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXN0SWRlbnRpZmllclN0YXJ0KHNjbnIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VHlwZSB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlICE9PSAyIC8qIFRva2VuVHlwZXMuQnJhY2VMZWZ0ICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGVla1NwYWNlcyhzY25yKTtcbiAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRQZWVrKCkgPT09ICctJyA/IHNjbnIucGVlaygpIDogc2Nuci5jdXJyZW50UGVlaygpO1xuICAgICAgICBjb25zdCByZXQgPSBpc051bWJlclN0YXJ0KGNoKTtcbiAgICAgICAgc2Nuci5yZXNldFBlZWsoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXRlcmFsU3RhcnQoc2NuciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRUeXBlIH0gPSBjb250ZXh0O1xuICAgICAgICBpZiAoY3VycmVudFR5cGUgIT09IDIgLyogVG9rZW5UeXBlcy5CcmFjZUxlZnQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwZWVrU3BhY2VzKHNjbnIpO1xuICAgICAgICBjb25zdCByZXQgPSBzY25yLmN1cnJlbnRQZWVrKCkgPT09IExJVEVSQUxfREVMSU1JVEVSO1xuICAgICAgICBzY25yLnJlc2V0UGVlaygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpbmtlZERvdFN0YXJ0KHNjbnIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VHlwZSB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlICE9PSA4IC8qIFRva2VuVHlwZXMuTGlua2VkQWxpYXMgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwZWVrU3BhY2VzKHNjbnIpO1xuICAgICAgICBjb25zdCByZXQgPSBzY25yLmN1cnJlbnRQZWVrKCkgPT09IFwiLlwiIC8qIFRva2VuQ2hhcnMuTGlua2VkRG90ICovO1xuICAgICAgICBzY25yLnJlc2V0UGVlaygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpbmtlZE1vZGlmaWVyU3RhcnQoc2NuciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRUeXBlIH0gPSBjb250ZXh0O1xuICAgICAgICBpZiAoY3VycmVudFR5cGUgIT09IDkgLyogVG9rZW5UeXBlcy5MaW5rZWREb3QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwZWVrU3BhY2VzKHNjbnIpO1xuICAgICAgICBjb25zdCByZXQgPSBpc0lkZW50aWZpZXJTdGFydChzY25yLmN1cnJlbnRQZWVrKCkpO1xuICAgICAgICBzY25yLnJlc2V0UGVlaygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpbmtlZERlbGltaXRlclN0YXJ0KHNjbnIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VHlwZSB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKCEoY3VycmVudFR5cGUgPT09IDggLyogVG9rZW5UeXBlcy5MaW5rZWRBbGlhcyAqLyB8fFxuICAgICAgICAgICAgY3VycmVudFR5cGUgPT09IDEyIC8qIFRva2VuVHlwZXMuTGlua2VkTW9kaWZpZXIgKi8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGVla1NwYWNlcyhzY25yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gc2Nuci5jdXJyZW50UGVlaygpID09PSBcIjpcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZERlbGltaXRlciAqLztcbiAgICAgICAgc2Nuci5yZXNldFBlZWsoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaW5rZWRSZWZlclN0YXJ0KHNjbnIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VHlwZSB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlICE9PSAxMCAvKiBUb2tlblR5cGVzLkxpbmtlZERlbGltaXRlciAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRQZWVrKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwie1wiIC8qIFRva2VuQ2hhcnMuQnJhY2VMZWZ0ICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KHNjbnIucGVlaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSBcIkBcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZEFsaWFzICovIHx8XG4gICAgICAgICAgICAgICAgY2ggPT09IFwiJVwiIC8qIFRva2VuQ2hhcnMuTW9kdWxvICovIHx8XG4gICAgICAgICAgICAgICAgY2ggPT09IFwifFwiIC8qIFRva2VuQ2hhcnMuUGlwZSAqLyB8fFxuICAgICAgICAgICAgICAgIGNoID09PSBcIjpcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZERlbGltaXRlciAqLyB8fFxuICAgICAgICAgICAgICAgIGNoID09PSBcIi5cIiAvKiBUb2tlbkNoYXJzLkxpbmtlZERvdCAqLyB8fFxuICAgICAgICAgICAgICAgIGNoID09PSBDSEFSX1NQIHx8XG4gICAgICAgICAgICAgICAgIWNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IENIQVJfTEYpIHtcbiAgICAgICAgICAgICAgICBzY25yLnBlZWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXQgPSBmbigpO1xuICAgICAgICBzY25yLnJlc2V0UGVlaygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1BsdXJhbFN0YXJ0KHNjbnIpIHtcbiAgICAgICAgcGVla1NwYWNlcyhzY25yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gc2Nuci5jdXJyZW50UGVlaygpID09PSBcInxcIiAvKiBUb2tlbkNoYXJzLlBpcGUgKi87XG4gICAgICAgIHNjbnIucmVzZXRQZWVrKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGVjdE1vZHVsb1N0YXJ0KHNjbnIpIHtcbiAgICAgICAgY29uc3Qgc3BhY2VzID0gcGVla1NwYWNlcyhzY25yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gc2Nuci5jdXJyZW50UGVlaygpID09PSBcIiVcIiAvKiBUb2tlbkNoYXJzLk1vZHVsbyAqLyAmJlxuICAgICAgICAgICAgc2Nuci5wZWVrKCkgPT09IFwie1wiIC8qIFRva2VuQ2hhcnMuQnJhY2VMZWZ0ICovO1xuICAgICAgICBzY25yLnJlc2V0UGVlaygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNNb2R1bG86IHJldCxcbiAgICAgICAgICAgIGhhc1NwYWNlOiBzcGFjZXMubGVuZ3RoID4gMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1RleHRTdGFydChzY25yLCByZXNldCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZm4gPSAoaGFzU3BhY2UgPSBmYWxzZSwgcHJldiA9ICcnLCBkZXRlY3RNb2R1bG8gPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRQZWVrKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwie1wiIC8qIFRva2VuQ2hhcnMuQnJhY2VMZWZ0ICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgPT09IFwiJVwiIC8qIFRva2VuQ2hhcnMuTW9kdWxvICovID8gZmFsc2UgOiBoYXNTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSBcIkBcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZEFsaWFzICovIHx8ICFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ID09PSBcIiVcIiAvKiBUb2tlbkNoYXJzLk1vZHVsbyAqLyA/IHRydWUgOiBoYXNTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSBcIiVcIiAvKiBUb2tlbkNoYXJzLk1vZHVsbyAqLykge1xuICAgICAgICAgICAgICAgIHNjbnIucGVlaygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihoYXNTcGFjZSwgXCIlXCIgLyogVG9rZW5DaGFycy5Nb2R1bG8gKi8sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwifFwiIC8qIFRva2VuQ2hhcnMuUGlwZSAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ID09PSBcIiVcIiAvKiBUb2tlbkNoYXJzLk1vZHVsbyAqLyB8fCBkZXRlY3RNb2R1bG9cbiAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIDogIShwcmV2ID09PSBDSEFSX1NQIHx8IHByZXYgPT09IENIQVJfTEYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IENIQVJfU1ApIHtcbiAgICAgICAgICAgICAgICBzY25yLnBlZWsoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4odHJ1ZSwgQ0hBUl9TUCwgZGV0ZWN0TW9kdWxvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSBDSEFSX0xGKSB7XG4gICAgICAgICAgICAgICAgc2Nuci5wZWVrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRydWUsIENIQVJfTEYsIGRldGVjdE1vZHVsbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmV0ID0gZm4oKTtcbiAgICAgICAgcmVzZXQgJiYgc2Nuci5yZXNldFBlZWsoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUNoYXIoc2NuciwgZm4pIHtcbiAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRDaGFyKCk7XG4gICAgICAgIGlmIChjaCA9PT0gRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbihjaCkpIHtcbiAgICAgICAgICAgIHNjbnIubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YWtlSWRlbnRpZmllckNoYXIoc2Nucikge1xuICAgICAgICBjb25zdCBjbG9zdXJlID0gKGNoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYyA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICByZXR1cm4gKChjYyA+PSA5NyAmJiBjYyA8PSAxMjIpIHx8IC8vIGEtelxuICAgICAgICAgICAgICAgIChjYyA+PSA2NSAmJiBjYyA8PSA5MCkgfHwgLy8gQS1aXG4gICAgICAgICAgICAgICAgKGNjID49IDQ4ICYmIGNjIDw9IDU3KSB8fCAvLyAwLTlcbiAgICAgICAgICAgICAgICBjYyA9PT0gOTUgfHwgLy8gX1xuICAgICAgICAgICAgICAgIGNjID09PSAzNiAvLyAkXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGFrZUNoYXIoc2NuciwgY2xvc3VyZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRha2VEaWdpdChzY25yKSB7XG4gICAgICAgIGNvbnN0IGNsb3N1cmUgPSAoY2gpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHJldHVybiBjYyA+PSA0OCAmJiBjYyA8PSA1NzsgLy8gMC05XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0YWtlQ2hhcihzY25yLCBjbG9zdXJlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUhleERpZ2l0KHNjbnIpIHtcbiAgICAgICAgY29uc3QgY2xvc3VyZSA9IChjaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2MgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuICgoY2MgPj0gNDggJiYgY2MgPD0gNTcpIHx8IC8vIDAtOVxuICAgICAgICAgICAgICAgIChjYyA+PSA2NSAmJiBjYyA8PSA3MCkgfHwgLy8gQS1GXG4gICAgICAgICAgICAgICAgKGNjID49IDk3ICYmIGNjIDw9IDEwMikpOyAvLyBhLWZcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRha2VDaGFyKHNjbnIsIGNsb3N1cmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXREaWdpdHMoc2Nucikge1xuICAgICAgICBsZXQgY2ggPSAnJztcbiAgICAgICAgbGV0IG51bSA9ICcnO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGFrZURpZ2l0KHNjbnIpKSkge1xuICAgICAgICAgICAgbnVtICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRNb2R1bG8oc2Nucikge1xuICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICBjb25zdCBjaCA9IHNjbnIuY3VycmVudENoYXIoKTtcbiAgICAgICAgaWYgKGNoICE9PSBcIiVcIiAvKiBUb2tlbkNoYXJzLk1vZHVsbyAqLykge1xuICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLkVYUEVDVEVEX1RPS0VOLCBjdXJyZW50UG9zaXRpb24oKSwgMCwgY2gpO1xuICAgICAgICB9XG4gICAgICAgIHNjbnIubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCIlXCIgLyogVG9rZW5DaGFycy5Nb2R1bG8gKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRUZXh0KHNjbnIpIHtcbiAgICAgICAgbGV0IGJ1ZiA9ICcnO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRDaGFyKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwie1wiIC8qIFRva2VuQ2hhcnMuQnJhY2VMZWZ0ICovIHx8XG4gICAgICAgICAgICAgICAgY2ggPT09IFwifVwiIC8qIFRva2VuQ2hhcnMuQnJhY2VSaWdodCAqLyB8fFxuICAgICAgICAgICAgICAgIGNoID09PSBcIkBcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZEFsaWFzICovIHx8XG4gICAgICAgICAgICAgICAgY2ggPT09IFwifFwiIC8qIFRva2VuQ2hhcnMuUGlwZSAqLyB8fFxuICAgICAgICAgICAgICAgICFjaCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiJVwiIC8qIFRva2VuQ2hhcnMuTW9kdWxvICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dFN0YXJ0KHNjbnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gQ0hBUl9TUCB8fCBjaCA9PT0gQ0hBUl9MRikge1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHRTdGFydChzY25yKSkge1xuICAgICAgICAgICAgICAgICAgICBidWYgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIHNjbnIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1BsdXJhbFN0YXJ0KHNjbnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBzY25yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gY2g7XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZE5hbWVkSWRlbnRpZmllcihzY25yKSB7XG4gICAgICAgIHNraXBTcGFjZXMoc2Nucik7XG4gICAgICAgIGxldCBjaCA9ICcnO1xuICAgICAgICBsZXQgbmFtZSA9ICcnO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGFrZUlkZW50aWZpZXJDaGFyKHNjbnIpKSkge1xuICAgICAgICAgICAgbmFtZSArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nuci5jdXJyZW50Q2hhcigpID09PSBFT0YpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihDb21waWxlRXJyb3JDb2Rlcy5VTlRFUk1JTkFURURfQ0xPU0lOR19CUkFDRSwgY3VycmVudFBvc2l0aW9uKCksIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkTGlzdElkZW50aWZpZXIoc2Nucikge1xuICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKHNjbnIuY3VycmVudENoYXIoKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzY25yLm5leHQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IGAtJHtnZXREaWdpdHMoc2Nucil9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGdldERpZ2l0cyhzY25yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nuci5jdXJyZW50Q2hhcigpID09PSBFT0YpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihDb21waWxlRXJyb3JDb2Rlcy5VTlRFUk1JTkFURURfQ0xPU0lOR19CUkFDRSwgY3VycmVudFBvc2l0aW9uKCksIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZExpdGVyYWwoc2Nucikge1xuICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICBlYXQoc2NuciwgYFxcJ2ApO1xuICAgICAgICBsZXQgY2ggPSAnJztcbiAgICAgICAgbGV0IGxpdGVyYWwgPSAnJztcbiAgICAgICAgY29uc3QgZm4gPSAoeCkgPT4geCAhPT0gTElURVJBTF9ERUxJTUlURVIgJiYgeCAhPT0gQ0hBUl9MRjtcbiAgICAgICAgd2hpbGUgKChjaCA9IHRha2VDaGFyKHNjbnIsIGZuKSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbCArPSByZWFkRXNjYXBlU2VxdWVuY2Uoc2Nucik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzY25yLmN1cnJlbnRDaGFyKCk7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBDSEFSX0xGIHx8IGN1cnJlbnQgPT09IEVPRikge1xuICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLlVOVEVSTUlOQVRFRF9TSU5HTEVfUVVPVEVfSU5fUExBQ0VIT0xERVIsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgICAgIC8vIFRPRE86IElzIGl0IGNvcnJlY3QgcmVhbGx5P1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IENIQVJfTEYpIHtcbiAgICAgICAgICAgICAgICBzY25yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBlYXQoc2NuciwgYFxcJ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWF0KHNjbnIsIGBcXCdgKTtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRFc2NhcGVTZXF1ZW5jZShzY25yKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc2Nuci5jdXJyZW50Q2hhcigpO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICAgIGNhc2UgYFxcJ2A6XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcXFxcJHtjaH1gO1xuICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc2NuciwgY2gsIDQpO1xuICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc2NuciwgY2gsIDYpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoQ29tcGlsZUVycm9yQ29kZXMuVU5LTk9XTl9FU0NBUEVfU0VRVUVOQ0UsIGN1cnJlbnRQb3NpdGlvbigpLCAwLCBjaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc2NuciwgdW5pY29kZSwgZGlnaXRzKSB7XG4gICAgICAgIGVhdChzY25yLCB1bmljb2RlKTtcbiAgICAgICAgbGV0IHNlcXVlbmNlID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGFrZUhleERpZ2l0KHNjbnIpO1xuICAgICAgICAgICAgaWYgKCFjaCkge1xuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihDb21waWxlRXJyb3JDb2Rlcy5JTlZBTElEX1VOSUNPREVfRVNDQVBFX1NFUVVFTkNFLCBjdXJyZW50UG9zaXRpb24oKSwgMCwgYFxcXFwke3VuaWNvZGV9JHtzZXF1ZW5jZX0ke3NjbnIuY3VycmVudENoYXIoKX1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcXVlbmNlICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXFxcXCR7dW5pY29kZX0ke3NlcXVlbmNlfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRJbnZhbGlkSWRlbnRpZmllcihzY25yKSB7XG4gICAgICAgIHNraXBTcGFjZXMoc2Nucik7XG4gICAgICAgIGxldCBjaCA9ICcnO1xuICAgICAgICBsZXQgaWRlbnRpZmllcnMgPSAnJztcbiAgICAgICAgY29uc3QgY2xvc3VyZSA9IChjaCkgPT4gY2ggIT09IFwie1wiIC8qIFRva2VuQ2hhcnMuQnJhY2VMZWZ0ICovICYmXG4gICAgICAgICAgICBjaCAhPT0gXCJ9XCIgLyogVG9rZW5DaGFycy5CcmFjZVJpZ2h0ICovICYmXG4gICAgICAgICAgICBjaCAhPT0gQ0hBUl9TUCAmJlxuICAgICAgICAgICAgY2ggIT09IENIQVJfTEY7XG4gICAgICAgIHdoaWxlICgoY2ggPSB0YWtlQ2hhcihzY25yLCBjbG9zdXJlKSkpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXJzICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZExpbmtlZE1vZGlmaWVyKHNjbnIpIHtcbiAgICAgICAgbGV0IGNoID0gJyc7XG4gICAgICAgIGxldCBuYW1lID0gJyc7XG4gICAgICAgIHdoaWxlICgoY2ggPSB0YWtlSWRlbnRpZmllckNoYXIoc2NucikpKSB7XG4gICAgICAgICAgICBuYW1lICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkTGlua2VkUmVmZXIoc2Nucikge1xuICAgICAgICBjb25zdCBmbiA9IChkZXRlY3QgPSBmYWxzZSwgYnVmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHNjbnIuY3VycmVudENoYXIoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCJ7XCIgLyogVG9rZW5DaGFycy5CcmFjZUxlZnQgKi8gfHxcbiAgICAgICAgICAgICAgICBjaCA9PT0gXCIlXCIgLyogVG9rZW5DaGFycy5Nb2R1bG8gKi8gfHxcbiAgICAgICAgICAgICAgICBjaCA9PT0gXCJAXCIgLyogVG9rZW5DaGFycy5MaW5rZWRBbGlhcyAqLyB8fFxuICAgICAgICAgICAgICAgIGNoID09PSBcInxcIiAvKiBUb2tlbkNoYXJzLlBpcGUgKi8gfHxcbiAgICAgICAgICAgICAgICAhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IENIQVJfU1ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IENIQVJfTEYpIHtcbiAgICAgICAgICAgICAgICBidWYgKz0gY2g7XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGRldGVjdCwgYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZiArPSBjaDtcbiAgICAgICAgICAgICAgICBzY25yLm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4odHJ1ZSwgYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZuKGZhbHNlLCAnJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRQbHVyYWwoc2Nucikge1xuICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBlYXQoc2NuciwgXCJ8XCIgLyogVG9rZW5DaGFycy5QaXBlICovKTtcbiAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgcmV0dXJuIHBsdXJhbDtcbiAgICB9XG4gICAgLy8gVE9ETzogV2UgbmVlZCByZWZhY3RvcmluZyBvZiB0b2tlbiBwYXJzaW5nIC4uLlxuICAgIGZ1bmN0aW9uIHJlYWRUb2tlbkluUGxhY2Vob2xkZXIoc2NuciwgY29udGV4dCkge1xuICAgICAgICBsZXQgdG9rZW4gPSBudWxsO1xuICAgICAgICBjb25zdCBjaCA9IHNjbnIuY3VycmVudENoYXIoKTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgY2FzZSBcIntcIiAvKiBUb2tlbkNoYXJzLkJyYWNlTGVmdCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5icmFjZU5lc3QgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoQ29tcGlsZUVycm9yQ29kZXMuTk9UX0FMTE9XX05FU1RfUExBQ0VIT0xERVIsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCAyIC8qIFRva2VuVHlwZXMuQnJhY2VMZWZ0ICovLCBcIntcIiAvKiBUb2tlbkNoYXJzLkJyYWNlTGVmdCAqLyk7XG4gICAgICAgICAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJyYWNlTmVzdCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGNhc2UgXCJ9XCIgLyogVG9rZW5DaGFycy5CcmFjZVJpZ2h0ICovOlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmJyYWNlTmVzdCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VHlwZSA9PT0gMiAvKiBUb2tlblR5cGVzLkJyYWNlTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoQ29tcGlsZUVycm9yQ29kZXMuRU1QVFlfUExBQ0VIT0xERVIsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCAzIC8qIFRva2VuVHlwZXMuQnJhY2VSaWdodCAqLywgXCJ9XCIgLyogVG9rZW5DaGFycy5CcmFjZVJpZ2h0ICovKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJyYWNlTmVzdC0tO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYnJhY2VOZXN0ID4gMCAmJiBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmluTGlua2VkICYmIGNvbnRleHQuYnJhY2VOZXN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5MaW5rZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgY2FzZSBcIkBcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZEFsaWFzICovOlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmJyYWNlTmVzdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLlVOVEVSTUlOQVRFRF9DTE9TSU5HX0JSQUNFLCBjdXJyZW50UG9zaXRpb24oKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gcmVhZFRva2VuSW5MaW5rZWQoc2NuciwgY29udGV4dCkgfHwgZ2V0RW5kVG9rZW4oY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5icmFjZU5lc3QgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IHZhbGlkTmFtZWRJZGVudGlmaWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsaWRMaXN0SWRlbnRpZmllciA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHZhbGlkTGl0ZXJhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGx1cmFsU3RhcnQoc2NucikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuYnJhY2VOZXN0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLlVOVEVSTUlOQVRFRF9DTE9TSU5HX0JSQUNFLCBjdXJyZW50UG9zaXRpb24oKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCAxIC8qIFRva2VuVHlwZXMuUGlwZSAqLywgcmVhZFBsdXJhbChzY25yKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYnJhY2VOZXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbkxpbmtlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmJyYWNlTmVzdCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQuY3VycmVudFR5cGUgPT09IDUgLyogVG9rZW5UeXBlcy5OYW1lZCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VHlwZSA9PT0gNiAvKiBUb2tlblR5cGVzLkxpc3QgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFR5cGUgPT09IDcgLyogVG9rZW5UeXBlcy5MaXRlcmFsICovKSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoQ29tcGlsZUVycm9yQ29kZXMuVU5URVJNSU5BVEVEX0NMT1NJTkdfQlJBQ0UsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5icmFjZU5lc3QgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuKHNjbnIsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHZhbGlkTmFtZWRJZGVudGlmaWVyID0gaXNOYW1lZElkZW50aWZpZXJTdGFydChzY25yLCBjb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCA1IC8qIFRva2VuVHlwZXMuTmFtZWQgKi8sIHJlYWROYW1lZElkZW50aWZpZXIoc2NucikpO1xuICAgICAgICAgICAgICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgodmFsaWRMaXN0SWRlbnRpZmllciA9IGlzTGlzdElkZW50aWZpZXJTdGFydChzY25yLCBjb250ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCA2IC8qIFRva2VuVHlwZXMuTGlzdCAqLywgcmVhZExpc3RJZGVudGlmaWVyKHNjbnIpKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHZhbGlkTGl0ZXJhbCA9IGlzTGl0ZXJhbFN0YXJ0KHNjbnIsIGNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGdldFRva2VuKGNvbnRleHQsIDcgLyogVG9rZW5UeXBlcy5MaXRlcmFsICovLCByZWFkTGl0ZXJhbChzY25yKSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTcGFjZXMoc2Nucik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZE5hbWVkSWRlbnRpZmllciAmJiAhdmFsaWRMaXN0SWRlbnRpZmllciAmJiAhdmFsaWRMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBiZSByZS1kZXNpZ25lZCBpbnZhbGlkIGNhc2VzLCB3aGVuIHdlIHdpbGwgZXh0ZW5kIG1lc3NhZ2Ugc3ludGF4IG5lYXIgdGhlIGZ1dHVyZSAuLi5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCAxMyAvKiBUb2tlblR5cGVzLkludmFsaWRQbGFjZSAqLywgcmVhZEludmFsaWRJZGVudGlmaWVyKHNjbnIpKTtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKENvbXBpbGVFcnJvckNvZGVzLklOVkFMSURfVE9LRU5fSU5fUExBQ0VIT0xERVIsIGN1cnJlbnRQb3NpdGlvbigpLCAwLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTcGFjZXMoc2Nucik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICAvLyBUT0RPOiBXZSBuZWVkIHJlZmFjdG9yaW5nIG9mIHRva2VuIHBhcnNpbmcgLi4uXG4gICAgZnVuY3Rpb24gcmVhZFRva2VuSW5MaW5rZWQoc2NuciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRUeXBlIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgdG9rZW4gPSBudWxsO1xuICAgICAgICBjb25zdCBjaCA9IHNjbnIuY3VycmVudENoYXIoKTtcbiAgICAgICAgaWYgKChjdXJyZW50VHlwZSA9PT0gOCAvKiBUb2tlblR5cGVzLkxpbmtlZEFsaWFzICovIHx8XG4gICAgICAgICAgICBjdXJyZW50VHlwZSA9PT0gOSAvKiBUb2tlblR5cGVzLkxpbmtlZERvdCAqLyB8fFxuICAgICAgICAgICAgY3VycmVudFR5cGUgPT09IDEyIC8qIFRva2VuVHlwZXMuTGlua2VkTW9kaWZpZXIgKi8gfHxcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlID09PSAxMCAvKiBUb2tlblR5cGVzLkxpbmtlZERlbGltaXRlciAqLykgJiZcbiAgICAgICAgICAgIChjaCA9PT0gQ0hBUl9MRiB8fCBjaCA9PT0gQ0hBUl9TUCkpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihDb21waWxlRXJyb3JDb2Rlcy5JTlZBTElEX0xJTktFRF9GT1JNQVQsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiQFwiIC8qIFRva2VuQ2hhcnMuTGlua2VkQWxpYXMgKi86XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCA4IC8qIFRva2VuVHlwZXMuTGlua2VkQWxpYXMgKi8sIFwiQFwiIC8qIFRva2VuQ2hhcnMuTGlua2VkQWxpYXMgKi8pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaW5MaW5rZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGNhc2UgXCIuXCIgLyogVG9rZW5DaGFycy5MaW5rZWREb3QgKi86XG4gICAgICAgICAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgICAgICAgICBzY25yLm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VG9rZW4oY29udGV4dCwgOSAvKiBUb2tlblR5cGVzLkxpbmtlZERvdCAqLywgXCIuXCIgLyogVG9rZW5DaGFycy5MaW5rZWREb3QgKi8pO1xuICAgICAgICAgICAgY2FzZSBcIjpcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZERlbGltaXRlciAqLzpcbiAgICAgICAgICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICAgICAgICAgIHNjbnIubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUb2tlbihjb250ZXh0LCAxMCAvKiBUb2tlblR5cGVzLkxpbmtlZERlbGltaXRlciAqLywgXCI6XCIgLyogVG9rZW5DaGFycy5MaW5rZWREZWxpbWl0ZXIgKi8pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoaXNQbHVyYWxTdGFydChzY25yKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGdldFRva2VuKGNvbnRleHQsIDEgLyogVG9rZW5UeXBlcy5QaXBlICovLCByZWFkUGx1cmFsKHNjbnIpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5icmFjZU5lc3QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmluTGlua2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlua2VkRG90U3RhcnQoc2NuciwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNMaW5rZWREZWxpbWl0ZXJTdGFydChzY25yLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBza2lwU3BhY2VzKHNjbnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuSW5MaW5rZWQoc2NuciwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmtlZE1vZGlmaWVyU3RhcnQoc2NuciwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRva2VuKGNvbnRleHQsIDEyIC8qIFRva2VuVHlwZXMuTGlua2VkTW9kaWZpZXIgKi8sIHJlYWRMaW5rZWRNb2RpZmllcihzY25yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmtlZFJlZmVyU3RhcnQoc2NuciwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNwYWNlcyhzY25yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIntcIiAvKiBUb2tlbkNoYXJzLkJyYWNlTGVmdCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NhbiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5JblBsYWNlaG9sZGVyKHNjbnIsIGNvbnRleHQpIHx8IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRva2VuKGNvbnRleHQsIDExIC8qIFRva2VuVHlwZXMuTGlua2VkS2V5ICovLCByZWFkTGlua2VkUmVmZXIoc2NucikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VHlwZSA9PT0gOCAvKiBUb2tlblR5cGVzLkxpbmtlZEFsaWFzICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihDb21waWxlRXJyb3JDb2Rlcy5JTlZBTElEX0xJTktFRF9GT1JNQVQsIGN1cnJlbnRQb3NpdGlvbigpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dC5icmFjZU5lc3QgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaW5MaW5rZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuKHNjbnIsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IFdlIG5lZWQgcmVmYWN0b3Jpbmcgb2YgdG9rZW4gcGFyc2luZyAuLi5cbiAgICBmdW5jdGlvbiByZWFkVG9rZW4oc2NuciwgY29udGV4dCkge1xuICAgICAgICBsZXQgdG9rZW4gPSB7IHR5cGU6IDE0IC8qIFRva2VuVHlwZXMuRU9GICovIH07XG4gICAgICAgIGlmIChjb250ZXh0LmJyYWNlTmVzdCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5JblBsYWNlaG9sZGVyKHNjbnIsIGNvbnRleHQpIHx8IGdldEVuZFRva2VuKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmluTGlua2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZFRva2VuSW5MaW5rZWQoc2NuciwgY29udGV4dCkgfHwgZ2V0RW5kVG9rZW4oY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2ggPSBzY25yLmN1cnJlbnRDaGFyKCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ7XCIgLyogVG9rZW5DaGFycy5CcmFjZUxlZnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRUb2tlbkluUGxhY2Vob2xkZXIoc2NuciwgY29udGV4dCkgfHwgZ2V0RW5kVG9rZW4oY29udGV4dCk7XG4gICAgICAgICAgICBjYXNlIFwifVwiIC8qIFRva2VuQ2hhcnMuQnJhY2VSaWdodCAqLzpcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoQ29tcGlsZUVycm9yQ29kZXMuVU5CQUxBTkNFRF9DTE9TSU5HX0JSQUNFLCBjdXJyZW50UG9zaXRpb24oKSwgMCk7XG4gICAgICAgICAgICAgICAgc2Nuci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRva2VuKGNvbnRleHQsIDMgLyogVG9rZW5UeXBlcy5CcmFjZVJpZ2h0ICovLCBcIn1cIiAvKiBUb2tlbkNoYXJzLkJyYWNlUmlnaHQgKi8pO1xuICAgICAgICAgICAgY2FzZSBcIkBcIiAvKiBUb2tlbkNoYXJzLkxpbmtlZEFsaWFzICovOlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFkVG9rZW5JbkxpbmtlZChzY25yLCBjb250ZXh0KSB8fCBnZXRFbmRUb2tlbihjb250ZXh0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGlzUGx1cmFsU3RhcnQoc2NucikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBnZXRUb2tlbihjb250ZXh0LCAxIC8qIFRva2VuVHlwZXMuUGlwZSAqLywgcmVhZFBsdXJhbChzY25yKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYnJhY2VOZXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pbkxpbmtlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNNb2R1bG8sIGhhc1NwYWNlIH0gPSBkZXRlY3RNb2R1bG9TdGFydChzY25yKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb2R1bG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc1NwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldFRva2VuKGNvbnRleHQsIDAgLyogVG9rZW5UeXBlcy5UZXh0ICovLCByZWFkVGV4dChzY25yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0VG9rZW4oY29udGV4dCwgNCAvKiBUb2tlblR5cGVzLk1vZHVsbyAqLywgcmVhZE1vZHVsbyhzY25yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1RleHRTdGFydChzY25yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VG9rZW4oY29udGV4dCwgMCAvKiBUb2tlblR5cGVzLlRleHQgKi8sIHJlYWRUZXh0KHNjbnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFR5cGUsIG9mZnNldCwgc3RhcnRMb2MsIGVuZExvYyB9ID0gX2NvbnRleHQ7XG4gICAgICAgIF9jb250ZXh0Lmxhc3RUeXBlID0gY3VycmVudFR5cGU7XG4gICAgICAgIF9jb250ZXh0Lmxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIF9jb250ZXh0Lmxhc3RTdGFydExvYyA9IHN0YXJ0TG9jO1xuICAgICAgICBfY29udGV4dC5sYXN0RW5kTG9jID0gZW5kTG9jO1xuICAgICAgICBfY29udGV4dC5vZmZzZXQgPSBjdXJyZW50T2Zmc2V0KCk7XG4gICAgICAgIF9jb250ZXh0LnN0YXJ0TG9jID0gY3VycmVudFBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChfc2Nuci5jdXJyZW50Q2hhcigpID09PSBFT0YpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUb2tlbihfY29udGV4dCwgMTQgLyogVG9rZW5UeXBlcy5FT0YgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkVG9rZW4oX3NjbnIsIF9jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dFRva2VuLFxuICAgICAgICBjdXJyZW50T2Zmc2V0LFxuICAgICAgICBjdXJyZW50UG9zaXRpb24sXG4gICAgICAgIGNvbnRleHRcbiAgICB9O1xufVxuXG5jb25zdCBFUlJPUl9ET01BSU4gPSAncGFyc2VyJztcbi8vIEJhY2tzbGFzaCBiYWNrc2xhc2gsIGJhY2tzbGFzaCBxdW90ZSwgdUhISEgsIFVISEhISEguXG5jb25zdCBLTk9XTl9FU0NBUEVTID0gLyg/OlxcXFxcXFxcfFxcXFwnfFxcXFx1KFswLTlhLWZBLUZdezR9KXxcXFxcVShbMC05YS1mQS1GXXs2fSkpL2c7XG5mdW5jdGlvbiBmcm9tRXNjYXBlU2VxdWVuY2UobWF0Y2gsIGNvZGVQb2ludDQsIGNvZGVQb2ludDYpIHtcbiAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICAgIGNhc2UgYFxcXFxcXFxcYDpcbiAgICAgICAgICAgIHJldHVybiBgXFxcXGA7XG4gICAgICAgIGNhc2UgYFxcXFxcXCdgOlxuICAgICAgICAgICAgcmV0dXJuIGBcXCdgO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBwYXJzZUludChjb2RlUG9pbnQ0IHx8IGNvZGVQb2ludDYsIDE2KTtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhkN2ZmIHx8IGNvZGVQb2ludCA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGludmFsaWQgLi4uXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZW0gd2l0aCBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgICAgICAgcmV0dXJuICfvv70nO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbiAhPT0gZmFsc2U7XG4gICAgY29uc3QgeyBvbkVycm9yIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIGVtaXRFcnJvcih0b2tlbnplciwgY29kZSwgc3RhcnQsIG9mZnNldCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBlbmQgPSB0b2tlbnplci5jdXJyZW50UG9zaXRpb24oKTtcbiAgICAgICAgZW5kLm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgIGVuZC5jb2x1bW4gKz0gb2Zmc2V0O1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbG9jID0gbG9jYXRpb24gPyBjcmVhdGVMb2NhdGlvbihzdGFydCwgZW5kKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBjcmVhdGVDb21waWxlRXJyb3IoY29kZSwgbG9jLCB7XG4gICAgICAgICAgICAgICAgZG9tYWluOiBFUlJPUl9ET01BSU4sXG4gICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnROb2RlKHR5cGUsIG9mZnNldCwgbG9jKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7IHR5cGUgfTtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgICBub2RlLnN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgbm9kZS5lbmQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBub2RlLmxvYyA9IHsgc3RhcnQ6IGxvYywgZW5kOiBsb2MgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kTm9kZShub2RlLCBvZmZzZXQsIHBvcywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgIG5vZGUuZW5kID0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2MuZW5kID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVGV4dCh0b2tlbml6ZXIsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0b2tlbml6ZXIuY29udGV4dCgpO1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnROb2RlKDMgLyogTm9kZVR5cGVzLlRleHQgKi8sIGNvbnRleHQub2Zmc2V0LCBjb250ZXh0LnN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBlbmROb2RlKG5vZGUsIHRva2VuaXplci5jdXJyZW50T2Zmc2V0KCksIHRva2VuaXplci5jdXJyZW50UG9zaXRpb24oKSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpc3QodG9rZW5pemVyLCBpbmRleCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdG9rZW5pemVyLmNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgeyBsYXN0T2Zmc2V0OiBvZmZzZXQsIGxhc3RTdGFydExvYzogbG9jIH0gPSBjb250ZXh0OyAvLyBnZXQgYnJhY2UgbGVmdCBsb2NcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0Tm9kZSg1IC8qIE5vZGVUeXBlcy5MaXN0ICovLCBvZmZzZXQsIGxvYyk7XG4gICAgICAgIG5vZGUuaW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICB0b2tlbml6ZXIubmV4dFRva2VuKCk7IC8vIHNraXAgYnJhY2ggcmlnaHRcbiAgICAgICAgZW5kTm9kZShub2RlLCB0b2tlbml6ZXIuY3VycmVudE9mZnNldCgpLCB0b2tlbml6ZXIuY3VycmVudFBvc2l0aW9uKCkpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lZCh0b2tlbml6ZXIsIGtleSkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdG9rZW5pemVyLmNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgeyBsYXN0T2Zmc2V0OiBvZmZzZXQsIGxhc3RTdGFydExvYzogbG9jIH0gPSBjb250ZXh0OyAvLyBnZXQgYnJhY2UgbGVmdCBsb2NcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0Tm9kZSg0IC8qIE5vZGVUeXBlcy5OYW1lZCAqLywgb2Zmc2V0LCBsb2MpO1xuICAgICAgICBub2RlLmtleSA9IGtleTtcbiAgICAgICAgdG9rZW5pemVyLm5leHRUb2tlbigpOyAvLyBza2lwIGJyYWNoIHJpZ2h0XG4gICAgICAgIGVuZE5vZGUobm9kZSwgdG9rZW5pemVyLmN1cnJlbnRPZmZzZXQoKSwgdG9rZW5pemVyLmN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbCh0b2tlbml6ZXIsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0b2tlbml6ZXIuY29udGV4dCgpO1xuICAgICAgICBjb25zdCB7IGxhc3RPZmZzZXQ6IG9mZnNldCwgbGFzdFN0YXJ0TG9jOiBsb2MgfSA9IGNvbnRleHQ7IC8vIGdldCBicmFjZSBsZWZ0IGxvY1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnROb2RlKDkgLyogTm9kZVR5cGVzLkxpdGVyYWwgKi8sIG9mZnNldCwgbG9jKTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlLnJlcGxhY2UoS05PV05fRVNDQVBFUywgZnJvbUVzY2FwZVNlcXVlbmNlKTtcbiAgICAgICAgdG9rZW5pemVyLm5leHRUb2tlbigpOyAvLyBza2lwIGJyYWNoIHJpZ2h0XG4gICAgICAgIGVuZE5vZGUobm9kZSwgdG9rZW5pemVyLmN1cnJlbnRPZmZzZXQoKSwgdG9rZW5pemVyLmN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGlua2VkTW9kaWZpZXIodG9rZW5pemVyKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdG9rZW5pemVyLmNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgeyBsYXN0T2Zmc2V0OiBvZmZzZXQsIGxhc3RTdGFydExvYzogbG9jIH0gPSBjb250ZXh0OyAvLyBnZXQgbGlua2VkIGRvdCBsb2NcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0Tm9kZSg4IC8qIE5vZGVUeXBlcy5MaW5rZWRNb2RpZmllciAqLywgb2Zmc2V0LCBsb2MpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTIgLyogVG9rZW5UeXBlcy5MaW5rZWRNb2RpZmllciAqLykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbW9kaWZpZXJcbiAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfRU1QVFlfTElOS0VEX01PRElGSUVSLCBjb250ZXh0Lmxhc3RTdGFydExvYywgMCk7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICBlbmROb2RlKG5vZGUsIG9mZnNldCwgbG9jKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmV4dENvbnN1bWVUb2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0b2tlblxuICAgICAgICBpZiAodG9rZW4udmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZW1pdEVycm9yKHRva2VuaXplciwgQ29tcGlsZUVycm9yQ29kZXMuVU5FWFBFQ1RFRF9MRVhJQ0FMX0FOQUxZU0lTLCBjb250ZXh0Lmxhc3RTdGFydExvYywgMCwgZ2V0VG9rZW5DYXB0aW9uKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZSA9IHRva2VuLnZhbHVlIHx8ICcnO1xuICAgICAgICBlbmROb2RlKG5vZGUsIHRva2VuaXplci5jdXJyZW50T2Zmc2V0KCksIHRva2VuaXplci5jdXJyZW50UG9zaXRpb24oKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGlua2VkS2V5KHRva2VuaXplciwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRva2VuaXplci5jb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFydE5vZGUoNyAvKiBOb2RlVHlwZXMuTGlua2VkS2V5ICovLCBjb250ZXh0Lm9mZnNldCwgY29udGV4dC5zdGFydExvYyk7XG4gICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZW5kTm9kZShub2RlLCB0b2tlbml6ZXIuY3VycmVudE9mZnNldCgpLCB0b2tlbml6ZXIuY3VycmVudFBvc2l0aW9uKCkpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaW5rZWQodG9rZW5pemVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0b2tlbml6ZXIuY29udGV4dCgpO1xuICAgICAgICBjb25zdCBsaW5rZWROb2RlID0gc3RhcnROb2RlKDYgLyogTm9kZVR5cGVzLkxpbmtlZCAqLywgY29udGV4dC5vZmZzZXQsIGNvbnRleHQuc3RhcnRMb2MpO1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFRva2VuVHlwZXMuTGlua2VkRG90ICovKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUxpbmtlZE1vZGlmaWVyKHRva2VuaXplcik7XG4gICAgICAgICAgICBsaW5rZWROb2RlLm1vZGlmaWVyID0gcGFyc2VkLm5vZGU7XG4gICAgICAgICAgICB0b2tlbiA9IHBhcnNlZC5uZXh0Q29uc3VtZVRva2VuIHx8IHRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhc3NldCBjaGVjayB0b2tlblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTAgLyogVG9rZW5UeXBlcy5MaW5rZWREZWxpbWl0ZXIgKi8pIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAvLyBza2lwIGJyYWNlIGxlZnRcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDIgLyogVG9rZW5UeXBlcy5CcmFjZUxlZnQgKi8pIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxMSAvKiBUb2tlblR5cGVzLkxpbmtlZEtleSAqLzpcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IodG9rZW5pemVyLCBDb21waWxlRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0xFWElDQUxfQU5BTFlTSVMsIGNvbnRleHQubGFzdFN0YXJ0TG9jLCAwLCBnZXRUb2tlbkNhcHRpb24odG9rZW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlua2VkTm9kZS5rZXkgPSBwYXJzZUxpbmtlZEtleSh0b2tlbml6ZXIsIHRva2VuLnZhbHVlIHx8ICcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNSAvKiBUb2tlblR5cGVzLk5hbWVkICovOlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rZWROb2RlLmtleSA9IHBhcnNlTmFtZWQodG9rZW5pemVyLCB0b2tlbi52YWx1ZSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYgLyogVG9rZW5UeXBlcy5MaXN0ICovOlxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5rZWROb2RlLmtleSA9IHBhcnNlTGlzdCh0b2tlbml6ZXIsIHRva2VuLnZhbHVlIHx8ICcnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNyAvKiBUb2tlblR5cGVzLkxpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKHRva2VuaXplciwgQ29tcGlsZUVycm9yQ29kZXMuVU5FWFBFQ1RFRF9MRVhJQ0FMX0FOQUxZU0lTLCBjb250ZXh0Lmxhc3RTdGFydExvYywgMCwgZ2V0VG9rZW5DYXB0aW9uKHRva2VuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmtlZE5vZGUua2V5ID0gcGFyc2VMaXRlcmFsKHRva2VuaXplciwgdG9rZW4udmFsdWUgfHwgJycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBrZXlcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IodG9rZW5pemVyLCBDb21waWxlRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0VNUFRZX0xJTktFRF9LRVksIGNvbnRleHQubGFzdFN0YXJ0TG9jLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29udGV4dCA9IHRva2VuaXplci5jb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1wdHlMaW5rZWRLZXlOb2RlID0gc3RhcnROb2RlKDcgLyogTm9kZVR5cGVzLkxpbmtlZEtleSAqLywgbmV4dENvbnRleHQub2Zmc2V0LCBuZXh0Q29udGV4dC5zdGFydExvYyk7XG4gICAgICAgICAgICAgICAgZW1wdHlMaW5rZWRLZXlOb2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgZW5kTm9kZShlbXB0eUxpbmtlZEtleU5vZGUsIG5leHRDb250ZXh0Lm9mZnNldCwgbmV4dENvbnRleHQuc3RhcnRMb2MpO1xuICAgICAgICAgICAgICAgIGxpbmtlZE5vZGUua2V5ID0gZW1wdHlMaW5rZWRLZXlOb2RlO1xuICAgICAgICAgICAgICAgIGVuZE5vZGUobGlua2VkTm9kZSwgbmV4dENvbnRleHQub2Zmc2V0LCBuZXh0Q29udGV4dC5zdGFydExvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbnN1bWVUb2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGxpbmtlZE5vZGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVuZE5vZGUobGlua2VkTm9kZSwgdG9rZW5pemVyLmN1cnJlbnRPZmZzZXQoKSwgdG9rZW5pemVyLmN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGU6IGxpbmtlZE5vZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VNZXNzYWdlKHRva2VuaXplcikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdG9rZW5pemVyLmNvbnRleHQoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBjb250ZXh0LmN1cnJlbnRUeXBlID09PSAxIC8qIFRva2VuVHlwZXMuUGlwZSAqL1xuICAgICAgICAgICAgPyB0b2tlbml6ZXIuY3VycmVudE9mZnNldCgpXG4gICAgICAgICAgICA6IGNvbnRleHQub2Zmc2V0O1xuICAgICAgICBjb25zdCBzdGFydExvYyA9IGNvbnRleHQuY3VycmVudFR5cGUgPT09IDEgLyogVG9rZW5UeXBlcy5QaXBlICovXG4gICAgICAgICAgICA/IGNvbnRleHQuZW5kTG9jXG4gICAgICAgICAgICA6IGNvbnRleHQuc3RhcnRMb2M7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFydE5vZGUoMiAvKiBOb2RlVHlwZXMuTWVzc2FnZSAqLywgc3RhcnRPZmZzZXQsIHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5pdGVtcyA9IFtdO1xuICAgICAgICBsZXQgbmV4dFRva2VuID0gbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBuZXh0VG9rZW4gfHwgdG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgbmV4dFRva2VuID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBUb2tlblR5cGVzLlRleHQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IodG9rZW5pemVyLCBDb21waWxlRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0xFWElDQUxfQU5BTFlTSVMsIGNvbnRleHQubGFzdFN0YXJ0TG9jLCAwLCBnZXRUb2tlbkNhcHRpb24odG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnB1c2gocGFyc2VUZXh0KHRva2VuaXplciwgdG9rZW4udmFsdWUgfHwgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2IC8qIFRva2VuVHlwZXMuTGlzdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMucHVzaChwYXJzZUxpc3QodG9rZW5pemVyLCB0b2tlbi52YWx1ZSB8fCAnJykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogVG9rZW5UeXBlcy5OYW1lZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMucHVzaChwYXJzZU5hbWVkKHRva2VuaXplciwgdG9rZW4udmFsdWUgfHwgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3IC8qIFRva2VuVHlwZXMuTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIGdldFRva2VuQ2FwdGlvbih0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMucHVzaChwYXJzZUxpdGVyYWwodG9rZW5pemVyLCB0b2tlbi52YWx1ZSB8fCAnJykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDggLyogVG9rZW5UeXBlcy5MaW5rZWRBbGlhcyAqLzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VMaW5rZWQodG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5wdXNoKHBhcnNlZC5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuID0gcGFyc2VkLm5leHRDb25zdW1lVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGNvbnRleHQuY3VycmVudFR5cGUgIT09IDE0IC8qIFRva2VuVHlwZXMuRU9GICovICYmXG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUeXBlICE9PSAxIC8qIFRva2VuVHlwZXMuUGlwZSAqLyk7XG4gICAgICAgIC8vIGFkanVzdCBtZXNzYWdlIG5vZGUgbG9jXG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGNvbnRleHQuY3VycmVudFR5cGUgPT09IDEgLyogVG9rZW5UeXBlcy5QaXBlICovXG4gICAgICAgICAgICA/IGNvbnRleHQubGFzdE9mZnNldFxuICAgICAgICAgICAgOiB0b2tlbml6ZXIuY3VycmVudE9mZnNldCgpO1xuICAgICAgICBjb25zdCBlbmRMb2MgPSBjb250ZXh0LmN1cnJlbnRUeXBlID09PSAxIC8qIFRva2VuVHlwZXMuUGlwZSAqL1xuICAgICAgICAgICAgPyBjb250ZXh0Lmxhc3RFbmRMb2NcbiAgICAgICAgICAgIDogdG9rZW5pemVyLmN1cnJlbnRQb3NpdGlvbigpO1xuICAgICAgICBlbmROb2RlKG5vZGUsIGVuZE9mZnNldCwgZW5kTG9jKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUGx1cmFsKHRva2VuaXplciwgb2Zmc2V0LCBsb2MsIG1zZ05vZGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRva2VuaXplci5jb250ZXh0KCk7XG4gICAgICAgIGxldCBoYXNFbXB0eU1lc3NhZ2UgPSBtc2dOb2RlLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0Tm9kZSgxIC8qIE5vZGVUeXBlcy5QbHVyYWwgKi8sIG9mZnNldCwgbG9jKTtcbiAgICAgICAgbm9kZS5jYXNlcyA9IFtdO1xuICAgICAgICBub2RlLmNhc2VzLnB1c2gobXNnTm9kZSk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHBhcnNlTWVzc2FnZSh0b2tlbml6ZXIpO1xuICAgICAgICAgICAgaWYgKCFoYXNFbXB0eU1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBoYXNFbXB0eU1lc3NhZ2UgPSBtc2cuaXRlbXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5jYXNlcy5wdXNoKG1zZyk7XG4gICAgICAgIH0gd2hpbGUgKGNvbnRleHQuY3VycmVudFR5cGUgIT09IDE0IC8qIFRva2VuVHlwZXMuRU9GICovKTtcbiAgICAgICAgaWYgKGhhc0VtcHR5TWVzc2FnZSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKHRva2VuaXplciwgQ29tcGlsZUVycm9yQ29kZXMuTVVTVF9IQVZFX01FU1NBR0VTX0lOX1BMVVJBTCwgbG9jLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbmROb2RlKG5vZGUsIHRva2VuaXplci5jdXJyZW50T2Zmc2V0KCksIHRva2VuaXplci5jdXJyZW50UG9zaXRpb24oKSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJlc291cmNlKHRva2VuaXplcikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdG9rZW5pemVyLmNvbnRleHQoKTtcbiAgICAgICAgY29uc3QgeyBvZmZzZXQsIHN0YXJ0TG9jIH0gPSBjb250ZXh0O1xuICAgICAgICBjb25zdCBtc2dOb2RlID0gcGFyc2VNZXNzYWdlKHRva2VuaXplcik7XG4gICAgICAgIGlmIChjb250ZXh0LmN1cnJlbnRUeXBlID09PSAxNCAvKiBUb2tlblR5cGVzLkVPRiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG1zZ05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VQbHVyYWwodG9rZW5pemVyLCBvZmZzZXQsIHN0YXJ0TG9jLCBtc2dOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZShzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemVyID0gY3JlYXRlVG9rZW5pemVyKHNvdXJjZSwgYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0b2tlbml6ZXIuY29udGV4dCgpO1xuICAgICAgICBjb25zdCBub2RlID0gc3RhcnROb2RlKDAgLyogTm9kZVR5cGVzLlJlc291cmNlICovLCBjb250ZXh0Lm9mZnNldCwgY29udGV4dC5zdGFydExvYyk7XG4gICAgICAgIGlmIChsb2NhdGlvbiAmJiBub2RlLmxvYykge1xuICAgICAgICAgICAgbm9kZS5sb2Muc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuYm9keSA9IHBhcnNlUmVzb3VyY2UodG9rZW5pemVyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25DYWNoZUtleSkge1xuICAgICAgICAgICAgbm9kZS5jYWNoZUtleSA9IG9wdGlvbnMub25DYWNoZUtleShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCB3aGV0aGVyIGFjaGlldmVkIHRvIEVPRlxuICAgICAgICBpZiAoY29udGV4dC5jdXJyZW50VHlwZSAhPT0gMTQgLyogVG9rZW5UeXBlcy5FT0YgKi8pIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcih0b2tlbml6ZXIsIENvbXBpbGVFcnJvckNvZGVzLlVORVhQRUNURURfTEVYSUNBTF9BTkFMWVNJUywgY29udGV4dC5sYXN0U3RhcnRMb2MsIDAsIHNvdXJjZVtjb250ZXh0Lm9mZnNldF0gfHwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVuZE5vZGUobm9kZSwgdG9rZW5pemVyLmN1cnJlbnRPZmZzZXQoKSwgdG9rZW5pemVyLmN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB7IHBhcnNlIH07XG59XG5mdW5jdGlvbiBnZXRUb2tlbkNhcHRpb24odG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gMTQgLyogVG9rZW5UeXBlcy5FT0YgKi8pIHtcbiAgICAgICAgcmV0dXJuICdFT0YnO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gKHRva2VuLnZhbHVlIHx8ICcnKS5yZXBsYWNlKC9cXHI/XFxuL2d1LCAnXFxcXG4nKTtcbiAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAxMCA/IG5hbWUuc2xpY2UoMCwgOSkgKyAn4oCmJyA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybWVyKGFzdCwgb3B0aW9ucyA9IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbikge1xuICAgIGNvbnN0IF9jb250ZXh0ID0ge1xuICAgICAgICBhc3QsXG4gICAgICAgIGhlbHBlcnM6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IF9jb250ZXh0O1xuICAgIGNvbnN0IGhlbHBlciA9IChuYW1lKSA9PiB7XG4gICAgICAgIF9jb250ZXh0LmhlbHBlcnMuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiB7IGNvbnRleHQsIGhlbHBlciB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2VOb2Rlcyhub2RlcywgdHJhbnNmb3JtZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXZlcnNlTm9kZShub2Rlc1tpXSwgdHJhbnNmb3JtZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCB0cmFuc2Zvcm1lcikge1xuICAgIC8vIFRPRE86IGlmIHdlIG5lZWQgcHJlLWhvb2sgb2YgdHJhbnNmb3JtLCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgdG8gaGVyZVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuUGx1cmFsICovOlxuICAgICAgICAgICAgdHJhdmVyc2VOb2Rlcyhub2RlLmNhc2VzLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lci5oZWxwZXIoXCJwbHVyYWxcIiAvKiBIZWxwZXJOYW1lTWFwLlBMVVJBTCAqLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyIC8qIE5vZGVUeXBlcy5NZXNzYWdlICovOlxuICAgICAgICAgICAgdHJhdmVyc2VOb2Rlcyhub2RlLml0ZW1zLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2IC8qIE5vZGVUeXBlcy5MaW5rZWQgKi86XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBub2RlO1xuICAgICAgICAgICAgdHJhdmVyc2VOb2RlKGxpbmtlZC5rZXksIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyLmhlbHBlcihcImxpbmtlZFwiIC8qIEhlbHBlck5hbWVNYXAuTElOS0VEICovKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyLmhlbHBlcihcInR5cGVcIiAvKiBIZWxwZXJOYW1lTWFwLlRZUEUgKi8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNSAvKiBOb2RlVHlwZXMuTGlzdCAqLzpcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyLmhlbHBlcihcImludGVycG9sYXRlXCIgLyogSGVscGVyTmFtZU1hcC5JTlRFUlBPTEFURSAqLyk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lci5oZWxwZXIoXCJsaXN0XCIgLyogSGVscGVyTmFtZU1hcC5MSVNUICovKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogTm9kZVR5cGVzLk5hbWVkICovOlxuICAgICAgICAgICAgdHJhbnNmb3JtZXIuaGVscGVyKFwiaW50ZXJwb2xhdGVcIiAvKiBIZWxwZXJOYW1lTWFwLklOVEVSUE9MQVRFICovKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVyLmhlbHBlcihcIm5hbWVkXCIgLyogSGVscGVyTmFtZU1hcC5OQU1FRCAqLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogaWYgd2UgbmVlZCBwb3N0LWhvb2sgb2YgdHJhbnNmb3JtLCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgdG8gaGVyZVxufVxuLy8gdHJhbnNmb3JtIEFTVFxuZnVuY3Rpb24gdHJhbnNmb3JtKGFzdCwgb3B0aW9ucyA9IHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbikge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVHJhbnNmb3JtZXIoYXN0KTtcbiAgICB0cmFuc2Zvcm1lci5oZWxwZXIoXCJub3JtYWxpemVcIiAvKiBIZWxwZXJOYW1lTWFwLk5PUk1BTElaRSAqLyk7XG4gICAgLy8gdHJhdmVyc2VcbiAgICBhc3QuYm9keSAmJiB0cmF2ZXJzZU5vZGUoYXN0LmJvZHksIHRyYW5zZm9ybWVyKTtcbiAgICAvLyBzZXQgbWV0YSBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGNvbnRleHQgPSB0cmFuc2Zvcm1lci5jb250ZXh0KCk7XG4gICAgYXN0LmhlbHBlcnMgPSBBcnJheS5mcm9tKGNvbnRleHQuaGVscGVycyk7XG59XG5cbmZ1bmN0aW9uIG9wdGltaXplKGFzdCkge1xuICAgIGNvbnN0IGJvZHkgPSBhc3QuYm9keTtcbiAgICBpZiAoYm9keS50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5NZXNzYWdlICovKSB7XG4gICAgICAgIG9wdGltaXplTWVzc2FnZU5vZGUoYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5LmNhc2VzLmZvckVhY2goYyA9PiBvcHRpbWl6ZU1lc3NhZ2VOb2RlKGMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzdDtcbn1cbmZ1bmN0aW9uIG9wdGltaXplTWVzc2FnZU5vZGUobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBpdGVtID0gbWVzc2FnZS5pdGVtc1swXTtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuVGV4dCAqLyB8fCBpdGVtLnR5cGUgPT09IDkgLyogTm9kZVR5cGVzLkxpdGVyYWwgKi8pIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdGljID0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZhbHVlOyAvLyBvcHRpbWl6YXRpb24gZm9yIHNpemVcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IG1lc3NhZ2UuaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoIShpdGVtLnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLlRleHQgKi8gfHwgaXRlbS50eXBlID09PSA5IC8qIE5vZGVUeXBlcy5MaXRlcmFsICovKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IG1lc3NhZ2UuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnN0YXRpYyA9IGpvaW4odmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBtZXNzYWdlLml0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLlRleHQgKi8gfHwgaXRlbS50eXBlID09PSA5IC8qIE5vZGVUeXBlcy5MaXRlcmFsICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnZhbHVlOyAvLyBvcHRpbWl6YXRpb24gZm9yIHNpemVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIG1pbmlmeShub2RlKSB7XG4gICAgbm9kZS50ID0gbm9kZS50eXBlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBOb2RlVHlwZXMuUmVzb3VyY2UgKi86XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZSA9IG5vZGU7XG4gICAgICAgICAgICBtaW5pZnkocmVzb3VyY2UuYm9keSk7XG4gICAgICAgICAgICByZXNvdXJjZS5iID0gcmVzb3VyY2UuYm9keTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXNvdXJjZS5ib2R5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuUGx1cmFsICovOlxuICAgICAgICAgICAgY29uc3QgcGx1cmFsID0gbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGNhc2VzID0gcGx1cmFsLmNhc2VzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1pbmlmeShjYXNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbHVyYWwuYyA9IGNhc2VzO1xuICAgICAgICAgICAgZGVsZXRlIHBsdXJhbC5jYXNlcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTm9kZVR5cGVzLk1lc3NhZ2UgKi86XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gbWVzc2FnZS5pdGVtcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtaW5pZnkoaXRlbXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5pID0gaXRlbXM7XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZS5pdGVtcztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucyA9IG1lc3NhZ2Uuc3RhdGljO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlLnN0YXRpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogTm9kZVR5cGVzLlRleHQgKi86XG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuTGl0ZXJhbCAqLzpcbiAgICAgICAgY2FzZSA4IC8qIE5vZGVUeXBlcy5MaW5rZWRNb2RpZmllciAqLzpcbiAgICAgICAgY2FzZSA3IC8qIE5vZGVUeXBlcy5MaW5rZWRLZXkgKi86XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlTm9kZS52ID0gdmFsdWVOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZU5vZGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2IC8qIE5vZGVUeXBlcy5MaW5rZWQgKi86XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBub2RlO1xuICAgICAgICAgICAgbWluaWZ5KGxpbmtlZC5rZXkpO1xuICAgICAgICAgICAgbGlua2VkLmsgPSBsaW5rZWQua2V5O1xuICAgICAgICAgICAgZGVsZXRlIGxpbmtlZC5rZXk7XG4gICAgICAgICAgICBpZiAobGlua2VkLm1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgbWluaWZ5KGxpbmtlZC5tb2RpZmllcik7XG4gICAgICAgICAgICAgICAgbGlua2VkLm0gPSBsaW5rZWQubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpbmtlZC5tb2RpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLkxpc3QgKi86XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gbm9kZTtcbiAgICAgICAgICAgIGxpc3QuaSA9IGxpc3QuaW5kZXg7XG4gICAgICAgICAgICBkZWxldGUgbGlzdC5pbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogTm9kZVR5cGVzLk5hbWVkICovOlxuICAgICAgICAgICAgY29uc3QgbmFtZWQgPSBub2RlO1xuICAgICAgICAgICAgbmFtZWQuayA9IG5hbWVkLmtleTtcbiAgICAgICAgICAgIGRlbGV0ZSBuYW1lZC5rZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBtaW5pZnkgbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIG5vZGUudHlwZTtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb2RlR2VuZXJhdG9yKGFzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc291cmNlTWFwLCBmaWxlbmFtZSwgYnJlYWtMaW5lQ29kZSwgbmVlZEluZGVudDogX25lZWRJbmRlbnQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgbG9jYXRpb24gPSBvcHRpb25zLmxvY2F0aW9uICE9PSBmYWxzZTtcbiAgICBjb25zdCBfY29udGV4dCA9IHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGNvZGU6ICcnLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIGxpbmU6IDEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXG4gICAgICAgIGJyZWFrTGluZUNvZGUsXG4gICAgICAgIG5lZWRJbmRlbnQ6IF9uZWVkSW5kZW50LFxuICAgICAgICBpbmRlbnRMZXZlbDogMFxuICAgIH07XG4gICAgaWYgKGxvY2F0aW9uICYmIGFzdC5sb2MpIHtcbiAgICAgICAgX2NvbnRleHQuc291cmNlID0gYXN0LmxvYy5zb3VyY2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiBfY29udGV4dDtcbiAgICBmdW5jdGlvbiBwdXNoKGNvZGUsIG5vZGUpIHtcbiAgICAgICAgX2NvbnRleHQuY29kZSArPSBjb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbmV3bGluZShuLCB3aXRoQnJlYWtMaW5lID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBfYnJlYWtMaW5lQ29kZSA9IHdpdGhCcmVha0xpbmUgPyBicmVha0xpbmVDb2RlIDogJyc7XG4gICAgICAgIHB1c2goX25lZWRJbmRlbnQgPyBfYnJlYWtMaW5lQ29kZSArIGAgIGAucmVwZWF0KG4pIDogX2JyZWFrTGluZUNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmRlbnQod2l0aE5ld0xpbmUgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gKytfY29udGV4dC5pbmRlbnRMZXZlbDtcbiAgICAgICAgd2l0aE5ld0xpbmUgJiYgX25ld2xpbmUobGV2ZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWluZGVudCh3aXRoTmV3TGluZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSAtLV9jb250ZXh0LmluZGVudExldmVsO1xuICAgICAgICB3aXRoTmV3TGluZSAmJiBfbmV3bGluZShsZXZlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5ld2xpbmUoKSB7XG4gICAgICAgIF9uZXdsaW5lKF9jb250ZXh0LmluZGVudExldmVsKTtcbiAgICB9XG4gICAgY29uc3QgaGVscGVyID0gKGtleSkgPT4gYF8ke2tleX1gO1xuICAgIGNvbnN0IG5lZWRJbmRlbnQgPSAoKSA9PiBfY29udGV4dC5uZWVkSW5kZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHB1c2gsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgZGVpbmRlbnQsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIGhlbHBlcixcbiAgICAgICAgbmVlZEluZGVudFxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUxpbmtlZE5vZGUoZ2VuZXJhdG9yLCBub2RlKSB7XG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGdlbmVyYXRvcjtcbiAgICBnZW5lcmF0b3IucHVzaChgJHtoZWxwZXIoXCJsaW5rZWRcIiAvKiBIZWxwZXJOYW1lTWFwLkxJTktFRCAqLyl9KGApO1xuICAgIGdlbmVyYXRlTm9kZShnZW5lcmF0b3IsIG5vZGUua2V5KTtcbiAgICBpZiAobm9kZS5tb2RpZmllcikge1xuICAgICAgICBnZW5lcmF0b3IucHVzaChgLCBgKTtcbiAgICAgICAgZ2VuZXJhdGVOb2RlKGdlbmVyYXRvciwgbm9kZS5tb2RpZmllcik7XG4gICAgICAgIGdlbmVyYXRvci5wdXNoKGAsIF90eXBlYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW5lcmF0b3IucHVzaChgLCB1bmRlZmluZWQsIF90eXBlYCk7XG4gICAgfVxuICAgIGdlbmVyYXRvci5wdXNoKGApYCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU1lc3NhZ2VOb2RlKGdlbmVyYXRvciwgbm9kZSkge1xuICAgIGNvbnN0IHsgaGVscGVyLCBuZWVkSW5kZW50IH0gPSBnZW5lcmF0b3I7XG4gICAgZ2VuZXJhdG9yLnB1c2goYCR7aGVscGVyKFwibm9ybWFsaXplXCIgLyogSGVscGVyTmFtZU1hcC5OT1JNQUxJWkUgKi8pfShbYCk7XG4gICAgZ2VuZXJhdG9yLmluZGVudChuZWVkSW5kZW50KCkpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG5vZGUuaXRlbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ2VuZXJhdGVOb2RlKGdlbmVyYXRvciwgbm9kZS5pdGVtc1tpXSk7XG4gICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0b3IucHVzaCgnLCAnKTtcbiAgICB9XG4gICAgZ2VuZXJhdG9yLmRlaW5kZW50KG5lZWRJbmRlbnQoKSk7XG4gICAgZ2VuZXJhdG9yLnB1c2goJ10pJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVBsdXJhbE5vZGUoZ2VuZXJhdG9yLCBub2RlKSB7XG4gICAgY29uc3QgeyBoZWxwZXIsIG5lZWRJbmRlbnQgfSA9IGdlbmVyYXRvcjtcbiAgICBpZiAobm9kZS5jYXNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdlbmVyYXRvci5wdXNoKGAke2hlbHBlcihcInBsdXJhbFwiIC8qIEhlbHBlck5hbWVNYXAuUExVUkFMICovKX0oW2ApO1xuICAgICAgICBnZW5lcmF0b3IuaW5kZW50KG5lZWRJbmRlbnQoKSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG5vZGUuY2FzZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZU5vZGUoZ2VuZXJhdG9yLCBub2RlLmNhc2VzW2ldKTtcbiAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5lcmF0b3IucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0b3IuZGVpbmRlbnQobmVlZEluZGVudCgpKTtcbiAgICAgICAgZ2VuZXJhdG9yLnB1c2goYF0pYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVSZXNvdXJjZShnZW5lcmF0b3IsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5ib2R5KSB7XG4gICAgICAgIGdlbmVyYXRlTm9kZShnZW5lcmF0b3IsIG5vZGUuYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZW5lcmF0b3IucHVzaCgnbnVsbCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbmVyYXRlTm9kZShnZW5lcmF0b3IsIG5vZGUpIHtcbiAgICBjb25zdCB7IGhlbHBlciB9ID0gZ2VuZXJhdG9yO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBOb2RlVHlwZXMuUmVzb3VyY2UgKi86XG4gICAgICAgICAgICBnZW5lcmF0ZVJlc291cmNlKGdlbmVyYXRvciwgbm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIE5vZGVUeXBlcy5QbHVyYWwgKi86XG4gICAgICAgICAgICBnZW5lcmF0ZVBsdXJhbE5vZGUoZ2VuZXJhdG9yLCBub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTm9kZVR5cGVzLk1lc3NhZ2UgKi86XG4gICAgICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VOb2RlKGdlbmVyYXRvciwgbm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2IC8qIE5vZGVUeXBlcy5MaW5rZWQgKi86XG4gICAgICAgICAgICBnZW5lcmF0ZUxpbmtlZE5vZGUoZ2VuZXJhdG9yLCBub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDggLyogTm9kZVR5cGVzLkxpbmtlZE1vZGlmaWVyICovOlxuICAgICAgICAgICAgZ2VuZXJhdG9yLnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS52YWx1ZSksIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNyAvKiBOb2RlVHlwZXMuTGlua2VkS2V5ICovOlxuICAgICAgICAgICAgZ2VuZXJhdG9yLnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS52YWx1ZSksIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNSAvKiBOb2RlVHlwZXMuTGlzdCAqLzpcbiAgICAgICAgICAgIGdlbmVyYXRvci5wdXNoKGAke2hlbHBlcihcImludGVycG9sYXRlXCIgLyogSGVscGVyTmFtZU1hcC5JTlRFUlBPTEFURSAqLyl9KCR7aGVscGVyKFwibGlzdFwiIC8qIEhlbHBlck5hbWVNYXAuTElTVCAqLyl9KCR7bm9kZS5pbmRleH0pKWAsIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNCAvKiBOb2RlVHlwZXMuTmFtZWQgKi86XG4gICAgICAgICAgICBnZW5lcmF0b3IucHVzaChgJHtoZWxwZXIoXCJpbnRlcnBvbGF0ZVwiIC8qIEhlbHBlck5hbWVNYXAuSU5URVJQT0xBVEUgKi8pfSgke2hlbHBlcihcIm5hbWVkXCIgLyogSGVscGVyTmFtZU1hcC5OQU1FRCAqLyl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5rZXkpfSkpYCwgbm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5MaXRlcmFsICovOlxuICAgICAgICAgICAgZ2VuZXJhdG9yLnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS52YWx1ZSksIG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuVGV4dCAqLzpcbiAgICAgICAgICAgIGdlbmVyYXRvci5wdXNoKEpTT04uc3RyaW5naWZ5KG5vZGUudmFsdWUpLCBub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke25vZGUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4vLyBnZW5lcmF0ZSBjb2RlIGZyb20gQVNUXG5jb25zdCBnZW5lcmF0ZSA9IChhc3QsIG9wdGlvbnMgPSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4pID0+IHtcbiAgICBjb25zdCBtb2RlID0gaXNTdHJpbmcob3B0aW9ucy5tb2RlKSA/IG9wdGlvbnMubW9kZSA6ICdub3JtYWwnO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gaXNTdHJpbmcob3B0aW9ucy5maWxlbmFtZSlcbiAgICAgICAgPyBvcHRpb25zLmZpbGVuYW1lXG4gICAgICAgIDogJ21lc3NhZ2UuaW50bCc7XG4gICAgY29uc3Qgc291cmNlTWFwID0gISFvcHRpb25zLnNvdXJjZU1hcDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBicmVha0xpbmVDb2RlID0gb3B0aW9ucy5icmVha0xpbmVDb2RlICE9IG51bGxcbiAgICAgICAgPyBvcHRpb25zLmJyZWFrTGluZUNvZGVcbiAgICAgICAgOiBtb2RlID09PSAnYXJyb3cnXG4gICAgICAgICAgICA/ICc7J1xuICAgICAgICAgICAgOiAnXFxuJztcbiAgICBjb25zdCBuZWVkSW5kZW50ID0gb3B0aW9ucy5uZWVkSW5kZW50ID8gb3B0aW9ucy5uZWVkSW5kZW50IDogbW9kZSAhPT0gJ2Fycm93JztcbiAgICBjb25zdCBoZWxwZXJzID0gYXN0LmhlbHBlcnMgfHwgW107XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gY3JlYXRlQ29kZUdlbmVyYXRvcihhc3QsIHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgYnJlYWtMaW5lQ29kZSxcbiAgICAgICAgbmVlZEluZGVudFxuICAgIH0pO1xuICAgIGdlbmVyYXRvci5wdXNoKG1vZGUgPT09ICdub3JtYWwnID8gYGZ1bmN0aW9uIF9fbXNnX18gKGN0eCkge2AgOiBgKGN0eCkgPT4ge2ApO1xuICAgIGdlbmVyYXRvci5pbmRlbnQobmVlZEluZGVudCk7XG4gICAgaWYgKGhlbHBlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBnZW5lcmF0b3IucHVzaChgY29uc3QgeyAke2pvaW4oaGVscGVycy5tYXAocyA9PiBgJHtzfTogXyR7c31gKSwgJywgJyl9IH0gPSBjdHhgKTtcbiAgICAgICAgZ2VuZXJhdG9yLm5ld2xpbmUoKTtcbiAgICB9XG4gICAgZ2VuZXJhdG9yLnB1c2goYHJldHVybiBgKTtcbiAgICBnZW5lcmF0ZU5vZGUoZ2VuZXJhdG9yLCBhc3QpO1xuICAgIGdlbmVyYXRvci5kZWluZGVudChuZWVkSW5kZW50KTtcbiAgICBnZW5lcmF0b3IucHVzaChgfWApO1xuICAgIGRlbGV0ZSBhc3QuaGVscGVycztcbiAgICBjb25zdCB7IGNvZGUsIG1hcCB9ID0gZ2VuZXJhdG9yLmNvbnRleHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3QsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIG1hcDogbWFwID8gbWFwLnRvSlNPTigpIDogdW5kZWZpbmVkIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFzc2lnbmVkT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgaml0ID0gISFhc3NpZ25lZE9wdGlvbnMuaml0O1xuICAgIGNvbnN0IGVuYWxiZU1pbmlmeSA9ICEhYXNzaWduZWRPcHRpb25zLm1pbmlmeTtcbiAgICBjb25zdCBlbmFtYmVPcHRpbWl6ZSA9IGFzc2lnbmVkT3B0aW9ucy5vcHRpbWl6ZSA9PSBudWxsID8gdHJ1ZSA6IGFzc2lnbmVkT3B0aW9ucy5vcHRpbWl6ZTtcbiAgICAvLyBwYXJzZSBzb3VyY2UgY29kZXNcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVQYXJzZXIoYXNzaWduZWRPcHRpb25zKTtcbiAgICBjb25zdCBhc3QgPSBwYXJzZXIucGFyc2Uoc291cmNlKTtcbiAgICBpZiAoIWppdCkge1xuICAgICAgICAvLyB0cmFuc2Zvcm0gQVNUc1xuICAgICAgICB0cmFuc2Zvcm0oYXN0LCBhc3NpZ25lZE9wdGlvbnMpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBqYXZhc2NyaXB0IGNvZGVzXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGFzc2lnbmVkT3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvcHRpbWl6ZSBBU1RzXG4gICAgICAgIGVuYW1iZU9wdGltaXplICYmIG9wdGltaXplKGFzdCk7XG4gICAgICAgIC8vIG1pbmltaXplIEFTVHNcbiAgICAgICAgZW5hbGJlTWluaWZ5ICYmIG1pbmlmeShhc3QpO1xuICAgICAgICAvLyBJbiBKSVQgbW9kZSwgbm8gYXN0IHRyYW5zZm9ybSwgbm8gY29kZSBnZW5lcmF0aW9uLlxuICAgICAgICByZXR1cm4geyBhc3QsIGNvZGU6ICcnIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21waWxlRXJyb3JDb2RlcywgRVJST1JfRE9NQUlOLCBMT0NBVElPTl9TVFVCLCBiYXNlQ29tcGlsZSwgY3JlYXRlQ29tcGlsZUVycm9yLCBjcmVhdGVMb2NhdGlvbiwgY3JlYXRlUGFyc2VyLCBjcmVhdGVQb3NpdGlvbiwgZGVmYXVsdE9uRXJyb3IsIGRldGVjdEh0bWxUYWcsIGVycm9yTWVzc2FnZXMgfTtcbiIsIi8qIVxuICAqIGRldnRvb2xzLWlmIHY5LjMuMC1iZXRhLjI1XG4gICogKGMpIDIwMjMga2F6dXlhIGthd2FndWNoaVxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAgKi9cbmNvbnN0IEludGxpZnlEZXZUb29sc0hvb2tzID0gIHtcbiAgICBJMThuSW5pdDogJ2kxOG46aW5pdCcsXG4gICAgRnVuY3Rpb25UcmFuc2xhdGU6ICdmdW5jdGlvbjp0cmFuc2xhdGUnXG59O1xuXG5leHBvcnQgeyBJbnRsaWZ5RGV2VG9vbHNIb29rcyB9O1xuIiwiLyohXG4gICogY29yZS1iYXNlIHY5LjMuMC1iZXRhLjI1XG4gICogKGMpIDIwMjMga2F6dXlhIGthd2FndWNoaVxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAgKi9cbmltcG9ydCB7IGdldEdsb2JhbFRoaXMsIGlzT2JqZWN0LCBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzUGxhaW5PYmplY3QsIGpvaW4sIHRvRGlzcGxheVN0cmluZywgaXNBcnJheSwgZm9ybWF0IGFzIGZvcm1hdCQxLCBpc0Jvb2xlYW4sIGFzc2lnbiwgaXNSZWdFeHAsIHdhcm4sIGVzY2FwZUh0bWwsIGluQnJvd3NlciwgbWFyaywgbWVhc3VyZSwgaXNFbXB0eU9iamVjdCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdlbmVyYXRlRm9ybWF0Q2FjaGVLZXksIGlzRGF0ZSB9IGZyb20gJ0BpbnRsaWZ5L3NoYXJlZCc7XG5pbXBvcnQgeyBDb21waWxlRXJyb3JDb2RlcywgY3JlYXRlQ29tcGlsZUVycm9yLCBkZXRlY3RIdG1sVGFnLCBkZWZhdWx0T25FcnJvciwgYmFzZUNvbXBpbGUgYXMgYmFzZUNvbXBpbGUkMSB9IGZyb20gJ0BpbnRsaWZ5L21lc3NhZ2UtY29tcGlsZXInO1xuZXhwb3J0IHsgQ29tcGlsZUVycm9yQ29kZXMsIGNyZWF0ZUNvbXBpbGVFcnJvciB9IGZyb20gJ0BpbnRsaWZ5L21lc3NhZ2UtY29tcGlsZXInO1xuaW1wb3J0IHsgSW50bGlmeURldlRvb2xzSG9va3MgfSBmcm9tICdAaW50bGlmeS9kZXZ0b29scy1pZic7XG5cbi8qKlxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxuICovXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICAgIGlmICh0eXBlb2YgX19JTlRMSUZZX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX0lOVExJRllfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX19JTlRMSUZZX0pJVF9DT01QSUxBVElPTl9fICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fSU5UTElGWV9KSVRfQ09NUElMQVRJT05fXyA9IGZhbHNlO1xuICAgIH1cbn1cblxuY29uc3QgcGF0aFN0YXRlTWFjaGluZSA9ICBbXTtcbnBhdGhTdGF0ZU1hY2hpbmVbMCAvKiBTdGF0ZXMuQkVGT1JFX1BBVEggKi9dID0ge1xuICAgIFtcIndcIiAvKiBQYXRoQ2hhclR5cGVzLldPUktTUEFDRSAqL106IFswIC8qIFN0YXRlcy5CRUZPUkVfUEFUSCAqL10sXG4gICAgW1wiaVwiIC8qIFBhdGhDaGFyVHlwZXMuSURFTlQgKi9dOiBbMyAvKiBTdGF0ZXMuSU5fSURFTlQgKi8sIDAgLyogQWN0aW9ucy5BUFBFTkQgKi9dLFxuICAgIFtcIltcIiAvKiBQYXRoQ2hhclR5cGVzLkxFRlRfQlJBQ0tFVCAqL106IFs0IC8qIFN0YXRlcy5JTl9TVUJfUEFUSCAqL10sXG4gICAgW1wib1wiIC8qIFBhdGhDaGFyVHlwZXMuRU5EX09GX0ZBSUwgKi9dOiBbNyAvKiBTdGF0ZXMuQUZURVJfUEFUSCAqL11cbn07XG5wYXRoU3RhdGVNYWNoaW5lWzEgLyogU3RhdGVzLklOX1BBVEggKi9dID0ge1xuICAgIFtcIndcIiAvKiBQYXRoQ2hhclR5cGVzLldPUktTUEFDRSAqL106IFsxIC8qIFN0YXRlcy5JTl9QQVRIICovXSxcbiAgICBbXCIuXCIgLyogUGF0aENoYXJUeXBlcy5ET1QgKi9dOiBbMiAvKiBTdGF0ZXMuQkVGT1JFX0lERU5UICovXSxcbiAgICBbXCJbXCIgLyogUGF0aENoYXJUeXBlcy5MRUZUX0JSQUNLRVQgKi9dOiBbNCAvKiBTdGF0ZXMuSU5fU1VCX1BBVEggKi9dLFxuICAgIFtcIm9cIiAvKiBQYXRoQ2hhclR5cGVzLkVORF9PRl9GQUlMICovXTogWzcgLyogU3RhdGVzLkFGVEVSX1BBVEggKi9dXG59O1xucGF0aFN0YXRlTWFjaGluZVsyIC8qIFN0YXRlcy5CRUZPUkVfSURFTlQgKi9dID0ge1xuICAgIFtcIndcIiAvKiBQYXRoQ2hhclR5cGVzLldPUktTUEFDRSAqL106IFsyIC8qIFN0YXRlcy5CRUZPUkVfSURFTlQgKi9dLFxuICAgIFtcImlcIiAvKiBQYXRoQ2hhclR5cGVzLklERU5UICovXTogWzMgLyogU3RhdGVzLklOX0lERU5UICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCIwXCIgLyogUGF0aENoYXJUeXBlcy5aRVJPICovXTogWzMgLyogU3RhdGVzLklOX0lERU5UICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXVxufTtcbnBhdGhTdGF0ZU1hY2hpbmVbMyAvKiBTdGF0ZXMuSU5fSURFTlQgKi9dID0ge1xuICAgIFtcImlcIiAvKiBQYXRoQ2hhclR5cGVzLklERU5UICovXTogWzMgLyogU3RhdGVzLklOX0lERU5UICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCIwXCIgLyogUGF0aENoYXJUeXBlcy5aRVJPICovXTogWzMgLyogU3RhdGVzLklOX0lERU5UICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCJ3XCIgLyogUGF0aENoYXJUeXBlcy5XT1JLU1BBQ0UgKi9dOiBbMSAvKiBTdGF0ZXMuSU5fUEFUSCAqLywgMSAvKiBBY3Rpb25zLlBVU0ggKi9dLFxuICAgIFtcIi5cIiAvKiBQYXRoQ2hhclR5cGVzLkRPVCAqL106IFsyIC8qIFN0YXRlcy5CRUZPUkVfSURFTlQgKi8sIDEgLyogQWN0aW9ucy5QVVNIICovXSxcbiAgICBbXCJbXCIgLyogUGF0aENoYXJUeXBlcy5MRUZUX0JSQUNLRVQgKi9dOiBbNCAvKiBTdGF0ZXMuSU5fU1VCX1BBVEggKi8sIDEgLyogQWN0aW9ucy5QVVNIICovXSxcbiAgICBbXCJvXCIgLyogUGF0aENoYXJUeXBlcy5FTkRfT0ZfRkFJTCAqL106IFs3IC8qIFN0YXRlcy5BRlRFUl9QQVRIICovLCAxIC8qIEFjdGlvbnMuUFVTSCAqL11cbn07XG5wYXRoU3RhdGVNYWNoaW5lWzQgLyogU3RhdGVzLklOX1NVQl9QQVRIICovXSA9IHtcbiAgICBbXCInXCIgLyogUGF0aENoYXJUeXBlcy5TSU5HTEVfUVVPVEUgKi9dOiBbNSAvKiBTdGF0ZXMuSU5fU0lOR0xFX1FVT1RFICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCJcXFwiXCIgLyogUGF0aENoYXJUeXBlcy5ET1VCTEVfUVVPVEUgKi9dOiBbNiAvKiBTdGF0ZXMuSU5fRE9VQkxFX1FVT1RFICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCJbXCIgLyogUGF0aENoYXJUeXBlcy5MRUZUX0JSQUNLRVQgKi9dOiBbXG4gICAgICAgIDQgLyogU3RhdGVzLklOX1NVQl9QQVRIICovLFxuICAgICAgICAyIC8qIEFjdGlvbnMuSU5DX1NVQl9QQVRIX0RFUFRIICovXG4gICAgXSxcbiAgICBbXCJdXCIgLyogUGF0aENoYXJUeXBlcy5SSUdIVF9CUkFDS0VUICovXTogWzEgLyogU3RhdGVzLklOX1BBVEggKi8sIDMgLyogQWN0aW9ucy5QVVNIX1NVQl9QQVRIICovXSxcbiAgICBbXCJvXCIgLyogUGF0aENoYXJUeXBlcy5FTkRfT0ZfRkFJTCAqL106IDggLyogU3RhdGVzLkVSUk9SICovLFxuICAgIFtcImxcIiAvKiBQYXRoQ2hhclR5cGVzLkVMU0UgKi9dOiBbNCAvKiBTdGF0ZXMuSU5fU1VCX1BBVEggKi8sIDAgLyogQWN0aW9ucy5BUFBFTkQgKi9dXG59O1xucGF0aFN0YXRlTWFjaGluZVs1IC8qIFN0YXRlcy5JTl9TSU5HTEVfUVVPVEUgKi9dID0ge1xuICAgIFtcIidcIiAvKiBQYXRoQ2hhclR5cGVzLlNJTkdMRV9RVU9URSAqL106IFs0IC8qIFN0YXRlcy5JTl9TVUJfUEFUSCAqLywgMCAvKiBBY3Rpb25zLkFQUEVORCAqL10sXG4gICAgW1wib1wiIC8qIFBhdGhDaGFyVHlwZXMuRU5EX09GX0ZBSUwgKi9dOiA4IC8qIFN0YXRlcy5FUlJPUiAqLyxcbiAgICBbXCJsXCIgLyogUGF0aENoYXJUeXBlcy5FTFNFICovXTogWzUgLyogU3RhdGVzLklOX1NJTkdMRV9RVU9URSAqLywgMCAvKiBBY3Rpb25zLkFQUEVORCAqL11cbn07XG5wYXRoU3RhdGVNYWNoaW5lWzYgLyogU3RhdGVzLklOX0RPVUJMRV9RVU9URSAqL10gPSB7XG4gICAgW1wiXFxcIlwiIC8qIFBhdGhDaGFyVHlwZXMuRE9VQkxFX1FVT1RFICovXTogWzQgLyogU3RhdGVzLklOX1NVQl9QQVRIICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXSxcbiAgICBbXCJvXCIgLyogUGF0aENoYXJUeXBlcy5FTkRfT0ZfRkFJTCAqL106IDggLyogU3RhdGVzLkVSUk9SICovLFxuICAgIFtcImxcIiAvKiBQYXRoQ2hhclR5cGVzLkVMU0UgKi9dOiBbNiAvKiBTdGF0ZXMuSU5fRE9VQkxFX1FVT1RFICovLCAwIC8qIEFjdGlvbnMuQVBQRU5EICovXVxufTtcbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgdmFsdWUuXG4gKi9cbmNvbnN0IGxpdGVyYWxWYWx1ZVJFID0gL15cXHM/KD86dHJ1ZXxmYWxzZXwtP1tcXGQuXSt8J1teJ10qJ3xcIlteXCJdKlwiKVxccz8kLztcbmZ1bmN0aW9uIGlzTGl0ZXJhbChleHApIHtcbiAgICByZXR1cm4gbGl0ZXJhbFZhbHVlUkUudGVzdChleHApO1xufVxuLyoqXG4gKiBTdHJpcCBxdW90ZXMgZnJvbSBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgICBjb25zdCBhID0gc3RyLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgYiA9IHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSA9PT0gMHgyMiB8fCBhID09PSAweDI3KSA/IHN0ci5zbGljZSgxLCAtMSkgOiBzdHI7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgdHlwZSBvZiBhIGNoYXJhY3RlciBpbiBhIGtleXBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDaGFyVHlwZShjaCkge1xuICAgIGlmIChjaCA9PT0gdW5kZWZpbmVkIHx8IGNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm9cIiAvKiBQYXRoQ2hhclR5cGVzLkVORF9PRl9GQUlMICovO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDViOiAvLyBbXG4gICAgICAgIGNhc2UgMHg1ZDogLy8gXVxuICAgICAgICBjYXNlIDB4MmU6IC8vIC5cbiAgICAgICAgY2FzZSAweDIyOiAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IC8vICdcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgY2FzZSAweDVmOiAvLyBfXG4gICAgICAgIGNhc2UgMHgyNDogLy8gJFxuICAgICAgICBjYXNlIDB4MmQ6IC8vIC1cbiAgICAgICAgICAgIHJldHVybiBcImlcIiAvKiBQYXRoQ2hhclR5cGVzLklERU5UICovO1xuICAgICAgICBjYXNlIDB4MDk6IC8vIFRhYiAoSFQpXG4gICAgICAgIGNhc2UgMHgwYTogLy8gTmV3bGluZSAoTEYpXG4gICAgICAgIGNhc2UgMHgwZDogLy8gUmV0dXJuIChDUilcbiAgICAgICAgY2FzZSAweGEwOiAvLyBOby1icmVhayBzcGFjZSAoTkJTUClcbiAgICAgICAgY2FzZSAweGZlZmY6IC8vIEJ5dGUgT3JkZXIgTWFyayAoQk9NKVxuICAgICAgICBjYXNlIDB4MjAyODogLy8gTGluZSBTZXBhcmF0b3IgKExTKVxuICAgICAgICBjYXNlIDB4MjAyOTogLy8gUGFyYWdyYXBoIFNlcGFyYXRvciAoUFMpXG4gICAgICAgICAgICByZXR1cm4gXCJ3XCIgLyogUGF0aENoYXJUeXBlcy5XT1JLU1BBQ0UgKi87XG4gICAgfVxuICAgIHJldHVybiBcImlcIiAvKiBQYXRoQ2hhclR5cGVzLklERU5UICovO1xufVxuLyoqXG4gKiBGb3JtYXQgYSBzdWJQYXRoLCByZXR1cm4gaXRzIHBsYWluIGZvcm0gaWYgaXQgaXNcbiAqIGEgbGl0ZXJhbCBzdHJpbmcgb3IgbnVtYmVyLiBPdGhlcndpc2UgcHJlcGVuZCB0aGVcbiAqIGR5bmFtaWMgaW5kaWNhdG9yICgqKS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U3ViUGF0aChwYXRoKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IHBhdGgudHJpbSgpO1xuICAgIC8vIGludmFsaWQgbGVhZGluZyAwXG4gICAgaWYgKHBhdGguY2hhckF0KDApID09PSAnMCcgJiYgaXNOYU4ocGFyc2VJbnQocGF0aCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTGl0ZXJhbCh0cmltbWVkKVxuICAgICAgICA/IHN0cmlwUXVvdGVzKHRyaW1tZWQpXG4gICAgICAgIDogXCIqXCIgLyogUGF0aENoYXJUeXBlcy5BU1RBUklTSyAqLyArIHRyaW1tZWQ7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIHBhdGggaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuICovXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCBtb2RlID0gMCAvKiBTdGF0ZXMuQkVGT1JFX1BBVEggKi87XG4gICAgbGV0IHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgbGV0IGM7XG4gICAgbGV0IGtleTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGxldCBuZXdDaGFyO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCB0cmFuc2l0aW9uO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IHR5cGVNYXA7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgIGFjdGlvbnNbMCAvKiBBY3Rpb25zLkFQUEVORCAqL10gPSAoKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5ID0gbmV3Q2hhcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleSArPSBuZXdDaGFyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhY3Rpb25zWzEgLyogQWN0aW9ucy5QVVNIICovXSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYWN0aW9uc1syIC8qIEFjdGlvbnMuSU5DX1NVQl9QQVRIX0RFUFRIICovXSA9ICgpID0+IHtcbiAgICAgICAgYWN0aW9uc1swIC8qIEFjdGlvbnMuQVBQRU5EICovXSgpO1xuICAgICAgICBzdWJQYXRoRGVwdGgrKztcbiAgICB9O1xuICAgIGFjdGlvbnNbMyAvKiBBY3Rpb25zLlBVU0hfU1VCX1BBVEggKi9dID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3ViUGF0aERlcHRoID4gMCkge1xuICAgICAgICAgICAgc3ViUGF0aERlcHRoLS07XG4gICAgICAgICAgICBtb2RlID0gNCAvKiBTdGF0ZXMuSU5fU1VCX1BBVEggKi87XG4gICAgICAgICAgICBhY3Rpb25zWzAgLyogQWN0aW9ucy5BUFBFTkQgKi9dKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJQYXRoRGVwdGggPSAwO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gZm9ybWF0U3ViUGF0aChrZXkpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zWzEgLyogQWN0aW9ucy5QVVNIICovXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtYXliZVVuZXNjYXBlUXVvdGUoKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdO1xuICAgICAgICBpZiAoKG1vZGUgPT09IDUgLyogU3RhdGVzLklOX1NJTkdMRV9RVU9URSAqLyAmJlxuICAgICAgICAgICAgbmV4dENoYXIgPT09IFwiJ1wiIC8qIFBhdGhDaGFyVHlwZXMuU0lOR0xFX1FVT1RFICovKSB8fFxuICAgICAgICAgICAgKG1vZGUgPT09IDYgLyogU3RhdGVzLklOX0RPVUJMRV9RVU9URSAqLyAmJlxuICAgICAgICAgICAgICAgIG5leHRDaGFyID09PSBcIlxcXCJcIiAvKiBQYXRoQ2hhclR5cGVzLkRPVUJMRV9RVU9URSAqLykpIHtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBuZXdDaGFyID0gJ1xcXFwnICsgbmV4dENoYXI7XG4gICAgICAgICAgICBhY3Rpb25zWzAgLyogQWN0aW9ucy5BUFBFTkQgKi9dKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobW9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBjID0gcGF0aFtpbmRleF07XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcgJiYgbWF5YmVVbmVzY2FwZVF1b3RlKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBnZXRQYXRoQ2hhclR5cGUoYyk7XG4gICAgICAgIHR5cGVNYXAgPSBwYXRoU3RhdGVNYWNoaW5lW21vZGVdO1xuICAgICAgICB0cmFuc2l0aW9uID0gdHlwZU1hcFt0eXBlXSB8fCB0eXBlTWFwW1wibFwiIC8qIFBhdGhDaGFyVHlwZXMuRUxTRSAqL10gfHwgOCAvKiBTdGF0ZXMuRVJST1IgKi87XG4gICAgICAgIC8vIGNoZWNrIHBhcnNlIGVycm9yXG4gICAgICAgIGlmICh0cmFuc2l0aW9uID09PSA4IC8qIFN0YXRlcy5FUlJPUiAqLykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgICAgICBpZiAodHJhbnNpdGlvblsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25zW3RyYW5zaXRpb25bMV1dO1xuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIG5ld0NoYXIgPSBjO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBwYXJzZSBmaW5pc2hcbiAgICAgICAgaWYgKG1vZGUgPT09IDcgLyogU3RhdGVzLkFGVEVSX1BBVEggKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gcGF0aCB0b2tlbiBjYWNoZVxuY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKipcbiAqIGtleS12YWx1ZSBtZXNzYWdlIHJlc29sdmVyXG4gKlxuICogQHJlbWFya3NcbiAqIFJlc29sdmVzIG1lc3NhZ2VzIHdpdGggdGhlIGtleS12YWx1ZSBzdHJ1Y3R1cmUuIE5vdGUgdGhhdCBtZXNzYWdlcyB3aXRoIGEgaGllcmFyY2hpY2FsIHN0cnVjdHVyZSBzdWNoIGFzIG9iamVjdHMgY2Fubm90IGJlIHJlc29sdmVkXG4gKlxuICogQHBhcmFtIG9iaiAtIEEgdGFyZ2V0IG9iamVjdCB0byBiZSByZXNvbHZlZCB3aXRoIHBhdGhcbiAqIEBwYXJhbSBwYXRoIC0gQSB7QGxpbmsgUGF0aCB8IHBhdGh9IHRvIHJlc29sdmUgdGhlIHZhbHVlIG9mIG1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJucyBBIHJlc29sdmVkIHtAbGluayBQYXRoVmFsdWUgfCBwYXRoIHZhbHVlfVxuICpcbiAqIEBWdWVJMThuR2VuZXJhbFxuICovXG5mdW5jdGlvbiByZXNvbHZlV2l0aEtleVZhbHVlKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmopID8gb2JqW3BhdGhdIDogbnVsbDtcbn1cbi8qKlxuICogbWVzc2FnZSByZXNvbHZlclxuICpcbiAqIEByZW1hcmtzXG4gKiBSZXNvbHZlcyBtZXNzYWdlcy4gbWVzc2FnZXMgd2l0aCBhIGhpZXJhcmNoaWNhbCBzdHJ1Y3R1cmUgc3VjaCBhcyBvYmplY3RzIGNhbiBiZSByZXNvbHZlZC4gVGhpcyByZXNvbHZlciBpcyB1c2VkIGluIFZ1ZUkxOG4gYXMgZGVmYXVsdC5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gQSB0YXJnZXQgb2JqZWN0IHRvIGJlIHJlc29sdmVkIHdpdGggcGF0aFxuICogQHBhcmFtIHBhdGggLSBBIHtAbGluayBQYXRoIHwgcGF0aH0gdG8gcmVzb2x2ZSB0aGUgdmFsdWUgb2YgbWVzc2FnZVxuICpcbiAqIEByZXR1cm5zIEEgcmVzb2x2ZWQge0BsaW5rIFBhdGhWYWx1ZSB8IHBhdGggdmFsdWV9XG4gKlxuICogQFZ1ZUkxOG5HZW5lcmFsXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVWYWx1ZShvYmosIHBhdGgpIHtcbiAgICAvLyBjaGVjayBvYmplY3RcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHBhcnNlIHBhdGhcbiAgICBsZXQgaGl0ID0gY2FjaGUuZ2V0KHBhdGgpO1xuICAgIGlmICghaGl0KSB7XG4gICAgICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQocGF0aCwgaGl0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBoaXRcbiAgICBpZiAoIWhpdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSBwYXRoIHZhbHVlXG4gICAgY29uc3QgbGVuID0gaGl0Lmxlbmd0aDtcbiAgICBsZXQgbGFzdCA9IG9iajtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgY29uc3QgdmFsID0gbGFzdFtoaXRbaV1dO1xuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSB2YWw7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbmNvbnN0IERFRkFVTFRfTU9ESUZJRVIgPSAoc3RyKSA9PiBzdHI7XG5jb25zdCBERUZBVUxUX01FU1NBR0UgPSAoY3R4KSA9PiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgREVGQVVMVF9NRVNTQUdFX0RBVEFfVFlQRSA9ICd0ZXh0JztcbmNvbnN0IERFRkFVTFRfTk9STUFMSVpFID0gKHZhbHVlcykgPT4gdmFsdWVzLmxlbmd0aCA9PT0gMCA/ICcnIDogam9pbih2YWx1ZXMpO1xuY29uc3QgREVGQVVMVF9JTlRFUlBPTEFURSA9IHRvRGlzcGxheVN0cmluZztcbmZ1bmN0aW9uIHBsdXJhbERlZmF1bHQoY2hvaWNlLCBjaG9pY2VzTGVuZ3RoKSB7XG4gICAgY2hvaWNlID0gTWF0aC5hYnMoY2hvaWNlKTtcbiAgICBpZiAoY2hvaWNlc0xlbmd0aCA9PT0gMikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGNob2ljZVxuICAgICAgICAgICAgPyBjaG9pY2UgPiAxXG4gICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgICA6IDE7XG4gICAgfVxuICAgIHJldHVybiBjaG9pY2UgPyBNYXRoLm1pbihjaG9pY2UsIDIpIDogMDtcbn1cbmZ1bmN0aW9uIGdldFBsdXJhbEluZGV4KG9wdGlvbnMpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBpbmRleCA9IGlzTnVtYmVyKG9wdGlvbnMucGx1cmFsSW5kZXgpXG4gICAgICAgID8gb3B0aW9ucy5wbHVyYWxJbmRleFxuICAgICAgICA6IC0xO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHJldHVybiBvcHRpb25zLm5hbWVkICYmIChpc051bWJlcihvcHRpb25zLm5hbWVkLmNvdW50KSB8fCBpc051bWJlcihvcHRpb25zLm5hbWVkLm4pKVxuICAgICAgICA/IGlzTnVtYmVyKG9wdGlvbnMubmFtZWQuY291bnQpXG4gICAgICAgICAgICA/IG9wdGlvbnMubmFtZWQuY291bnRcbiAgICAgICAgICAgIDogaXNOdW1iZXIob3B0aW9ucy5uYW1lZC5uKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5uYW1lZC5uXG4gICAgICAgICAgICAgICAgOiBpbmRleFxuICAgICAgICA6IGluZGV4O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZWQocGx1cmFsSW5kZXgsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5jb3VudCkge1xuICAgICAgICBwcm9wcy5jb3VudCA9IHBsdXJhbEluZGV4O1xuICAgIH1cbiAgICBpZiAoIXByb3BzLm4pIHtcbiAgICAgICAgcHJvcHMubiA9IHBsdXJhbEluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb250ZXh0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlO1xuICAgIGNvbnN0IHBsdXJhbEluZGV4ID0gZ2V0UGx1cmFsSW5kZXgob3B0aW9ucyk7XG4gICAgY29uc3QgcGx1cmFsUnVsZSA9IGlzT2JqZWN0KG9wdGlvbnMucGx1cmFsUnVsZXMpICYmXG4gICAgICAgIGlzU3RyaW5nKGxvY2FsZSkgJiZcbiAgICAgICAgaXNGdW5jdGlvbihvcHRpb25zLnBsdXJhbFJ1bGVzW2xvY2FsZV0pXG4gICAgICAgID8gb3B0aW9ucy5wbHVyYWxSdWxlc1tsb2NhbGVdXG4gICAgICAgIDogcGx1cmFsRGVmYXVsdDtcbiAgICBjb25zdCBvcmdQbHVyYWxSdWxlID0gaXNPYmplY3Qob3B0aW9ucy5wbHVyYWxSdWxlcykgJiZcbiAgICAgICAgaXNTdHJpbmcobG9jYWxlKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKG9wdGlvbnMucGx1cmFsUnVsZXNbbG9jYWxlXSlcbiAgICAgICAgPyBwbHVyYWxEZWZhdWx0XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBsdXJhbCA9IChtZXNzYWdlcykgPT4ge1xuICAgICAgICByZXR1cm4gbWVzc2FnZXNbcGx1cmFsUnVsZShwbHVyYWxJbmRleCwgbWVzc2FnZXMubGVuZ3RoLCBvcmdQbHVyYWxSdWxlKV07XG4gICAgfTtcbiAgICBjb25zdCBfbGlzdCA9IG9wdGlvbnMubGlzdCB8fCBbXTtcbiAgICBjb25zdCBsaXN0ID0gKGluZGV4KSA9PiBfbGlzdFtpbmRleF07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBfbmFtZWQgPSBvcHRpb25zLm5hbWVkIHx8IHt9O1xuICAgIGlzTnVtYmVyKG9wdGlvbnMucGx1cmFsSW5kZXgpICYmIG5vcm1hbGl6ZU5hbWVkKHBsdXJhbEluZGV4LCBfbmFtZWQpO1xuICAgIGNvbnN0IG5hbWVkID0gKGtleSkgPT4gX25hbWVkW2tleV07XG4gICAgZnVuY3Rpb24gbWVzc2FnZShrZXkpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IG1zZyA9IGlzRnVuY3Rpb24ob3B0aW9ucy5tZXNzYWdlcylcbiAgICAgICAgICAgID8gb3B0aW9ucy5tZXNzYWdlcyhrZXkpXG4gICAgICAgICAgICA6IGlzT2JqZWN0KG9wdGlvbnMubWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLm1lc3NhZ2VzW2tleV1cbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gIW1zZ1xuICAgICAgICAgICAgPyBvcHRpb25zLnBhcmVudFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5wYXJlbnQubWVzc2FnZShrZXkpIC8vIHJlc29sdmUgZnJvbSBwYXJlbnQgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfTUVTU0FHRVxuICAgICAgICAgICAgOiBtc2c7XG4gICAgfVxuICAgIGNvbnN0IF9tb2RpZmllciA9IChuYW1lKSA9PiBvcHRpb25zLm1vZGlmaWVyc1xuICAgICAgICA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdXG4gICAgICAgIDogREVGQVVMVF9NT0RJRklFUjtcbiAgICBjb25zdCBub3JtYWxpemUgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMucHJvY2Vzc29yKSAmJiBpc0Z1bmN0aW9uKG9wdGlvbnMucHJvY2Vzc29yLm5vcm1hbGl6ZSlcbiAgICAgICAgPyBvcHRpb25zLnByb2Nlc3Nvci5ub3JtYWxpemVcbiAgICAgICAgOiBERUZBVUxUX05PUk1BTElaRTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZSA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucy5wcm9jZXNzb3IpICYmXG4gICAgICAgIGlzRnVuY3Rpb24ob3B0aW9ucy5wcm9jZXNzb3IuaW50ZXJwb2xhdGUpXG4gICAgICAgID8gb3B0aW9ucy5wcm9jZXNzb3IuaW50ZXJwb2xhdGVcbiAgICAgICAgOiBERUZBVUxUX0lOVEVSUE9MQVRFO1xuICAgIGNvbnN0IHR5cGUgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMucHJvY2Vzc29yKSAmJiBpc1N0cmluZyhvcHRpb25zLnByb2Nlc3Nvci50eXBlKVxuICAgICAgICA/IG9wdGlvbnMucHJvY2Vzc29yLnR5cGVcbiAgICAgICAgOiBERUZBVUxUX01FU1NBR0VfREFUQV9UWVBFO1xuICAgIGNvbnN0IGxpbmtlZCA9IChrZXksIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgW2FyZzEsIGFyZzJdID0gYXJncztcbiAgICAgICAgbGV0IHR5cGUgPSAndGV4dCc7XG4gICAgICAgIGxldCBtb2RpZmllciA9ICcnO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChhcmcxKSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gYXJnMS5tb2RpZmllciB8fCBtb2RpZmllcjtcbiAgICAgICAgICAgICAgICB0eXBlID0gYXJnMS50eXBlIHx8IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhhcmcxKSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gYXJnMSB8fCBtb2RpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBhcmcxIHx8IG1vZGlmaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGFyZzIpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGFyZzIgfHwgdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBtZXNzYWdlKGtleSkoY3R4KTtcbiAgICAgICAgY29uc3QgbXNnID0gXG4gICAgICAgIC8vIFRoZSBtZXNzYWdlIGluIHZub2RlIHJlc29sdmVkIHdpdGggbGlua2VkIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheSBieSBwcm9jZXNzb3Iubm9tYWxpemVcbiAgICAgICAgdHlwZSA9PT0gJ3Zub2RlJyAmJiBpc0FycmF5KHJldCkgJiYgbW9kaWZpZXJcbiAgICAgICAgICAgID8gcmV0WzBdXG4gICAgICAgICAgICA6IHJldDtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyID8gX21vZGlmaWVyKG1vZGlmaWVyKShtc2csIHR5cGUpIDogbXNnO1xuICAgIH07XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgICBbXCJsaXN0XCIgLyogSGVscGVyTmFtZU1hcC5MSVNUICovXTogbGlzdCxcbiAgICAgICAgW1wibmFtZWRcIiAvKiBIZWxwZXJOYW1lTWFwLk5BTUVEICovXTogbmFtZWQsXG4gICAgICAgIFtcInBsdXJhbFwiIC8qIEhlbHBlck5hbWVNYXAuUExVUkFMICovXTogcGx1cmFsLFxuICAgICAgICBbXCJsaW5rZWRcIiAvKiBIZWxwZXJOYW1lTWFwLkxJTktFRCAqL106IGxpbmtlZCxcbiAgICAgICAgW1wibWVzc2FnZVwiIC8qIEhlbHBlck5hbWVNYXAuTUVTU0FHRSAqL106IG1lc3NhZ2UsXG4gICAgICAgIFtcInR5cGVcIiAvKiBIZWxwZXJOYW1lTWFwLlRZUEUgKi9dOiB0eXBlLFxuICAgICAgICBbXCJpbnRlcnBvbGF0ZVwiIC8qIEhlbHBlck5hbWVNYXAuSU5URVJQT0xBVEUgKi9dOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgW1wibm9ybWFsaXplXCIgLyogSGVscGVyTmFtZU1hcC5OT1JNQUxJWkUgKi9dOiBub3JtYWxpemVcbiAgICB9O1xuICAgIHJldHVybiBjdHg7XG59XG5cbmxldCBkZXZ0b29scyA9IG51bGw7XG5mdW5jdGlvbiBzZXREZXZUb29sc0hvb2soaG9vaykge1xuICAgIGRldnRvb2xzID0gaG9vaztcbn1cbmZ1bmN0aW9uIGdldERldlRvb2xzSG9vaygpIHtcbiAgICByZXR1cm4gZGV2dG9vbHM7XG59XG5mdW5jdGlvbiBpbml0STE4bkRldlRvb2xzKGkxOG4sIHZlcnNpb24sIG1ldGEpIHtcbiAgICAvLyBUT0RPOiBxdWV1ZSBpZiBkZXZ0b29scyBpcyB1bmRlZmluZWRcbiAgICBkZXZ0b29scyAmJlxuICAgICAgICBkZXZ0b29scy5lbWl0KEludGxpZnlEZXZUb29sc0hvb2tzLkkxOG5Jbml0LCB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgfSk7XG59XG5jb25zdCB0cmFuc2xhdGVEZXZUb29scyA9IC8qICNfX1BVUkVfXyovIGNyZWF0ZURldlRvb2xzSG9vayhJbnRsaWZ5RGV2VG9vbHNIb29rcy5GdW5jdGlvblRyYW5zbGF0ZSk7XG5mdW5jdGlvbiBjcmVhdGVEZXZUb29sc0hvb2soaG9vaykge1xuICAgIHJldHVybiAocGF5bG9hZHMpID0+IGRldnRvb2xzICYmIGRldnRvb2xzLmVtaXQoaG9vaywgcGF5bG9hZHMpO1xufVxuXG5jb25zdCBDb3JlV2FybkNvZGVzID0ge1xuICAgIE5PVF9GT1VORF9LRVk6IDEsXG4gICAgRkFMTEJBQ0tfVE9fVFJBTlNMQVRFOiAyLFxuICAgIENBTk5PVF9GT1JNQVRfTlVNQkVSOiAzLFxuICAgIEZBTExCQUNLX1RPX05VTUJFUl9GT1JNQVQ6IDQsXG4gICAgQ0FOTk9UX0ZPUk1BVF9EQVRFOiA1LFxuICAgIEZBTExCQUNLX1RPX0RBVEVfRk9STUFUOiA2LFxuICAgIF9fRVhURU5EX1BPSU5UX186IDdcbn07XG4vKiogQGludGVybmFsICovXG5jb25zdCB3YXJuTWVzc2FnZXMgPSB7XG4gICAgW0NvcmVXYXJuQ29kZXMuTk9UX0ZPVU5EX0tFWV06IGBOb3QgZm91bmQgJ3trZXl9JyBrZXkgaW4gJ3tsb2NhbGV9JyBsb2NhbGUgbWVzc2FnZXMuYCxcbiAgICBbQ29yZVdhcm5Db2Rlcy5GQUxMQkFDS19UT19UUkFOU0xBVEVdOiBgRmFsbCBiYWNrIHRvIHRyYW5zbGF0ZSAne2tleX0nIGtleSB3aXRoICd7dGFyZ2V0fScgbG9jYWxlLmAsXG4gICAgW0NvcmVXYXJuQ29kZXMuQ0FOTk9UX0ZPUk1BVF9OVU1CRVJdOiBgQ2Fubm90IGZvcm1hdCBhIG51bWJlciB2YWx1ZSBkdWUgdG8gbm90IHN1cHBvcnRlZCBJbnRsLk51bWJlckZvcm1hdC5gLFxuICAgIFtDb3JlV2FybkNvZGVzLkZBTExCQUNLX1RPX05VTUJFUl9GT1JNQVRdOiBgRmFsbCBiYWNrIHRvIG51bWJlciBmb3JtYXQgJ3trZXl9JyBrZXkgd2l0aCAne3RhcmdldH0nIGxvY2FsZS5gLFxuICAgIFtDb3JlV2FybkNvZGVzLkNBTk5PVF9GT1JNQVRfREFURV06IGBDYW5ub3QgZm9ybWF0IGEgZGF0ZSB2YWx1ZSBkdWUgdG8gbm90IHN1cHBvcnRlZCBJbnRsLkRhdGVUaW1lRm9ybWF0LmAsXG4gICAgW0NvcmVXYXJuQ29kZXMuRkFMTEJBQ0tfVE9fREFURV9GT1JNQVRdOiBgRmFsbCBiYWNrIHRvIGRhdGV0aW1lIGZvcm1hdCAne2tleX0nIGtleSB3aXRoICd7dGFyZ2V0fScgbG9jYWxlLmBcbn07XG5mdW5jdGlvbiBnZXRXYXJuTWVzc2FnZShjb2RlLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZvcm1hdCQxKHdhcm5NZXNzYWdlc1tjb2RlXSwgLi4uYXJncyk7XG59XG5cbi8qKlxuICogRmFsbGJhY2sgd2l0aCBzaW1wbGUgaW1wbGVtZW5hdGlvblxuICpcbiAqIEByZW1hcmtzXG4gKiBBIGZhbGxiYWNrIGxvY2FsZSBmdW5jdGlvbiBpbXBsZW1lbnRlZCB3aXRoIGEgc2ltcGxlIGZhbGxiYWNrIGFsZ29yaXRobS5cbiAqXG4gKiBCYXNpY2FsbHksIGl0IHJldHVybnMgdGhlIHZhbHVlIGFzIHNwZWNpZmllZCBpbiB0aGUgYGZhbGxiYWNrTG9jYWxlYCBwcm9wcywgYW5kIGlzIHByb2Nlc3NlZCB3aXRoIHRoZSBmYWxsYmFjayBpbnNpZGUgaW50bGlmeS5cbiAqXG4gKiBAcGFyYW0gY3R4IC0gQSB7QGxpbmsgQ29yZUNvbnRleHQgfCBjb250ZXh0fVxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSB7QGxpbmsgRmFsbGJhY2tMb2NhbGUgfCBmYWxsYmFjayBsb2NhbGV9XG4gKiBAcGFyYW0gc3RhcnQgLSBBIHN0YXJ0aW5nIHtAbGluayBMb2NhbGUgfCBsb2NhbGV9XG4gKlxuICogQHJldHVybnMgRmFsbGJhY2sgbG9jYWxlc1xuICpcbiAqIEBWdWVJMThuR2VuZXJhbFxuICovXG5mdW5jdGlvbiBmYWxsYmFja1dpdGhTaW1wbGUoY3R4LCBmYWxsYmFjaywgc3RhcnQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbikge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHJldHVybiBbLi4ubmV3IFNldChbXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIC4uLihpc0FycmF5KGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgID8gZmFsbGJhY2tcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5rZXlzKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICA6IGlzU3RyaW5nKGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbZmFsbGJhY2tdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtzdGFydF0pXG4gICAgICAgIF0pXTtcbn1cbi8qKlxuICogRmFsbGJhY2sgd2l0aCBsb2NhbGUgY2hhaW5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBmYWxsYmFjayBsb2NhbGUgZnVuY3Rpb24gaW1wbGVtZW50ZWQgd2l0aCBhIGZhbGxiYWNrIGNoYWluIGFsZ29yaXRobS4gSXQncyB1c2VkIGluIFZ1ZUkxOG4gYXMgZGVmYXVsdC5cbiAqXG4gKiBAcGFyYW0gY3R4IC0gQSB7QGxpbmsgQ29yZUNvbnRleHQgfCBjb250ZXh0fVxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSB7QGxpbmsgRmFsbGJhY2tMb2NhbGUgfCBmYWxsYmFjayBsb2NhbGV9XG4gKiBAcGFyYW0gc3RhcnQgLSBBIHN0YXJ0aW5nIHtAbGluayBMb2NhbGUgfCBsb2NhbGV9XG4gKlxuICogQHJldHVybnMgRmFsbGJhY2sgbG9jYWxlc1xuICpcbiAqIEBWdWVJMThuU2VlIFtGYWxsYmFja2luZ10oLi4vZ3VpZGUvZXNzZW50aWFscy9mYWxsYmFjaylcbiAqXG4gKiBAVnVlSTE4bkdlbmVyYWxcbiAqL1xuZnVuY3Rpb24gZmFsbGJhY2tXaXRoTG9jYWxlQ2hhaW4oY3R4LCBmYWxsYmFjaywgc3RhcnQpIHtcbiAgICBjb25zdCBzdGFydExvY2FsZSA9IGlzU3RyaW5nKHN0YXJ0KSA/IHN0YXJ0IDogREVGQVVMVF9MT0NBTEU7XG4gICAgY29uc3QgY29udGV4dCA9IGN0eDtcbiAgICBpZiAoIWNvbnRleHQuX19sb2NhbGVDaGFpbkNhY2hlKSB7XG4gICAgICAgIGNvbnRleHQuX19sb2NhbGVDaGFpbkNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBsZXQgY2hhaW4gPSBjb250ZXh0Ll9fbG9jYWxlQ2hhaW5DYWNoZS5nZXQoc3RhcnRMb2NhbGUpO1xuICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgY2hhaW4gPSBbXTtcbiAgICAgICAgLy8gZmlyc3QgYmxvY2sgZGVmaW5lZCBieSBzdGFydFxuICAgICAgICBsZXQgYmxvY2sgPSBbc3RhcnRdO1xuICAgICAgICAvLyB3aGlsZSBhbnkgaW50ZXJ2ZW5pbmcgYmxvY2sgZm91bmRcbiAgICAgICAgd2hpbGUgKGlzQXJyYXkoYmxvY2spKSB7XG4gICAgICAgICAgICBibG9jayA9IGFwcGVuZEJsb2NrVG9DaGFpbihjaGFpbiwgYmxvY2ssIGZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgLy8gbGFzdCBibG9jayBkZWZpbmVkIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSBpc0FycmF5KGZhbGxiYWNrKSB8fCAhaXNQbGFpbk9iamVjdChmYWxsYmFjaylcbiAgICAgICAgICAgID8gZmFsbGJhY2tcbiAgICAgICAgICAgIDogZmFsbGJhY2tbJ2RlZmF1bHQnXVxuICAgICAgICAgICAgICAgID8gZmFsbGJhY2tbJ2RlZmF1bHQnXVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgLy8gY29udmVydCBkZWZhdWx0cyB0byBhcnJheVxuICAgICAgICBibG9jayA9IGlzU3RyaW5nKGRlZmF1bHRzKSA/IFtkZWZhdWx0c10gOiBkZWZhdWx0cztcbiAgICAgICAgaWYgKGlzQXJyYXkoYmxvY2spKSB7XG4gICAgICAgICAgICBhcHBlbmRCbG9ja1RvQ2hhaW4oY2hhaW4sIGJsb2NrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5fX2xvY2FsZUNoYWluQ2FjaGUuc2V0KHN0YXJ0TG9jYWxlLCBjaGFpbik7XG4gICAgfVxuICAgIHJldHVybiBjaGFpbjtcbn1cbmZ1bmN0aW9uIGFwcGVuZEJsb2NrVG9DaGFpbihjaGFpbiwgYmxvY2ssIGJsb2Nrcykge1xuICAgIGxldCBmb2xsb3cgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoICYmIGlzQm9vbGVhbihmb2xsb3cpOyBpKyspIHtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYmxvY2tbaV07XG4gICAgICAgIGlmIChpc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgICAgICAgICBmb2xsb3cgPSBhcHBlbmRMb2NhbGVUb0NoYWluKGNoYWluLCBibG9ja1tpXSwgYmxvY2tzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9sbG93O1xufVxuZnVuY3Rpb24gYXBwZW5kTG9jYWxlVG9DaGFpbihjaGFpbiwgbG9jYWxlLCBibG9ja3MpIHtcbiAgICBsZXQgZm9sbG93O1xuICAgIGNvbnN0IHRva2VucyA9IGxvY2FsZS5zcGxpdCgnLScpO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG9rZW5zLmpvaW4oJy0nKTtcbiAgICAgICAgZm9sbG93ID0gYXBwZW5kSXRlbVRvQ2hhaW4oY2hhaW4sIHRhcmdldCwgYmxvY2tzKTtcbiAgICAgICAgdG9rZW5zLnNwbGljZSgtMSwgMSk7XG4gICAgfSB3aGlsZSAodG9rZW5zLmxlbmd0aCAmJiBmb2xsb3cgPT09IHRydWUpO1xuICAgIHJldHVybiBmb2xsb3c7XG59XG5mdW5jdGlvbiBhcHBlbmRJdGVtVG9DaGFpbihjaGFpbiwgdGFyZ2V0LCBibG9ja3MpIHtcbiAgICBsZXQgZm9sbG93ID0gZmFsc2U7XG4gICAgaWYgKCFjaGFpbi5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgIGZvbGxvdyA9IHRydWU7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGZvbGxvdyA9IHRhcmdldFt0YXJnZXQubGVuZ3RoIC0gMV0gIT09ICchJztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZSA9IHRhcmdldC5yZXBsYWNlKC8hL2csICcnKTtcbiAgICAgICAgICAgIGNoYWluLnB1c2gobG9jYWxlKTtcbiAgICAgICAgICAgIGlmICgoaXNBcnJheShibG9ja3MpIHx8IGlzUGxhaW5PYmplY3QoYmxvY2tzKSkgJiZcbiAgICAgICAgICAgICAgICBibG9ja3NbbG9jYWxlXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZm9sbG93ID0gYmxvY2tzW2xvY2FsZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvbGxvdztcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBJbnRsaWZ5IGNvcmUtYmFzZSB2ZXJzaW9uXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVkVSU0lPTiA9ICc5LjMuMC1iZXRhLjI1JztcbmNvbnN0IE5PVF9SRU9TTFZFRCA9IC0xO1xuY29uc3QgREVGQVVMVF9MT0NBTEUgPSAnZW4tVVMnO1xuY29uc3QgTUlTU0lOR19SRVNPTFZFX1ZBTFVFID0gJyc7XG5jb25zdCBjYXBpdGFsaXplID0gKHN0cikgPT4gYCR7c3RyLmNoYXJBdCgwKS50b0xvY2FsZVVwcGVyQ2FzZSgpfSR7c3RyLnN1YnN0cigxKX1gO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdExpbmtlZE1vZGlmaWVycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cHBlcjogKHZhbCwgdHlwZSkgPT4ge1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHQnICYmIGlzU3RyaW5nKHZhbClcbiAgICAgICAgICAgICAgICA/IHZhbC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiB0eXBlID09PSAndm5vZGUnICYmIGlzT2JqZWN0KHZhbCkgJiYgJ19fdl9pc1ZOb2RlJyBpbiB2YWxcbiAgICAgICAgICAgICAgICAgICAgPyB2YWwuY2hpbGRyZW4udG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgbG93ZXI6ICh2YWwsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0JyAmJiBpc1N0cmluZyh2YWwpXG4gICAgICAgICAgICAgICAgPyB2YWwudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ3Zub2RlJyAmJiBpc09iamVjdCh2YWwpICYmICdfX3ZfaXNWTm9kZScgaW4gdmFsXG4gICAgICAgICAgICAgICAgICAgID8gdmFsLmNoaWxkcmVuLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGNhcGl0YWxpemU6ICh2YWwsIHR5cGUpID0+IHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuICh0eXBlID09PSAndGV4dCcgJiYgaXNTdHJpbmcodmFsKVxuICAgICAgICAgICAgICAgID8gY2FwaXRhbGl6ZSh2YWwpXG4gICAgICAgICAgICAgICAgOiB0eXBlID09PSAndm5vZGUnICYmIGlzT2JqZWN0KHZhbCkgJiYgJ19fdl9pc1ZOb2RlJyBpbiB2YWxcbiAgICAgICAgICAgICAgICAgICAgPyBjYXBpdGFsaXplKHZhbC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgOiB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBfY29tcGlsZXI7XG5mdW5jdGlvbiByZWdpc3Rlck1lc3NhZ2VDb21waWxlcihjb21waWxlcikge1xuICAgIF9jb21waWxlciA9IGNvbXBpbGVyO1xufVxubGV0IF9yZXNvbHZlcjtcbi8qKlxuICogUmVnaXN0ZXIgdGhlIG1lc3NhZ2UgcmVzb2x2ZXJcbiAqXG4gKiBAcGFyYW0gcmVzb2x2ZXIgLSBBIHtAbGluayBNZXNzYWdlUmVzb2x2ZXJ9IGZ1bmN0aW9uXG4gKlxuICogQFZ1ZUkxOG5HZW5lcmFsXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTWVzc2FnZVJlc29sdmVyKHJlc29sdmVyKSB7XG4gICAgX3Jlc29sdmVyID0gcmVzb2x2ZXI7XG59XG5sZXQgX2ZhbGxiYWNrZXI7XG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBsb2NhbGUgZmFsbGJhY2tlclxuICpcbiAqIEBwYXJhbSBmYWxsYmFja2VyIC0gQSB7QGxpbmsgTG9jYWxlRmFsbGJhY2tlcn0gZnVuY3Rpb25cbiAqXG4gKiBAVnVlSTE4bkdlbmVyYWxcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2NhbGVGYWxsYmFja2VyKGZhbGxiYWNrZXIpIHtcbiAgICBfZmFsbGJhY2tlciA9IGZhbGxiYWNrZXI7XG59XG4vLyBBZGRpdGlvbmFsIE1ldGEgZm9yIEludGxpZnkgRGV2VG9vbHNcbmxldCBfYWRkaXRpb25hbE1ldGEgPSAgbnVsbDtcbmNvbnN0IHNldEFkZGl0aW9uYWxNZXRhID0gIChtZXRhKSA9PiB7XG4gICAgX2FkZGl0aW9uYWxNZXRhID0gbWV0YTtcbn07XG5jb25zdCBnZXRBZGRpdGlvbmFsTWV0YSA9ICAoKSA9PiBfYWRkaXRpb25hbE1ldGE7XG5sZXQgX2ZhbGxiYWNrQ29udGV4dCA9IG51bGw7XG5jb25zdCBzZXRGYWxsYmFja0NvbnRleHQgPSAoY29udGV4dCkgPT4ge1xuICAgIF9mYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xufTtcbmNvbnN0IGdldEZhbGxiYWNrQ29udGV4dCA9ICgpID0+IF9mYWxsYmFja0NvbnRleHQ7XG4vLyBJRCBmb3IgQ29yZUNvbnRleHRcbmxldCBfY2lkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvcmVDb250ZXh0KG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIHNldHVwIG9wdGlvbnNcbiAgICBjb25zdCB2ZXJzaW9uID0gaXNTdHJpbmcob3B0aW9ucy52ZXJzaW9uKSA/IG9wdGlvbnMudmVyc2lvbiA6IFZFUlNJT047XG4gICAgY29uc3QgbG9jYWxlID0gaXNTdHJpbmcob3B0aW9ucy5sb2NhbGUpID8gb3B0aW9ucy5sb2NhbGUgOiBERUZBVUxUX0xPQ0FMRTtcbiAgICBjb25zdCBmYWxsYmFja0xvY2FsZSA9IGlzQXJyYXkob3B0aW9ucy5mYWxsYmFja0xvY2FsZSkgfHxcbiAgICAgICAgaXNQbGFpbk9iamVjdChvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICBpc1N0cmluZyhvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICBvcHRpb25zLmZhbGxiYWNrTG9jYWxlID09PSBmYWxzZVxuICAgICAgICA/IG9wdGlvbnMuZmFsbGJhY2tMb2NhbGVcbiAgICAgICAgOiBsb2NhbGU7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMubWVzc2FnZXMpXG4gICAgICAgID8gb3B0aW9ucy5tZXNzYWdlc1xuICAgICAgICA6IHsgW2xvY2FsZV06IHt9IH07XG4gICAgY29uc3QgZGF0ZXRpbWVGb3JtYXRzID0gaXNQbGFpbk9iamVjdChvcHRpb25zLmRhdGV0aW1lRm9ybWF0cylcbiAgICAgICAgICAgID8gb3B0aW9ucy5kYXRldGltZUZvcm1hdHNcbiAgICAgICAgICAgIDogeyBbbG9jYWxlXToge30gfVxuICAgICAgICA7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0cyA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucy5udW1iZXJGb3JtYXRzKVxuICAgICAgICAgICAgPyBvcHRpb25zLm51bWJlckZvcm1hdHNcbiAgICAgICAgICAgIDogeyBbbG9jYWxlXToge30gfVxuICAgICAgICA7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gYXNzaWduKHt9LCBvcHRpb25zLm1vZGlmaWVycyB8fCB7fSwgZ2V0RGVmYXVsdExpbmtlZE1vZGlmaWVycygpKTtcbiAgICBjb25zdCBwbHVyYWxSdWxlcyA9IG9wdGlvbnMucGx1cmFsUnVsZXMgfHwge307XG4gICAgY29uc3QgbWlzc2luZyA9IGlzRnVuY3Rpb24ob3B0aW9ucy5taXNzaW5nKSA/IG9wdGlvbnMubWlzc2luZyA6IG51bGw7XG4gICAgY29uc3QgbWlzc2luZ1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5taXNzaW5nV2FybikgfHwgaXNSZWdFeHAob3B0aW9ucy5taXNzaW5nV2FybilcbiAgICAgICAgPyBvcHRpb25zLm1pc3NpbmdXYXJuXG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBmYWxsYmFja1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1dhcm4pIHx8IGlzUmVnRXhwKG9wdGlvbnMuZmFsbGJhY2tXYXJuKVxuICAgICAgICA/IG9wdGlvbnMuZmFsbGJhY2tXYXJuXG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBmYWxsYmFja0Zvcm1hdCA9ICEhb3B0aW9ucy5mYWxsYmFja0Zvcm1hdDtcbiAgICBjb25zdCB1bnJlc29sdmluZyA9ICEhb3B0aW9ucy51bnJlc29sdmluZztcbiAgICBjb25zdCBwb3N0VHJhbnNsYXRpb24gPSBpc0Z1bmN0aW9uKG9wdGlvbnMucG9zdFRyYW5zbGF0aW9uKVxuICAgICAgICA/IG9wdGlvbnMucG9zdFRyYW5zbGF0aW9uXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBpc1BsYWluT2JqZWN0KG9wdGlvbnMucHJvY2Vzc29yKSA/IG9wdGlvbnMucHJvY2Vzc29yIDogbnVsbDtcbiAgICBjb25zdCB3YXJuSHRtbE1lc3NhZ2UgPSBpc0Jvb2xlYW4ob3B0aW9ucy53YXJuSHRtbE1lc3NhZ2UpXG4gICAgICAgID8gb3B0aW9ucy53YXJuSHRtbE1lc3NhZ2VcbiAgICAgICAgOiB0cnVlO1xuICAgIGNvbnN0IGVzY2FwZVBhcmFtZXRlciA9ICEhb3B0aW9ucy5lc2NhcGVQYXJhbWV0ZXI7XG4gICAgY29uc3QgbWVzc2FnZUNvbXBpbGVyID0gaXNGdW5jdGlvbihvcHRpb25zLm1lc3NhZ2VDb21waWxlcilcbiAgICAgICAgPyBvcHRpb25zLm1lc3NhZ2VDb21waWxlclxuICAgICAgICA6IF9jb21waWxlcjtcbiAgICBjb25zdCBtZXNzYWdlUmVzb2x2ZXIgPSBpc0Z1bmN0aW9uKG9wdGlvbnMubWVzc2FnZVJlc29sdmVyKVxuICAgICAgICA/IG9wdGlvbnMubWVzc2FnZVJlc29sdmVyXG4gICAgICAgIDogX3Jlc29sdmVyIHx8IHJlc29sdmVXaXRoS2V5VmFsdWU7XG4gICAgY29uc3QgbG9jYWxlRmFsbGJhY2tlciA9IGlzRnVuY3Rpb24ob3B0aW9ucy5sb2NhbGVGYWxsYmFja2VyKVxuICAgICAgICA/IG9wdGlvbnMubG9jYWxlRmFsbGJhY2tlclxuICAgICAgICA6IF9mYWxsYmFja2VyIHx8IGZhbGxiYWNrV2l0aFNpbXBsZTtcbiAgICBjb25zdCBmYWxsYmFja0NvbnRleHQgPSBpc09iamVjdChvcHRpb25zLmZhbGxiYWNrQ29udGV4dClcbiAgICAgICAgPyBvcHRpb25zLmZhbGxiYWNrQ29udGV4dFxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbldhcm4gPSBpc0Z1bmN0aW9uKG9wdGlvbnMub25XYXJuKSA/IG9wdGlvbnMub25XYXJuIDogd2FybjtcbiAgICAvLyBzZXR1cCBpbnRlcm5hbCBvcHRpb25zXG4gICAgY29uc3QgaW50ZXJuYWxPcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBfX2RhdGV0aW1lRm9ybWF0dGVycyA9IGlzT2JqZWN0KGludGVybmFsT3B0aW9ucy5fX2RhdGV0aW1lRm9ybWF0dGVycylcbiAgICAgICAgICAgID8gaW50ZXJuYWxPcHRpb25zLl9fZGF0ZXRpbWVGb3JtYXR0ZXJzXG4gICAgICAgICAgICA6IG5ldyBNYXAoKVxuICAgICAgICA7XG4gICAgY29uc3QgX19udW1iZXJGb3JtYXR0ZXJzID0gaXNPYmplY3QoaW50ZXJuYWxPcHRpb25zLl9fbnVtYmVyRm9ybWF0dGVycylcbiAgICAgICAgICAgID8gaW50ZXJuYWxPcHRpb25zLl9fbnVtYmVyRm9ybWF0dGVyc1xuICAgICAgICAgICAgOiBuZXcgTWFwKClcbiAgICAgICAgO1xuICAgIGNvbnN0IF9fbWV0YSA9IGlzT2JqZWN0KGludGVybmFsT3B0aW9ucy5fX21ldGEpID8gaW50ZXJuYWxPcHRpb25zLl9fbWV0YSA6IHt9O1xuICAgIF9jaWQrKztcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBjaWQ6IF9jaWQsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgZmFsbGJhY2tMb2NhbGUsXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIHBsdXJhbFJ1bGVzLFxuICAgICAgICBtaXNzaW5nLFxuICAgICAgICBtaXNzaW5nV2FybixcbiAgICAgICAgZmFsbGJhY2tXYXJuLFxuICAgICAgICBmYWxsYmFja0Zvcm1hdCxcbiAgICAgICAgdW5yZXNvbHZpbmcsXG4gICAgICAgIHBvc3RUcmFuc2xhdGlvbixcbiAgICAgICAgcHJvY2Vzc29yLFxuICAgICAgICB3YXJuSHRtbE1lc3NhZ2UsXG4gICAgICAgIGVzY2FwZVBhcmFtZXRlcixcbiAgICAgICAgbWVzc2FnZUNvbXBpbGVyLFxuICAgICAgICBtZXNzYWdlUmVzb2x2ZXIsXG4gICAgICAgIGxvY2FsZUZhbGxiYWNrZXIsXG4gICAgICAgIGZhbGxiYWNrQ29udGV4dCxcbiAgICAgICAgb25XYXJuLFxuICAgICAgICBfX21ldGFcbiAgICB9O1xuICAgIHtcbiAgICAgICAgY29udGV4dC5kYXRldGltZUZvcm1hdHMgPSBkYXRldGltZUZvcm1hdHM7XG4gICAgICAgIGNvbnRleHQubnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHM7XG4gICAgICAgIGNvbnRleHQuX19kYXRldGltZUZvcm1hdHRlcnMgPSBfX2RhdGV0aW1lRm9ybWF0dGVycztcbiAgICAgICAgY29udGV4dC5fX251bWJlckZvcm1hdHRlcnMgPSBfX251bWJlckZvcm1hdHRlcnM7XG4gICAgfVxuICAgIC8vIGZvciB2dWUtZGV2dG9vbHMgdGltZWxpbmUgZXZlbnRcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnRleHQuX192X2VtaXR0ZXIgPVxuICAgICAgICAgICAgaW50ZXJuYWxPcHRpb25zLl9fdl9lbWl0dGVyICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IGludGVybmFsT3B0aW9ucy5fX3ZfZW1pdHRlclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBOT1RFOiBleHBlcmltZW50YWwgISFcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fSU5UTElGWV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgaW5pdEkxOG5EZXZUb29scyhjb250ZXh0LCB2ZXJzaW9uLCBfX21ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGlzVHJhbnNsYXRlRmFsbGJhY2tXYXJuKGZhbGxiYWNrLCBrZXkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sgaW5zdGFuY2VvZiBSZWdFeHAgPyBmYWxsYmFjay50ZXN0KGtleSkgOiBmYWxsYmFjaztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGlzVHJhbnNsYXRlTWlzc2luZ1dhcm4obWlzc2luZywga2V5KSB7XG4gICAgcmV0dXJuIG1pc3NpbmcgaW5zdGFuY2VvZiBSZWdFeHAgPyBtaXNzaW5nLnRlc3Qoa2V5KSA6IG1pc3Npbmc7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBoYW5kbGVNaXNzaW5nKGNvbnRleHQsIGtleSwgbG9jYWxlLCBtaXNzaW5nV2FybiwgdHlwZSkge1xuICAgIGNvbnN0IHsgbWlzc2luZywgb25XYXJuIH0gPSBjb250ZXh0O1xuICAgIC8vIGZvciB2dWUtZGV2dG9vbHMgdGltZWxpbmUgZXZlbnRcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjb250ZXh0Ll9fdl9lbWl0dGVyO1xuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwibWlzc2luZ1wiIC8qIFZ1ZURldlRvb2xzVGltZWxpbmVFdmVudHMuTUlTU0lORyAqLywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBncm91cElkOiBgJHt0eXBlfToke2tleX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXQgPSBtaXNzaW5nKGNvbnRleHQsIGxvY2FsZSwga2V5LCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHJldCkgPyByZXQgOiBrZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzVHJhbnNsYXRlTWlzc2luZ1dhcm4obWlzc2luZ1dhcm4sIGtleSkpIHtcbiAgICAgICAgICAgIG9uV2FybihnZXRXYXJuTWVzc2FnZShDb3JlV2FybkNvZGVzLk5PVF9GT1VORF9LRVksIHsga2V5LCBsb2NhbGUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gdXBkYXRlRmFsbGJhY2tMb2NhbGUoY3R4LCBsb2NhbGUsIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGN0eDtcbiAgICBjb250ZXh0Ll9fbG9jYWxlQ2hhaW5DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBjdHgubG9jYWxlRmFsbGJhY2tlcihjdHgsIGZhbGxiYWNrLCBsb2NhbGUpO1xufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmZ1bmN0aW9uIGZvcm1hdChhc3QpIHtcbiAgICBjb25zdCBtc2cgPSAoY3R4KSA9PiBmb3JtYXRQYXJ0cyhjdHgsIGFzdCk7XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIGZvcm1hdFBhcnRzKGN0eCwgYXN0KSB7XG4gICAgY29uc3QgYm9keSA9IGFzdC5iIHx8IGFzdC5ib2R5O1xuICAgIGlmICgoYm9keS50IHx8IGJvZHkudHlwZSkgPT09IDEgLyogTm9kZVR5cGVzLlBsdXJhbCAqLykge1xuICAgICAgICBjb25zdCBwbHVyYWwgPSBib2R5O1xuICAgICAgICBjb25zdCBjYXNlcyA9IHBsdXJhbC5jIHx8IHBsdXJhbC5jYXNlcztcbiAgICAgICAgcmV0dXJuIGN0eC5wbHVyYWwoY2FzZXMucmVkdWNlKChtZXNzYWdlcywgYykgPT4gW1xuICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICBmb3JtYXRNZXNzYWdlUGFydHMoY3R4LCBjKVxuICAgICAgICBdLCBbXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2VQYXJ0cyhjdHgsIGJvZHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2VQYXJ0cyhjdHgsIG5vZGUpIHtcbiAgICBjb25zdCBfc3RhdGljID0gbm9kZS5zIHx8IG5vZGUuc3RhdGljO1xuICAgIGlmIChfc3RhdGljKSB7XG4gICAgICAgIHJldHVybiBjdHgudHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgICA/IF9zdGF0aWNcbiAgICAgICAgICAgIDogY3R4Lm5vcm1hbGl6ZShbX3N0YXRpY10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSAobm9kZS5pIHx8IG5vZGUuaXRlbXMpLnJlZHVjZSgoYWNtLCBjKSA9PiBbLi4uYWNtLCBmb3JtYXRNZXNzYWdlUGFydChjdHgsIGMpXSwgW10pO1xuICAgICAgICByZXR1cm4gY3R4Lm5vcm1hbGl6ZShtZXNzYWdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZVBhcnQoY3R4LCBub2RlKSB7XG4gICAgY29uc3QgdHlwZSA9IG5vZGUudCB8fCBub2RlLnR5cGU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuVGV4dCAqLzpcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuICh0ZXh0LnYgfHwgdGV4dC52YWx1ZSk7XG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIChsaXRlcmFsLnYgfHwgbGl0ZXJhbC52YWx1ZSk7XG4gICAgICAgIGNhc2UgNCAvKiBOb2RlVHlwZXMuTmFtZWQgKi86XG4gICAgICAgICAgICBjb25zdCBuYW1lZCA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmludGVycG9sYXRlKGN0eC5uYW1lZChuYW1lZC5rIHx8IG5hbWVkLmtleSkpO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLkxpc3QgKi86XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBjdHguaW50ZXJwb2xhdGUoY3R4Lmxpc3QobGlzdC5pIHx8IGxpc3QuaW5kZXgpKTtcbiAgICAgICAgY2FzZSA2IC8qIE5vZGVUeXBlcy5MaW5rZWQgKi86XG4gICAgICAgICAgICBjb25zdCBsaW5rZWQgPSBub2RlO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBsaW5rZWQubSB8fCBsaW5rZWQubW9kaWZpZXI7XG4gICAgICAgICAgICByZXR1cm4gY3R4LmxpbmtlZChmb3JtYXRNZXNzYWdlUGFydChjdHgsIGxpbmtlZC5rIHx8IGxpbmtlZC5rZXkpLCBtb2RpZmllciA/IGZvcm1hdE1lc3NhZ2VQYXJ0KGN0eCwgbW9kaWZpZXIpIDogdW5kZWZpbmVkLCBjdHgudHlwZSk7XG4gICAgICAgIGNhc2UgNyAvKiBOb2RlVHlwZXMuTGlua2VkS2V5ICovOlxuICAgICAgICAgICAgY29uc3QgbGlua2VkS2V5ID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiAobGlua2VkS2V5LnYgfHwgbGlua2VkS2V5LnZhbHVlKTtcbiAgICAgICAgY2FzZSA4IC8qIE5vZGVUeXBlcy5MaW5rZWRNb2RpZmllciAqLzpcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlZE1vZGlmaWVyID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiAobGlua2VkTW9kaWZpZXIudiB8fCBsaW5rZWRNb2RpZmllci52YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBub2RlIHR5cGUgb24gZm9ybWF0IG1lc3NhZ2UgcGFydDogJHt0eXBlfWApO1xuICAgIH1cbn1cblxubGV0IGNvZGUgPSBDb21waWxlRXJyb3JDb2Rlcy5fX0VYVEVORF9QT0lOVF9fO1xuY29uc3QgaW5jID0gKCkgPT4gKytjb2RlO1xuY29uc3QgQ29yZUVycm9yQ29kZXMgPSB7XG4gICAgSU5WQUxJRF9BUkdVTUVOVDogY29kZSxcbiAgICBJTlZBTElEX0RBVEVfQVJHVU1FTlQ6IGluYygpLFxuICAgIElOVkFMSURfSVNPX0RBVEVfQVJHVU1FTlQ6IGluYygpLFxuICAgIE5PVF9TVVBQT1JUX0FTVDogaW5jKCksXG4gICAgX19FWFRFTkRfUE9JTlRfXzogaW5jKCkgLy8gMTlcbn07XG5mdW5jdGlvbiBjcmVhdGVDb3JlRXJyb3IoY29kZSkge1xuICAgIHJldHVybiBjcmVhdGVDb21waWxlRXJyb3IoY29kZSwgbnVsbCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8geyBtZXNzYWdlczogZXJyb3JNZXNzYWdlcyB9IDogdW5kZWZpbmVkKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XG4gICAgW0NvcmVFcnJvckNvZGVzLklOVkFMSURfQVJHVU1FTlRdOiAnSW52YWxpZCBhcmd1bWVudHMnLFxuICAgIFtDb3JlRXJyb3JDb2Rlcy5JTlZBTElEX0RBVEVfQVJHVU1FTlRdOiAnVGhlIGRhdGUgcHJvdmlkZWQgaXMgYW4gaW52YWxpZCBEYXRlIG9iamVjdC4nICtcbiAgICAgICAgJ01ha2Ugc3VyZSB5b3VyIERhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGRhdGUuJyxcbiAgICBbQ29yZUVycm9yQ29kZXMuSU5WQUxJRF9JU09fREFURV9BUkdVTUVOVF06ICdUaGUgYXJndW1lbnQgcHJvdmlkZWQgaXMgbm90IGEgdmFsaWQgSVNPIGRhdGUgc3RyaW5nJyxcbiAgICBbQ29yZUVycm9yQ29kZXMuTk9UX1NVUFBPUlRfQVNUXTogJ05vdCBzdXBwb3J0IEFTVCdcbn07XG5cbmNvbnN0IFdBUk5fTUVTU0FHRSA9IGBEZXRlY3RlZCBIVE1MIGluICd7c291cmNlfScgbWVzc2FnZS4gUmVjb21tZW5kIG5vdCB1c2luZyBIVE1MIG1lc3NhZ2VzIHRvIGF2b2lkIFhTUy5gO1xuZnVuY3Rpb24gY2hlY2tIdG1sTWVzc2FnZShzb3VyY2UsIHdhcm5IdG1sTWVzc2FnZSkge1xuICAgIGlmICh3YXJuSHRtbE1lc3NhZ2UgJiYgZGV0ZWN0SHRtbFRhZyhzb3VyY2UpKSB7XG4gICAgICAgIHdhcm4oZm9ybWF0JDEoV0FSTl9NRVNTQUdFLCB7IHNvdXJjZSB9KSk7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdE9uQ2FjaGVLZXkgPSAobWVzc2FnZSkgPT4gbWVzc2FnZTtcbmxldCBjb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gY2xlYXJDb21waWxlQ2FjaGUoKSB7XG4gICAgY29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIGJhc2VDb21waWxlKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGVycm9yIGRldGVjdGluZyBvbiBjb21waWxlXG4gICAgbGV0IGRldGVjdEVycm9yID0gZmFsc2U7XG4gICAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgICBvcHRpb25zLm9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGRldGVjdEVycm9yID0gdHJ1ZTtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgIH07XG4gICAgLy8gY29tcGlsZSB3aXRoIG1lc2FzZ2UtY29tcGlsZXJcbiAgICByZXR1cm4geyAuLi5iYXNlQ29tcGlsZSQxKG1lc3NhZ2UsIG9wdGlvbnMpLCBkZXRlY3RFcnJvciB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc1N0cmluZyhtZXNzYWdlKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVDb3JlRXJyb3IoQ29yZUVycm9yQ29kZXMuTk9UX1NVUFBPUlRfQVNUKTtcbiAgICB9XG4gICAge1xuICAgICAgICAvLyBjaGVjayBIVE1MIG1lc3NhZ2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgd2Fybkh0bWxNZXNzYWdlID0gaXNCb29sZWFuKG9wdGlvbnMud2Fybkh0bWxNZXNzYWdlKVxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9wdGlvbnMud2Fybkh0bWxNZXNzYWdlXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0h0bWxNZXNzYWdlKG1lc3NhZ2UsIHdhcm5IdG1sTWVzc2FnZSk7XG4gICAgICAgIC8vIGNoZWNrIGNhY2hlc1xuICAgICAgICBjb25zdCBvbkNhY2hlS2V5ID0gb3B0aW9ucy5vbkNhY2hlS2V5IHx8IGRlZmF1bHRPbkNhY2hlS2V5O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IG9uQ2FjaGVLZXkobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGlsZVxuICAgICAgICBjb25zdCB7IGNvZGUsIGRldGVjdEVycm9yIH0gPSBiYXNlQ29tcGlsZShtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgLy8gZXZhbHVhdGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgbXNnID0gbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHtjb2RlfWApKCk7XG4gICAgICAgIC8vIGlmIG9jY3VycmVkIGNvbXBpbGUgZXJyb3IsIGRvbid0IGNhY2hlXG4gICAgICAgIHJldHVybiAhZGV0ZWN0RXJyb3JcbiAgICAgICAgICAgID8gKGNvbXBpbGVDYWNoZVtjYWNoZUtleV0gPSBtc2cpXG4gICAgICAgICAgICA6IG1zZztcbiAgICB9XG59XG5mdW5jdGlvbiBjb21waWxlKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChpc1N0cmluZyhtZXNzYWdlKSkge1xuICAgICAgICAvLyBjaGVjayBIVE1MIG1lc3NhZ2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgd2Fybkh0bWxNZXNzYWdlID0gaXNCb29sZWFuKG9wdGlvbnMud2Fybkh0bWxNZXNzYWdlKVxuICAgICAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9wdGlvbnMud2Fybkh0bWxNZXNzYWdlXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0h0bWxNZXNzYWdlKG1lc3NhZ2UsIHdhcm5IdG1sTWVzc2FnZSk7XG4gICAgICAgIC8vIGNoZWNrIGNhY2hlc1xuICAgICAgICBjb25zdCBvbkNhY2hlS2V5ID0gb3B0aW9ucy5vbkNhY2hlS2V5IHx8IGRlZmF1bHRPbkNhY2hlS2V5O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IG9uQ2FjaGVLZXkobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtjYWNoZUtleV07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGlsZSB3aXRoIEpJVCBtb2RlXG4gICAgICAgIGNvbnN0IHsgYXN0LCBkZXRlY3RFcnJvciB9ID0gYmFzZUNvbXBpbGUobWVzc2FnZSwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyksXG4gICAgICAgICAgICBqaXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbXBvc2UgbWVzc2FnZSBmdW5jdGlvbiBmcm9tIEFTVFxuICAgICAgICBjb25zdCBtc2cgPSBmb3JtYXQoYXN0KTtcbiAgICAgICAgLy8gaWYgb2NjdXJyZWQgY29tcGlsZSBlcnJvciwgZG9uJ3QgY2FjaGVcbiAgICAgICAgcmV0dXJuICFkZXRlY3RFcnJvclxuICAgICAgICAgICAgPyAoY29tcGlsZUNhY2hlW2NhY2hlS2V5XSA9IG1zZylcbiAgICAgICAgICAgIDogbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQVNUIGNhc2UgKHBhc3NlZCBmcm9tIGJ1bmRsZXIpXG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gbWVzc2FnZS5jYWNoZUtleTtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjb21waWxlQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wb3NlIG1lc3NhZ2UgZnVuY3Rpb24gZnJvbSBtZXNzYWdlIChBU1QpXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBpbGVDYWNoZVtjYWNoZUtleV0gPVxuICAgICAgICAgICAgICAgIGZvcm1hdChtZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBOT09QX01FU1NBR0VfRlVOQ1RJT04gPSAoKSA9PiAnJztcbmNvbnN0IGlzTWVzc2FnZUZ1bmN0aW9uID0gKHZhbCkgPT4gaXNGdW5jdGlvbih2YWwpO1xuY29uc3QgaXNNZXNzYWdlQVNUID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiB2YWwudHlwZSA9PT0gMCAmJiAnYm9keScgaW4gdmFsO1xuLy8gaW1wbGVtZW50YXRpb24gb2YgYHRyYW5zbGF0ZWAgZnVuY3Rpb25cbmZ1bmN0aW9uIHRyYW5zbGF0ZShjb250ZXh0LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBmYWxsYmFja0Zvcm1hdCwgcG9zdFRyYW5zbGF0aW9uLCB1bnJlc29sdmluZywgbWVzc2FnZUNvbXBpbGVyLCBmYWxsYmFja0xvY2FsZSwgbWVzc2FnZXMgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgW2tleSwgb3B0aW9uc10gPSBwYXJzZVRyYW5zbGF0ZUFyZ3MoLi4uYXJncyk7XG4gICAgY29uc3QgbWlzc2luZ1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5taXNzaW5nV2FybilcbiAgICAgICAgPyBvcHRpb25zLm1pc3NpbmdXYXJuXG4gICAgICAgIDogY29udGV4dC5taXNzaW5nV2FybjtcbiAgICBjb25zdCBmYWxsYmFja1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1dhcm4pXG4gICAgICAgID8gb3B0aW9ucy5mYWxsYmFja1dhcm5cbiAgICAgICAgOiBjb250ZXh0LmZhbGxiYWNrV2FybjtcbiAgICBjb25zdCBlc2NhcGVQYXJhbWV0ZXIgPSBpc0Jvb2xlYW4ob3B0aW9ucy5lc2NhcGVQYXJhbWV0ZXIpXG4gICAgICAgID8gb3B0aW9ucy5lc2NhcGVQYXJhbWV0ZXJcbiAgICAgICAgOiBjb250ZXh0LmVzY2FwZVBhcmFtZXRlcjtcbiAgICBjb25zdCByZXNvbHZlZE1lc3NhZ2UgPSAhIW9wdGlvbnMucmVzb2x2ZWRNZXNzYWdlO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IGRlZmF1bHRNc2dPcktleSA9IGlzU3RyaW5nKG9wdGlvbnMuZGVmYXVsdCkgfHwgaXNCb29sZWFuKG9wdGlvbnMuZGVmYXVsdCkgLy8gZGVmYXVsdCBieSBmdW5jdGlvbiBvcHRpb25cbiAgICAgICAgPyAhaXNCb29sZWFuKG9wdGlvbnMuZGVmYXVsdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5kZWZhdWx0XG4gICAgICAgICAgICA6ICghbWVzc2FnZUNvbXBpbGVyID8gKCkgPT4ga2V5IDoga2V5KVxuICAgICAgICA6IGZhbGxiYWNrRm9ybWF0IC8vIGRlZmF1bHQgYnkgYGZhbGxiYWNrRm9ybWF0YCBvcHRpb25cbiAgICAgICAgICAgID8gKCFtZXNzYWdlQ29tcGlsZXIgPyAoKSA9PiBrZXkgOiBrZXkpXG4gICAgICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGVuYWJsZURlZmF1bHRNc2cgPSBmYWxsYmFja0Zvcm1hdCB8fCBkZWZhdWx0TXNnT3JLZXkgIT09ICcnO1xuICAgIGNvbnN0IGxvY2FsZSA9IGlzU3RyaW5nKG9wdGlvbnMubG9jYWxlKSA/IG9wdGlvbnMubG9jYWxlIDogY29udGV4dC5sb2NhbGU7XG4gICAgLy8gZXNjYXBlIHBhcmFtc1xuICAgIGVzY2FwZVBhcmFtZXRlciAmJiBlc2NhcGVQYXJhbXMob3B0aW9ucyk7XG4gICAgLy8gcmVzb2x2ZSBtZXNzYWdlIGZvcm1hdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgW2Zvcm1hdFNjb3BlLCB0YXJnZXRMb2NhbGUsIG1lc3NhZ2VdID0gIXJlc29sdmVkTWVzc2FnZVxuICAgICAgICA/IHJlc29sdmVNZXNzYWdlRm9ybWF0KGNvbnRleHQsIGtleSwgbG9jYWxlLCBmYWxsYmFja0xvY2FsZSwgZmFsbGJhY2tXYXJuLCBtaXNzaW5nV2FybilcbiAgICAgICAgOiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBtZXNzYWdlc1tsb2NhbGVdIHx8IHt9XG4gICAgICAgIF07XG4gICAgLy8gTk9URTpcbiAgICAvLyAgRml4IHRvIHdvcmsgYXJvdW5kIGBzc3JUcmFuc2Zyb21gIGJ1ZyBpbiBWaXRlLlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzQzMDZcbiAgICAvLyAgVG8gZ2V0IGFyb3VuZCB0aGlzLCB1c2UgdGVtcG9yYXJ5IHZhcmlhYmxlcy5cbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL251eHQvZnJhbWV3b3JrL2lzc3Vlcy8xNDYxI2lzc3VlY29tbWVudC05NTQ2MDYyNDNcbiAgICBsZXQgZm9ybWF0ID0gZm9ybWF0U2NvcGU7XG4gICAgLy8gaWYgeW91IHVzZSBkZWZhdWx0IG1lc3NhZ2UsIHNldCBpdCBhcyBtZXNzYWdlIGZvcm1hdCFcbiAgICBsZXQgY2FjaGVCYXNlS2V5ID0ga2V5O1xuICAgIGlmICghcmVzb2x2ZWRNZXNzYWdlICYmXG4gICAgICAgICEoaXNTdHJpbmcoZm9ybWF0KSB8fFxuICAgICAgICAgICAgaXNNZXNzYWdlQVNUKGZvcm1hdCkgfHxcbiAgICAgICAgICAgIGlzTWVzc2FnZUZ1bmN0aW9uKGZvcm1hdCkpKSB7XG4gICAgICAgIGlmIChlbmFibGVEZWZhdWx0TXNnKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBkZWZhdWx0TXNnT3JLZXk7XG4gICAgICAgICAgICBjYWNoZUJhc2VLZXkgPSBmb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2tpbmcgbWVzc2FnZSBmb3JtYXQgYW5kIHRhcmdldCBsb2NhbGVcbiAgICBpZiAoIXJlc29sdmVkTWVzc2FnZSAmJlxuICAgICAgICAoIShpc1N0cmluZyhmb3JtYXQpIHx8XG4gICAgICAgICAgICBpc01lc3NhZ2VBU1QoZm9ybWF0KSB8fFxuICAgICAgICAgICAgaXNNZXNzYWdlRnVuY3Rpb24oZm9ybWF0KSkgfHxcbiAgICAgICAgICAgICFpc1N0cmluZyh0YXJnZXRMb2NhbGUpKSkge1xuICAgICAgICByZXR1cm4gdW5yZXNvbHZpbmcgPyBOT1RfUkVPU0xWRUQgOiBrZXk7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlZmFjdG9yXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1N0cmluZyhmb3JtYXQpICYmIGNvbnRleHQubWVzc2FnZUNvbXBpbGVyID09IG51bGwpIHtcbiAgICAgICAgd2FybihgVGhlIG1lc3NhZ2UgZm9ybWF0IGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZC4gYCArXG4gICAgICAgICAgICBgQmVjYXVzZSBtZXNzYWdlIGNvbXBpbGVyIGlzbid0IGluY2x1ZGVkLiBgICtcbiAgICAgICAgICAgIGBZb3UgbmVlZCB0byBwcmUtY29tcGlsYXRpb24gYWxsIG1lc3NhZ2UgZm9ybWF0LiBgICtcbiAgICAgICAgICAgIGBTbyB0cmFuc2xhdGUgZnVuY3Rpb24gcmV0dXJuICcke2tleX0nLmApO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICAvLyBzZXR1cCBjb21waWxlIGVycm9yIGRldGVjdGluZ1xuICAgIGxldCBvY2N1cnJlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGVycm9yRGV0ZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgIG9jY3VycmVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIGNvbXBpbGUgbWVzc2FnZSBmb3JtYXRcbiAgICBjb25zdCBtc2cgPSAhaXNNZXNzYWdlRnVuY3Rpb24oZm9ybWF0KVxuICAgICAgICA/IGNvbXBpbGVNZXNzYWdlRm9ybWF0KGNvbnRleHQsIGtleSwgdGFyZ2V0TG9jYWxlLCBmb3JtYXQsIGNhY2hlQmFzZUtleSwgZXJyb3JEZXRlY3RvcilcbiAgICAgICAgOiBmb3JtYXQ7XG4gICAgLy8gaWYgb2NjdXJyZWQgY29tcGlsZSBlcnJvciwgcmV0dXJuIHRoZSBtZXNzYWdlIGZvcm1hdFxuICAgIGlmIChvY2N1cnJlZCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgICAvLyBldmFsdWF0ZSBtZXNzYWdlIHdpdGggY29udGV4dFxuICAgIGNvbnN0IGN0eE9wdGlvbnMgPSBnZXRNZXNzYWdlQ29udGV4dE9wdGlvbnMoY29udGV4dCwgdGFyZ2V0TG9jYWxlLCBtZXNzYWdlLCBvcHRpb25zKTtcbiAgICBjb25zdCBtc2dDb250ZXh0ID0gY3JlYXRlTWVzc2FnZUNvbnRleHQoY3R4T3B0aW9ucyk7XG4gICAgY29uc3QgbWVzc2FnZWQgPSBldmFsdWF0ZU1lc3NhZ2UoY29udGV4dCwgbXNnLCBtc2dDb250ZXh0KTtcbiAgICAvLyBpZiB1c2UgcG9zdCB0cmFuc2xhdGlvbiBvcHRpb24sIHByb2NlZWQgaXQgd2l0aCBoYW5kbGVyXG4gICAgY29uc3QgcmV0ID0gcG9zdFRyYW5zbGF0aW9uXG4gICAgICAgID8gcG9zdFRyYW5zbGF0aW9uKG1lc3NhZ2VkLCBrZXkpXG4gICAgICAgIDogbWVzc2FnZWQ7XG4gICAgLy8gTk9URTogZXhwZXJpbWVudGFsICEhXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX0lOVExJRllfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGtleTogaXNTdHJpbmcoa2V5KVxuICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgOiBpc01lc3NhZ2VGdW5jdGlvbihmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0LmtleVxuICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgbG9jYWxlOiB0YXJnZXRMb2NhbGUgfHwgKGlzTWVzc2FnZUZ1bmN0aW9uKGZvcm1hdClcbiAgICAgICAgICAgICAgICA/IGZvcm1hdC5sb2NhbGVcbiAgICAgICAgICAgICAgICA6ICcnKSxcbiAgICAgICAgICAgIGZvcm1hdDogaXNTdHJpbmcoZm9ybWF0KVxuICAgICAgICAgICAgICAgID8gZm9ybWF0XG4gICAgICAgICAgICAgICAgOiBpc01lc3NhZ2VGdW5jdGlvbihmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0LnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgbWVzc2FnZTogcmV0XG4gICAgICAgIH07XG4gICAgICAgIHBheWxvYWRzLm1ldGEgPSBhc3NpZ24oe30sIGNvbnRleHQuX19tZXRhLCBnZXRBZGRpdGlvbmFsTWV0YSgpIHx8IHt9KTtcbiAgICAgICAgdHJhbnNsYXRlRGV2VG9vbHMocGF5bG9hZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZXNjYXBlUGFyYW1zKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBcnJheShvcHRpb25zLmxpc3QpKSB7XG4gICAgICAgIG9wdGlvbnMubGlzdCA9IG9wdGlvbnMubGlzdC5tYXAoaXRlbSA9PiBpc1N0cmluZyhpdGVtKSA/IGVzY2FwZUh0bWwoaXRlbSkgOiBpdGVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucy5uYW1lZCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5uYW1lZCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubmFtZWRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm5hbWVkW2tleV0gPSBlc2NhcGVIdG1sKG9wdGlvbnMubmFtZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVNZXNzYWdlRm9ybWF0KGNvbnRleHQsIGtleSwgbG9jYWxlLCBmYWxsYmFja0xvY2FsZSwgZmFsbGJhY2tXYXJuLCBtaXNzaW5nV2Fybikge1xuICAgIGNvbnN0IHsgbWVzc2FnZXMsIG9uV2FybiwgbWVzc2FnZVJlc29sdmVyOiByZXNvbHZlVmFsdWUsIGxvY2FsZUZhbGxiYWNrZXIgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbG9jYWxlcyA9IGxvY2FsZUZhbGxiYWNrZXIoY29udGV4dCwgZmFsbGJhY2tMb2NhbGUsIGxvY2FsZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCBtZXNzYWdlID0ge307XG4gICAgbGV0IHRhcmdldExvY2FsZTtcbiAgICBsZXQgZm9ybWF0ID0gbnVsbDtcbiAgICBsZXQgZnJvbSA9IGxvY2FsZTtcbiAgICBsZXQgdG8gPSBudWxsO1xuICAgIGNvbnN0IHR5cGUgPSAndHJhbnNsYXRlJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0TG9jYWxlID0gdG8gPSBsb2NhbGVzW2ldO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBsb2NhbGUgIT09IHRhcmdldExvY2FsZSAmJlxuICAgICAgICAgICAgaXNUcmFuc2xhdGVGYWxsYmFja1dhcm4oZmFsbGJhY2tXYXJuLCBrZXkpKSB7XG4gICAgICAgICAgICBvbldhcm4oZ2V0V2Fybk1lc3NhZ2UoQ29yZVdhcm5Db2Rlcy5GQUxMQkFDS19UT19UUkFOU0xBVEUsIHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRMb2NhbGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IgdnVlLWRldnRvb2xzIHRpbWVsaW5lIGV2ZW50XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbG9jYWxlICE9PSB0YXJnZXRMb2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjb250ZXh0Ll9fdl9lbWl0dGVyO1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJmYWxsYmFja1wiIC8qIFZ1ZURldlRvb2xzVGltZWxpbmVFdmVudHMuRkFMQkFDSyAqLywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBgJHt0eXBlfToke2tleX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICBtZXNzYWdlc1t0YXJnZXRMb2NhbGVdIHx8IHt9O1xuICAgICAgICAvLyBmb3IgdnVlLWRldnRvb2xzIHRpbWVsaW5lIGV2ZW50XG4gICAgICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgICAgIGxldCBzdGFydFRhZztcbiAgICAgICAgbGV0IGVuZFRhZztcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbkJyb3dzZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgc3RhcnRUYWcgPSAnaW50bGlmeS1tZXNzYWdlLXJlc29sdmUtc3RhcnQnO1xuICAgICAgICAgICAgZW5kVGFnID0gJ2ludGxpZnktbWVzc2FnZS1yZXNvbHZlLWVuZCc7XG4gICAgICAgICAgICBtYXJrICYmIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZm9ybWF0ID0gcmVzb2x2ZVZhbHVlKG1lc3NhZ2UsIGtleSkpID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpZiBudWxsLCByZXNvbHZlIHdpdGggb2JqZWN0IGtleSBwYXRoXG4gICAgICAgICAgICBmb3JtYXQgPSBtZXNzYWdlW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvciB2dWUtZGV2dG9vbHMgdGltZWxpbmUgZXZlbnRcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbkJyb3dzZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjb250ZXh0Ll9fdl9lbWl0dGVyO1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIgJiYgc3RhcnQgJiYgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwibWVzc2FnZS1yZXNvbHZlXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5NRVNTQUdFX1JFU09MVkUgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLXJlc29sdmVcIiAvKiBWdWVEZXZUb29sc1RpbWVsaW5lRXZlbnRzLk1FU1NBR0VfUkVTT0xWRSAqLyxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBmb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBgJHt0eXBlfToke2tleX1gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRUYWcgJiYgZW5kVGFnICYmIG1hcmsgJiYgbWVhc3VyZSkge1xuICAgICAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBtZWFzdXJlKCdpbnRsaWZ5IG1lc3NhZ2UgcmVzb2x2ZScsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmluZyhmb3JtYXQpIHx8IGlzTWVzc2FnZUFTVChmb3JtYXQpIHx8IGlzTWVzc2FnZUZ1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdSZXQgPSBoYW5kbGVNaXNzaW5nKGNvbnRleHQsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBrZXksIHRhcmdldExvY2FsZSwgbWlzc2luZ1dhcm4sIHR5cGUpO1xuICAgICAgICBpZiAobWlzc2luZ1JldCAhPT0ga2V5KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBtaXNzaW5nUmV0O1xuICAgICAgICB9XG4gICAgICAgIGZyb20gPSB0bztcbiAgICB9XG4gICAgcmV0dXJuIFtmb3JtYXQsIHRhcmdldExvY2FsZSwgbWVzc2FnZV07XG59XG5mdW5jdGlvbiBjb21waWxlTWVzc2FnZUZvcm1hdChjb250ZXh0LCBrZXksIHRhcmdldExvY2FsZSwgZm9ybWF0LCBjYWNoZUJhc2VLZXksIGVycm9yRGV0ZWN0b3IpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2VDb21waWxlciwgd2Fybkh0bWxNZXNzYWdlIH0gPSBjb250ZXh0O1xuICAgIGlmIChpc01lc3NhZ2VGdW5jdGlvbihmb3JtYXQpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGZvcm1hdDtcbiAgICAgICAgbXNnLmxvY2FsZSA9IG1zZy5sb2NhbGUgfHwgdGFyZ2V0TG9jYWxlO1xuICAgICAgICBtc2cua2V5ID0gbXNnLmtleSB8fCBrZXk7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlQ29tcGlsZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtc2cgPSAoKCkgPT4gZm9ybWF0KTtcbiAgICAgICAgbXNnLmxvY2FsZSA9IHRhcmdldExvY2FsZTtcbiAgICAgICAgbXNnLmtleSA9IGtleTtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgLy8gZm9yIHZ1ZS1kZXZ0b29scyB0aW1lbGluZSBldmVudFxuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0VGFnO1xuICAgIGxldCBlbmRUYWc7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbkJyb3dzZXIpIHtcbiAgICAgICAgc3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHN0YXJ0VGFnID0gJ2ludGxpZnktbWVzc2FnZS1jb21waWxhdGlvbi1zdGFydCc7XG4gICAgICAgIGVuZFRhZyA9ICdpbnRsaWZ5LW1lc3NhZ2UtY29tcGlsYXRpb24tZW5kJztcbiAgICAgICAgbWFyayAmJiBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0gbWVzc2FnZUNvbXBpbGVyKGZvcm1hdCwgZ2V0Q29tcGlsZU9wdGlvbnMoY29udGV4dCwgdGFyZ2V0TG9jYWxlLCBjYWNoZUJhc2VLZXksIGZvcm1hdCwgd2Fybkh0bWxNZXNzYWdlLCBlcnJvckRldGVjdG9yKSk7XG4gICAgLy8gZm9yIHZ1ZS1kZXZ0b29scyB0aW1lbGluZSBldmVudFxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5Ccm93c2VyKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNvbnRleHQuX192X2VtaXR0ZXI7XG4gICAgICAgIGlmIChlbWl0dGVyICYmIHN0YXJ0KSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoXCJtZXNzYWdlLWNvbXBpbGF0aW9uXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5NRVNTQUdFX0NPTVBJTEFUSU9OICovLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLWNvbXBpbGF0aW9uXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5NRVNTQUdFX0NPTVBJTEFUSU9OICovLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICB0aW1lOiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgICAgICBncm91cElkOiBgJHsndHJhbnNsYXRlJ306JHtrZXl9YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0VGFnICYmIGVuZFRhZyAmJiBtYXJrICYmIG1lYXN1cmUpIHtcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgIG1lYXN1cmUoJ2ludGxpZnkgbWVzc2FnZSBjb21waWxhdGlvbicsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1zZy5sb2NhbGUgPSB0YXJnZXRMb2NhbGU7XG4gICAgbXNnLmtleSA9IGtleTtcbiAgICBtc2cuc291cmNlID0gZm9ybWF0O1xuICAgIHJldHVybiBtc2c7XG59XG5mdW5jdGlvbiBldmFsdWF0ZU1lc3NhZ2UoY29udGV4dCwgbXNnLCBtc2dDdHgpIHtcbiAgICAvLyBmb3IgdnVlLWRldnRvb2xzIHRpbWVsaW5lIGV2ZW50XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgc3RhcnRUYWc7XG4gICAgbGV0IGVuZFRhZztcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluQnJvd3Nlcikge1xuICAgICAgICBzdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgc3RhcnRUYWcgPSAnaW50bGlmeS1tZXNzYWdlLWV2YWx1YXRpb24tc3RhcnQnO1xuICAgICAgICBlbmRUYWcgPSAnaW50bGlmeS1tZXNzYWdlLWV2YWx1YXRpb24tZW5kJztcbiAgICAgICAgbWFyayAmJiBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZWQgPSBtc2cobXNnQ3R4KTtcbiAgICAvLyBmb3IgdnVlLWRldnRvb2xzIHRpbWVsaW5lIGV2ZW50XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbkJyb3dzZXIpIHtcbiAgICAgICAgY29uc3QgZW5kID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBlbWl0dGVyID0gY29udGV4dC5fX3ZfZW1pdHRlcjtcbiAgICAgICAgaWYgKGVtaXR0ZXIgJiYgc3RhcnQpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcIm1lc3NhZ2UtZXZhbHVhdGlvblwiIC8qIFZ1ZURldlRvb2xzVGltZWxpbmVFdmVudHMuTUVTU0FHRV9FVkFMVUFUSU9OICovLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLWV2YWx1YXRpb25cIiAvKiBWdWVEZXZUb29sc1RpbWVsaW5lRXZlbnRzLk1FU1NBR0VfRVZBTFVBVElPTiAqLyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWVzc2FnZWQsXG4gICAgICAgICAgICAgICAgdGltZTogZW5kIC0gc3RhcnQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogYCR7J3RyYW5zbGF0ZSd9OiR7bXNnLmtleX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRUYWcgJiYgZW5kVGFnICYmIG1hcmsgJiYgbWVhc3VyZSkge1xuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICAgICAgbWVhc3VyZSgnaW50bGlmeSBtZXNzYWdlIGV2YWx1YXRpb24nLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZWQ7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zbGF0ZUFyZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IFthcmcxLCBhcmcyLCBhcmczXSA9IGFyZ3M7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGlmICghaXNTdHJpbmcoYXJnMSkgJiZcbiAgICAgICAgIWlzTnVtYmVyKGFyZzEpICYmXG4gICAgICAgICFpc01lc3NhZ2VGdW5jdGlvbihhcmcxKSAmJlxuICAgICAgICAhaXNNZXNzYWdlQVNUKGFyZzEpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNvcmVFcnJvcihDb3JlRXJyb3JDb2Rlcy5JTlZBTElEX0FSR1VNRU5UKTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3Qga2V5ID0gaXNOdW1iZXIoYXJnMSlcbiAgICAgICAgPyBTdHJpbmcoYXJnMSlcbiAgICAgICAgOiBpc01lc3NhZ2VGdW5jdGlvbihhcmcxKVxuICAgICAgICAgICAgPyBhcmcxXG4gICAgICAgICAgICA6IGFyZzE7XG4gICAgaWYgKGlzTnVtYmVyKGFyZzIpKSB7XG4gICAgICAgIG9wdGlvbnMucGx1cmFsID0gYXJnMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcoYXJnMikpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0ID0gYXJnMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhcmcyKSAmJiAhaXNFbXB0eU9iamVjdChhcmcyKSkge1xuICAgICAgICBvcHRpb25zLm5hbWVkID0gYXJnMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShhcmcyKSkge1xuICAgICAgICBvcHRpb25zLmxpc3QgPSBhcmcyO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoYXJnMykpIHtcbiAgICAgICAgb3B0aW9ucy5wbHVyYWwgPSBhcmczO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyhhcmczKSkge1xuICAgICAgICBvcHRpb25zLmRlZmF1bHQgPSBhcmczO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZzMpKSB7XG4gICAgICAgIGFzc2lnbihvcHRpb25zLCBhcmczKTtcbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIG9wdGlvbnNdO1xufVxuZnVuY3Rpb24gZ2V0Q29tcGlsZU9wdGlvbnMoY29udGV4dCwgbG9jYWxlLCBrZXksIHNvdXJjZSwgd2Fybkh0bWxNZXNzYWdlLCBlcnJvckRldGVjdG9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2Fybkh0bWxNZXNzYWdlLFxuICAgICAgICBvbkVycm9yOiAoZXJyKSA9PiB7XG4gICAgICAgICAgICBlcnJvckRldGVjdG9yICYmIGVycm9yRGV0ZWN0b3IoZXJyKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfc291cmNlID0gZ2V0U291cmNlRm9yQ29kZUZyYW1lKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBNZXNzYWdlIGNvbXBpbGF0aW9uIGVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvY2F0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIF9zb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUoX3NvdXJjZSwgZXJyLmxvY2F0aW9uLnN0YXJ0Lm9mZnNldCwgZXJyLmxvY2F0aW9uLmVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjb250ZXh0Ll9fdl9lbWl0dGVyO1xuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVyICYmIF9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiY29tcGlsZS1lcnJvclwiIC8qIFZ1ZURldlRvb2xzVGltZWxpbmVFdmVudHMuQ09NUElMRV9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogX3NvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlcnIubG9jYXRpb24gJiYgZXJyLmxvY2F0aW9uLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZXJyLmxvY2F0aW9uICYmIGVyci5sb2NhdGlvbi5lbmQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogYCR7J3RyYW5zbGF0ZSd9OiR7a2V5fWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29kZUZyYW1lID8gYCR7bWVzc2FnZX1cXG4ke2NvZGVGcmFtZX1gIDogbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2FjaGVLZXk6IChzb3VyY2UpID0+IGdlbmVyYXRlRm9ybWF0Q2FjaGVLZXkobG9jYWxlLCBrZXksIHNvdXJjZSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U291cmNlRm9yQ29kZUZyYW1lKHNvdXJjZSkge1xuICAgIGlmIChpc1N0cmluZyhzb3VyY2UpKSA7XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzb3VyY2UubG9jPy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubG9jLnNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VDb250ZXh0T3B0aW9ucyhjb250ZXh0LCBsb2NhbGUsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1vZGlmaWVycywgcGx1cmFsUnVsZXMsIG1lc3NhZ2VSZXNvbHZlcjogcmVzb2x2ZVZhbHVlLCBmYWxsYmFja0xvY2FsZSwgZmFsbGJhY2tXYXJuLCBtaXNzaW5nV2FybiwgZmFsbGJhY2tDb250ZXh0IH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHJlc29sdmVNZXNzYWdlID0gKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsID0gcmVzb2x2ZVZhbHVlKG1lc3NhZ2UsIGtleSk7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIHJvb3QgY29udGV4dFxuICAgICAgICBpZiAodmFsID09IG51bGwgJiYgZmFsbGJhY2tDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBbLCAsIG1lc3NhZ2VdID0gcmVzb2x2ZU1lc3NhZ2VGb3JtYXQoZmFsbGJhY2tDb250ZXh0LCBrZXksIGxvY2FsZSwgZmFsbGJhY2tMb2NhbGUsIGZhbGxiYWNrV2FybiwgbWlzc2luZ1dhcm4pO1xuICAgICAgICAgICAgdmFsID0gcmVzb2x2ZVZhbHVlKG1lc3NhZ2UsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbCkgfHwgaXNNZXNzYWdlQVNUKHZhbCkpIHtcbiAgICAgICAgICAgIGxldCBvY2N1cnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEZXRlY3RvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBvY2N1cnJlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbXNnID0gY29tcGlsZU1lc3NhZ2VGb3JtYXQoY29udGV4dCwga2V5LCBsb2NhbGUsIHZhbCwga2V5LCBlcnJvckRldGVjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiAhb2NjdXJyZWRcbiAgICAgICAgICAgICAgICA/IG1zZ1xuICAgICAgICAgICAgICAgIDogTk9PUF9NRVNTQUdFX0ZVTkNUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWVzc2FnZUZ1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUgaW1wbGVtZW50ZWQgd2FybmluZyBtZXNzYWdlXG4gICAgICAgICAgICByZXR1cm4gTk9PUF9NRVNTQUdFX0ZVTkNUSU9OO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjdHhPcHRpb25zID0ge1xuICAgICAgICBsb2NhbGUsXG4gICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgcGx1cmFsUnVsZXMsXG4gICAgICAgIG1lc3NhZ2VzOiByZXNvbHZlTWVzc2FnZVxuICAgIH07XG4gICAgaWYgKGNvbnRleHQucHJvY2Vzc29yKSB7XG4gICAgICAgIGN0eE9wdGlvbnMucHJvY2Vzc29yID0gY29udGV4dC5wcm9jZXNzb3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpc3QpIHtcbiAgICAgICAgY3R4T3B0aW9ucy5saXN0ID0gb3B0aW9ucy5saXN0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYW1lZCkge1xuICAgICAgICBjdHhPcHRpb25zLm5hbWVkID0gb3B0aW9ucy5uYW1lZDtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9wdGlvbnMucGx1cmFsKSkge1xuICAgICAgICBjdHhPcHRpb25zLnBsdXJhbEluZGV4ID0gb3B0aW9ucy5wbHVyYWw7XG4gICAgfVxuICAgIHJldHVybiBjdHhPcHRpb25zO1xufVxuXG5jb25zdCBpbnRsRGVmaW5lZCA9IHR5cGVvZiBJbnRsICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IEF2YWlsYWJpbGl0aWVzID0ge1xuICAgIGRhdGVUaW1lRm9ybWF0OiBpbnRsRGVmaW5lZCAmJiB0eXBlb2YgSW50bC5EYXRlVGltZUZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgbnVtYmVyRm9ybWF0OiBpbnRsRGVmaW5lZCAmJiB0eXBlb2YgSW50bC5OdW1iZXJGb3JtYXQgIT09ICd1bmRlZmluZWQnXG59O1xuXG4vLyBpbXBsZW1lbnRhdGlvbiBvZiBgZGF0ZXRpbWVgIGZ1bmN0aW9uXG5mdW5jdGlvbiBkYXRldGltZShjb250ZXh0LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBkYXRldGltZUZvcm1hdHMsIHVucmVzb2x2aW5nLCBmYWxsYmFja0xvY2FsZSwgb25XYXJuLCBsb2NhbGVGYWxsYmFja2VyIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgX19kYXRldGltZUZvcm1hdHRlcnMgfSA9IGNvbnRleHQ7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhQXZhaWxhYmlsaXRpZXMuZGF0ZVRpbWVGb3JtYXQpIHtcbiAgICAgICAgb25XYXJuKGdldFdhcm5NZXNzYWdlKENvcmVXYXJuQ29kZXMuQ0FOTk9UX0ZPUk1BVF9EQVRFKSk7XG4gICAgICAgIHJldHVybiBNSVNTSU5HX1JFU09MVkVfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IFtrZXksIHZhbHVlLCBvcHRpb25zLCBvdmVycmlkZXNdID0gcGFyc2VEYXRlVGltZUFyZ3MoLi4uYXJncyk7XG4gICAgY29uc3QgbWlzc2luZ1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5taXNzaW5nV2FybilcbiAgICAgICAgPyBvcHRpb25zLm1pc3NpbmdXYXJuXG4gICAgICAgIDogY29udGV4dC5taXNzaW5nV2FybjtcbiAgICBjb25zdCBmYWxsYmFja1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1dhcm4pXG4gICAgICAgID8gb3B0aW9ucy5mYWxsYmFja1dhcm5cbiAgICAgICAgOiBjb250ZXh0LmZhbGxiYWNrV2FybjtcbiAgICBjb25zdCBwYXJ0ID0gISFvcHRpb25zLnBhcnQ7XG4gICAgY29uc3QgbG9jYWxlID0gaXNTdHJpbmcob3B0aW9ucy5sb2NhbGUpID8gb3B0aW9ucy5sb2NhbGUgOiBjb250ZXh0LmxvY2FsZTtcbiAgICBjb25zdCBsb2NhbGVzID0gbG9jYWxlRmFsbGJhY2tlcihjb250ZXh0LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmYWxsYmFja0xvY2FsZSwgbG9jYWxlKTtcbiAgICBpZiAoIWlzU3RyaW5nKGtleSkgfHwga2V5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvdmVycmlkZXMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgZm9ybWF0XG4gICAgbGV0IGRhdGV0aW1lRm9ybWF0ID0ge307XG4gICAgbGV0IHRhcmdldExvY2FsZTtcbiAgICBsZXQgZm9ybWF0ID0gbnVsbDtcbiAgICBsZXQgZnJvbSA9IGxvY2FsZTtcbiAgICBsZXQgdG8gPSBudWxsO1xuICAgIGNvbnN0IHR5cGUgPSAnZGF0ZXRpbWUgZm9ybWF0JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0TG9jYWxlID0gdG8gPSBsb2NhbGVzW2ldO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBsb2NhbGUgIT09IHRhcmdldExvY2FsZSAmJlxuICAgICAgICAgICAgaXNUcmFuc2xhdGVGYWxsYmFja1dhcm4oZmFsbGJhY2tXYXJuLCBrZXkpKSB7XG4gICAgICAgICAgICBvbldhcm4oZ2V0V2Fybk1lc3NhZ2UoQ29yZVdhcm5Db2Rlcy5GQUxMQkFDS19UT19EQVRFX0ZPUk1BVCwge1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldExvY2FsZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciB2dWUtZGV2dG9vbHMgdGltZWxpbmUgZXZlbnRcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBsb2NhbGUgIT09IHRhcmdldExvY2FsZSkge1xuICAgICAgICAgICAgY29uc3QgZW1pdHRlciA9IGNvbnRleHQuX192X2VtaXR0ZXI7XG4gICAgICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImZhbGxiYWNrXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5GQUxCQUNLICovLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGAke3R5cGV9OiR7a2V5fWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRldGltZUZvcm1hdCA9XG4gICAgICAgICAgICBkYXRldGltZUZvcm1hdHNbdGFyZ2V0TG9jYWxlXSB8fCB7fTtcbiAgICAgICAgZm9ybWF0ID0gZGF0ZXRpbWVGb3JtYXRba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZm9ybWF0KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoYW5kbGVNaXNzaW5nKGNvbnRleHQsIGtleSwgdGFyZ2V0TG9jYWxlLCBtaXNzaW5nV2FybiwgdHlwZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBmcm9tID0gdG87XG4gICAgfVxuICAgIC8vIGNoZWNraW5nIGZvcm1hdCBhbmQgdGFyZ2V0IGxvY2FsZVxuICAgIGlmICghaXNQbGFpbk9iamVjdChmb3JtYXQpIHx8ICFpc1N0cmluZyh0YXJnZXRMb2NhbGUpKSB7XG4gICAgICAgIHJldHVybiB1bnJlc29sdmluZyA/IE5PVF9SRU9TTFZFRCA6IGtleTtcbiAgICB9XG4gICAgbGV0IGlkID0gYCR7dGFyZ2V0TG9jYWxlfV9fJHtrZXl9YDtcbiAgICBpZiAoIWlzRW1wdHlPYmplY3Qob3ZlcnJpZGVzKSkge1xuICAgICAgICBpZCA9IGAke2lkfV9fJHtKU09OLnN0cmluZ2lmeShvdmVycmlkZXMpfWA7XG4gICAgfVxuICAgIGxldCBmb3JtYXR0ZXIgPSBfX2RhdGV0aW1lRm9ybWF0dGVycy5nZXQoaWQpO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRhcmdldExvY2FsZSwgYXNzaWduKHt9LCBmb3JtYXQsIG92ZXJyaWRlcykpO1xuICAgICAgICBfX2RhdGV0aW1lRm9ybWF0dGVycy5zZXQoaWQsIGZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJldHVybiAhcGFydCA/IGZvcm1hdHRlci5mb3JtYXQodmFsdWUpIDogZm9ybWF0dGVyLmZvcm1hdFRvUGFydHModmFsdWUpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgREFURVRJTUVfRk9STUFUX09QVElPTlNfS0VZUyA9IFtcbiAgICAnbG9jYWxlTWF0Y2hlcicsXG4gICAgJ3dlZWtkYXknLFxuICAgICdlcmEnLFxuICAgICd5ZWFyJyxcbiAgICAnbW9udGgnLFxuICAgICdkYXknLFxuICAgICdob3VyJyxcbiAgICAnbWludXRlJyxcbiAgICAnc2Vjb25kJyxcbiAgICAndGltZVpvbmVOYW1lJyxcbiAgICAnZm9ybWF0TWF0Y2hlcicsXG4gICAgJ2hvdXIxMicsXG4gICAgJ3RpbWVab25lJyxcbiAgICAnZGF0ZVN0eWxlJyxcbiAgICAndGltZVN0eWxlJyxcbiAgICAnY2FsZW5kYXInLFxuICAgICdkYXlQZXJpb2QnLFxuICAgICdudW1iZXJpbmdTeXN0ZW0nLFxuICAgICdob3VyQ3ljbGUnLFxuICAgICdmcmFjdGlvbmFsU2Vjb25kRGlnaXRzJ1xuXTtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWVBcmdzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChpc1N0cmluZyhhcmcxKSkge1xuICAgICAgICAvLyBPbmx5IGFsbG93IElTTyBzdHJpbmdzIC0gb3RoZXIgZGF0ZSBmb3JtYXRzIGFyZSBvZnRlbiBzdXBwb3J0ZWQsXG4gICAgICAgIC8vIGJ1dCBtYXkgY2F1c2UgZGlmZmVyZW50IHJlc3VsdHMgaW4gZGlmZmVyZW50IGJyb3dzZXJzLlxuICAgICAgICBjb25zdCBtYXRjaGVzID0gYXJnMS5tYXRjaCgvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KShUfFxccyk/KC4qKS8pO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUNvcmVFcnJvcihDb3JlRXJyb3JDb2Rlcy5JTlZBTElEX0lTT19EQVRFX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGNhbiBub3QgcGFyc2UgdGhlIGlzbyBkYXRldGltZSBzZXBhcmF0ZWQgYnkgc3BhY2UsXG4gICAgICAgIC8vIHRoaXMgaXMgYSBjb21wcm9taXNlIHNvbHV0aW9uIGJ5IHJlcGxhY2UgdGhlICdUJy8nICcgd2l0aCAnVCdcbiAgICAgICAgY29uc3QgZGF0ZVRpbWUgPSBtYXRjaGVzWzNdXG4gICAgICAgICAgICA/IG1hdGNoZXNbM10udHJpbSgpLnN0YXJ0c1dpdGgoJ1QnKVxuICAgICAgICAgICAgICAgID8gYCR7bWF0Y2hlc1sxXS50cmltKCl9JHttYXRjaGVzWzNdLnRyaW0oKX1gXG4gICAgICAgICAgICAgICAgOiBgJHttYXRjaGVzWzFdLnRyaW0oKX1UJHttYXRjaGVzWzNdLnRyaW0oKX1gXG4gICAgICAgICAgICA6IG1hdGNoZXNbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGRhdGVUaW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBmYWlsIGlmIHRoZSBkYXRlIGlzIG5vdCB2YWxpZFxuICAgICAgICAgICAgdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlQ29yZUVycm9yKENvcmVFcnJvckNvZGVzLklOVkFMSURfSVNPX0RBVEVfQVJHVU1FTlQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGF0ZShhcmcxKSkge1xuICAgICAgICBpZiAoaXNOYU4oYXJnMS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVDb3JlRXJyb3IoQ29yZUVycm9yQ29kZXMuSU5WQUxJRF9EQVRFX0FSR1VNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFyZzE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTnVtYmVyKGFyZzEpKSB7XG4gICAgICAgIHZhbHVlID0gYXJnMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNvcmVFcnJvcihDb3JlRXJyb3JDb2Rlcy5JTlZBTElEX0FSR1VNRU5UKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGFyZzIpKSB7XG4gICAgICAgIG9wdGlvbnMua2V5ID0gYXJnMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhcmcyKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhhcmcyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoREFURVRJTUVfRk9STUFUX09QVElPTlNfS0VZUy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzW2tleV0gPSBhcmcyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBhcmcyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcoYXJnMykpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBhcmczO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZzMpKSB7XG4gICAgICAgIG92ZXJyaWRlcyA9IGFyZzM7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGFyZzQpKSB7XG4gICAgICAgIG92ZXJyaWRlcyA9IGFyZzQ7XG4gICAgfVxuICAgIHJldHVybiBbb3B0aW9ucy5rZXkgfHwgJycsIHZhbHVlLCBvcHRpb25zLCBvdmVycmlkZXNdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY2xlYXJEYXRlVGltZUZvcm1hdChjdHgsIGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IGN0eDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgaWQgPSBgJHtsb2NhbGV9X18ke2tleX1gO1xuICAgICAgICBpZiAoIWNvbnRleHQuX19kYXRldGltZUZvcm1hdHRlcnMuaGFzKGlkKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5fX2RhdGV0aW1lRm9ybWF0dGVycy5kZWxldGUoaWQpO1xuICAgIH1cbn1cblxuLy8gaW1wbGVtZW50YXRpb24gb2YgYG51bWJlcmAgZnVuY3Rpb25cbmZ1bmN0aW9uIG51bWJlcihjb250ZXh0LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBudW1iZXJGb3JtYXRzLCB1bnJlc29sdmluZywgZmFsbGJhY2tMb2NhbGUsIG9uV2FybiwgbG9jYWxlRmFsbGJhY2tlciB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IF9fbnVtYmVyRm9ybWF0dGVycyB9ID0gY29udGV4dDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFBdmFpbGFiaWxpdGllcy5udW1iZXJGb3JtYXQpIHtcbiAgICAgICAgb25XYXJuKGdldFdhcm5NZXNzYWdlKENvcmVXYXJuQ29kZXMuQ0FOTk9UX0ZPUk1BVF9OVU1CRVIpKTtcbiAgICAgICAgcmV0dXJuIE1JU1NJTkdfUkVTT0xWRV9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgW2tleSwgdmFsdWUsIG9wdGlvbnMsIG92ZXJyaWRlc10gPSBwYXJzZU51bWJlckFyZ3MoLi4uYXJncyk7XG4gICAgY29uc3QgbWlzc2luZ1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5taXNzaW5nV2FybilcbiAgICAgICAgPyBvcHRpb25zLm1pc3NpbmdXYXJuXG4gICAgICAgIDogY29udGV4dC5taXNzaW5nV2FybjtcbiAgICBjb25zdCBmYWxsYmFja1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1dhcm4pXG4gICAgICAgID8gb3B0aW9ucy5mYWxsYmFja1dhcm5cbiAgICAgICAgOiBjb250ZXh0LmZhbGxiYWNrV2FybjtcbiAgICBjb25zdCBwYXJ0ID0gISFvcHRpb25zLnBhcnQ7XG4gICAgY29uc3QgbG9jYWxlID0gaXNTdHJpbmcob3B0aW9ucy5sb2NhbGUpID8gb3B0aW9ucy5sb2NhbGUgOiBjb250ZXh0LmxvY2FsZTtcbiAgICBjb25zdCBsb2NhbGVzID0gbG9jYWxlRmFsbGJhY2tlcihjb250ZXh0LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBmYWxsYmFja0xvY2FsZSwgbG9jYWxlKTtcbiAgICBpZiAoIWlzU3RyaW5nKGtleSkgfHwga2V5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3ZlcnJpZGVzKS5mb3JtYXQodmFsdWUpO1xuICAgIH1cbiAgICAvLyByZXNvbHZlIGZvcm1hdFxuICAgIGxldCBudW1iZXJGb3JtYXQgPSB7fTtcbiAgICBsZXQgdGFyZ2V0TG9jYWxlO1xuICAgIGxldCBmb3JtYXQgPSBudWxsO1xuICAgIGxldCBmcm9tID0gbG9jYWxlO1xuICAgIGxldCB0byA9IG51bGw7XG4gICAgY29uc3QgdHlwZSA9ICdudW1iZXIgZm9ybWF0JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0TG9jYWxlID0gdG8gPSBsb2NhbGVzW2ldO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBsb2NhbGUgIT09IHRhcmdldExvY2FsZSAmJlxuICAgICAgICAgICAgaXNUcmFuc2xhdGVGYWxsYmFja1dhcm4oZmFsbGJhY2tXYXJuLCBrZXkpKSB7XG4gICAgICAgICAgICBvbldhcm4oZ2V0V2Fybk1lc3NhZ2UoQ29yZVdhcm5Db2Rlcy5GQUxMQkFDS19UT19OVU1CRVJfRk9STUFULCB7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0TG9jYWxlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yIHZ1ZS1kZXZ0b29scyB0aW1lbGluZSBldmVudFxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGxvY2FsZSAhPT0gdGFyZ2V0TG9jYWxlKSB7XG4gICAgICAgICAgICBjb25zdCBlbWl0dGVyID0gY29udGV4dC5fX3ZfZW1pdHRlcjtcbiAgICAgICAgICAgIGlmIChlbWl0dGVyKSB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KFwiZmFsbGJhY2tcIiAvKiBWdWVEZXZUb29sc1RpbWVsaW5lRXZlbnRzLkZBTEJBQ0sgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogYCR7dHlwZX06JHtrZXl9YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlckZvcm1hdCA9XG4gICAgICAgICAgICBudW1iZXJGb3JtYXRzW3RhcmdldExvY2FsZV0gfHwge307XG4gICAgICAgIGZvcm1hdCA9IG51bWJlckZvcm1hdFtrZXldO1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChmb3JtYXQpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhhbmRsZU1pc3NpbmcoY29udGV4dCwga2V5LCB0YXJnZXRMb2NhbGUsIG1pc3NpbmdXYXJuLCB0eXBlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGZyb20gPSB0bztcbiAgICB9XG4gICAgLy8gY2hlY2tpbmcgZm9ybWF0IGFuZCB0YXJnZXQgbG9jYWxlXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGZvcm1hdCkgfHwgIWlzU3RyaW5nKHRhcmdldExvY2FsZSkpIHtcbiAgICAgICAgcmV0dXJuIHVucmVzb2x2aW5nID8gTk9UX1JFT1NMVkVEIDoga2V5O1xuICAgIH1cbiAgICBsZXQgaWQgPSBgJHt0YXJnZXRMb2NhbGV9X18ke2tleX1gO1xuICAgIGlmICghaXNFbXB0eU9iamVjdChvdmVycmlkZXMpKSB7XG4gICAgICAgIGlkID0gYCR7aWR9X18ke0pTT04uc3RyaW5naWZ5KG92ZXJyaWRlcyl9YDtcbiAgICB9XG4gICAgbGV0IGZvcm1hdHRlciA9IF9fbnVtYmVyRm9ybWF0dGVycy5nZXQoaWQpO1xuICAgIGlmICghZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0YXJnZXRMb2NhbGUsIGFzc2lnbih7fSwgZm9ybWF0LCBvdmVycmlkZXMpKTtcbiAgICAgICAgX19udW1iZXJGb3JtYXR0ZXJzLnNldChpZCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuICFwYXJ0ID8gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSkgOiBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyh2YWx1ZSk7XG59XG4vKiogQGludGVybmFsICovXG5jb25zdCBOVU1CRVJfRk9STUFUX09QVElPTlNfS0VZUyA9IFtcbiAgICAnbG9jYWxlTWF0Y2hlcicsXG4gICAgJ3N0eWxlJyxcbiAgICAnY3VycmVuY3knLFxuICAgICdjdXJyZW5jeURpc3BsYXknLFxuICAgICdjdXJyZW5jeVNpZ24nLFxuICAgICd1c2VHcm91cGluZycsXG4gICAgJ21pbmltdW1JbnRlZ2VyRGlnaXRzJyxcbiAgICAnbWluaW11bUZyYWN0aW9uRGlnaXRzJyxcbiAgICAnbWF4aW11bUZyYWN0aW9uRGlnaXRzJyxcbiAgICAnbWluaW11bVNpZ25pZmljYW50RGlnaXRzJyxcbiAgICAnbWF4aW11bVNpZ25pZmljYW50RGlnaXRzJyxcbiAgICAnY29tcGFjdERpc3BsYXknLFxuICAgICdub3RhdGlvbicsXG4gICAgJ3NpZ25EaXNwbGF5JyxcbiAgICAndW5pdCcsXG4gICAgJ3VuaXREaXNwbGF5JyxcbiAgICAncm91bmRpbmdNb2RlJyxcbiAgICAncm91bmRpbmdQcmlvcml0eScsXG4gICAgJ3JvdW5kaW5nSW5jcmVtZW50JyxcbiAgICAndHJhaWxpbmdaZXJvRGlzcGxheSdcbl07XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBwYXJzZU51bWJlckFyZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IFthcmcxLCBhcmcyLCBhcmczLCBhcmc0XSA9IGFyZ3M7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICBpZiAoIWlzTnVtYmVyKGFyZzEpKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUNvcmVFcnJvcihDb3JlRXJyb3JDb2Rlcy5JTlZBTElEX0FSR1VNRU5UKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBhcmcxO1xuICAgIGlmIChpc1N0cmluZyhhcmcyKSkge1xuICAgICAgICBvcHRpb25zLmtleSA9IGFyZzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoYXJnMikpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJnMikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKE5VTUJFUl9GT1JNQVRfT1BUSU9OU19LRVlTLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXNba2V5XSA9IGFyZzJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IGFyZzJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhhcmczKSkge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGFyZzM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoYXJnMykpIHtcbiAgICAgICAgb3ZlcnJpZGVzID0gYXJnMztcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYXJnNCkpIHtcbiAgICAgICAgb3ZlcnJpZGVzID0gYXJnNDtcbiAgICB9XG4gICAgcmV0dXJuIFtvcHRpb25zLmtleSB8fCAnJywgdmFsdWUsIG9wdGlvbnMsIG92ZXJyaWRlc107XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBjbGVhck51bWJlckZvcm1hdChjdHgsIGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IGN0eDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgaWQgPSBgJHtsb2NhbGV9X18ke2tleX1gO1xuICAgICAgICBpZiAoIWNvbnRleHQuX19udW1iZXJGb3JtYXR0ZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuX19udW1iZXJGb3JtYXR0ZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxufVxuXG57XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xufVxuXG5leHBvcnQgeyBDb3JlRXJyb3JDb2RlcywgQ29yZVdhcm5Db2RlcywgREFURVRJTUVfRk9STUFUX09QVElPTlNfS0VZUywgREVGQVVMVF9MT0NBTEUsIERFRkFVTFRfTUVTU0FHRV9EQVRBX1RZUEUsIE1JU1NJTkdfUkVTT0xWRV9WQUxVRSwgTk9UX1JFT1NMVkVELCBOVU1CRVJfRk9STUFUX09QVElPTlNfS0VZUywgVkVSU0lPTiwgY2xlYXJDb21waWxlQ2FjaGUsIGNsZWFyRGF0ZVRpbWVGb3JtYXQsIGNsZWFyTnVtYmVyRm9ybWF0LCBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbiwgY3JlYXRlQ29yZUNvbnRleHQsIGNyZWF0ZUNvcmVFcnJvciwgY3JlYXRlTWVzc2FnZUNvbnRleHQsIGRhdGV0aW1lLCBmYWxsYmFja1dpdGhMb2NhbGVDaGFpbiwgZmFsbGJhY2tXaXRoU2ltcGxlLCBnZXRBZGRpdGlvbmFsTWV0YSwgZ2V0RGV2VG9vbHNIb29rLCBnZXRGYWxsYmFja0NvbnRleHQsIGdldFdhcm5NZXNzYWdlLCBoYW5kbGVNaXNzaW5nLCBpbml0STE4bkRldlRvb2xzLCBpc01lc3NhZ2VBU1QsIGlzTWVzc2FnZUZ1bmN0aW9uLCBpc1RyYW5zbGF0ZUZhbGxiYWNrV2FybiwgaXNUcmFuc2xhdGVNaXNzaW5nV2FybiwgbnVtYmVyLCBwYXJzZSwgcGFyc2VEYXRlVGltZUFyZ3MsIHBhcnNlTnVtYmVyQXJncywgcGFyc2VUcmFuc2xhdGVBcmdzLCByZWdpc3RlckxvY2FsZUZhbGxiYWNrZXIsIHJlZ2lzdGVyTWVzc2FnZUNvbXBpbGVyLCByZWdpc3Rlck1lc3NhZ2VSZXNvbHZlciwgcmVzb2x2ZVZhbHVlLCByZXNvbHZlV2l0aEtleVZhbHVlLCBzZXRBZGRpdGlvbmFsTWV0YSwgc2V0RGV2VG9vbHNIb29rLCBzZXRGYWxsYmFja0NvbnRleHQsIHRyYW5zbGF0ZSwgdHJhbnNsYXRlRGV2VG9vbHMsIHVwZGF0ZUZhbGxiYWNrTG9jYWxlIH07XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0RGV2dG9vbHNHbG9iYWxIb29rKCkge1xuICAgIHJldHVybiBnZXRUYXJnZXQoKS5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgIDoge307XG59XG5leHBvcnQgY29uc3QgaXNQcm94eUF2YWlsYWJsZSA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbiIsImV4cG9ydCBjb25zdCBIT09LX1NFVFVQID0gJ2RldnRvb2xzLXBsdWdpbjpzZXR1cCc7XG5leHBvcnQgY29uc3QgSE9PS19QTFVHSU5fU0VUVElOR1NfU0VUID0gJ3BsdWdpbjpzZXR0aW5nczpzZXQnO1xuIiwibGV0IHN1cHBvcnRlZDtcbmxldCBwZXJmO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVyZm9ybWFuY2VTdXBwb3J0ZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBnbG9iYWwucGVyZl9ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcmZvcm1hbmNlKSkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBwZXJmID0gZ2xvYmFsLnBlcmZfaG9va3MucGVyZm9ybWFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIGlzUGVyZm9ybWFuY2VTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpO1xufVxuIiwiaW1wb3J0IHsgSE9PS19QTFVHSU5fU0VUVElOR1NfU0VUIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuL3RpbWUuanMnO1xuZXhwb3J0IGNsYXNzIEFwaVByb3h5IHtcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW4sIGhvb2spIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldFF1ZXVlID0gW107XG4gICAgICAgIHRoaXMub25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgdGhpcy5ob29rID0gaG9vaztcbiAgICAgICAgY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge307XG4gICAgICAgIGlmIChwbHVnaW4uc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWQgaW4gcGx1Z2luLnNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBsdWdpbi5zZXR0aW5nc1tpZF07XG4gICAgICAgICAgICAgICAgZGVmYXVsdFNldHRpbmdzW2lkXSA9IGl0ZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2FsU2V0dGluZ3NTYXZlSWQgPSBgX192dWUtZGV2dG9vbHMtcGx1Z2luLXNldHRpbmdzX18ke3BsdWdpbi5pZH1gO1xuICAgICAgICBsZXQgY3VycmVudFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFNldHRpbmdzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsU2V0dGluZ3NTYXZlSWQpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY3VycmVudFNldHRpbmdzLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFsbGJhY2tzID0ge1xuICAgICAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZXR0aW5ncztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTZXR0aW5ncyh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU2V0dGluZ3NTYXZlSWQsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFNldHRpbmdzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm93KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3coKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgICBob29rLm9uKEhPT0tfUExVR0lOX1NFVFRJTkdTX1NFVCwgKHBsdWdpbklkLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5JZCA9PT0gdGhpcy5wbHVnaW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWxsYmFja3Muc2V0U2V0dGluZ3ModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveGllZE9uID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICBnZXQ6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldC5vbltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJveGllZFRhcmdldCA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveGllZE9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyh0aGlzLmZhbGxiYWNrcykuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFsbGJhY2tzW3Byb3BdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJlYWxUYXJnZXQodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vblF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5vbltpdGVtLm1ldGhvZF0oLi4uaXRlbS5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy50YXJnZXRRdWV1ZSkge1xuICAgICAgICAgICAgaXRlbS5yZXNvbHZlKGF3YWl0IHRoaXMudGFyZ2V0W2l0ZW0ubWV0aG9kXSguLi5pdGVtLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGdldFRhcmdldCwgZ2V0RGV2dG9vbHNHbG9iYWxIb29rLCBpc1Byb3h5QXZhaWxhYmxlIH0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHsgSE9PS19TRVRVUCB9IGZyb20gJy4vY29uc3QuanMnO1xuaW1wb3J0IHsgQXBpUHJveHkgfSBmcm9tICcuL3Byb3h5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXBpL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2luLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGltZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBEZXZ0b29sc1BsdWdpbihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHBsdWdpbkRlc2NyaXB0b3I7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KCk7XG4gICAgY29uc3QgaG9vayA9IGdldERldnRvb2xzR2xvYmFsSG9vaygpO1xuICAgIGNvbnN0IGVuYWJsZVByb3h5ID0gaXNQcm94eUF2YWlsYWJsZSAmJiBkZXNjcmlwdG9yLmVuYWJsZUVhcmx5UHJveHk7XG4gICAgaWYgKGhvb2sgJiYgKHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5fQVBJX0FWQUlMQUJMRV9fIHx8ICFlbmFibGVQcm94eSkpIHtcbiAgICAgICAgaG9vay5lbWl0KEhPT0tfU0VUVVAsIHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJveHkgPSBlbmFibGVQcm94eSA/IG5ldyBBcGlQcm94eShkZXNjcmlwdG9yLCBob29rKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfUExVR0lOU19fID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTlNfXyB8fCBbXTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIHBsdWdpbkRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICAgICAgICBzZXR1cEZuLFxuICAgICAgICAgICAgcHJveHksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJveHkpXG4gICAgICAgICAgICBzZXR1cEZuKHByb3h5LnByb3hpZWRUYXJnZXQpO1xuICAgIH1cbn1cbiIsIi8qIVxuICAqIHZ1ZS1kZXZ0b29scyB2OS4zLjAtYmV0YS4yNVxuICAqIChjKSAyMDIzIGthenV5YSBrYXdhZ3VjaGlcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gICovXG5jb25zdCBWdWVEZXZUb29sc0xhYmVscyA9IHtcbiAgICBbXCJ2dWUtZGV2dG9vbHMtcGx1Z2luLXZ1ZS1pMThuXCIgLyogVnVlRGV2VG9vbHNJRHMuUExVR0lOICovXTogJ1Z1ZSBJMThuIGRldnRvb2xzJyxcbiAgICBbXCJ2dWUtaTE4bi1yZXNvdXJjZS1pbnNwZWN0b3JcIiAvKiBWdWVEZXZUb29sc0lEcy5DVVNUT01fSU5TUEVDVE9SICovXTogJ0kxOG4gUmVzb3VyY2VzJyxcbiAgICBbXCJ2dWUtaTE4bi10aW1lbGluZVwiIC8qIFZ1ZURldlRvb2xzSURzLlRJTUVMSU5FICovXTogJ1Z1ZSBJMThuJ1xufTtcbmNvbnN0IFZ1ZURldlRvb2xzUGxhY2Vob2xkZXJzID0ge1xuICAgIFtcInZ1ZS1pMThuLXJlc291cmNlLWluc3BlY3RvclwiIC8qIFZ1ZURldlRvb2xzSURzLkNVU1RPTV9JTlNQRUNUT1IgKi9dOiAnU2VhcmNoIGZvciBzY29wZXMgLi4uJ1xufTtcbmNvbnN0IFZ1ZURldlRvb2xzVGltZWxpbmVDb2xvcnMgPSB7XG4gICAgW1widnVlLWkxOG4tdGltZWxpbmVcIiAvKiBWdWVEZXZUb29sc0lEcy5USU1FTElORSAqL106IDB4ZmZjZDE5XG59O1xuXG5leHBvcnQgeyBWdWVEZXZUb29sc0xhYmVscywgVnVlRGV2VG9vbHNQbGFjZWhvbGRlcnMsIFZ1ZURldlRvb2xzVGltZWxpbmVDb2xvcnMgfTtcbiIsIi8qIVxuICAqIHZ1ZS1pMThuIHY5LjMuMC1iZXRhLjI1XG4gICogKGMpIDIwMjMga2F6dXlhIGthd2FndWNoaVxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAgKi9cbmltcG9ydCB7IGdldEdsb2JhbFRoaXMsIGZvcm1hdCwgbWFrZVN5bWJvbCwgaXNQbGFpbk9iamVjdCwgaXNBcnJheSwgaXNTdHJpbmcsIGhhc093biwgaXNPYmplY3QsIHdhcm4sIGlzQm9vbGVhbiwgaXNSZWdFeHAsIGlzRnVuY3Rpb24sIGluQnJvd3NlciwgYXNzaWduLCBpc051bWJlciwgY3JlYXRlRW1pdHRlciwgaXNFbXB0eU9iamVjdCB9IGZyb20gJ0BpbnRsaWZ5L3NoYXJlZCc7XG5pbXBvcnQgeyBDb3JlV2FybkNvZGVzLCBDb21waWxlRXJyb3JDb2RlcywgY3JlYXRlQ29tcGlsZUVycm9yLCBERUZBVUxUX0xPQ0FMRSwgdXBkYXRlRmFsbGJhY2tMb2NhbGUsIHNldEZhbGxiYWNrQ29udGV4dCwgY3JlYXRlQ29yZUNvbnRleHQsIGNsZWFyRGF0ZVRpbWVGb3JtYXQsIGNsZWFyTnVtYmVyRm9ybWF0LCBzZXRBZGRpdGlvbmFsTWV0YSwgZ2V0RmFsbGJhY2tDb250ZXh0LCBOT1RfUkVPU0xWRUQsIGlzVHJhbnNsYXRlRmFsbGJhY2tXYXJuLCBpc1RyYW5zbGF0ZU1pc3NpbmdXYXJuLCBwYXJzZVRyYW5zbGF0ZUFyZ3MsIHRyYW5zbGF0ZSwgTUlTU0lOR19SRVNPTFZFX1ZBTFVFLCBwYXJzZURhdGVUaW1lQXJncywgZGF0ZXRpbWUsIHBhcnNlTnVtYmVyQXJncywgbnVtYmVyLCBmYWxsYmFja1dpdGhMb2NhbGVDaGFpbiwgTlVNQkVSX0ZPUk1BVF9PUFRJT05TX0tFWVMsIERBVEVUSU1FX0ZPUk1BVF9PUFRJT05TX0tFWVMsIGlzTWVzc2FnZUFTVCwgcmVnaXN0ZXJNZXNzYWdlQ29tcGlsZXIsIGNvbXBpbGVUb0Z1bmN0aW9uLCBjb21waWxlLCByZWdpc3Rlck1lc3NhZ2VSZXNvbHZlciwgcmVzb2x2ZVZhbHVlLCByZWdpc3RlckxvY2FsZUZhbGxiYWNrZXIsIHNldERldlRvb2xzSG9vayB9IGZyb20gJ0BpbnRsaWZ5L2NvcmUtYmFzZSc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgVGV4dCwgcmVmLCBjb21wdXRlZCwgd2F0Y2gsIGdldEN1cnJlbnRJbnN0YW5jZSwgRnJhZ21lbnQsIGRlZmluZUNvbXBvbmVudCwgaCwgZWZmZWN0U2NvcGUsIGluamVjdCwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgc2hhbGxvd1JlZiwgb25CZWZvcmVNb3VudCwgaXNSZWYgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgc2V0dXBEZXZ0b29sc1BsdWdpbiB9IGZyb20gJ0B2dWUvZGV2dG9vbHMtYXBpJztcbmltcG9ydCB7IFZ1ZURldlRvb2xzTGFiZWxzLCBWdWVEZXZUb29sc1BsYWNlaG9sZGVycywgVnVlRGV2VG9vbHNUaW1lbGluZUNvbG9ycyB9IGZyb20gJ0BpbnRsaWZ5L3Z1ZS1kZXZ0b29scyc7XG5cbi8qKlxuICogVnVlIEkxOG4gVmVyc2lvblxuICpcbiAqIEByZW1hcmtzXG4gKiBTZW12ZXIgZm9ybWF0LiBTYW1lIGZvcm1hdCBhcyB0aGUgcGFja2FnZS5qc29uIGB2ZXJzaW9uYCBmaWVsZC5cbiAqXG4gKiBAVnVlSTE4bkdlbmVyYWxcbiAqL1xuY29uc3QgVkVSU0lPTiA9ICc5LjMuMC1iZXRhLjI1Jztcbi8qKlxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxuICovXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xuICAgIGlmICh0eXBlb2YgX19WVUVfSTE4Tl9GVUxMX0lOU1RBTExfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9JMThOX0ZVTExfSU5TVEFMTF9fID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9JMThOX0xFR0FDWV9BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9JMThOX0xFR0FDWV9BUElfXyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX19JTlRMSUZZX0pJVF9DT01QSUxBVElPTl9fICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fSU5UTElGWV9KSVRfQ09NUElMQVRJT05fXyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9fSU5UTElGWV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19JTlRMSUZZX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xuICAgIH1cbn1cblxubGV0IGNvZGUkMSA9IENvcmVXYXJuQ29kZXMuX19FWFRFTkRfUE9JTlRfXztcbmNvbnN0IGluYyQxID0gKCkgPT4gKytjb2RlJDE7XG5jb25zdCBJMThuV2FybkNvZGVzID0ge1xuICAgIEZBTExCQUNLX1RPX1JPT1Q6IGNvZGUkMSxcbiAgICBOT1RfU1VQUE9SVEVEX1BSRVNFUlZFOiBpbmMkMSgpLFxuICAgIE5PVF9TVVBQT1JURURfRk9STUFUVEVSOiBpbmMkMSgpLFxuICAgIE5PVF9TVVBQT1JURURfUFJFU0VSVkVfRElSRUNUSVZFOiBpbmMkMSgpLFxuICAgIE5PVF9TVVBQT1JURURfR0VUX0NIT0lDRV9JTkRFWDogaW5jJDEoKSxcbiAgICBDT01QT05FTlRfTkFNRV9MRUdBQ1lfQ09NUEFUSUJMRTogaW5jJDEoKSxcbiAgICBOT1RfRk9VTkRfUEFSRU5UX1NDT1BFOiBpbmMkMSgpLFxuICAgIElHTk9SRV9PQkpfRkxBVFRFTjogaW5jJDEoKSAvLyAxNFxufTtcbmNvbnN0IHdhcm5NZXNzYWdlcyA9IHtcbiAgICBbSTE4bldhcm5Db2Rlcy5GQUxMQkFDS19UT19ST09UXTogYEZhbGwgYmFjayB0byB7dHlwZX0gJ3trZXl9JyB3aXRoIHJvb3QgbG9jYWxlLmAsXG4gICAgW0kxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9QUkVTRVJWRV06IGBOb3Qgc3VwcG9ydGVkICdwcmVzZXJ2ZScuYCxcbiAgICBbSTE4bldhcm5Db2Rlcy5OT1RfU1VQUE9SVEVEX0ZPUk1BVFRFUl06IGBOb3Qgc3VwcG9ydGVkICdmb3JtYXR0ZXInLmAsXG4gICAgW0kxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9QUkVTRVJWRV9ESVJFQ1RJVkVdOiBgTm90IHN1cHBvcnRlZCAncHJlc2VydmVEaXJlY3RpdmVDb250ZW50Jy5gLFxuICAgIFtJMThuV2FybkNvZGVzLk5PVF9TVVBQT1JURURfR0VUX0NIT0lDRV9JTkRFWF06IGBOb3Qgc3VwcG9ydGVkICdnZXRDaG9pY2VJbmRleCcuYCxcbiAgICBbSTE4bldhcm5Db2Rlcy5DT01QT05FTlRfTkFNRV9MRUdBQ1lfQ09NUEFUSUJMRV06IGBDb21wb25lbnQgbmFtZSBsZWdhY3kgY29tcGF0aWJsZTogJ3tuYW1lfScgLT4gJ2kxOG4nYCxcbiAgICBbSTE4bldhcm5Db2Rlcy5OT1RfRk9VTkRfUEFSRU5UX1NDT1BFXTogYE5vdCBmb3VuZCBwYXJlbnQgc2NvcGUuIHVzZSB0aGUgZ2xvYmFsIHNjb3BlLmAsXG4gICAgW0kxOG5XYXJuQ29kZXMuSUdOT1JFX09CSl9GTEFUVEVOXTogYElnbm9yZSBvYmplY3QgZmxhdHRlbjogJ3trZXl9JyBrZXkgaGFzIGFuIHN0cmluZyB2YWx1ZWBcbn07XG5mdW5jdGlvbiBnZXRXYXJuTWVzc2FnZShjb2RlLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3YXJuTWVzc2FnZXNbY29kZV0sIC4uLmFyZ3MpO1xufVxuXG5sZXQgY29kZSA9IENvbXBpbGVFcnJvckNvZGVzLl9fRVhURU5EX1BPSU5UX187XG5jb25zdCBpbmMgPSAoKSA9PiArK2NvZGU7XG5jb25zdCBJMThuRXJyb3JDb2RlcyA9IHtcbiAgICAvLyBjb21wb3NlciBtb2R1bGUgZXJyb3JzXG4gICAgVU5FWFBFQ1RFRF9SRVRVUk5fVFlQRTogY29kZSxcbiAgICAvLyBsZWdhY3kgbW9kdWxlIGVycm9yc1xuICAgIElOVkFMSURfQVJHVU1FTlQ6IGluYygpLFxuICAgIC8vIGkxOG4gbW9kdWxlIGVycm9yc1xuICAgIE1VU1RfQkVfQ0FMTF9TRVRVUF9UT1A6IGluYygpLFxuICAgIE5PVF9JTlNUQUxMRUQ6IGluYygpLFxuICAgIE5PVF9BVkFJTEFCTEVfSU5fTEVHQUNZX01PREU6IGluYygpLFxuICAgIC8vIGRpcmVjdGl2ZSBtb2R1bGUgZXJyb3JzXG4gICAgUkVRVUlSRURfVkFMVUU6IGluYygpLFxuICAgIElOVkFMSURfVkFMVUU6IGluYygpLFxuICAgIC8vIHZ1ZS1kZXZ0b29scyBlcnJvcnNcbiAgICBDQU5OT1RfU0VUVVBfVlVFX0RFVlRPT0xTX1BMVUdJTjogaW5jKCksXG4gICAgTk9UX0lOU1RBTExFRF9XSVRIX1BST1ZJREU6IGluYygpLFxuICAgIC8vIHVuZXhwZWN0ZWQgZXJyb3JcbiAgICBVTkVYUEVDVEVEX0VSUk9SOiBpbmMoKSxcbiAgICAvLyBub3QgY29tcGF0aWJsZSBsZWdhY3kgdnVlLWkxOG4gY29uc3RydWN0b3JcbiAgICBOT1RfQ09NUEFUSUJMRV9MRUdBQ1lfVlVFX0kxOE46IGluYygpLFxuICAgIC8vIGJyaWRnZSBzdXBwb3J0IHZ1ZSAyLnggb25seVxuICAgIEJSSURHRV9TVVBQT1JUX1ZVRV8yX09OTFk6IGluYygpLFxuICAgIC8vIG5lZWQgdG8gZGVmaW5lIGBpMThuYCBvcHRpb24gaW4gYGFsbG93Q29tcG9zaXRpb246IHRydWVgIGFuZCBgdXNlU2NvcGU6ICdsb2NhbCcgYXQgYHVzZUkxOG5gYFxuICAgIE1VU1RfREVGSU5FX0kxOE5fT1BUSU9OX0lOX0FMTE9XX0NPTVBPU0lUSU9OOiBpbmMoKSxcbiAgICAvLyBOb3QgYXZhaWxhYmxlIENvbXBvc3Rpb24gQVBJIGluIExlZ2FjeSBBUEkgbW9kZS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHRoZSBsZWdhY3kgQVBJIG1vZGUgaXMgd29ya2luZyBwcm9wZXJseVxuICAgIE5PVF9BVkFJTEFCTEVfQ09NUE9TSVRJT05fSU5fTEVHQUNZOiBpbmMoKSxcbiAgICAvLyBmb3IgZW5oYW5jZW1lbnRcbiAgICBfX0VYVEVORF9QT0lOVF9fOiBpbmMoKSAvLyAyOVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUkxOG5FcnJvcihjb2RlLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVFcnJvcihjb2RlLCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyB7IG1lc3NhZ2VzOiBlcnJvck1lc3NhZ2VzLCBhcmdzIH0gOiB1bmRlZmluZWQpO1xufVxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICBbSTE4bkVycm9yQ29kZXMuVU5FWFBFQ1RFRF9SRVRVUk5fVFlQRV06ICdVbmV4cGVjdGVkIHJldHVybiB0eXBlIGluIGNvbXBvc2VyJyxcbiAgICBbSTE4bkVycm9yQ29kZXMuSU5WQUxJRF9BUkdVTUVOVF06ICdJbnZhbGlkIGFyZ3VtZW50JyxcbiAgICBbSTE4bkVycm9yQ29kZXMuTVVTVF9CRV9DQUxMX1NFVFVQX1RPUF06ICdNdXN0IGJlIGNhbGxlZCBhdCB0aGUgdG9wIG9mIGEgYHNldHVwYCBmdW5jdGlvbicsXG4gICAgW0kxOG5FcnJvckNvZGVzLk5PVF9JTlNUQUxMRURdOiAnTmVlZCB0byBpbnN0YWxsIHdpdGggYGFwcC51c2VgIGZ1bmN0aW9uJyxcbiAgICBbSTE4bkVycm9yQ29kZXMuVU5FWFBFQ1RFRF9FUlJPUl06ICdVbmV4cGVjdGVkIGVycm9yJyxcbiAgICBbSTE4bkVycm9yQ29kZXMuTk9UX0FWQUlMQUJMRV9JTl9MRUdBQ1lfTU9ERV06ICdOb3QgYXZhaWxhYmxlIGluIGxlZ2FjeSBtb2RlJyxcbiAgICBbSTE4bkVycm9yQ29kZXMuUkVRVUlSRURfVkFMVUVdOiBgUmVxdWlyZWQgaW4gdmFsdWU6IHswfWAsXG4gICAgW0kxOG5FcnJvckNvZGVzLklOVkFMSURfVkFMVUVdOiBgSW52YWxpZCB2YWx1ZWAsXG4gICAgW0kxOG5FcnJvckNvZGVzLkNBTk5PVF9TRVRVUF9WVUVfREVWVE9PTFNfUExVR0lOXTogYENhbm5vdCBzZXR1cCB2dWUtZGV2dG9vbHMgcGx1Z2luYCxcbiAgICBbSTE4bkVycm9yQ29kZXMuTk9UX0lOU1RBTExFRF9XSVRIX1BST1ZJREVdOiAnTmVlZCB0byBpbnN0YWxsIHdpdGggYHByb3ZpZGVgIGZ1bmN0aW9uJyxcbiAgICBbSTE4bkVycm9yQ29kZXMuTk9UX0NPTVBBVElCTEVfTEVHQUNZX1ZVRV9JMThOXTogJ05vdCBjb21wYXRpYmxlIGxlZ2FjeSBWdWVJMThuLicsXG4gICAgW0kxOG5FcnJvckNvZGVzLkJSSURHRV9TVVBQT1JUX1ZVRV8yX09OTFldOiAndnVlLWkxOG4tYnJpZGdlIHN1cHBvcnQgVnVlIDIueCBvbmx5JyxcbiAgICBbSTE4bkVycm9yQ29kZXMuTVVTVF9ERUZJTkVfSTE4Tl9PUFRJT05fSU5fQUxMT1dfQ09NUE9TSVRJT05dOiAnTXVzdCBkZWZpbmUg4oCYaTE4buKAmSBvcHRpb24gb3IgY3VzdG9tIGJsb2NrIGluIENvbXBvc2l0aW9uIEFQSSB3aXRoIHVzaW5nIGxvY2FsIHNjb3BlIGluIExlZ2FjeSBBUEkgbW9kZScsXG4gICAgW0kxOG5FcnJvckNvZGVzLk5PVF9BVkFJTEFCTEVfQ09NUE9TSVRJT05fSU5fTEVHQUNZXTogJ05vdCBhdmFpbGFibGUgQ29tcG9zdGlvbiBBUEkgaW4gTGVnYWN5IEFQSSBtb2RlLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgdGhlIGxlZ2FjeSBBUEkgbW9kZSBpcyB3b3JraW5nIHByb3Blcmx5J1xufTtcblxuY29uc3QgVHJhbnNsYXRlVk5vZGVTeW1ib2wgPSBcbi8qICNfX1BVUkVfXyovIG1ha2VTeW1ib2woJ19fdHJhbnNsYXRlVk5vZGUnKTtcbmNvbnN0IERhdGV0aW1lUGFydHNTeW1ib2wgPSAvKiAjX19QVVJFX18qLyBtYWtlU3ltYm9sKCdfX2RhdGV0aW1lUGFydHMnKTtcbmNvbnN0IE51bWJlclBhcnRzU3ltYm9sID0gLyogI19fUFVSRV9fKi8gbWFrZVN5bWJvbCgnX19udW1iZXJQYXJ0cycpO1xuY29uc3QgRW5hYmxlRW1pdHRlciA9IC8qICNfX1BVUkVfXyovIG1ha2VTeW1ib2woJ19fZW5hYmxlRW1pdHRlcicpO1xuY29uc3QgRGlzYWJsZUVtaXR0ZXIgPSAvKiAjX19QVVJFX18qLyBtYWtlU3ltYm9sKCdfX2Rpc2FibGVFbWl0dGVyJyk7XG5jb25zdCBTZXRQbHVyYWxSdWxlc1N5bWJvbCA9IG1ha2VTeW1ib2woJ19fc2V0UGx1cmFsUnVsZXMnKTtcbm1ha2VTeW1ib2woJ19faW50bGlmeU1ldGEnKTtcbmNvbnN0IEluZWpjdFdpdGhPcHRpb24gPSAvKiAjX19QVVJFX18qLyBtYWtlU3ltYm9sKCdfX2luamVjdFdpdGhPcHRpb24nKTtcbmNvbnN0IF9fVlVFX0kxOE5fQlJJREdFX18gPSAgJ19fVlVFX0kxOE5fQlJJREdFX18nO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIFRyYW5zZm9ybSBmbGF0IGpzb24gaW4gb2JqIHRvIG5vcm1hbCBqc29uIGluIG9ialxuICovXG5mdW5jdGlvbiBoYW5kbGVGbGF0SnNvbihvYmopIHtcbiAgICAvLyBjaGVjayBvYmpcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIC8vIGNoZWNrIGtleVxuICAgICAgICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBmb3Igbm9ybWFsIGpzb25cbiAgICAgICAgaWYgKCFrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgLy8gcmVjdXJzaXZlIHByb2Nlc3MgdmFsdWUgaWYgdmFsdWUgaXMgYWxzbyBhIG9iamVjdFxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZsYXRKc29uKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgZm9yIGZsYXQganNvbiwgdHJhbnNmb3JtIHRvIG5vcm1hbCBqc29uXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ28gdG8gdGhlIGxhc3Qgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBzdWJLZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBzdWJLZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgY3VycmVudE9iaiA9IG9iajtcbiAgICAgICAgICAgIGxldCBoYXNTdHJpbmdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghKHN1YktleXNbaV0gaW4gY3VycmVudE9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9ialtzdWJLZXlzW2ldXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnRPYmpbc3ViS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihnZXRXYXJuTWVzc2FnZShJMThuV2FybkNvZGVzLklHTk9SRV9PQkpfRkxBVFRFTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc3ViS2V5c1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBoYXNTdHJpbmdWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqID0gY3VycmVudE9ialtzdWJLZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0IG9iamVjdCB2YWx1ZSwgZGVsZXRlIG9sZCBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFoYXNTdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmpbc3ViS2V5c1tsYXN0SW5kZXhdXSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZSBwcm9jZXNzIHZhbHVlIGlmIHZhbHVlIGlzIGFsc28gYSBvYmplY3RcbiAgICAgICAgICAgIGlmIChpc09iamVjdChjdXJyZW50T2JqW3N1YktleXNbbGFzdEluZGV4XV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmxhdEpzb24oY3VycmVudE9ialtzdWJLZXlzW2xhc3RJbmRleF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZ2V0TG9jYWxlTWVzc2FnZXMobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlcywgX19pMThuLCBtZXNzYWdlUmVzb2x2ZXIsIGZsYXRKc29uIH0gPSBvcHRpb25zO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IHJldCA9IChpc1BsYWluT2JqZWN0KG1lc3NhZ2VzKVxuICAgICAgICA/IG1lc3NhZ2VzXG4gICAgICAgIDogaXNBcnJheShfX2kxOG4pXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHsgW2xvY2FsZV06IHt9IH0pO1xuICAgIC8vIG1lcmdlIGxvY2FsZSBtZXNzYWdlcyBvZiBpMThuIGN1c3RvbSBibG9ja1xuICAgIGlmIChpc0FycmF5KF9faTE4bikpIHtcbiAgICAgICAgX19pMThuLmZvckVhY2goY3VzdG9tID0+IHtcbiAgICAgICAgICAgIGlmICgnbG9jYWxlJyBpbiBjdXN0b20gJiYgJ3Jlc291cmNlJyBpbiBjdXN0b20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxvY2FsZSwgcmVzb3VyY2UgfSA9IGN1c3RvbTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtsb2NhbGVdID0gcmV0W2xvY2FsZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIGRlZXBDb3B5KHJlc291cmNlLCByZXRbbG9jYWxlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWVwQ29weShyZXNvdXJjZSwgcmV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1N0cmluZyhjdXN0b20pICYmIGRlZXBDb3B5KEpTT04ucGFyc2UoY3VzdG9tKSwgcmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBtZXNzYWdlcyBmb3IgZmxhdCBqc29uXG4gICAgaWYgKG1lc3NhZ2VSZXNvbHZlciA9PSBudWxsICYmIGZsYXRKc29uKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJldCkge1xuICAgICAgICAgICAgaWYgKGhhc093bihyZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVGbGF0SnNvbihyZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGlzTm90T2JqZWN0T3JJc0FycmF5ID0gKHZhbCkgPT4gIWlzT2JqZWN0KHZhbCkgfHwgaXNBcnJheSh2YWwpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGRlZXBDb3B5KHNyYywgZGVzKSB7XG4gICAgLy8gc3JjIGFuZCBkZXMgc2hvdWxkIGJvdGggYmUgb2JqZWN0cywgYW5kIG5vbiBvZiB0aGVuIGNhbiBiZSBhIGFycmF5XG4gICAgaWYgKGlzTm90T2JqZWN0T3JJc0FycmF5KHNyYykgfHwgaXNOb3RPYmplY3RPcklzQXJyYXkoZGVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVJMThuRXJyb3IoSTE4bkVycm9yQ29kZXMuSU5WQUxJRF9WQUxVRSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHNyYykge1xuICAgICAgICBpZiAoaGFzT3duKHNyYywga2V5KSkge1xuICAgICAgICAgICAgaWYgKGlzTm90T2JqZWN0T3JJc0FycmF5KHNyY1trZXldKSB8fCBpc05vdE9iamVjdE9ySXNBcnJheShkZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHdpdGggc3JjW2tleV0gd2hlbjpcbiAgICAgICAgICAgICAgICAvLyBzcmNba2V5XSBvciBkZXNba2V5XSBpcyBub3QgYSBvYmplY3QsIG9yXG4gICAgICAgICAgICAgICAgLy8gc3JjW2tleV0gb3IgZGVzW2tleV0gaXMgYSBhcnJheVxuICAgICAgICAgICAgICAgIGRlc1trZXldID0gc3JjW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzcmNba2V5XSBhbmQgZGVzW2tleV0gYXJlIGJvdGggb2JqZWN0LCBtZXJnZSB0aGVtXG4gICAgICAgICAgICAgICAgZGVlcENvcHkoc3JjW2tleV0sIGRlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBnZXRDb21wb25lbnRPcHRpb25zKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnR5cGUgO1xufVxuZnVuY3Rpb24gYWRqdXN0STE4blJlc291cmNlcyhnbCwgb3B0aW9ucywgY29tcG9uZW50T3B0aW9ucyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGxldCBtZXNzYWdlcyA9IGlzT2JqZWN0KG9wdGlvbnMubWVzc2FnZXMpID8gb3B0aW9ucy5tZXNzYWdlcyA6IHt9O1xuICAgIGlmICgnX19pMThuR2xvYmFsJyBpbiBjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gZ2V0TG9jYWxlTWVzc2FnZXMoZ2wubG9jYWxlLnZhbHVlLCB7XG4gICAgICAgICAgICBtZXNzYWdlcyxcbiAgICAgICAgICAgIF9faTE4bjogY29tcG9uZW50T3B0aW9ucy5fX2kxOG5HbG9iYWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlIGxvY2FsZSBtZXNzYWdlc1xuICAgIGNvbnN0IGxvY2FsZXMgPSBPYmplY3Qua2V5cyhtZXNzYWdlcyk7XG4gICAgaWYgKGxvY2FsZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvY2FsZXMuZm9yRWFjaChsb2NhbGUgPT4ge1xuICAgICAgICAgICAgZ2wubWVyZ2VMb2NhbGVNZXNzYWdlKGxvY2FsZSwgbWVzc2FnZXNbbG9jYWxlXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB7XG4gICAgICAgIC8vIG1lcmdlIGRhdGV0aW1lIGZvcm1hdHNcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzKSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXMuZm9yRWFjaChsb2NhbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBnbC5tZXJnZURhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucy5kYXRldGltZUZvcm1hdHNbbG9jYWxlXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgbnVtYmVyIGZvcm1hdHNcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMubnVtYmVyRm9ybWF0cykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zLm51bWJlckZvcm1hdHMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlcy5mb3JFYWNoKGxvY2FsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdsLm1lcmdlTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucy5udW1iZXJGb3JtYXRzW2xvY2FsZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIGtleSwgMClcbiAgICAgICAgO1xufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8vIGV4dGVuZCBWTm9kZSBpbnRlcmZhY2VcbmNvbnN0IERFVlRPT0xTX01FVEEgPSAnX19JTlRMSUZZX01FVEFfXyc7XG5sZXQgY29tcG9zZXJJRCA9IDA7XG5mdW5jdGlvbiBkZWZpbmVDb3JlTWlzc2luZ0hhbmRsZXIobWlzc2luZykge1xuICAgIHJldHVybiAoKGN0eCwgbG9jYWxlLCBrZXksIHR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIG1pc3NpbmcobG9jYWxlLCBrZXksIGdldEN1cnJlbnRJbnN0YW5jZSgpIHx8IHVuZGVmaW5lZCwgdHlwZSk7XG4gICAgfSk7XG59XG4vLyBmb3IgSW50bGlmeSBEZXZUb29sc1xuY29uc3QgZ2V0TWV0YUluZm8gPSAgKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgbGV0IG1ldGEgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgKG1ldGEgPSBnZXRDb21wb25lbnRPcHRpb25zKGluc3RhbmNlKVtERVZUT09MU19NRVRBXSlcbiAgICAgICAgPyB7IFtERVZUT09MU19NRVRBXTogbWV0YSB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICA6IG51bGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgY29tcG9zZXIgaW50ZXJmYWNlIGZhY3RvcnlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvc2VyKG9wdGlvbnMgPSB7fSwgVnVlSTE4bkxlZ2FjeSkge1xuICAgIGNvbnN0IHsgX19yb290IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IF9pc0dsb2JhbCA9IF9fcm9vdCA9PT0gdW5kZWZpbmVkO1xuICAgIGxldCBfaW5oZXJpdExvY2FsZSA9IGlzQm9vbGVhbihvcHRpb25zLmluaGVyaXRMb2NhbGUpXG4gICAgICAgID8gb3B0aW9ucy5pbmhlcml0TG9jYWxlXG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBfbG9jYWxlID0gcmVmKFxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIF9fcm9vdCAmJiBfaW5oZXJpdExvY2FsZVxuICAgICAgICA/IF9fcm9vdC5sb2NhbGUudmFsdWVcbiAgICAgICAgOiBpc1N0cmluZyhvcHRpb25zLmxvY2FsZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgIDogREVGQVVMVF9MT0NBTEUpO1xuICAgIGNvbnN0IF9mYWxsYmFja0xvY2FsZSA9IHJlZihcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBfX3Jvb3QgJiYgX2luaGVyaXRMb2NhbGVcbiAgICAgICAgPyBfX3Jvb3QuZmFsbGJhY2tMb2NhbGUudmFsdWVcbiAgICAgICAgOiBpc1N0cmluZyhvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICAgICAgaXNBcnJheShvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5mYWxsYmFja0xvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICAgID8gb3B0aW9ucy5mYWxsYmFja0xvY2FsZVxuICAgICAgICAgICAgOiBfbG9jYWxlLnZhbHVlKTtcbiAgICBjb25zdCBfbWVzc2FnZXMgPSByZWYoZ2V0TG9jYWxlTWVzc2FnZXMoX2xvY2FsZS52YWx1ZSwgb3B0aW9ucykpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF9kYXRldGltZUZvcm1hdHMgPSByZWYoaXNQbGFpbk9iamVjdChvcHRpb25zLmRhdGV0aW1lRm9ybWF0cylcbiAgICAgICAgICAgID8gb3B0aW9ucy5kYXRldGltZUZvcm1hdHNcbiAgICAgICAgICAgIDogeyBbX2xvY2FsZS52YWx1ZV06IHt9IH0pXG4gICAgICAgIDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfbnVtYmVyRm9ybWF0cyA9IHJlZihpc1BsYWluT2JqZWN0KG9wdGlvbnMubnVtYmVyRm9ybWF0cylcbiAgICAgICAgICAgID8gb3B0aW9ucy5udW1iZXJGb3JtYXRzXG4gICAgICAgICAgICA6IHsgW19sb2NhbGUudmFsdWVdOiB7fSB9KVxuICAgICAgICA7XG4gICAgLy8gd2FybmluZyBzdXBwcmVzcyBvcHRpb25zXG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IF9taXNzaW5nV2FybiA9IF9fcm9vdFxuICAgICAgICA/IF9fcm9vdC5taXNzaW5nV2FyblxuICAgICAgICA6IGlzQm9vbGVhbihvcHRpb25zLm1pc3NpbmdXYXJuKSB8fCBpc1JlZ0V4cChvcHRpb25zLm1pc3NpbmdXYXJuKVxuICAgICAgICAgICAgPyBvcHRpb25zLm1pc3NpbmdXYXJuXG4gICAgICAgICAgICA6IHRydWU7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IF9mYWxsYmFja1dhcm4gPSBfX3Jvb3RcbiAgICAgICAgPyBfX3Jvb3QuZmFsbGJhY2tXYXJuXG4gICAgICAgIDogaXNCb29sZWFuKG9wdGlvbnMuZmFsbGJhY2tXYXJuKSB8fCBpc1JlZ0V4cChvcHRpb25zLmZhbGxiYWNrV2FybilcbiAgICAgICAgICAgID8gb3B0aW9ucy5mYWxsYmFja1dhcm5cbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgX2ZhbGxiYWNrUm9vdCA9IF9fcm9vdFxuICAgICAgICA/IF9fcm9vdC5mYWxsYmFja1Jvb3RcbiAgICAgICAgOiBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1Jvb3QpXG4gICAgICAgICAgICA/IG9wdGlvbnMuZmFsbGJhY2tSb290XG4gICAgICAgICAgICA6IHRydWU7XG4gICAgLy8gY29uZmlndXJlIGZhbGwgYmFjayB0byByb290XG4gICAgbGV0IF9mYWxsYmFja0Zvcm1hdCA9ICEhb3B0aW9ucy5mYWxsYmFja0Zvcm1hdDtcbiAgICAvLyBydW50aW1lIG1pc3NpbmdcbiAgICBsZXQgX21pc3NpbmcgPSBpc0Z1bmN0aW9uKG9wdGlvbnMubWlzc2luZykgPyBvcHRpb25zLm1pc3NpbmcgOiBudWxsO1xuICAgIGxldCBfcnVudGltZU1pc3NpbmcgPSBpc0Z1bmN0aW9uKG9wdGlvbnMubWlzc2luZylcbiAgICAgICAgPyBkZWZpbmVDb3JlTWlzc2luZ0hhbmRsZXIob3B0aW9ucy5taXNzaW5nKVxuICAgICAgICA6IG51bGw7XG4gICAgLy8gcG9zdFRyYW5zbGF0aW9uIGhhbmRsZXJcbiAgICBsZXQgX3Bvc3RUcmFuc2xhdGlvbiA9IGlzRnVuY3Rpb24ob3B0aW9ucy5wb3N0VHJhbnNsYXRpb24pXG4gICAgICAgID8gb3B0aW9ucy5wb3N0VHJhbnNsYXRpb25cbiAgICAgICAgOiBudWxsO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBfd2Fybkh0bWxNZXNzYWdlID0gX19yb290XG4gICAgICAgID8gX19yb290Lndhcm5IdG1sTWVzc2FnZVxuICAgICAgICA6IGlzQm9vbGVhbihvcHRpb25zLndhcm5IdG1sTWVzc2FnZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy53YXJuSHRtbE1lc3NhZ2VcbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICBsZXQgX2VzY2FwZVBhcmFtZXRlciA9ICEhb3B0aW9ucy5lc2NhcGVQYXJhbWV0ZXI7XG4gICAgLy8gY3VzdG9tIGxpbmtlZCBtb2RpZmllcnNcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfbW9kaWZpZXJzID0gX19yb290XG4gICAgICAgID8gX19yb290Lm1vZGlmaWVyc1xuICAgICAgICA6IGlzUGxhaW5PYmplY3Qob3B0aW9ucy5tb2RpZmllcnMpXG4gICAgICAgICAgICA/IG9wdGlvbnMubW9kaWZpZXJzXG4gICAgICAgICAgICA6IHt9O1xuICAgIC8vIHBsdXJhbFJ1bGVzXG4gICAgbGV0IF9wbHVyYWxSdWxlcyA9IG9wdGlvbnMucGx1cmFsUnVsZXMgfHwgKF9fcm9vdCAmJiBfX3Jvb3QucGx1cmFsUnVsZXMpO1xuICAgIC8vIHJ1bnRpbWUgY29udGV4dFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgX2NvbnRleHQ7XG4gICAgY29uc3QgZ2V0Q29yZUNvbnRleHQgPSAoKSA9PiB7XG4gICAgICAgIF9pc0dsb2JhbCAmJiBzZXRGYWxsYmFja0NvbnRleHQobnVsbCk7XG4gICAgICAgIGNvbnN0IGN0eE9wdGlvbnMgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBWRVJTSU9OLFxuICAgICAgICAgICAgbG9jYWxlOiBfbG9jYWxlLnZhbHVlLFxuICAgICAgICAgICAgZmFsbGJhY2tMb2NhbGU6IF9mYWxsYmFja0xvY2FsZS52YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBfbWVzc2FnZXMudmFsdWUsXG4gICAgICAgICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXG4gICAgICAgICAgICBwbHVyYWxSdWxlczogX3BsdXJhbFJ1bGVzLFxuICAgICAgICAgICAgbWlzc2luZzogX3J1bnRpbWVNaXNzaW5nID09PSBudWxsID8gdW5kZWZpbmVkIDogX3J1bnRpbWVNaXNzaW5nLFxuICAgICAgICAgICAgbWlzc2luZ1dhcm46IF9taXNzaW5nV2FybixcbiAgICAgICAgICAgIGZhbGxiYWNrV2FybjogX2ZhbGxiYWNrV2FybixcbiAgICAgICAgICAgIGZhbGxiYWNrRm9ybWF0OiBfZmFsbGJhY2tGb3JtYXQsXG4gICAgICAgICAgICB1bnJlc29sdmluZzogdHJ1ZSxcbiAgICAgICAgICAgIHBvc3RUcmFuc2xhdGlvbjogX3Bvc3RUcmFuc2xhdGlvbiA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9wb3N0VHJhbnNsYXRpb24sXG4gICAgICAgICAgICB3YXJuSHRtbE1lc3NhZ2U6IF93YXJuSHRtbE1lc3NhZ2UsXG4gICAgICAgICAgICBlc2NhcGVQYXJhbWV0ZXI6IF9lc2NhcGVQYXJhbWV0ZXIsXG4gICAgICAgICAgICBtZXNzYWdlUmVzb2x2ZXI6IG9wdGlvbnMubWVzc2FnZVJlc29sdmVyLFxuICAgICAgICAgICAgX19tZXRhOiB7IGZyYW1ld29yazogJ3Z1ZScgfVxuICAgICAgICB9O1xuICAgICAgICB7XG4gICAgICAgICAgICBjdHhPcHRpb25zLmRhdGV0aW1lRm9ybWF0cyA9IF9kYXRldGltZUZvcm1hdHMudmFsdWU7XG4gICAgICAgICAgICBjdHhPcHRpb25zLm51bWJlckZvcm1hdHMgPSBfbnVtYmVyRm9ybWF0cy52YWx1ZTtcbiAgICAgICAgICAgIGN0eE9wdGlvbnMuX19kYXRldGltZUZvcm1hdHRlcnMgPSBpc1BsYWluT2JqZWN0KF9jb250ZXh0KVxuICAgICAgICAgICAgICAgID8gX2NvbnRleHQuX19kYXRldGltZUZvcm1hdHRlcnNcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGN0eE9wdGlvbnMuX19udW1iZXJGb3JtYXR0ZXJzID0gaXNQbGFpbk9iamVjdChfY29udGV4dClcbiAgICAgICAgICAgICAgICA/IF9jb250ZXh0Ll9fbnVtYmVyRm9ybWF0dGVyc1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGN0eE9wdGlvbnMuX192X2VtaXR0ZXIgPSBpc1BsYWluT2JqZWN0KF9jb250ZXh0KVxuICAgICAgICAgICAgICAgID8gX2NvbnRleHQuX192X2VtaXR0ZXJcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdHggPSBjcmVhdGVDb3JlQ29udGV4dChjdHhPcHRpb25zKTtcbiAgICAgICAgX2lzR2xvYmFsICYmIHNldEZhbGxiYWNrQ29udGV4dChjdHgpO1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gICAgX2NvbnRleHQgPSBnZXRDb3JlQ29udGV4dCgpO1xuICAgIHVwZGF0ZUZhbGxiYWNrTG9jYWxlKF9jb250ZXh0LCBfbG9jYWxlLnZhbHVlLCBfZmFsbGJhY2tMb2NhbGUudmFsdWUpO1xuICAgIC8vIHRyYWNrIHJlYWN0aXZpdHlcbiAgICBmdW5jdGlvbiB0cmFja1JlYWN0aXZpdHlWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgX2xvY2FsZS52YWx1ZSxcbiAgICAgICAgICAgICAgICBfZmFsbGJhY2tMb2NhbGUudmFsdWUsXG4gICAgICAgICAgICAgICAgX21lc3NhZ2VzLnZhbHVlLFxuICAgICAgICAgICAgICAgIF9kYXRldGltZUZvcm1hdHMudmFsdWUsXG4gICAgICAgICAgICAgICAgX251bWJlckZvcm1hdHMudmFsdWVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDtcbiAgICB9XG4gICAgLy8gbG9jYWxlXG4gICAgY29uc3QgbG9jYWxlID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQ6ICgpID0+IF9sb2NhbGUudmFsdWUsXG4gICAgICAgIHNldDogdmFsID0+IHtcbiAgICAgICAgICAgIF9sb2NhbGUudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBfY29udGV4dC5sb2NhbGUgPSBfbG9jYWxlLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gZmFsbGJhY2tMb2NhbGVcbiAgICBjb25zdCBmYWxsYmFja0xvY2FsZSA9IGNvbXB1dGVkKHtcbiAgICAgICAgZ2V0OiAoKSA9PiBfZmFsbGJhY2tMb2NhbGUudmFsdWUsXG4gICAgICAgIHNldDogdmFsID0+IHtcbiAgICAgICAgICAgIF9mYWxsYmFja0xvY2FsZS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIF9jb250ZXh0LmZhbGxiYWNrTG9jYWxlID0gX2ZhbGxiYWNrTG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgdXBkYXRlRmFsbGJhY2tMb2NhbGUoX2NvbnRleHQsIF9sb2NhbGUudmFsdWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBtZXNzYWdlc1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gY29tcHV0ZWQoKCkgPT4gX21lc3NhZ2VzLnZhbHVlKTtcbiAgICAvLyBkYXRldGltZUZvcm1hdHNcbiAgICBjb25zdCBkYXRldGltZUZvcm1hdHMgPSAvKiAjX19QVVJFX18qLyBjb21wdXRlZCgoKSA9PiBfZGF0ZXRpbWVGb3JtYXRzLnZhbHVlKTtcbiAgICAvLyBudW1iZXJGb3JtYXRzXG4gICAgY29uc3QgbnVtYmVyRm9ybWF0cyA9IC8qICNfX1BVUkVfXyovIGNvbXB1dGVkKCgpID0+IF9udW1iZXJGb3JtYXRzLnZhbHVlKTtcbiAgICAvLyBnZXRQb3N0VHJhbnNsYXRpb25IYW5kbGVyXG4gICAgZnVuY3Rpb24gZ2V0UG9zdFRyYW5zbGF0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oX3Bvc3RUcmFuc2xhdGlvbikgPyBfcG9zdFRyYW5zbGF0aW9uIDogbnVsbDtcbiAgICB9XG4gICAgLy8gc2V0UG9zdFRyYW5zbGF0aW9uSGFuZGxlclxuICAgIGZ1bmN0aW9uIHNldFBvc3RUcmFuc2xhdGlvbkhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICBfcG9zdFRyYW5zbGF0aW9uID0gaGFuZGxlcjtcbiAgICAgICAgX2NvbnRleHQucG9zdFRyYW5zbGF0aW9uID0gaGFuZGxlcjtcbiAgICB9XG4gICAgLy8gZ2V0TWlzc2luZ0hhbmRsZXJcbiAgICBmdW5jdGlvbiBnZXRNaXNzaW5nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9taXNzaW5nO1xuICAgIH1cbiAgICAvLyBzZXRNaXNzaW5nSGFuZGxlclxuICAgIGZ1bmN0aW9uIHNldE1pc3NpbmdIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9ydW50aW1lTWlzc2luZyA9IGRlZmluZUNvcmVNaXNzaW5nSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBfbWlzc2luZyA9IGhhbmRsZXI7XG4gICAgICAgIF9jb250ZXh0Lm1pc3NpbmcgPSBfcnVudGltZU1pc3Npbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVzb2x2ZWRUcmFuc2xhdGVNZXNzYWdlKHR5cGUsIGFyZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09ICd0cmFuc2xhdGUnIHx8ICFhcmcucmVzb2x2ZWRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB3cmFwV2l0aERlcHMgPSAoZm4sIGFyZ3VtZW50UGFyc2VyLCB3YXJuVHlwZSwgZmFsbGJhY2tTdWNjZXNzLCBmYWxsYmFja0ZhaWwsIHN1Y2Nlc3NDb25kaXRpb24pID0+IHtcbiAgICAgICAgdHJhY2tSZWFjdGl2aXR5VmFsdWVzKCk7IC8vIHRyYWNrIHJlYWN0aXZlIGRlcGVuZGVuY3lcbiAgICAgICAgLy8gTk9URTogZXhwZXJpbWVudGFsICEhXG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fSU5UTElGWV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICBzZXRBZGRpdGlvbmFsTWV0YShnZXRNZXRhSW5mbygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzR2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZmFsbGJhY2tDb250ZXh0ID0gX19yb290XG4gICAgICAgICAgICAgICAgICAgID8gZ2V0RmFsbGJhY2tDb250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQgPSBmbihfY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fSU5UTElGWV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICBzZXRBZGRpdGlvbmFsTWV0YShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzR2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZmFsbGJhY2tDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihyZXQpICYmIHJldCA9PT0gTk9UX1JFT1NMVkVEKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCBhcmcyXSA9IGFyZ3VtZW50UGFyc2VyKCk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgX19yb290ICYmXG4gICAgICAgICAgICAgICAgaXNTdHJpbmcoa2V5KSAmJlxuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWRUcmFuc2xhdGVNZXNzYWdlKHdhcm5UeXBlLCBhcmcyKSkge1xuICAgICAgICAgICAgICAgIGlmIChfZmFsbGJhY2tSb290ICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1RyYW5zbGF0ZUZhbGxiYWNrV2FybihfZmFsbGJhY2tXYXJuLCBrZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RyYW5zbGF0ZU1pc3NpbmdXYXJuKF9taXNzaW5nV2Fybiwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihnZXRXYXJuTWVzc2FnZShJMThuV2FybkNvZGVzLkZBTExCQUNLX1RPX1JPT1QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHdhcm5UeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZm9yIHZ1ZS1kZXZ0b29scyB0aW1lbGluZSBldmVudFxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfX3ZfZW1pdHRlcjogZW1pdHRlciB9ID0gX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWl0dGVyICYmIF9mYWxsYmFja1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChcImZhbGxiYWNrXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5GQUxCQUNLICovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogd2FyblR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAnZ2xvYmFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBgJHt3YXJuVHlwZX06JHtrZXl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19yb290ICYmIF9mYWxsYmFja1Jvb3RcbiAgICAgICAgICAgICAgICA/IGZhbGxiYWNrU3VjY2VzcyhfX3Jvb3QpXG4gICAgICAgICAgICAgICAgOiBmYWxsYmFja0ZhaWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdWNjZXNzQ29uZGl0aW9uKHJldCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLlVORVhQRUNURURfUkVUVVJOX1RZUEUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyB0XG4gICAgZnVuY3Rpb24gdCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB3cmFwV2l0aERlcHMoY29udGV4dCA9PiBSZWZsZWN0LmFwcGx5KHRyYW5zbGF0ZSwgbnVsbCwgW2NvbnRleHQsIC4uLmFyZ3NdKSwgKCkgPT4gcGFyc2VUcmFuc2xhdGVBcmdzKC4uLmFyZ3MpLCAndHJhbnNsYXRlJywgcm9vdCA9PiBSZWZsZWN0LmFwcGx5KHJvb3QudCwgcm9vdCwgWy4uLmFyZ3NdKSwga2V5ID0+IGtleSwgdmFsID0+IGlzU3RyaW5nKHZhbCkpO1xuICAgIH1cbiAgICAvLyBydFxuICAgIGZ1bmN0aW9uIHJ0KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgW2FyZzEsIGFyZzIsIGFyZzNdID0gYXJncztcbiAgICAgICAgaWYgKGFyZzMgJiYgIWlzT2JqZWN0KGFyZzMpKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJMThuRXJyb3IoSTE4bkVycm9yQ29kZXMuSU5WQUxJRF9BUkdVTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQoLi4uW2FyZzEsIGFyZzIsIGFzc2lnbih7IHJlc29sdmVkTWVzc2FnZTogdHJ1ZSB9LCBhcmczIHx8IHt9KV0pO1xuICAgIH1cbiAgICAvLyBkXG4gICAgZnVuY3Rpb24gZCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB3cmFwV2l0aERlcHMoY29udGV4dCA9PiBSZWZsZWN0LmFwcGx5KGRhdGV0aW1lLCBudWxsLCBbY29udGV4dCwgLi4uYXJnc10pLCAoKSA9PiBwYXJzZURhdGVUaW1lQXJncyguLi5hcmdzKSwgJ2RhdGV0aW1lIGZvcm1hdCcsIHJvb3QgPT4gUmVmbGVjdC5hcHBseShyb290LmQsIHJvb3QsIFsuLi5hcmdzXSksICgpID0+IE1JU1NJTkdfUkVTT0xWRV9WQUxVRSwgdmFsID0+IGlzU3RyaW5nKHZhbCkpO1xuICAgIH1cbiAgICAvLyBuXG4gICAgZnVuY3Rpb24gbiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB3cmFwV2l0aERlcHMoY29udGV4dCA9PiBSZWZsZWN0LmFwcGx5KG51bWJlciwgbnVsbCwgW2NvbnRleHQsIC4uLmFyZ3NdKSwgKCkgPT4gcGFyc2VOdW1iZXJBcmdzKC4uLmFyZ3MpLCAnbnVtYmVyIGZvcm1hdCcsIHJvb3QgPT4gUmVmbGVjdC5hcHBseShyb290Lm4sIHJvb3QsIFsuLi5hcmdzXSksICgpID0+IE1JU1NJTkdfUkVTT0xWRV9WQUxVRSwgdmFsID0+IGlzU3RyaW5nKHZhbCkpO1xuICAgIH1cbiAgICAvLyBmb3IgY3VzdG9tIHByb2Nlc3NvclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAodmFsID0+IGlzU3RyaW5nKHZhbCkgfHwgaXNOdW1iZXIodmFsKSB8fCBpc0Jvb2xlYW4odmFsKVxuICAgICAgICAgICAgPyBjcmVhdGVUZXh0Tm9kZShTdHJpbmcodmFsKSlcbiAgICAgICAgICAgIDogdmFsKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJwb2xhdGUgPSAodmFsKSA9PiB2YWw7XG4gICAgY29uc3QgcHJvY2Vzc29yID0ge1xuICAgICAgICBub3JtYWxpemUsXG4gICAgICAgIGludGVycG9sYXRlLFxuICAgICAgICB0eXBlOiAndm5vZGUnXG4gICAgfTtcbiAgICAvLyB0cmFuc2xhdGVWTm9kZSwgdXNpbmcgZm9yIGBpMThuLXRgIGNvbXBvbmVudFxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVZOb2RlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBXaXRoRGVwcyhjb250ZXh0ID0+IHtcbiAgICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgICBjb25zdCBfY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgICAgICAgICByZXQgPSBSZWZsZWN0LmFwcGx5KHRyYW5zbGF0ZSwgbnVsbCwgW19jb250ZXh0LCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSwgKCkgPT4gcGFyc2VUcmFuc2xhdGVBcmdzKC4uLmFyZ3MpLCAndHJhbnNsYXRlJywgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJvb3QgPT4gcm9vdFtUcmFuc2xhdGVWTm9kZVN5bWJvbF0oLi4uYXJncyksIGtleSA9PiBbY3JlYXRlVGV4dE5vZGUoa2V5KV0sIHZhbCA9PiBpc0FycmF5KHZhbCkpO1xuICAgIH1cbiAgICAvLyBudW1iZXJQYXJ0cywgdXNpbmcgZm9yIGBpMThuLW5gIGNvbXBvbmVudFxuICAgIGZ1bmN0aW9uIG51bWJlclBhcnRzKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBXaXRoRGVwcyhjb250ZXh0ID0+IFJlZmxlY3QuYXBwbHkobnVtYmVyLCBudWxsLCBbY29udGV4dCwgLi4uYXJnc10pLCAoKSA9PiBwYXJzZU51bWJlckFyZ3MoLi4uYXJncyksICdudW1iZXIgZm9ybWF0JywgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJvb3QgPT4gcm9vdFtOdW1iZXJQYXJ0c1N5bWJvbF0oLi4uYXJncyksICgpID0+IFtdLCB2YWwgPT4gaXNTdHJpbmcodmFsKSB8fCBpc0FycmF5KHZhbCkpO1xuICAgIH1cbiAgICAvLyBkYXRldGltZVBhcnRzLCB1c2luZyBmb3IgYGkxOG4tZGAgY29tcG9uZW50XG4gICAgZnVuY3Rpb24gZGF0ZXRpbWVQYXJ0cyguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB3cmFwV2l0aERlcHMoY29udGV4dCA9PiBSZWZsZWN0LmFwcGx5KGRhdGV0aW1lLCBudWxsLCBbY29udGV4dCwgLi4uYXJnc10pLCAoKSA9PiBwYXJzZURhdGVUaW1lQXJncyguLi5hcmdzKSwgJ2RhdGV0aW1lIGZvcm1hdCcsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByb290ID0+IHJvb3RbRGF0ZXRpbWVQYXJ0c1N5bWJvbF0oLi4uYXJncyksICgpID0+IFtdLCB2YWwgPT4gaXNTdHJpbmcodmFsKSB8fCBpc0FycmF5KHZhbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQbHVyYWxSdWxlcyhydWxlcykge1xuICAgICAgICBfcGx1cmFsUnVsZXMgPSBydWxlcztcbiAgICAgICAgX2NvbnRleHQucGx1cmFsUnVsZXMgPSBfcGx1cmFsUnVsZXM7XG4gICAgfVxuICAgIC8vIHRlXG4gICAgZnVuY3Rpb24gdGUoa2V5LCBsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gaXNTdHJpbmcobG9jYWxlKSA/IGxvY2FsZSA6IF9sb2NhbGUudmFsdWU7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRMb2NhbGVNZXNzYWdlKHRhcmdldExvY2FsZSk7XG4gICAgICAgIHJldHVybiBfY29udGV4dC5tZXNzYWdlUmVzb2x2ZXIobWVzc2FnZSwga2V5KSAhPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZU1lc3NhZ2VzKGtleSkge1xuICAgICAgICBsZXQgbWVzc2FnZXMgPSBudWxsO1xuICAgICAgICBjb25zdCBsb2NhbGVzID0gZmFsbGJhY2tXaXRoTG9jYWxlQ2hhaW4oX2NvbnRleHQsIF9mYWxsYmFja0xvY2FsZS52YWx1ZSwgX2xvY2FsZS52YWx1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TG9jYWxlTWVzc2FnZXMgPSBfbWVzc2FnZXMudmFsdWVbbG9jYWxlc1tpXV0gfHwge307XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlVmFsdWUgPSBfY29udGV4dC5tZXNzYWdlUmVzb2x2ZXIodGFyZ2V0TG9jYWxlTWVzc2FnZXMsIGtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcyA9IG1lc3NhZ2VWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuICAgIC8vIHRtXG4gICAgZnVuY3Rpb24gdG0oa2V5KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gcmVzb2x2ZU1lc3NhZ2VzKGtleSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gbWVzc2FnZXMgIT0gbnVsbFxuICAgICAgICAgICAgPyBtZXNzYWdlc1xuICAgICAgICAgICAgOiBfX3Jvb3RcbiAgICAgICAgICAgICAgICA/IF9fcm9vdC50bShrZXkpIHx8IHt9XG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICB9XG4gICAgLy8gZ2V0TG9jYWxlTWVzc2FnZVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZU1lc3NhZ2UobG9jYWxlKSB7XG4gICAgICAgIHJldHVybiAoX21lc3NhZ2VzLnZhbHVlW2xvY2FsZV0gfHwge30pO1xuICAgIH1cbiAgICAvLyBzZXRMb2NhbGVNZXNzYWdlXG4gICAgZnVuY3Rpb24gc2V0TG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgX21lc3NhZ2VzLnZhbHVlW2xvY2FsZV0gPSBtZXNzYWdlO1xuICAgICAgICBfY29udGV4dC5tZXNzYWdlcyA9IF9tZXNzYWdlcy52YWx1ZTtcbiAgICB9XG4gICAgLy8gbWVyZ2VMb2NhbGVNZXNzYWdlXG4gICAgZnVuY3Rpb24gbWVyZ2VMb2NhbGVNZXNzYWdlKGxvY2FsZSwgbWVzc2FnZSkge1xuICAgICAgICBfbWVzc2FnZXMudmFsdWVbbG9jYWxlXSA9IF9tZXNzYWdlcy52YWx1ZVtsb2NhbGVdIHx8IHt9O1xuICAgICAgICBkZWVwQ29weShtZXNzYWdlLCBfbWVzc2FnZXMudmFsdWVbbG9jYWxlXSk7XG4gICAgICAgIF9jb250ZXh0Lm1lc3NhZ2VzID0gX21lc3NhZ2VzLnZhbHVlO1xuICAgIH1cbiAgICAvLyBnZXREYXRlVGltZUZvcm1hdFxuICAgIGZ1bmN0aW9uIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gX2RhdGV0aW1lRm9ybWF0cy52YWx1ZVtsb2NhbGVdIHx8IHt9O1xuICAgIH1cbiAgICAvLyBzZXREYXRlVGltZUZvcm1hdFxuICAgIGZ1bmN0aW9uIHNldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgICAgIF9kYXRldGltZUZvcm1hdHMudmFsdWVbbG9jYWxlXSA9IGZvcm1hdDtcbiAgICAgICAgX2NvbnRleHQuZGF0ZXRpbWVGb3JtYXRzID0gX2RhdGV0aW1lRm9ybWF0cy52YWx1ZTtcbiAgICAgICAgY2xlYXJEYXRlVGltZUZvcm1hdChfY29udGV4dCwgbG9jYWxlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvLyBtZXJnZURhdGVUaW1lRm9ybWF0XG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRlVGltZUZvcm1hdChsb2NhbGUsIGZvcm1hdCkge1xuICAgICAgICBfZGF0ZXRpbWVGb3JtYXRzLnZhbHVlW2xvY2FsZV0gPSBhc3NpZ24oX2RhdGV0aW1lRm9ybWF0cy52YWx1ZVtsb2NhbGVdIHx8IHt9LCBmb3JtYXQpO1xuICAgICAgICBfY29udGV4dC5kYXRldGltZUZvcm1hdHMgPSBfZGF0ZXRpbWVGb3JtYXRzLnZhbHVlO1xuICAgICAgICBjbGVhckRhdGVUaW1lRm9ybWF0KF9jb250ZXh0LCBsb2NhbGUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8vIGdldE51bWJlckZvcm1hdFxuICAgIGZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIF9udW1iZXJGb3JtYXRzLnZhbHVlW2xvY2FsZV0gfHwge307XG4gICAgfVxuICAgIC8vIHNldE51bWJlckZvcm1hdFxuICAgIGZ1bmN0aW9uIHNldE51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdCkge1xuICAgICAgICBfbnVtYmVyRm9ybWF0cy52YWx1ZVtsb2NhbGVdID0gZm9ybWF0O1xuICAgICAgICBfY29udGV4dC5udW1iZXJGb3JtYXRzID0gX251bWJlckZvcm1hdHMudmFsdWU7XG4gICAgICAgIGNsZWFyTnVtYmVyRm9ybWF0KF9jb250ZXh0LCBsb2NhbGUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8vIG1lcmdlTnVtYmVyRm9ybWF0XG4gICAgZnVuY3Rpb24gbWVyZ2VOdW1iZXJGb3JtYXQobG9jYWxlLCBmb3JtYXQpIHtcbiAgICAgICAgX251bWJlckZvcm1hdHMudmFsdWVbbG9jYWxlXSA9IGFzc2lnbihfbnVtYmVyRm9ybWF0cy52YWx1ZVtsb2NhbGVdIHx8IHt9LCBmb3JtYXQpO1xuICAgICAgICBfY29udGV4dC5udW1iZXJGb3JtYXRzID0gX251bWJlckZvcm1hdHMudmFsdWU7XG4gICAgICAgIGNsZWFyTnVtYmVyRm9ybWF0KF9jb250ZXh0LCBsb2NhbGUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8vIGZvciBkZWJ1Z1xuICAgIGNvbXBvc2VySUQrKztcbiAgICAvLyB3YXRjaCByb290IGxvY2FsZSAmIGZhbGxiYWNrTG9jYWxlXG4gICAgaWYgKF9fcm9vdCAmJiBpbkJyb3dzZXIpIHtcbiAgICAgICAgd2F0Y2goX19yb290LmxvY2FsZSwgKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKF9pbmhlcml0TG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgX2xvY2FsZS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5sb2NhbGUgPSB2YWw7XG4gICAgICAgICAgICAgICAgdXBkYXRlRmFsbGJhY2tMb2NhbGUoX2NvbnRleHQsIF9sb2NhbGUudmFsdWUsIF9mYWxsYmFja0xvY2FsZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3YXRjaChfX3Jvb3QuZmFsbGJhY2tMb2NhbGUsICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmIChfaW5oZXJpdExvY2FsZSkge1xuICAgICAgICAgICAgICAgIF9mYWxsYmFja0xvY2FsZS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5mYWxsYmFja0xvY2FsZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB1cGRhdGVGYWxsYmFja0xvY2FsZShfY29udGV4dCwgX2xvY2FsZS52YWx1ZSwgX2ZhbGxiYWNrTG9jYWxlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGRlZmluZSBiYXNpYyBjb21wb3NpdGlvbiBBUEkhXG4gICAgY29uc3QgY29tcG9zZXIgPSB7XG4gICAgICAgIGlkOiBjb21wb3NlcklELFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIGZhbGxiYWNrTG9jYWxlLFxuICAgICAgICBnZXQgaW5oZXJpdExvY2FsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfaW5oZXJpdExvY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGluaGVyaXRMb2NhbGUodmFsKSB7XG4gICAgICAgICAgICBfaW5oZXJpdExvY2FsZSA9IHZhbDtcbiAgICAgICAgICAgIGlmICh2YWwgJiYgX19yb290KSB7XG4gICAgICAgICAgICAgICAgX2xvY2FsZS52YWx1ZSA9IF9fcm9vdC5sb2NhbGUudmFsdWU7XG4gICAgICAgICAgICAgICAgX2ZhbGxiYWNrTG9jYWxlLnZhbHVlID0gX19yb290LmZhbGxiYWNrTG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZhbGxiYWNrTG9jYWxlKF9jb250ZXh0LCBfbG9jYWxlLnZhbHVlLCBfZmFsbGJhY2tMb2NhbGUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQgYXZhaWxhYmxlTG9jYWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhfbWVzc2FnZXMudmFsdWUpLnNvcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIGdldCBtb2RpZmllcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX21vZGlmaWVycztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsdXJhbFJ1bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9wbHVyYWxSdWxlcyB8fCB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzR2xvYmFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pc0dsb2JhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IG1pc3NpbmdXYXJuKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9taXNzaW5nV2FybjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IG1pc3NpbmdXYXJuKHZhbCkge1xuICAgICAgICAgICAgX21pc3NpbmdXYXJuID0gdmFsO1xuICAgICAgICAgICAgX2NvbnRleHQubWlzc2luZ1dhcm4gPSBfbWlzc2luZ1dhcm47XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBmYWxsYmFja1dhcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZhbGxiYWNrV2FybjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGZhbGxiYWNrV2Fybih2YWwpIHtcbiAgICAgICAgICAgIF9mYWxsYmFja1dhcm4gPSB2YWw7XG4gICAgICAgICAgICBfY29udGV4dC5mYWxsYmFja1dhcm4gPSBfZmFsbGJhY2tXYXJuO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZmFsbGJhY2tSb290KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9mYWxsYmFja1Jvb3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmYWxsYmFja1Jvb3QodmFsKSB7XG4gICAgICAgICAgICBfZmFsbGJhY2tSb290ID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZmFsbGJhY2tGb3JtYXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZhbGxiYWNrRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZmFsbGJhY2tGb3JtYXQodmFsKSB7XG4gICAgICAgICAgICBfZmFsbGJhY2tGb3JtYXQgPSB2YWw7XG4gICAgICAgICAgICBfY29udGV4dC5mYWxsYmFja0Zvcm1hdCA9IF9mYWxsYmFja0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHdhcm5IdG1sTWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfd2Fybkh0bWxNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgd2Fybkh0bWxNZXNzYWdlKHZhbCkge1xuICAgICAgICAgICAgX3dhcm5IdG1sTWVzc2FnZSA9IHZhbDtcbiAgICAgICAgICAgIF9jb250ZXh0Lndhcm5IdG1sTWVzc2FnZSA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVzY2FwZVBhcmFtZXRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXNjYXBlUGFyYW1ldGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZXNjYXBlUGFyYW1ldGVyKHZhbCkge1xuICAgICAgICAgICAgX2VzY2FwZVBhcmFtZXRlciA9IHZhbDtcbiAgICAgICAgICAgIF9jb250ZXh0LmVzY2FwZVBhcmFtZXRlciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgdCxcbiAgICAgICAgZ2V0TG9jYWxlTWVzc2FnZSxcbiAgICAgICAgc2V0TG9jYWxlTWVzc2FnZSxcbiAgICAgICAgbWVyZ2VMb2NhbGVNZXNzYWdlLFxuICAgICAgICBnZXRQb3N0VHJhbnNsYXRpb25IYW5kbGVyLFxuICAgICAgICBzZXRQb3N0VHJhbnNsYXRpb25IYW5kbGVyLFxuICAgICAgICBnZXRNaXNzaW5nSGFuZGxlcixcbiAgICAgICAgc2V0TWlzc2luZ0hhbmRsZXIsXG4gICAgICAgIFtTZXRQbHVyYWxSdWxlc1N5bWJvbF06IHNldFBsdXJhbFJ1bGVzXG4gICAgfTtcbiAgICB7XG4gICAgICAgIGNvbXBvc2VyLmRhdGV0aW1lRm9ybWF0cyA9IGRhdGV0aW1lRm9ybWF0cztcbiAgICAgICAgY29tcG9zZXIubnVtYmVyRm9ybWF0cyA9IG51bWJlckZvcm1hdHM7XG4gICAgICAgIGNvbXBvc2VyLnJ0ID0gcnQ7XG4gICAgICAgIGNvbXBvc2VyLnRlID0gdGU7XG4gICAgICAgIGNvbXBvc2VyLnRtID0gdG07XG4gICAgICAgIGNvbXBvc2VyLmQgPSBkO1xuICAgICAgICBjb21wb3Nlci5uID0gbjtcbiAgICAgICAgY29tcG9zZXIuZ2V0RGF0ZVRpbWVGb3JtYXQgPSBnZXREYXRlVGltZUZvcm1hdDtcbiAgICAgICAgY29tcG9zZXIuc2V0RGF0ZVRpbWVGb3JtYXQgPSBzZXREYXRlVGltZUZvcm1hdDtcbiAgICAgICAgY29tcG9zZXIubWVyZ2VEYXRlVGltZUZvcm1hdCA9IG1lcmdlRGF0ZVRpbWVGb3JtYXQ7XG4gICAgICAgIGNvbXBvc2VyLmdldE51bWJlckZvcm1hdCA9IGdldE51bWJlckZvcm1hdDtcbiAgICAgICAgY29tcG9zZXIuc2V0TnVtYmVyRm9ybWF0ID0gc2V0TnVtYmVyRm9ybWF0O1xuICAgICAgICBjb21wb3Nlci5tZXJnZU51bWJlckZvcm1hdCA9IG1lcmdlTnVtYmVyRm9ybWF0O1xuICAgICAgICBjb21wb3NlcltJbmVqY3RXaXRoT3B0aW9uXSA9IG9wdGlvbnMuX19pbmplY3RXaXRoT3B0aW9uO1xuICAgICAgICBjb21wb3NlcltUcmFuc2xhdGVWTm9kZVN5bWJvbF0gPSB0cmFuc2xhdGVWTm9kZTtcbiAgICAgICAgY29tcG9zZXJbRGF0ZXRpbWVQYXJ0c1N5bWJvbF0gPSBkYXRldGltZVBhcnRzO1xuICAgICAgICBjb21wb3NlcltOdW1iZXJQYXJ0c1N5bWJvbF0gPSBudW1iZXJQYXJ0cztcbiAgICB9XG4gICAgLy8gZm9yIHZ1ZS1kZXZ0b29scyB0aW1lbGluZSBldmVudFxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29tcG9zZXJbRW5hYmxlRW1pdHRlcl0gPSAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgX2NvbnRleHQuX192X2VtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICB9O1xuICAgICAgICBjb21wb3NlcltEaXNhYmxlRW1pdHRlcl0gPSAoKSA9PiB7XG4gICAgICAgICAgICBfY29udGV4dC5fX3ZfZW1pdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvc2VyO1xufVxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQ29udmVydCB0byBJMThuIENvbXBvc2VyIE9wdGlvbnMgZnJvbSBWdWVJMThuIE9wdGlvbnNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY29udmVydENvbXBvc2VyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgbG9jYWxlID0gaXNTdHJpbmcob3B0aW9ucy5sb2NhbGUpID8gb3B0aW9ucy5sb2NhbGUgOiBERUZBVUxUX0xPQ0FMRTtcbiAgICBjb25zdCBmYWxsYmFja0xvY2FsZSA9IGlzU3RyaW5nKG9wdGlvbnMuZmFsbGJhY2tMb2NhbGUpIHx8XG4gICAgICAgIGlzQXJyYXkob3B0aW9ucy5mYWxsYmFja0xvY2FsZSkgfHxcbiAgICAgICAgaXNQbGFpbk9iamVjdChvcHRpb25zLmZhbGxiYWNrTG9jYWxlKSB8fFxuICAgICAgICBvcHRpb25zLmZhbGxiYWNrTG9jYWxlID09PSBmYWxzZVxuICAgICAgICA/IG9wdGlvbnMuZmFsbGJhY2tMb2NhbGVcbiAgICAgICAgOiBsb2NhbGU7XG4gICAgY29uc3QgbWlzc2luZyA9IGlzRnVuY3Rpb24ob3B0aW9ucy5taXNzaW5nKSA/IG9wdGlvbnMubWlzc2luZyA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtaXNzaW5nV2FybiA9IGlzQm9vbGVhbihvcHRpb25zLnNpbGVudFRyYW5zbGF0aW9uV2FybikgfHxcbiAgICAgICAgaXNSZWdFeHAob3B0aW9ucy5zaWxlbnRUcmFuc2xhdGlvbldhcm4pXG4gICAgICAgID8gIW9wdGlvbnMuc2lsZW50VHJhbnNsYXRpb25XYXJuXG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBmYWxsYmFja1dhcm4gPSBpc0Jvb2xlYW4ob3B0aW9ucy5zaWxlbnRGYWxsYmFja1dhcm4pIHx8XG4gICAgICAgIGlzUmVnRXhwKG9wdGlvbnMuc2lsZW50RmFsbGJhY2tXYXJuKVxuICAgICAgICA/ICFvcHRpb25zLnNpbGVudEZhbGxiYWNrV2FyblxuICAgICAgICA6IHRydWU7XG4gICAgY29uc3QgZmFsbGJhY2tSb290ID0gaXNCb29sZWFuKG9wdGlvbnMuZmFsbGJhY2tSb290KVxuICAgICAgICA/IG9wdGlvbnMuZmFsbGJhY2tSb290XG4gICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBmYWxsYmFja0Zvcm1hdCA9ICEhb3B0aW9ucy5mb3JtYXRGYWxsYmFja01lc3NhZ2VzO1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IGlzUGxhaW5PYmplY3Qob3B0aW9ucy5tb2RpZmllcnMpID8gb3B0aW9ucy5tb2RpZmllcnMgOiB7fTtcbiAgICBjb25zdCBwbHVyYWxpemF0aW9uUnVsZXMgPSBvcHRpb25zLnBsdXJhbGl6YXRpb25SdWxlcztcbiAgICBjb25zdCBwb3N0VHJhbnNsYXRpb24gPSBpc0Z1bmN0aW9uKG9wdGlvbnMucG9zdFRyYW5zbGF0aW9uKVxuICAgICAgICA/IG9wdGlvbnMucG9zdFRyYW5zbGF0aW9uXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHdhcm5IdG1sTWVzc2FnZSA9IGlzU3RyaW5nKG9wdGlvbnMud2Fybkh0bWxJbk1lc3NhZ2UpXG4gICAgICAgID8gb3B0aW9ucy53YXJuSHRtbEluTWVzc2FnZSAhPT0gJ29mZidcbiAgICAgICAgOiB0cnVlO1xuICAgIGNvbnN0IGVzY2FwZVBhcmFtZXRlciA9ICEhb3B0aW9ucy5lc2NhcGVQYXJhbWV0ZXJIdG1sO1xuICAgIGNvbnN0IGluaGVyaXRMb2NhbGUgPSBpc0Jvb2xlYW4ob3B0aW9ucy5zeW5jKSA/IG9wdGlvbnMuc3luYyA6IHRydWU7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBvcHRpb25zLmZvcm1hdHRlcikge1xuICAgICAgICB3YXJuKGdldFdhcm5NZXNzYWdlKEkxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9GT1JNQVRURVIpKTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBvcHRpb25zLnByZXNlcnZlRGlyZWN0aXZlQ29udGVudCkge1xuICAgICAgICB3YXJuKGdldFdhcm5NZXNzYWdlKEkxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9QUkVTRVJWRV9ESVJFQ1RJVkUpKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zLnNoYXJlZE1lc3NhZ2VzKSkge1xuICAgICAgICBjb25zdCBzaGFyZWRNZXNzYWdlcyA9IG9wdGlvbnMuc2hhcmVkTWVzc2FnZXM7XG4gICAgICAgIGNvbnN0IGxvY2FsZXMgPSBPYmplY3Qua2V5cyhzaGFyZWRNZXNzYWdlcyk7XG4gICAgICAgIG1lc3NhZ2VzID0gbG9jYWxlcy5yZWR1Y2UoKG1lc3NhZ2VzLCBsb2NhbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tsb2NhbGVdIHx8IChtZXNzYWdlc1tsb2NhbGVdID0ge30pO1xuICAgICAgICAgICAgYXNzaWduKG1lc3NhZ2UsIHNoYXJlZE1lc3NhZ2VzW2xvY2FsZV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICB9LCAobWVzc2FnZXMgfHwge30pKTtcbiAgICB9XG4gICAgY29uc3QgeyBfX2kxOG4sIF9fcm9vdCwgX19pbmplY3RXaXRoT3B0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRhdGV0aW1lRm9ybWF0cyA9IG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzO1xuICAgIGNvbnN0IG51bWJlckZvcm1hdHMgPSBvcHRpb25zLm51bWJlckZvcm1hdHM7XG4gICAgY29uc3QgZmxhdEpzb24gPSBvcHRpb25zLmZsYXRKc29uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgZmFsbGJhY2tMb2NhbGUsXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBmbGF0SnNvbixcbiAgICAgICAgZGF0ZXRpbWVGb3JtYXRzLFxuICAgICAgICBudW1iZXJGb3JtYXRzLFxuICAgICAgICBtaXNzaW5nLFxuICAgICAgICBtaXNzaW5nV2FybixcbiAgICAgICAgZmFsbGJhY2tXYXJuLFxuICAgICAgICBmYWxsYmFja1Jvb3QsXG4gICAgICAgIGZhbGxiYWNrRm9ybWF0LFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIHBsdXJhbFJ1bGVzOiBwbHVyYWxpemF0aW9uUnVsZXMsXG4gICAgICAgIHBvc3RUcmFuc2xhdGlvbixcbiAgICAgICAgd2Fybkh0bWxNZXNzYWdlLFxuICAgICAgICBlc2NhcGVQYXJhbWV0ZXIsXG4gICAgICAgIG1lc3NhZ2VSZXNvbHZlcjogb3B0aW9ucy5tZXNzYWdlUmVzb2x2ZXIsXG4gICAgICAgIGluaGVyaXRMb2NhbGUsXG4gICAgICAgIF9faTE4bixcbiAgICAgICAgX19yb290LFxuICAgICAgICBfX2luamVjdFdpdGhPcHRpb25cbiAgICB9O1xufVxuLyoqXG4gKiBjcmVhdGUgVnVlSTE4biBpbnRlcmZhY2UgZmFjdG9yeVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gY3JlYXRlVnVlSTE4bihvcHRpb25zID0ge30sIFZ1ZUkxOG5MZWdhY3kpIHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbXBvc2VyID0gY3JlYXRlQ29tcG9zZXIoY29udmVydENvbXBvc2VyT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgIC8vIGRlZmluZXMgVnVlSTE4blxuICAgICAgICBjb25zdCB2dWVJMThuID0ge1xuICAgICAgICAgICAgLy8gaWRcbiAgICAgICAgICAgIGlkOiBjb21wb3Nlci5pZCxcbiAgICAgICAgICAgIC8vIGxvY2FsZVxuICAgICAgICAgICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIubG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBsb2NhbGUodmFsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9zZXIubG9jYWxlLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrTG9jYWxlXG4gICAgICAgICAgICBnZXQgZmFsbGJhY2tMb2NhbGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLmZhbGxiYWNrTG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBmYWxsYmFja0xvY2FsZSh2YWwpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5mYWxsYmFja0xvY2FsZS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBtZXNzYWdlc1xuICAgICAgICAgICAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3Nlci5tZXNzYWdlcy52YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBkYXRldGltZUZvcm1hdHNcbiAgICAgICAgICAgIGdldCBkYXRldGltZUZvcm1hdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLmRhdGV0aW1lRm9ybWF0cy52YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBudW1iZXJGb3JtYXRzXG4gICAgICAgICAgICBnZXQgbnVtYmVyRm9ybWF0cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIubnVtYmVyRm9ybWF0cy52YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhdmFpbGFibGVMb2NhbGVzXG4gICAgICAgICAgICBnZXQgYXZhaWxhYmxlTG9jYWxlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIuYXZhaWxhYmxlTG9jYWxlcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBmb3JtYXR0ZXJcbiAgICAgICAgICAgIGdldCBmb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oZ2V0V2Fybk1lc3NhZ2UoSTE4bldhcm5Db2Rlcy5OT1RfU1VQUE9SVEVEX0ZPUk1BVFRFUikpO1xuICAgICAgICAgICAgICAgIC8vIGR1bW15XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBmb3JtYXR0ZXIodmFsKSB7XG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oZ2V0V2Fybk1lc3NhZ2UoSTE4bldhcm5Db2Rlcy5OT1RfU1VQUE9SVEVEX0ZPUk1BVFRFUikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG1pc3NpbmdcbiAgICAgICAgICAgIGdldCBtaXNzaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3Nlci5nZXRNaXNzaW5nSGFuZGxlcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBtaXNzaW5nKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5zZXRNaXNzaW5nSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBzaWxlbnRUcmFuc2xhdGlvbldhcm5cbiAgICAgICAgICAgIGdldCBzaWxlbnRUcmFuc2xhdGlvbldhcm4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQm9vbGVhbihjb21wb3Nlci5taXNzaW5nV2FybilcbiAgICAgICAgICAgICAgICAgICAgPyAhY29tcG9zZXIubWlzc2luZ1dhcm5cbiAgICAgICAgICAgICAgICAgICAgOiBjb21wb3Nlci5taXNzaW5nV2FybjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgc2lsZW50VHJhbnNsYXRpb25XYXJuKHZhbCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLm1pc3NpbmdXYXJuID0gaXNCb29sZWFuKHZhbCkgPyAhdmFsIDogdmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHNpbGVudEZhbGxiYWNrV2FyblxuICAgICAgICAgICAgZ2V0IHNpbGVudEZhbGxiYWNrV2FybigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNCb29sZWFuKGNvbXBvc2VyLmZhbGxiYWNrV2FybilcbiAgICAgICAgICAgICAgICAgICAgPyAhY29tcG9zZXIuZmFsbGJhY2tXYXJuXG4gICAgICAgICAgICAgICAgICAgIDogY29tcG9zZXIuZmFsbGJhY2tXYXJuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBzaWxlbnRGYWxsYmFja1dhcm4odmFsKSB7XG4gICAgICAgICAgICAgICAgY29tcG9zZXIuZmFsbGJhY2tXYXJuID0gaXNCb29sZWFuKHZhbCkgPyAhdmFsIDogdmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgICAgICAgZ2V0IG1vZGlmaWVycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIubW9kaWZpZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGZvcm1hdEZhbGxiYWNrTWVzc2FnZXNcbiAgICAgICAgICAgIGdldCBmb3JtYXRGYWxsYmFja01lc3NhZ2VzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3Nlci5mYWxsYmFja0Zvcm1hdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgZm9ybWF0RmFsbGJhY2tNZXNzYWdlcyh2YWwpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5mYWxsYmFja0Zvcm1hdCA9IHZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwb3N0VHJhbnNsYXRpb25cbiAgICAgICAgICAgIGdldCBwb3N0VHJhbnNsYXRpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLmdldFBvc3RUcmFuc2xhdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgcG9zdFRyYW5zbGF0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5zZXRQb3N0VHJhbnNsYXRpb25IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHN5bmNcbiAgICAgICAgICAgIGdldCBzeW5jKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3Nlci5pbmhlcml0TG9jYWxlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBzeW5jKHZhbCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLmluaGVyaXRMb2NhbGUgPSB2YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gd2FybkluSHRtbE1lc3NhZ2VcbiAgICAgICAgICAgIGdldCB3YXJuSHRtbEluTWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIud2Fybkh0bWxNZXNzYWdlID8gJ3dhcm4nIDogJ29mZic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IHdhcm5IdG1sSW5NZXNzYWdlKHZhbCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLndhcm5IdG1sTWVzc2FnZSA9IHZhbCAhPT0gJ29mZic7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNjYXBlUGFyYW1ldGVySHRtbFxuICAgICAgICAgICAgZ2V0IGVzY2FwZVBhcmFtZXRlckh0bWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLmVzY2FwZVBhcmFtZXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgZXNjYXBlUGFyYW1ldGVySHRtbCh2YWwpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5lc2NhcGVQYXJhbWV0ZXIgPSB2YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcHJlc2VydmVEaXJlY3RpdmVDb250ZW50XG4gICAgICAgICAgICBnZXQgcHJlc2VydmVEaXJlY3RpdmVDb250ZW50KCkge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuKGdldFdhcm5NZXNzYWdlKEkxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9QUkVTRVJWRV9ESVJFQ1RJVkUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgcHJlc2VydmVEaXJlY3RpdmVDb250ZW50KHZhbCkge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuKGdldFdhcm5NZXNzYWdlKEkxOG5XYXJuQ29kZXMuTk9UX1NVUFBPUlRFRF9QUkVTRVJWRV9ESVJFQ1RJVkUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwbHVyYWxpemF0aW9uUnVsZXNcbiAgICAgICAgICAgIGdldCBwbHVyYWxpemF0aW9uUnVsZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLnBsdXJhbFJ1bGVzIHx8IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGZvciBpbnRlcm5hbFxuICAgICAgICAgICAgX19jb21wb3NlcjogY29tcG9zZXIsXG4gICAgICAgICAgICAvLyB0XG4gICAgICAgICAgICB0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYXJnMSwgYXJnMiwgYXJnM10gPSBhcmdzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5JTlZBTElEX0FSR1VNRU5UKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYXJnMikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGFyZzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVkID0gYXJnMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnMykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGFyZzM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoYXJnMykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZWQgPSBhcmczO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gY29tcG9zZXIudChrZXksIChsaXN0IHx8IG5hbWVkIHx8IHt9KSBhcyBhbnksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkoY29tcG9zZXIudCwgY29tcG9zZXIsIFtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAobGlzdCB8fCBuYW1lZCB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydCguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkoY29tcG9zZXIucnQsIGNvbXBvc2VyLCBbLi4uYXJnc10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHRjXG4gICAgICAgICAgICB0YyguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2FyZzEsIGFyZzIsIGFyZzNdID0gYXJncztcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyBwbHVyYWw6IDEgfTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5JTlZBTElEX0FSR1VNRU5UKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYXJnMikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcihhcmcyKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBsdXJhbCA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoYXJnMikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoYXJnMikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZWQgPSBhcmcyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYXJnMykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBhcmczO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGFyZzMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBhcmczO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGFyZzMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVkID0gYXJnMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGNvbXBvc2VyLnQoa2V5LCAobGlzdCB8fCBuYW1lZCB8fCB7fSkgYXMgYW55LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KGNvbXBvc2VyLnQsIGNvbXBvc2VyLCBbXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgKGxpc3QgfHwgbmFtZWQgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdGVcbiAgICAgICAgICAgIHRlKGtleSwgbG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLnRlKGtleSwgbG9jYWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyB0bVxuICAgICAgICAgICAgdG0oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VyLnRtKGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZ2V0TG9jYWxlTWVzc2FnZVxuICAgICAgICAgICAgZ2V0TG9jYWxlTWVzc2FnZShsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIuZ2V0TG9jYWxlTWVzc2FnZShsb2NhbGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHNldExvY2FsZU1lc3NhZ2VcbiAgICAgICAgICAgIHNldExvY2FsZU1lc3NhZ2UobG9jYWxlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9zZXIuc2V0TG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG1lcmdlTG9jYWxlTWVzc2FnZVxuICAgICAgICAgICAgbWVyZ2VMb2NhbGVNZXNzYWdlKGxvY2FsZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLm1lcmdlTG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGRcbiAgICAgICAgICAgIGQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KGNvbXBvc2VyLmQsIGNvbXBvc2VyLCBbLi4uYXJnc10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGdldERhdGVUaW1lRm9ybWF0XG4gICAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZXIuZ2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBzZXREYXRlVGltZUZvcm1hdFxuICAgICAgICAgICAgc2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjb21wb3Nlci5zZXREYXRlVGltZUZvcm1hdChsb2NhbGUsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gbWVyZ2VEYXRlVGltZUZvcm1hdFxuICAgICAgICAgICAgbWVyZ2VEYXRlVGltZUZvcm1hdChsb2NhbGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLm1lcmdlRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIG5cbiAgICAgICAgICAgIG4oLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KGNvbXBvc2VyLm4sIGNvbXBvc2VyLCBbLi4uYXJnc10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGdldE51bWJlckZvcm1hdFxuICAgICAgICAgICAgZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3Nlci5nZXROdW1iZXJGb3JtYXQobG9jYWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBzZXROdW1iZXJGb3JtYXRcbiAgICAgICAgICAgIHNldE51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2VyLnNldE51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gbWVyZ2VOdW1iZXJGb3JtYXRcbiAgICAgICAgICAgIG1lcmdlTnVtYmVyRm9ybWF0KGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY29tcG9zZXIubWVyZ2VOdW1iZXJGb3JtYXQobG9jYWxlLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGdldENob2ljZUluZGV4XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBnZXRDaG9pY2VJbmRleChjaG9pY2UsIGNob2ljZXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgd2FybihnZXRXYXJuTWVzc2FnZShJMThuV2FybkNvZGVzLk5PVF9TVVBQT1JURURfR0VUX0NIT0lDRV9JTkRFWCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBmb3IgaW50ZXJuYWxcbiAgICAgICAgICAgIF9fb25Db21wb25lbnRJbnN0YW5jZUNyZWF0ZWQodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnRJbnN0YW5jZUNyZWF0ZWRMaXN0ZW5lciB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50SW5zdGFuY2VDcmVhdGVkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2VDcmVhdGVkTGlzdGVuZXIodGFyZ2V0LCB2dWVJMThuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciB2dWUtZGV2dG9vbHMgdGltZWxpbmUgZXZlbnRcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgdnVlSTE4bi5fX2VuYWJsZUVtaXR0ZXIgPSAoZW1pdHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9fY29tcG9zZXIgPSBjb21wb3NlcjtcbiAgICAgICAgICAgICAgICBfX2NvbXBvc2VyW0VuYWJsZUVtaXR0ZXJdICYmIF9fY29tcG9zZXJbRW5hYmxlRW1pdHRlcl0oZW1pdHRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdnVlSTE4bi5fX2Rpc2FibGVFbWl0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9fY29tcG9zZXIgPSBjb21wb3NlcjtcbiAgICAgICAgICAgICAgICBfX2NvbXBvc2VyW0Rpc2FibGVFbWl0dGVyXSAmJiBfX2NvbXBvc2VyW0Rpc2FibGVFbWl0dGVyXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdnVlSTE4bjtcbiAgICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuY29uc3QgYmFzZUZvcm1hdFByb3BzID0ge1xuICAgIHRhZzoge1xuICAgICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3RdXG4gICAgfSxcbiAgICBsb2NhbGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIC8vIE5PVEU6IGF2b2lkIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvcnVzaHN0YWNrL2lzc3Vlcy8xMDUwXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbCAvKiBDb21wb25lbnRJMThuU2NvcGUgKi8pID0+IHZhbCA9PT0gJ3BhcmVudCcgfHwgdmFsID09PSAnZ2xvYmFsJyxcbiAgICAgICAgZGVmYXVsdDogJ3BhcmVudCcgLyogQ29tcG9uZW50STE4blNjb3BlICovXG4gICAgfSxcbiAgICBpMThuOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdldEludGVycG9sYXRlQXJnKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnsgc2xvdHMgfSwgLy8gU2V0dXBDb250ZXh0LFxua2V5cykge1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBzbG90IHdpdGggbGlzdFxuICAgICAgICBjb25zdCByZXQgPSBzbG90cy5kZWZhdWx0ID8gc2xvdHMuZGVmYXVsdCgpIDogW107XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiByZXQucmVkdWNlKChzbG90LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLnNsb3QsXG4gICAgICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICAgICAgLi4uKGN1cnJlbnQudHlwZSA9PT0gRnJhZ21lbnQgPyBjdXJyZW50LmNoaWxkcmVuIDogW2N1cnJlbnRdXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG5hbWVkIHNsb3RzXG4gICAgICAgIHJldHVybiBrZXlzLnJlZHVjZSgoYXJnLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBzbG90c1trZXldO1xuICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICBhcmdba2V5XSA9IHNsb3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRhYmxlVGFnKHRhZykge1xuICAgIHJldHVybiBGcmFnbWVudCA7XG59XG5cbmNvbnN0IFRyYW5zbGF0aW9uSW1wbCA9IC8qI19fUFVSRV9fKi8gZGVmaW5lQ29tcG9uZW50KHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIG5hbWU6ICdpMThuLXQnLFxuICAgIHByb3BzOiBhc3NpZ24oe1xuICAgICAgICBrZXlwYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwbHVyYWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdmFsaWRhdG9yOiAodmFsKSA9PiBpc051bWJlcih2YWwpIHx8ICFpc05hTih2YWwpXG4gICAgICAgIH1cbiAgICB9LCBiYXNlRm9ybWF0UHJvcHMpLFxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgc2xvdHMsIGF0dHJzIH0gPSBjb250ZXh0O1xuICAgICAgICAvLyBOT1RFOiBhdm9pZCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3J1c2hzdGFjay9pc3N1ZXMvMTA1MFxuICAgICAgICBjb25zdCBpMThuID0gcHJvcHMuaTE4biB8fFxuICAgICAgICAgICAgdXNlSTE4bih7XG4gICAgICAgICAgICAgICAgdXNlU2NvcGU6IHByb3BzLnNjb3BlLFxuICAgICAgICAgICAgICAgIF9fdXNlQ29tcG9uZW50OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzbG90cykuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdfJyk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAocHJvcHMubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMucGx1cmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBsdXJhbCA9IGlzU3RyaW5nKHByb3BzLnBsdXJhbCkgPyArcHJvcHMucGx1cmFsIDogcHJvcHMucGx1cmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJnID0gZ2V0SW50ZXJwb2xhdGVBcmcoY29udGV4dCwga2V5cyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBpMThuW1RyYW5zbGF0ZVZOb2RlU3ltYm9sXShwcm9wcy5rZXlwYXRoLCBhcmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgYXNzaWduZWRBdHRycyA9IGFzc2lnbih7fSwgYXR0cnMpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gaXNTdHJpbmcocHJvcHMudGFnKSB8fCBpc09iamVjdChwcm9wcy50YWcpXG4gICAgICAgICAgICAgICAgPyBwcm9wcy50YWdcbiAgICAgICAgICAgICAgICA6IGdldEZyYWdtZW50YWJsZVRhZygpO1xuICAgICAgICAgICAgcmV0dXJuIGgodGFnLCBhc3NpZ25lZEF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgfVxufSk7XG4vKipcbiAqIGV4cG9ydCB0aGUgcHVibGljIHR5cGUgZm9yIGgvdHN4IGluZmVyZW5jZVxuICogYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcbiAqL1xuLyoqXG4gKiBUcmFuc2xhdGlvbiBDb21wb25lbnRcbiAqXG4gKiBAcmVtYXJrc1xuICogU2VlIHRoZSBmb2xsb3dpbmcgaXRlbXMgZm9yIHByb3BlcnR5IGFib3V0IGRldGFpbHNcbiAqXG4gKiBAVnVlSTE4blNlZSBbVHJhbnNsYXRpb25Qcm9wc10oY29tcG9uZW50I3RyYW5zbGF0aW9ucHJvcHMpXG4gKiBAVnVlSTE4blNlZSBbQmFzZUZvcm1hdFByb3BzXShjb21wb25lbnQjYmFzZWZvcm1hdHByb3BzKVxuICogQFZ1ZUkxOG5TZWUgW0NvbXBvbmVudCBJbnRlcnBvbGF0aW9uXSguLi9ndWlkZS9hZHZhbmNlZC9jb21wb25lbnQpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxkaXYgaWQ9XCJhcHBcIj5cbiAqICAgPCEtLSAuLi4gLS0+XG4gKiAgIDxpMThuIGtleXBhdGg9XCJ0ZXJtXCIgdGFnPVwibGFiZWxcIiBmb3I9XCJ0b3NcIj5cbiAqICAgICA8YSA6aHJlZj1cInVybFwiIHRhcmdldD1cIl9ibGFua1wiPnt7ICR0KCd0b3MnKSB9fTwvYT5cbiAqICAgPC9pMThuPlxuICogICA8IS0tIC4uLiAtLT5cbiAqIDwvZGl2PlxuICogYGBgXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlQXBwIH0gZnJvbSAndnVlJ1xuICogaW1wb3J0IHsgY3JlYXRlSTE4biB9IGZyb20gJ3Z1ZS1pMThuJ1xuICpcbiAqIGNvbnN0IG1lc3NhZ2VzID0ge1xuICogICBlbjoge1xuICogICAgIHRvczogJ1Rlcm0gb2YgU2VydmljZScsXG4gKiAgICAgdGVybTogJ0kgYWNjZXB0IHh4eCB7MH0uJ1xuICogICB9LFxuICogICBqYToge1xuICogICAgIHRvczogJ+WIqeeUqOimj+e0hCcsXG4gKiAgICAgdGVybTogJ+engeOBryB4eHgg44GuezB944Gr5ZCM5oSP44GX44G+44GZ44CCJ1xuICogICB9XG4gKiB9XG4gKlxuICogY29uc3QgaTE4biA9IGNyZWF0ZUkxOG4oe1xuICogICBsb2NhbGU6ICdlbicsXG4gKiAgIG1lc3NhZ2VzXG4gKiB9KVxuICpcbiAqIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcCh7XG4gKiAgIGRhdGE6IHtcbiAqICAgICB1cmw6ICcvdGVybSdcbiAqICAgfVxuICogfSkudXNlKGkxOG4pLm1vdW50KCcjYXBwJylcbiAqIGBgYFxuICpcbiAqIEBWdWVJMThuQ29tcG9uZW50XG4gKi9cbmNvbnN0IFRyYW5zbGF0aW9uID0gVHJhbnNsYXRpb25JbXBsO1xuY29uc3QgSTE4blQgPSBUcmFuc2xhdGlvbjtcblxuZnVuY3Rpb24gaXNWTm9kZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNBcnJheSh0YXJnZXQpICYmICFpc1N0cmluZyh0YXJnZXRbMF0pO1xufVxuZnVuY3Rpb24gcmVuZGVyRm9ybWF0dGVyKHByb3BzLCBjb250ZXh0LCBzbG90S2V5cywgcGFydEZvcm1hdHRlcikge1xuICAgIGNvbnN0IHsgc2xvdHMsIGF0dHJzIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHBhcnQ6IHRydWUgfTtcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMubG9jYWxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IHByb3BzLmxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcocHJvcHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgb3B0aW9ucy5rZXkgPSBwcm9wcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QocHJvcHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhwcm9wcy5mb3JtYXQua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5rZXkgPSBwcm9wcy5mb3JtYXQua2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBudW1iZXIgZm9ybWF0IG9wdGlvbnMgb25seVxuICAgICAgICAgICAgb3ZlcnJpZGVzID0gT2JqZWN0LmtleXMocHJvcHMuZm9ybWF0KS5yZWR1Y2UoKG9wdGlvbnMsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xvdEtleXMuaW5jbHVkZXMocHJvcClcbiAgICAgICAgICAgICAgICAgICAgPyBhc3NpZ24oe30sIG9wdGlvbnMsIHsgW3Byb3BdOiBwcm9wcy5mb3JtYXRbcHJvcF0gfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIDogb3B0aW9ucztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhcnRGb3JtYXR0ZXIoLi4uW3Byb3BzLnZhbHVlLCBvcHRpb25zLCBvdmVycmlkZXNdKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW29wdGlvbnMua2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkocGFydHMpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gc2xvdHNbcGFydC50eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gc2xvdFxuICAgICAgICAgICAgICAgICAgICA/IHNsb3QoeyBbcGFydC50eXBlXTogcGFydC52YWx1ZSwgaW5kZXgsIHBhcnRzIH0pXG4gICAgICAgICAgICAgICAgICAgIDogW3BhcnQudmFsdWVdO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbMF0ua2V5ID0gYCR7cGFydC50eXBlfS0ke2luZGV4fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcocGFydHMpKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtwYXJ0c107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzaWduZWRBdHRycyA9IGFzc2lnbih7fSwgYXR0cnMpO1xuICAgICAgICBjb25zdCB0YWcgPSBpc1N0cmluZyhwcm9wcy50YWcpIHx8IGlzT2JqZWN0KHByb3BzLnRhZylcbiAgICAgICAgICAgID8gcHJvcHMudGFnXG4gICAgICAgICAgICA6IGdldEZyYWdtZW50YWJsZVRhZygpO1xuICAgICAgICByZXR1cm4gaCh0YWcsIGFzc2lnbmVkQXR0cnMsIGNoaWxkcmVuKTtcbiAgICB9O1xufVxuXG5jb25zdCBOdW1iZXJGb3JtYXRJbXBsID0gLyojX19QVVJFX18qLyBkZWZpbmVDb21wb25lbnQoe1xuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgbmFtZTogJ2kxOG4tbicsXG4gICAgcHJvcHM6IGFzc2lnbih7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF1cbiAgICAgICAgfVxuICAgIH0sIGJhc2VGb3JtYXRQcm9wcyksXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaTE4biA9IHByb3BzLmkxOG4gfHxcbiAgICAgICAgICAgIHVzZUkxOG4oe1xuICAgICAgICAgICAgICAgIHVzZVNjb3BlOiAncGFyZW50JyxcbiAgICAgICAgICAgICAgICBfX3VzZUNvbXBvbmVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZW5kZXJGb3JtYXR0ZXIocHJvcHMsIGNvbnRleHQsIE5VTUJFUl9GT1JNQVRfT1BUSU9OU19LRVlTLCAoLi4uYXJncykgPT4gXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGkxOG5bTnVtYmVyUGFydHNTeW1ib2xdKC4uLmFyZ3MpKTtcbiAgICB9XG59KTtcbi8qKlxuICogZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXG4gKiBhbHNvIHRvIGF2b2lkIGlubGluZSBpbXBvcnQoKSBpbiBnZW5lcmF0ZWQgZC50cyBmaWxlc1xuICovXG4vKipcbiAqIE51bWJlciBGb3JtYXQgQ29tcG9uZW50XG4gKlxuICogQHJlbWFya3NcbiAqIFNlZSB0aGUgZm9sbG93aW5nIGl0ZW1zIGZvciBwcm9wZXJ0eSBhYm91dCBkZXRhaWxzXG4gKlxuICogQFZ1ZUkxOG5TZWUgW0Zvcm1hdHRhYmxlUHJvcHNdKGNvbXBvbmVudCNmb3JtYXR0YWJsZXByb3BzKVxuICogQFZ1ZUkxOG5TZWUgW0Jhc2VGb3JtYXRQcm9wc10oY29tcG9uZW50I2Jhc2Vmb3JtYXRwcm9wcylcbiAqIEBWdWVJMThuU2VlIFtDdXN0b20gRm9ybWF0dGluZ10oLi4vZ3VpZGUvZXNzZW50aWFscy9udW1iZXIjY3VzdG9tLWZvcm1hdHRpbmcpXG4gKlxuICogQFZ1ZUkxOG5EYW5nZXJcbiAqIE5vdCBzdXBwb3J0ZWQgSUUsIGR1ZSB0byBubyBzdXBwb3J0IGBJbnRsLk51bWJlckZvcm1hdCNmb3JtYXRUb1BhcnRzYCBpbiBbSUVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTnVtYmVyRm9ybWF0L2Zvcm1hdFRvUGFydHMpXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIGl0LCB5b3UgbmVlZCB0byB1c2UgW3BvbHlmaWxsXShodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvdHJlZS9tYWluL3BhY2thZ2VzL2ludGwtbnVtYmVyZm9ybWF0KVxuICpcbiAqIEBWdWVJMThuQ29tcG9uZW50XG4gKi9cbmNvbnN0IE51bWJlckZvcm1hdCA9IE51bWJlckZvcm1hdEltcGw7XG5jb25zdCBJMThuTiA9IE51bWJlckZvcm1hdDtcblxuY29uc3QgRGF0ZXRpbWVGb3JtYXRJbXBsID0gLyogI19fUFVSRV9fKi8gZGVmaW5lQ29tcG9uZW50KHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIG5hbWU6ICdpMThuLWQnLFxuICAgIHByb3BzOiBhc3NpZ24oe1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgRGF0ZV0sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF1cbiAgICAgICAgfVxuICAgIH0sIGJhc2VGb3JtYXRQcm9wcyksXG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaTE4biA9IHByb3BzLmkxOG4gfHxcbiAgICAgICAgICAgIHVzZUkxOG4oe1xuICAgICAgICAgICAgICAgIHVzZVNjb3BlOiAncGFyZW50JyxcbiAgICAgICAgICAgICAgICBfX3VzZUNvbXBvbmVudDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZW5kZXJGb3JtYXR0ZXIocHJvcHMsIGNvbnRleHQsIERBVEVUSU1FX0ZPUk1BVF9PUFRJT05TX0tFWVMsICguLi5hcmdzKSA9PiBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaTE4bltEYXRldGltZVBhcnRzU3ltYm9sXSguLi5hcmdzKSk7XG4gICAgfVxufSk7XG4vKipcbiAqIERhdGV0aW1lIEZvcm1hdCBDb21wb25lbnRcbiAqXG4gKiBAcmVtYXJrc1xuICogU2VlIHRoZSBmb2xsb3dpbmcgaXRlbXMgZm9yIHByb3BlcnR5IGFib3V0IGRldGFpbHNcbiAqXG4gKiBAVnVlSTE4blNlZSBbRm9ybWF0dGFibGVQcm9wc10oY29tcG9uZW50I2Zvcm1hdHRhYmxlcHJvcHMpXG4gKiBAVnVlSTE4blNlZSBbQmFzZUZvcm1hdFByb3BzXShjb21wb25lbnQjYmFzZWZvcm1hdHByb3BzKVxuICogQFZ1ZUkxOG5TZWUgW0N1c3RvbSBGb3JtYXR0aW5nXSguLi9ndWlkZS9lc3NlbnRpYWxzL2RhdGV0aW1lI2N1c3RvbS1mb3JtYXR0aW5nKVxuICpcbiAqIEBWdWVJMThuRGFuZ2VyXG4gKiBOb3Qgc3VwcG9ydGVkIElFLCBkdWUgdG8gbm8gc3VwcG9ydCBgSW50bC5EYXRlVGltZUZvcm1hdCNmb3JtYXRUb1BhcnRzYCBpbiBbSUVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvRGF0ZVRpbWVGb3JtYXQvZm9ybWF0VG9QYXJ0cylcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgaXQsIHlvdSBuZWVkIHRvIHVzZSBbcG9seWZpbGxdKGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy90cmVlL21haW4vcGFja2FnZXMvaW50bC1kYXRldGltZWZvcm1hdClcbiAqXG4gKiBAVnVlSTE4bkNvbXBvbmVudFxuICovXG5jb25zdCBEYXRldGltZUZvcm1hdCA9IERhdGV0aW1lRm9ybWF0SW1wbDtcbmNvbnN0IEkxOG5EID0gRGF0ZXRpbWVGb3JtYXQ7XG5cbmZ1bmN0aW9uIGdldENvbXBvc2VyJDIoaTE4biwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpMThuSW50ZXJuYWwgPSBpMThuO1xuICAgIGlmIChpMThuLm1vZGUgPT09ICdjb21wb3NpdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChpMThuSW50ZXJuYWwuX19nZXRJbnN0YW5jZShpbnN0YW5jZSkgfHwgaTE4bi5nbG9iYWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdnVlSTE4biA9IGkxOG5JbnRlcm5hbC5fX2dldEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHZ1ZUkxOG4gIT0gbnVsbFxuICAgICAgICAgICAgPyB2dWVJMThuLl9fY29tcG9zZXJcbiAgICAgICAgICAgIDogaTE4bi5nbG9iYWwuX19jb21wb3NlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB2VERpcmVjdGl2ZShpMThuKSB7XG4gICAgY29uc3QgX3Byb2Nlc3MgPSAoYmluZGluZykgPT4ge1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlLCBtb2RpZmllcnMsIHZhbHVlIH0gPSBiaW5kaW5nO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCAhaW5zdGFuY2UuJCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLlVORVhQRUNURURfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvc2VyID0gZ2V0Q29tcG9zZXIkMihpMThuLCBpbnN0YW5jZS4kKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RpZmllcnMucHJlc2VydmUpIHtcbiAgICAgICAgICAgIHdhcm4oZ2V0V2Fybk1lc3NhZ2UoSTE4bldhcm5Db2Rlcy5OT1RfU1VQUE9SVEVEX1BSRVNFUlZFKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFJlZmxlY3QuYXBwbHkoY29tcG9zZXIudCwgY29tcG9zZXIsIFsuLi5tYWtlUGFyYW1zKHBhcnNlZFZhbHVlKV0pLFxuICAgICAgICAgICAgY29tcG9zZXJcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKGVsLCBiaW5kaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IFt0ZXh0Q29udGVudCwgY29tcG9zZXJdID0gX3Byb2Nlc3MoYmluZGluZyk7XG4gICAgICAgIGlmIChpbkJyb3dzZXIgJiYgaTE4bi5nbG9iYWwgPT09IGNvbXBvc2VyKSB7XG4gICAgICAgICAgICAvLyBnbG9iYWwgc2NvcGUgb25seVxuICAgICAgICAgICAgZWwuX19pMThuV2F0Y2hlciA9IHdhdGNoKGNvbXBvc2VyLmxvY2FsZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuaW5zdGFuY2UgJiYgYmluZGluZy5pbnN0YW5jZS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsLl9fY29tcG9zZXIgPSBjb21wb3NlcjtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcbiAgICB9O1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAoZWwpID0+IHtcbiAgICAgICAgaWYgKGluQnJvd3NlciAmJiBlbC5fX2kxOG5XYXRjaGVyKSB7XG4gICAgICAgICAgICBlbC5fX2kxOG5XYXRjaGVyKCk7XG4gICAgICAgICAgICBlbC5fX2kxOG5XYXRjaGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGVsZXRlIGVsLl9faTE4bldhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLl9fY29tcG9zZXIpIHtcbiAgICAgICAgICAgIGVsLl9fY29tcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkZWxldGUgZWwuX19jb21wb3NlcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlID0gKGVsLCB7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKGVsLl9fY29tcG9zZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvc2VyID0gZWwuX19jb21wb3NlcjtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBlbC50ZXh0Q29udGVudCA9IFJlZmxlY3QuYXBwbHkoY29tcG9zZXIudCwgY29tcG9zZXIsIFtcbiAgICAgICAgICAgICAgICAuLi5tYWtlUGFyYW1zKHBhcnNlZFZhbHVlKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGdldFNTUlByb3BzID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgY29uc3QgW3RleHRDb250ZW50XSA9IF9wcm9jZXNzKGJpbmRpbmcpO1xuICAgICAgICByZXR1cm4geyB0ZXh0Q29udGVudCB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlZDogcmVnaXN0ZXIsXG4gICAgICAgIHVubW91bnRlZDogdW5yZWdpc3RlcixcbiAgICAgICAgYmVmb3JlVXBkYXRlOiB1cGRhdGUsXG4gICAgICAgIGdldFNTUlByb3BzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHZhbHVlIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGlmICghKCdwYXRoJyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5SRVFVSVJFRF9WQUxVRSwgJ3BhdGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBjcmVhdGVJMThuRXJyb3IoSTE4bkVycm9yQ29kZXMuSU5WQUxJRF9WQUxVRSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZVBhcmFtcyh2YWx1ZSkge1xuICAgIGNvbnN0IHsgcGF0aCwgbG9jYWxlLCBhcmdzLCBjaG9pY2UsIHBsdXJhbCB9ID0gdmFsdWU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IG5hbWVkID0gYXJncyB8fCB7fTtcbiAgICBpZiAoaXNTdHJpbmcobG9jYWxlKSkge1xuICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGNob2ljZSkpIHtcbiAgICAgICAgb3B0aW9ucy5wbHVyYWwgPSBjaG9pY2U7XG4gICAgfVxuICAgIGlmIChpc051bWJlcihwbHVyYWwpKSB7XG4gICAgICAgIG9wdGlvbnMucGx1cmFsID0gcGx1cmFsO1xuICAgIH1cbiAgICByZXR1cm4gW3BhdGgsIG5hbWVkLCBvcHRpb25zXTtcbn1cblxuZnVuY3Rpb24gYXBwbHkoYXBwLCBpMThuLCAuLi5vcHRpb25zKSB7XG4gICAgY29uc3QgcGx1Z2luT3B0aW9ucyA9IGlzUGxhaW5PYmplY3Qob3B0aW9uc1swXSlcbiAgICAgICAgPyBvcHRpb25zWzBdXG4gICAgICAgIDoge307XG4gICAgY29uc3QgdXNlSTE4bkNvbXBvbmVudE5hbWUgPSAhIXBsdWdpbk9wdGlvbnMudXNlSTE4bkNvbXBvbmVudE5hbWU7XG4gICAgY29uc3QgZ2xvYmFsSW5zdGFsbCA9IGlzQm9vbGVhbihwbHVnaW5PcHRpb25zLmdsb2JhbEluc3RhbGwpXG4gICAgICAgID8gcGx1Z2luT3B0aW9ucy5nbG9iYWxJbnN0YWxsXG4gICAgICAgIDogdHJ1ZTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGdsb2JhbEluc3RhbGwgJiYgdXNlSTE4bkNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgd2FybihnZXRXYXJuTWVzc2FnZShJMThuV2FybkNvZGVzLkNPTVBPTkVOVF9OQU1FX0xFR0FDWV9DT01QQVRJQkxFLCB7XG4gICAgICAgICAgICBuYW1lOiBUcmFuc2xhdGlvbi5uYW1lXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGdsb2JhbEluc3RhbGwpIHtcbiAgICAgICAgWyF1c2VJMThuQ29tcG9uZW50TmFtZSA/IFRyYW5zbGF0aW9uLm5hbWUgOiAnaTE4bicsICdJMThuVCddLmZvckVhY2gobmFtZSA9PiBhcHAuY29tcG9uZW50KG5hbWUsIFRyYW5zbGF0aW9uKSk7XG4gICAgICAgIFtOdW1iZXJGb3JtYXQubmFtZSwgJ0kxOG5OJ10uZm9yRWFjaChuYW1lID0+IGFwcC5jb21wb25lbnQobmFtZSwgTnVtYmVyRm9ybWF0KSk7XG4gICAgICAgIFtEYXRldGltZUZvcm1hdC5uYW1lLCAnSTE4bkQnXS5mb3JFYWNoKG5hbWUgPT4gYXBwLmNvbXBvbmVudChuYW1lLCBEYXRldGltZUZvcm1hdCkpO1xuICAgIH1cbiAgICAvLyBpbnN0YWxsIGRpcmVjdGl2ZVxuICAgIHtcbiAgICAgICAgYXBwLmRpcmVjdGl2ZSgndCcsIHZURGlyZWN0aXZlKGkxOG4pKTtcbiAgICB9XG59XG5cbmNvbnN0IFZVRV9JMThOX0NPTVBPTkVOVF9UWVBFUyA9ICd2dWUtaTE4bjogY29tcG9zZXIgcHJvcGVydGllcyc7XG5sZXQgZGV2dG9vbHNBcGk7XG5hc3luYyBmdW5jdGlvbiBlbmFibGVEZXZUb29scyhhcHAsIGkxOG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgICAgICAgICAgaWQ6IFwidnVlLWRldnRvb2xzLXBsdWdpbi12dWUtaTE4blwiIC8qIFZ1ZURldlRvb2xzSURzLlBMVUdJTiAqLyxcbiAgICAgICAgICAgICAgICBsYWJlbDogVnVlRGV2VG9vbHNMYWJlbHNbXCJ2dWUtZGV2dG9vbHMtcGx1Z2luLXZ1ZS1pMThuXCIgLyogVnVlRGV2VG9vbHNJRHMuUExVR0lOICovXSxcbiAgICAgICAgICAgICAgICBwYWNrYWdlTmFtZTogJ3Z1ZS1pMThuJyxcbiAgICAgICAgICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vdnVlLWkxOG4uaW50bGlmeS5kZXYnLFxuICAgICAgICAgICAgICAgIGxvZ286ICdodHRwczovL3Z1ZS1pMThuLmludGxpZnkuZGV2L3Z1ZS1pMThuLWRldnRvb2xzLWxvZ28ucG5nJyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZVR5cGVzOiBbVlVFX0kxOE5fQ09NUE9ORU5UX1RZUEVTXSxcbiAgICAgICAgICAgICAgICBhcHA6IGFwcCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH0sIGFwaSA9PiB7XG4gICAgICAgICAgICAgICAgZGV2dG9vbHNBcGkgPSBhcGk7XG4gICAgICAgICAgICAgICAgYXBpLm9uLnZpc2l0Q29tcG9uZW50VHJlZSgoeyBjb21wb25lbnRJbnN0YW5jZSwgdHJlZU5vZGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRUcmVlVGFncyhjb21wb25lbnRJbnN0YW5jZSwgdHJlZU5vZGUsIGkxOG4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFwaS5vbi5pbnNwZWN0Q29tcG9uZW50KCh7IGNvbXBvbmVudEluc3RhbmNlLCBpbnN0YW5jZURhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50SW5zdGFuY2Uudm5vZGUuZWwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLnZub2RlLmVsLl9fVlVFX0kxOE5fXyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaTE4bi5tb2RlID09PSAnbGVnYWN5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBnbG9iYWwgc2NvcGUgb24gbGVnYWN5IG1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50SW5zdGFuY2Uudm5vZGUuZWwuX19WVUVfSTE4Tl9fICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpMThuLmdsb2JhbC5fX2NvbXBvc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3BlY3RDb21wb3NlcihpbnN0YW5jZURhdGEsIGNvbXBvbmVudEluc3RhbmNlLnZub2RlLmVsLl9fVlVFX0kxOE5fXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zcGVjdENvbXBvc2VyKGluc3RhbmNlRGF0YSwgY29tcG9uZW50SW5zdGFuY2Uudm5vZGUuZWwuX19WVUVfSTE4Tl9fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFwaS5hZGRJbnNwZWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBpZDogXCJ2dWUtaTE4bi1yZXNvdXJjZS1pbnNwZWN0b3JcIiAvKiBWdWVEZXZUb29sc0lEcy5DVVNUT01fSU5TUEVDVE9SICovLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogVnVlRGV2VG9vbHNMYWJlbHNbXCJ2dWUtaTE4bi1yZXNvdXJjZS1pbnNwZWN0b3JcIiAvKiBWdWVEZXZUb29sc0lEcy5DVVNUT01fSU5TUEVDVE9SICovXSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2xhbmd1YWdlJyxcbiAgICAgICAgICAgICAgICAgICAgdHJlZUZpbHRlclBsYWNlaG9sZGVyOiBWdWVEZXZUb29sc1BsYWNlaG9sZGVyc1tcInZ1ZS1pMThuLXJlc291cmNlLWluc3BlY3RvclwiIC8qIFZ1ZURldlRvb2xzSURzLkNVU1RPTV9JTlNQRUNUT1IgKi9dXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUocGF5bG9hZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmluc3BlY3RvcklkID09PSBcInZ1ZS1pMThuLXJlc291cmNlLWluc3BlY3RvclwiIC8qIFZ1ZURldlRvb2xzSURzLkNVU1RPTV9JTlNQRUNUT1IgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyU2NvcGUocGF5bG9hZCwgaTE4bik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yU3RhdGUoYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IFwidnVlLWkxOG4tcmVzb3VyY2UtaW5zcGVjdG9yXCIgLyogVnVlRGV2VG9vbHNJRHMuQ1VTVE9NX0lOU1BFQ1RPUiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnVuaGlnaGxpZ2h0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zcGVjdFNjb3BlKHBheWxvYWQsIGkxOG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubm9kZUlkID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm9vdHMuaGFzKHBheWxvYWQuYXBwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcm9vdF0gPSBhd2FpdCBhcGkuZ2V0Q29tcG9uZW50SW5zdGFuY2VzKHBheWxvYWQuYXBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMuc2V0KHBheWxvYWQuYXBwLCByb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmhpZ2hsaWdodEVsZW1lbnQocm9vdHMuZ2V0KHBheWxvYWQuYXBwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudEluc3RhbmNlKHBheWxvYWQubm9kZUlkLCBpMThuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSAmJiBhcGkuaGlnaGxpZ2h0RWxlbWVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcGkub24uZWRpdEluc3BlY3RvclN0YXRlKHBheWxvYWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gXCJ2dWUtaTE4bi1yZXNvdXJjZS1pbnNwZWN0b3JcIiAvKiBWdWVEZXZUb29sc0lEcy5DVVNUT01fSU5TUEVDVE9SICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0U2NvcGUocGF5bG9hZCwgaTE4bik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcInZ1ZS1pMThuLXRpbWVsaW5lXCIgLyogVnVlRGV2VG9vbHNJRHMuVElNRUxJTkUgKi8sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBWdWVEZXZUb29sc0xhYmVsc1tcInZ1ZS1pMThuLXRpbWVsaW5lXCIgLyogVnVlRGV2VG9vbHNJRHMuVElNRUxJTkUgKi9dLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogVnVlRGV2VG9vbHNUaW1lbGluZUNvbG9yc1tcInZ1ZS1pMThuLXRpbWVsaW5lXCIgLyogVnVlRGV2VG9vbHNJRHMuVElNRUxJTkUgKi9dXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgcmVqZWN0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGdldEkxOG5TY29wZUxhYmxlKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIChpbnN0YW5jZS50eXBlLm5hbWUgfHxcbiAgICAgICAgaW5zdGFuY2UudHlwZS5kaXNwbGF5TmFtZSB8fFxuICAgICAgICBpbnN0YW5jZS50eXBlLl9fZmlsZSB8fFxuICAgICAgICAnQW5vbnltb3VzJyk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRUcmVlVGFncyhpbnN0YW5jZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50cmVlTm9kZSwgaTE4bikge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IGdsb2JhbCA9IGkxOG4ubW9kZSA9PT0gJ2NvbXBvc2l0aW9uJ1xuICAgICAgICA/IGkxOG4uZ2xvYmFsXG4gICAgICAgIDogaTE4bi5nbG9iYWwuX19jb21wb3NlcjtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uudm5vZGUuZWwgJiYgaW5zdGFuY2Uudm5vZGUuZWwuX19WVUVfSTE4Tl9fKSB7XG4gICAgICAgIC8vIGFkZCBjdXN0b20gdGFncyBsb2NhbCBzY29wZSBvbmx5XG4gICAgICAgIGlmIChpbnN0YW5jZS52bm9kZS5lbC5fX1ZVRV9JMThOX18gIT09IGdsb2JhbCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0ge1xuICAgICAgICAgICAgICAgIGxhYmVsOiBgaTE4biAoJHtnZXRJMThuU2NvcGVMYWJsZShpbnN0YW5jZSl9IFNjb3BlKWAsXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAweDAwMDAwMCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IDB4ZmZjZDE5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJlZU5vZGUudGFncy5wdXNoKHRhZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0Q29tcG9zZXIoaW5zdGFuY2VEYXRhLCBjb21wb3Nlcikge1xuICAgIGNvbnN0IHR5cGUgPSBWVUVfSTE4Tl9DT01QT05FTlRfVFlQRVM7XG4gICAgaW5zdGFuY2VEYXRhLnN0YXRlLnB1c2goe1xuICAgICAgICB0eXBlLFxuICAgICAgICBrZXk6ICdsb2NhbGUnLFxuICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGNvbXBvc2VyLmxvY2FsZS52YWx1ZVxuICAgIH0pO1xuICAgIGluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5OiAnYXZhaWxhYmxlTG9jYWxlcycsXG4gICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGNvbXBvc2VyLmF2YWlsYWJsZUxvY2FsZXNcbiAgICB9KTtcbiAgICBpbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGtleTogJ2ZhbGxiYWNrTG9jYWxlJyxcbiAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjb21wb3Nlci5mYWxsYmFja0xvY2FsZS52YWx1ZVxuICAgIH0pO1xuICAgIGluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5OiAnaW5oZXJpdExvY2FsZScsXG4gICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY29tcG9zZXIuaW5oZXJpdExvY2FsZVxuICAgIH0pO1xuICAgIGluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5OiAnbWVzc2FnZXMnLFxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBnZXRMb2NhbGVNZXNzYWdlVmFsdWUoY29tcG9zZXIubWVzc2FnZXMudmFsdWUpXG4gICAgfSk7XG4gICAge1xuICAgICAgICBpbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAga2V5OiAnZGF0ZXRpbWVGb3JtYXRzJyxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb21wb3Nlci5kYXRldGltZUZvcm1hdHMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBrZXk6ICdudW1iZXJGb3JtYXRzJyxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb21wb3Nlci5udW1iZXJGb3JtYXRzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBnZXRMb2NhbGVNZXNzYWdlVmFsdWUobWVzc2FnZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IG1lc3NhZ2VzW2tleV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHYpICYmICdzb3VyY2UnIGluIHYpIHtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSBnZXRNZXNzYWdlRnVuY3Rpb25EZXRhaWxzKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWVzc2FnZUFTVCh2KSAmJiB2LmxvYyAmJiB2LmxvYy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSB2LmxvYy5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIHZhbHVlW2tleV0gPSBnZXRMb2NhbGVNZXNzYWdlVmFsdWUodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZVtrZXldID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEVTQyA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5mdW5jdGlvbiBlc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1s8PlwiJl0vZywgZXNjYXBlQ2hhcik7XG59XG5mdW5jdGlvbiBlc2NhcGVDaGFyKGEpIHtcbiAgICByZXR1cm4gRVNDW2FdIHx8IGE7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUZ1bmN0aW9uRGV0YWlscyhmdW5jKSB7XG4gICAgY29uc3QgYXJnU3RyaW5nID0gZnVuYy5zb3VyY2UgPyBgKFwiJHtlc2NhcGUoZnVuYy5zb3VyY2UpfVwiKWAgOiBgKD8pYDtcbiAgICByZXR1cm4ge1xuICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgZGlzcGxheTogYDxzcGFuPsaSPC9zcGFuPiAke2FyZ1N0cmluZ31gXG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTY29wZShwYXlsb2FkLCBpMThuKSB7XG4gICAgcGF5bG9hZC5yb290Tm9kZXMucHVzaCh7XG4gICAgICAgIGlkOiAnZ2xvYmFsJyxcbiAgICAgICAgbGFiZWw6ICdHbG9iYWwgU2NvcGUnXG4gICAgfSk7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgZ2xvYmFsID0gaTE4bi5tb2RlID09PSAnY29tcG9zaXRpb24nXG4gICAgICAgID8gaTE4bi5nbG9iYWxcbiAgICAgICAgOiBpMThuLmdsb2JhbC5fX2NvbXBvc2VyO1xuICAgIGZvciAoY29uc3QgW2tleUluc3RhbmNlLCBpbnN0YW5jZV0gb2YgaTE4bi5fX2luc3RhbmNlcykge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgY29tcG9zZXIgPSBpMThuLm1vZGUgPT09ICdjb21wb3NpdGlvbidcbiAgICAgICAgICAgID8gaW5zdGFuY2VcbiAgICAgICAgICAgIDogaW5zdGFuY2UuX19jb21wb3NlcjtcbiAgICAgICAgaWYgKGdsb2JhbCA9PT0gY29tcG9zZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQucm9vdE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGNvbXBvc2VyLmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBsYWJlbDogYCR7Z2V0STE4blNjb3BlTGFibGUoa2V5SW5zdGFuY2UpfSBTY29wZWBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50SW5zdGFuY2Uobm9kZUlkLCBpMThuKSB7XG4gICAgbGV0IGluc3RhbmNlID0gbnVsbDtcbiAgICBpZiAobm9kZUlkICE9PSAnZ2xvYmFsJykge1xuICAgICAgICBmb3IgKGNvbnN0IFtjb21wb25lbnQsIGNvbXBvc2VyXSBvZiBpMThuLl9faW5zdGFuY2VzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGNvbXBvc2VyLmlkLnRvU3RyaW5nKCkgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvc2VyJDEobm9kZUlkLCBpMThuKSB7XG4gICAgaWYgKG5vZGVJZCA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgcmV0dXJuIGkxOG4ubW9kZSA9PT0gJ2NvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgPyBpMThuLmdsb2JhbFxuICAgICAgICAgICAgOiBpMThuLmdsb2JhbC5fX2NvbXBvc2VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBBcnJheS5mcm9tKGkxOG4uX19pbnN0YW5jZXMudmFsdWVzKCkpLmZpbmQoaXRlbSA9PiBpdGVtLmlkLnRvU3RyaW5nKCkgPT09IG5vZGVJZCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGkxOG4ubW9kZSA9PT0gJ2NvbXBvc2l0aW9uJ1xuICAgICAgICAgICAgICAgID8gaW5zdGFuY2VcbiAgICAgICAgICAgICAgICA6IGluc3RhbmNlLl9fY29tcG9zZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3RTY29wZShwYXlsb2FkLCBpMThuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgY29uc3QgY29tcG9zZXIgPSBnZXRDb21wb3NlciQxKHBheWxvYWQubm9kZUlkLCBpMThuKTtcbiAgICBpZiAoY29tcG9zZXIpIHtcbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IG1ha2VTY29wZUluc3BlY3RTdGF0ZShjb21wb3Nlcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVNjb3BlSW5zcGVjdFN0YXRlKGNvbXBvc2VyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcbiAgICBjb25zdCBsb2NhbGVUeXBlID0gJ0xvY2FsZSByZWxhdGVkIGluZm8nO1xuICAgIGNvbnN0IGxvY2FsZVN0YXRlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogbG9jYWxlVHlwZSxcbiAgICAgICAgICAgIGtleTogJ2xvY2FsZScsXG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb21wb3Nlci5sb2NhbGUudmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogbG9jYWxlVHlwZSxcbiAgICAgICAgICAgIGtleTogJ2ZhbGxiYWNrTG9jYWxlJyxcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGNvbXBvc2VyLmZhbGxiYWNrTG9jYWxlLnZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGxvY2FsZVR5cGUsXG4gICAgICAgICAgICBrZXk6ICdhdmFpbGFibGVMb2NhbGVzJyxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb21wb3Nlci5hdmFpbGFibGVMb2NhbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IGxvY2FsZVR5cGUsXG4gICAgICAgICAgICBrZXk6ICdpbmhlcml0TG9jYWxlJyxcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGNvbXBvc2VyLmluaGVyaXRMb2NhbGVcbiAgICAgICAgfVxuICAgIF07XG4gICAgc3RhdGVbbG9jYWxlVHlwZV0gPSBsb2NhbGVTdGF0ZXM7XG4gICAgY29uc3QgbG9jYWxlTWVzc2FnZXNUeXBlID0gJ0xvY2FsZSBtZXNzYWdlcyBpbmZvJztcbiAgICBjb25zdCBsb2NhbGVNZXNzYWdlc1N0YXRlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogbG9jYWxlTWVzc2FnZXNUeXBlLFxuICAgICAgICAgICAga2V5OiAnbWVzc2FnZXMnLFxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGdldExvY2FsZU1lc3NhZ2VWYWx1ZShjb21wb3Nlci5tZXNzYWdlcy52YWx1ZSlcbiAgICAgICAgfVxuICAgIF07XG4gICAgc3RhdGVbbG9jYWxlTWVzc2FnZXNUeXBlXSA9IGxvY2FsZU1lc3NhZ2VzU3RhdGVzO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGF0ZXRpbWVGb3JtYXRzVHlwZSA9ICdEYXRldGltZSBmb3JtYXRzIGluZm8nO1xuICAgICAgICBjb25zdCBkYXRldGltZUZvcm1hdHNTdGF0ZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogZGF0ZXRpbWVGb3JtYXRzVHlwZSxcbiAgICAgICAgICAgICAgICBrZXk6ICdkYXRldGltZUZvcm1hdHMnLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29tcG9zZXIuZGF0ZXRpbWVGb3JtYXRzLnZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHN0YXRlW2RhdGV0aW1lRm9ybWF0c1R5cGVdID0gZGF0ZXRpbWVGb3JtYXRzU3RhdGVzO1xuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXRzVHlwZSA9ICdEYXRldGltZSBmb3JtYXRzIGluZm8nO1xuICAgICAgICBjb25zdCBudW1iZXJGb3JtYXRzU3RhdGVzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bWJlckZvcm1hdHNUeXBlLFxuICAgICAgICAgICAgICAgIGtleTogJ251bWJlckZvcm1hdHMnLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY29tcG9zZXIubnVtYmVyRm9ybWF0cy52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgICBzdGF0ZVtudW1iZXJGb3JtYXRzVHlwZV0gPSBudW1iZXJGb3JtYXRzU3RhdGVzO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBhZGRUaW1lbGluZUV2ZW50KGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKGRldnRvb2xzQXBpKSB7XG4gICAgICAgIGxldCBncm91cElkO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAnZ3JvdXBJZCcgaW4gcGF5bG9hZCkge1xuICAgICAgICAgICAgZ3JvdXBJZCA9IHBheWxvYWQuZ3JvdXBJZDtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXlsb2FkLmdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGV2dG9vbHNBcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICBsYXllcklkOiBcInZ1ZS1pMThuLXRpbWVsaW5lXCIgLyogVnVlRGV2VG9vbHNJRHMuVElNRUxJTkUgKi8sXG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBldmVudCxcbiAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgbWV0YToge30sXG4gICAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZCB8fCB7fSxcbiAgICAgICAgICAgICAgICBsb2dUeXBlOiBldmVudCA9PT0gXCJjb21waWxlLWVycm9yXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5DT01QSUxFX0VSUk9SICovXG4gICAgICAgICAgICAgICAgICAgID8gJ2Vycm9yJ1xuICAgICAgICAgICAgICAgICAgICA6IGV2ZW50ID09PSBcImZhbGxiYWNrXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5GQUxCQUNLICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJtaXNzaW5nXCIgLyogVnVlRGV2VG9vbHNUaW1lbGluZUV2ZW50cy5NSVNTSU5HICovXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd3YXJuaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZWRpdFNjb3BlKHBheWxvYWQsIGkxOG4pIHtcbiAgICBjb25zdCBjb21wb3NlciA9IGdldENvbXBvc2VyJDEocGF5bG9hZC5ub2RlSWQsIGkxOG4pO1xuICAgIGlmIChjb21wb3Nlcikge1xuICAgICAgICBjb25zdCBbZmllbGRdID0gcGF5bG9hZC5wYXRoO1xuICAgICAgICBpZiAoZmllbGQgPT09ICdsb2NhbGUnICYmIGlzU3RyaW5nKHBheWxvYWQuc3RhdGUudmFsdWUpKSB7XG4gICAgICAgICAgICBjb21wb3Nlci5sb2NhbGUudmFsdWUgPSBwYXlsb2FkLnN0YXRlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkID09PSAnZmFsbGJhY2tMb2NhbGUnICYmXG4gICAgICAgICAgICAoaXNTdHJpbmcocGF5bG9hZC5zdGF0ZS52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBpc0FycmF5KHBheWxvYWQuc3RhdGUudmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGF5bG9hZC5zdGF0ZS52YWx1ZSkpKSB7XG4gICAgICAgICAgICBjb21wb3Nlci5mYWxsYmFja0xvY2FsZS52YWx1ZSA9IHBheWxvYWQuc3RhdGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGQgPT09ICdpbmhlcml0TG9jYWxlJyAmJiBpc0Jvb2xlYW4ocGF5bG9hZC5zdGF0ZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbXBvc2VyLmluaGVyaXRMb2NhbGUgPSBwYXlsb2FkLnN0YXRlLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnRzIGNvbXBhdGliaWxpdHkgZm9yIGxlZ2FjeSB2dWUtaTE4biBBUElzXG4gKiBUaGlzIG1peGluIGlzIHVzZWQgd2hlbiB3ZSB1c2UgdnVlLWkxOG5AdjkueCBvciBsYXRlclxuICovXG5mdW5jdGlvbiBkZWZpbmVNaXhpbih2dWVpMThuLCBjb21wb3NlciwgaTE4bikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVJMThuRXJyb3IoSTE4bkVycm9yQ29kZXMuVU5FWFBFQ1RFRF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zSTE4biA9IG9wdGlvbnMuaTE4bjtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5fX2kxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc0kxOG4uX19pMThuID0gb3B0aW9ucy5fX2kxOG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnNJMThuLl9fcm9vdCA9IGNvbXBvc2VyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzID09PSB0aGlzLiRyb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGkxOG4gPSBtZXJnZVRvUm9vdCh2dWVpMThuLCBvcHRpb25zSTE4bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zSTE4bi5fX2luamVjdFdpdGhPcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpMThuID0gY3JlYXRlVnVlSTE4bihvcHRpb25zSTE4bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5fX2kxOG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gdGhpcy4kcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpMThuID0gbWVyZ2VUb1Jvb3QodnVlaTE4biwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRpMThuID0gY3JlYXRlVnVlSTE4bih7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2kxOG46IG9wdGlvbnMuX19pMThuLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19pbmplY3RXaXRoT3B0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19yb290OiBjb21wb3NlclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgZ2xvYmFsXG4gICAgICAgICAgICAgICAgdGhpcy4kaTE4biA9IHZ1ZWkxOG47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5fX2kxOG5HbG9iYWwpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RJMThuUmVzb3VyY2VzKGNvbXBvc2VyLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZ1ZWkxOG4uX19vbkNvbXBvbmVudEluc3RhbmNlQ3JlYXRlZCh0aGlzLiRpMThuKTtcbiAgICAgICAgICAgIGkxOG4uX19zZXRJbnN0YW5jZShpbnN0YW5jZSwgdGhpcy4kaTE4bik7XG4gICAgICAgICAgICAvLyBkZWZpbmVzIHZ1ZS1pMThuIGxlZ2FjeSBBUElzXG4gICAgICAgICAgICB0aGlzLiR0ID0gKC4uLmFyZ3MpID0+IHRoaXMuJGkxOG4udCguLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuJHJ0ID0gKC4uLmFyZ3MpID0+IHRoaXMuJGkxOG4ucnQoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLiR0YyA9ICguLi5hcmdzKSA9PiB0aGlzLiRpMThuLnRjKC4uLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy4kdGUgPSAoa2V5LCBsb2NhbGUpID0+IHRoaXMuJGkxOG4udGUoa2V5LCBsb2NhbGUpO1xuICAgICAgICAgICAgdGhpcy4kZCA9ICguLi5hcmdzKSA9PiB0aGlzLiRpMThuLmQoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLiRuID0gKC4uLmFyZ3MpID0+IHRoaXMuJGkxOG4ubiguLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuJHRtID0gKGtleSkgPT4gdGhpcy4kaTE4bi50bShrZXkpO1xuICAgICAgICAgICAgLy8gZXh0ZW5kIHZ1ZS1pMThuIGxlZ2FjeSBBUElzXG4gICAgICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4kcm9vdCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiRpMThuLl9fZXh0ZW5kZWRfXyAmJlxuICAgICAgICAgICAgICAgIGkxOG4uX192dWVJMThuRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgaTE4bi5fX3Z1ZUkxOG5FeHRlbmQodGhpcy4kaTE4bik7XG4gICAgICAgICAgICAgICAgdGhpcy4kaTE4bi5fX2V4dGVuZGVkX18gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VudGVkKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmXG4gICAgICAgICAgICAgICAgIWZhbHNlICYmXG4gICAgICAgICAgICAgICAgdGhpcy4kZWwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiRpMThuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuX19WVUVfSTE4Tl9fID0gdGhpcy4kaTE4bi5fX2NvbXBvc2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSAodGhpcy5fX3ZfZW1pdHRlciA9XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVtaXR0ZXIoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX3Z1ZUkxOG4gPSB0aGlzLiRpMThuO1xuICAgICAgICAgICAgICAgIF92dWVJMThuLl9fZW5hYmxlRW1pdHRlciAmJiBfdnVlSTE4bi5fX2VuYWJsZUVtaXR0ZXIoZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbignKicsIGFkZFRpbWVsaW5lRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bm1vdW50ZWQoKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLlVORVhQRUNURURfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmXG4gICAgICAgICAgICAgICAgIWZhbHNlICYmXG4gICAgICAgICAgICAgICAgdGhpcy4kZWwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5fX1ZVRV9JMThOX18pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3ZfZW1pdHRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdl9lbWl0dGVyLm9mZignKicsIGFkZFRpbWVsaW5lRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX3ZfZW1pdHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJGkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX3Z1ZUkxOG4gPSB0aGlzLiRpMThuO1xuICAgICAgICAgICAgICAgICAgICBfdnVlSTE4bi5fX2Rpc2FibGVFbWl0dGVyICYmIF92dWVJMThuLl9fZGlzYWJsZUVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGVsLl9fVlVFX0kxOE5fXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy4kdDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRydDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiR0YztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiR0ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiRkO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuJG47XG4gICAgICAgICAgICBkZWxldGUgdGhpcy4kdG07XG4gICAgICAgICAgICBpMThuLl9fZGVsZXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGkxOG47XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VUb1Jvb3Qocm9vdCwgb3B0aW9ucykge1xuICAgIHJvb3QubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgcm9vdC5sb2NhbGU7XG4gICAgcm9vdC5mYWxsYmFja0xvY2FsZSA9IG9wdGlvbnMuZmFsbGJhY2tMb2NhbGUgfHwgcm9vdC5mYWxsYmFja0xvY2FsZTtcbiAgICByb290Lm1pc3NpbmcgPSBvcHRpb25zLm1pc3NpbmcgfHwgcm9vdC5taXNzaW5nO1xuICAgIHJvb3Quc2lsZW50VHJhbnNsYXRpb25XYXJuID1cbiAgICAgICAgb3B0aW9ucy5zaWxlbnRUcmFuc2xhdGlvbldhcm4gfHwgcm9vdC5zaWxlbnRGYWxsYmFja1dhcm47XG4gICAgcm9vdC5zaWxlbnRGYWxsYmFja1dhcm4gPVxuICAgICAgICBvcHRpb25zLnNpbGVudEZhbGxiYWNrV2FybiB8fCByb290LnNpbGVudEZhbGxiYWNrV2FybjtcbiAgICByb290LmZvcm1hdEZhbGxiYWNrTWVzc2FnZXMgPVxuICAgICAgICBvcHRpb25zLmZvcm1hdEZhbGxiYWNrTWVzc2FnZXMgfHwgcm9vdC5mb3JtYXRGYWxsYmFja01lc3NhZ2VzO1xuICAgIHJvb3QucG9zdFRyYW5zbGF0aW9uID0gb3B0aW9ucy5wb3N0VHJhbnNsYXRpb24gfHwgcm9vdC5wb3N0VHJhbnNsYXRpb247XG4gICAgcm9vdC53YXJuSHRtbEluTWVzc2FnZSA9IG9wdGlvbnMud2Fybkh0bWxJbk1lc3NhZ2UgfHwgcm9vdC53YXJuSHRtbEluTWVzc2FnZTtcbiAgICByb290LmVzY2FwZVBhcmFtZXRlckh0bWwgPVxuICAgICAgICBvcHRpb25zLmVzY2FwZVBhcmFtZXRlckh0bWwgfHwgcm9vdC5lc2NhcGVQYXJhbWV0ZXJIdG1sO1xuICAgIHJvb3Quc3luYyA9IG9wdGlvbnMuc3luYyB8fCByb290LnN5bmM7XG4gICAgcm9vdC5fX2NvbXBvc2VyW1NldFBsdXJhbFJ1bGVzU3ltYm9sXShvcHRpb25zLnBsdXJhbGl6YXRpb25SdWxlcyB8fCByb290LnBsdXJhbGl6YXRpb25SdWxlcyk7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBnZXRMb2NhbGVNZXNzYWdlcyhyb290LmxvY2FsZSwge1xuICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgX19pMThuOiBvcHRpb25zLl9faTE4blxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKGxvY2FsZSA9PiByb290Lm1lcmdlTG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2VzW2xvY2FsZV0pKTtcbiAgICBpZiAob3B0aW9ucy5kYXRldGltZUZvcm1hdHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5kYXRldGltZUZvcm1hdHMpLmZvckVhY2gobG9jYWxlID0+IHJvb3QubWVyZ2VEYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzW2xvY2FsZV0pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubnVtYmVyRm9ybWF0cykge1xuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLm51bWJlckZvcm1hdHMpLmZvckVhY2gobG9jYWxlID0+IHJvb3QubWVyZ2VOdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zLm51bWJlckZvcm1hdHNbbG9jYWxlXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbn1cblxuLyoqXG4gKiBJbmplY3Rpb24ga2V5IGZvciB7QGxpbmsgdXNlSTE4bn1cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGdsb2JhbCBpbmplY3Rpb24ga2V5IGZvciBJMThuIGluc3RhbmNlcyB3aXRoIGB1c2VJMThuYC4gdGhpcyBpbmplY3Rpb24ga2V5IGlzIHVzZWQgaW4gV2ViIENvbXBvbmVudHMuXG4gKiBTcGVjaWZ5IHRoZSBpMThuIGluc3RhbmNlIGNyZWF0ZWQgYnkge0BsaW5rIGNyZWF0ZUkxOG59IHRvZ2V0aGVyIHdpdGggYHByb3ZpZGVgIGZ1bmN0aW9uLlxuICpcbiAqIEBWdWVJMThuR2VuZXJhbFxuICovXG5jb25zdCBJMThuSW5qZWN0aW9uS2V5ID0gXG4vKiAjX19QVVJFX18qLyBtYWtlU3ltYm9sKCdnbG9iYWwtdnVlLWkxOG4nKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBjcmVhdGVJMThuKG9wdGlvbnMgPSB7fSwgVnVlSTE4bkxlZ2FjeSkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF9fbGVnYWN5TW9kZSA9IF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fICYmIGlzQm9vbGVhbihvcHRpb25zLmxlZ2FjeSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5sZWdhY3lcbiAgICAgICAgICAgIDogX19WVUVfSTE4Tl9MRUdBQ1lfQVBJX187XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgX19nbG9iYWxJbmplY3Rpb24gPSBpc0Jvb2xlYW4ob3B0aW9ucy5nbG9iYWxJbmplY3Rpb24pXG4gICAgICAgID8gb3B0aW9ucy5nbG9iYWxJbmplY3Rpb25cbiAgICAgICAgOiB0cnVlO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF9fYWxsb3dDb21wb3NpdGlvbiA9IF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fICYmIF9fbGVnYWN5TW9kZVxuICAgICAgICAgICAgPyAhIW9wdGlvbnMuYWxsb3dDb21wb3NpdGlvblxuICAgICAgICAgICAgOiB0cnVlO1xuICAgIGNvbnN0IF9faW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IFtnbG9iYWxTY29wZSwgX19nbG9iYWxdID0gY3JlYXRlR2xvYmFsKG9wdGlvbnMsIF9fbGVnYWN5TW9kZSk7XG4gICAgY29uc3Qgc3ltYm9sID0gLyogI19fUFVSRV9fKi8gbWFrZVN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAndnVlLWkxOG4nIDogJycpO1xuICAgIGZ1bmN0aW9uIF9fZ2V0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfX2luc3RhbmNlcy5nZXQoY29tcG9uZW50KSB8fCBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfX3NldEluc3RhbmNlKGNvbXBvbmVudCwgaW5zdGFuY2UpIHtcbiAgICAgICAgX19pbnN0YW5jZXMuc2V0KGNvbXBvbmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfX2RlbGV0ZUluc3RhbmNlKGNvbXBvbmVudCkge1xuICAgICAgICBfX2luc3RhbmNlcy5kZWxldGUoY29tcG9uZW50KTtcbiAgICB9XG4gICAge1xuICAgICAgICBjb25zdCBpMThuID0ge1xuICAgICAgICAgICAgLy8gbW9kZVxuICAgICAgICAgICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fICYmIF9fbGVnYWN5TW9kZVxuICAgICAgICAgICAgICAgICAgICA/ICdsZWdhY3knXG4gICAgICAgICAgICAgICAgICAgIDogJ2NvbXBvc2l0aW9uJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBhbGxvd0NvbXBvc2l0aW9uXG4gICAgICAgICAgICBnZXQgYWxsb3dDb21wb3NpdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hbGxvd0NvbXBvc2l0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGluc3RhbGwgcGx1Z2luXG4gICAgICAgICAgICBhc3luYyBpbnN0YWxsKGFwcCwgLi4ub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5fX1ZVRV9JMThOX18gPSBpMThuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZXR1cCBnbG9iYWwgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICBhcHAuX19WVUVfSTE4Tl9TWU1CT0xfXyA9IHN5bWJvbDtcbiAgICAgICAgICAgICAgICBhcHAucHJvdmlkZShhcHAuX19WVUVfSTE4Tl9TWU1CT0xfXywgaTE4bik7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGNvbXBvc2VyICYgdnVlaTE4biBleHRlbmQgaG9vayBvcHRpb25zIGZyb20gcGx1Z2luIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaTE4bi5fX2NvbXBvc2VyRXh0ZW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuX19jb21wb3NlckV4dGVuZDtcbiAgICAgICAgICAgICAgICAgICAgaTE4bi5fX3Z1ZUkxOG5FeHRlbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5fX3Z1ZUkxOG5FeHRlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdsb2JhbCBtZXRob2QgYW5kIHByb3BlcnRpZXMgaW5qZWN0aW9uIGZvciBDb21wb3NpdGlvbiBBUElcbiAgICAgICAgICAgICAgICBsZXQgZ2xvYmFsUmVsZWFzZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghX19sZWdhY3lNb2RlICYmIF9fZ2xvYmFsSW5qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFJlbGVhc2VIYW5kbGVyID0gaW5qZWN0R2xvYmFsRmllbGRzKGFwcCwgaTE4bi5nbG9iYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnN0YWxsIGJ1aWx0LWluIGNvbXBvbmVudHMgYW5kIGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9JMThOX0ZVTExfSU5TVEFMTF9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5KGFwcCwgaTE4biwgLi4ub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldHVwIG1peGluIGZvciBMZWdhY3kgQVBJXG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fICYmIF9fbGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHAubWl4aW4oZGVmaW5lTWl4aW4oX19nbG9iYWwsIF9fZ2xvYmFsLl9fY29tcG9zZXIsIGkxOG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSBnbG9iYWwgc2NvcGVcbiAgICAgICAgICAgICAgICBjb25zdCB1bm1vdW50QXBwID0gYXBwLnVubW91bnQ7XG4gICAgICAgICAgICAgICAgYXBwLnVubW91bnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFJlbGVhc2VIYW5kbGVyICYmIGdsb2JhbFJlbGVhc2VIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGkxOG4uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50QXBwKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBzZXR1cCB2dWUtZGV2dG9vbHMgcGx1Z2luXG4gICAgICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAhZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gYXdhaXQgZW5hYmxlRGV2VG9vbHMoYXBwLCBpMThuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5DQU5OT1RfU0VUVVBfVlVFX0RFVlRPT0xTX1BMVUdJTik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1pdHRlciA9IGNyZWF0ZUVtaXR0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fbGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX3Z1ZUkxOG4gPSBfX2dsb2JhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92dWVJMThuLl9fZW5hYmxlRW1pdHRlciAmJiBfdnVlSTE4bi5fX2VuYWJsZUVtaXR0ZXIoZW1pdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2NvbXBvc2VyID0gX19nbG9iYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29tcG9zZXJbRW5hYmxlRW1pdHRlcl0gJiYgX2NvbXBvc2VyW0VuYWJsZUVtaXR0ZXJdKGVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIub24oJyonLCBhZGRUaW1lbGluZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZ2xvYmFsIGFjY2Vzc29yXG4gICAgICAgICAgICBnZXQgZ2xvYmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dsb2JhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIGdsb2JhbFNjb3BlLnN0b3AoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBAaW50ZXJuYWxcbiAgICAgICAgICAgIF9faW5zdGFuY2VzLFxuICAgICAgICAgICAgLy8gQGludGVybmFsXG4gICAgICAgICAgICBfX2dldEluc3RhbmNlLFxuICAgICAgICAgICAgLy8gQGludGVybmFsXG4gICAgICAgICAgICBfX3NldEluc3RhbmNlLFxuICAgICAgICAgICAgLy8gQGludGVybmFsXG4gICAgICAgICAgICBfX2RlbGV0ZUluc3RhbmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpMThuO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB1c2VJMThuKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKGluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLk1VU1RfQkVfQ0FMTF9TRVRVUF9UT1ApO1xuICAgIH1cbiAgICBpZiAoIWluc3RhbmNlLmlzQ0UgJiZcbiAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5hcHAgIT0gbnVsbCAmJlxuICAgICAgICAhaW5zdGFuY2UuYXBwQ29udGV4dC5hcHAuX19WVUVfSTE4Tl9TWU1CT0xfXykge1xuICAgICAgICB0aHJvdyBjcmVhdGVJMThuRXJyb3IoSTE4bkVycm9yQ29kZXMuTk9UX0lOU1RBTExFRCk7XG4gICAgfVxuICAgIGNvbnN0IGkxOG4gPSBnZXRJMThuSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIGNvbnN0IGdsID0gZ2V0R2xvYmFsQ29tcG9zZXIoaTE4bik7XG4gICAgY29uc3QgY29tcG9uZW50T3B0aW9ucyA9IGdldENvbXBvbmVudE9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUob3B0aW9ucywgY29tcG9uZW50T3B0aW9ucyk7XG4gICAgaWYgKF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChpMThuLm1vZGUgPT09ICdsZWdhY3knICYmICFvcHRpb25zLl9fdXNlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoIWkxOG4uYWxsb3dDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5OT1RfQVZBSUxBQkxFX0lOX0xFR0FDWV9NT0RFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VJMThuRm9yTGVnYWN5KGluc3RhbmNlLCBzY29wZSwgZ2wsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY29wZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgYWRqdXN0STE4blJlc291cmNlcyhnbCwgb3B0aW9ucywgY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBnbDtcbiAgICB9XG4gICAgaWYgKHNjb3BlID09PSAncGFyZW50Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY29tcG9zZXIgPSBnZXRDb21wb3NlcihpMThuLCBpbnN0YW5jZSwgb3B0aW9ucy5fX3VzZUNvbXBvbmVudCk7XG4gICAgICAgIGlmIChjb21wb3NlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybihnZXRXYXJuTWVzc2FnZShJMThuV2FybkNvZGVzLk5PVF9GT1VORF9QQVJFTlRfU0NPUEUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvc2VyID0gZ2w7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvc2VyO1xuICAgIH1cbiAgICBjb25zdCBpMThuSW50ZXJuYWwgPSBpMThuO1xuICAgIGxldCBjb21wb3NlciA9IGkxOG5JbnRlcm5hbC5fX2dldEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBpZiAoY29tcG9zZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb21wb3Nlck9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoJ19faTE4bicgaW4gY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAgICAgY29tcG9zZXJPcHRpb25zLl9faTE4biA9IGNvbXBvbmVudE9wdGlvbnMuX19pMThuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbCkge1xuICAgICAgICAgICAgY29tcG9zZXJPcHRpb25zLl9fcm9vdCA9IGdsO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvc2VyID0gY3JlYXRlQ29tcG9zZXIoY29tcG9zZXJPcHRpb25zKTtcbiAgICAgICAgaWYgKGkxOG5JbnRlcm5hbC5fX2NvbXBvc2VyRXh0ZW5kKSB7XG4gICAgICAgICAgICBpMThuSW50ZXJuYWwuX19jb21wb3NlckV4dGVuZChjb21wb3Nlcik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBMaWZlQ3ljbGUoaTE4bkludGVybmFsLCBpbnN0YW5jZSwgY29tcG9zZXIpO1xuICAgICAgICBpMThuSW50ZXJuYWwuX19zZXRJbnN0YW5jZShpbnN0YW5jZSwgY29tcG9zZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zZXI7XG59XG4vKipcbiAqIENhc3QgdG8gVnVlSTE4biBsZWdhY3kgY29tcGF0aWJsZSB0eXBlXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgQVBJIGlzIHByb3ZpZGVkIG9ubHkgd2l0aCBbdnVlLWkxOG4tYnJpZGdlXShodHRwczovL3Z1ZS1pMThuLmludGxpZnkuZGV2L2d1aWRlL21pZ3JhdGlvbi93YXlzLmh0bWwjd2hhdC1pcy12dWUtaTE4bi1icmlkZ2UpLlxuICpcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gY29udmVydCBhbiB7QGxpbmsgSTE4bn0gaW5zdGFuY2UgY3JlYXRlZCB3aXRoIHtAbGluayBjcmVhdGVJMThuIHwgY3JlYXRlSTE4bihsZWdhY3k6IHRydWUpfSBpbnRvIGEgYHZ1ZS1pMThuQHY4LnhgIGNvbXBhdGlibGUgaW5zdGFuY2Ugb2YgYG5ldyBWdWVJMThuYCBpbiBhIFR5cGVTY3JpcHQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIGkxOG4gLSBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgSTE4bn1cbiAqIEByZXR1cm5zIEEgaTE4biBpbnN0YW5jZSB3aGljaCBpcyBjYXN0ZWQgdG8ge0BsaW5rIFZ1ZUkxOG59IHR5cGVcbiAqXG4gKiBAVnVlSTE4blRpcFxuICogOm5ldzogcHJvdmlkZWQgYnkgKip2dWUtaTE4bi1icmlkZ2Ugb25seSoqXG4gKlxuICogQFZ1ZUkxOG5HZW5lcmFsXG4gKi9cbmNvbnN0IGNhc3RUb1Z1ZUkxOG4gPSAgKGkxOG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pID0+IHtcbiAgICBpZiAoIShfX1ZVRV9JMThOX0JSSURHRV9fIGluIGkxOG4pKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5OT1RfQ09NUEFUSUJMRV9MRUdBQ1lfVlVFX0kxOE4pO1xuICAgIH1cbiAgICByZXR1cm4gaTE4bjtcbn07XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWwob3B0aW9ucywgbGVnYWN5TW9kZSwgVnVlSTE4bkxlZ2FjeSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGNvbnN0IHNjb3BlID0gZWZmZWN0U2NvcGUoKTtcbiAgICB7XG4gICAgICAgIGNvbnN0IG9iaiA9IF9fVlVFX0kxOE5fTEVHQUNZX0FQSV9fICYmIGxlZ2FjeU1vZGVcbiAgICAgICAgICAgID8gc2NvcGUucnVuKCgpID0+IGNyZWF0ZVZ1ZUkxOG4ob3B0aW9ucykpXG4gICAgICAgICAgICA6IHNjb3BlLnJ1bigoKSA9PiBjcmVhdGVDb21wb3NlcihvcHRpb25zKSk7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLlVORVhQRUNURURfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc2NvcGUsIG9ial07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0STE4bkluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgICBjb25zdCBpMThuID0gaW5qZWN0KCFpbnN0YW5jZS5pc0NFXG4gICAgICAgICAgICA/IGluc3RhbmNlLmFwcENvbnRleHQuYXBwLl9fVlVFX0kxOE5fU1lNQk9MX19cbiAgICAgICAgICAgIDogSTE4bkluamVjdGlvbktleSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWkxOG4pIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcighaW5zdGFuY2UuaXNDRVxuICAgICAgICAgICAgICAgID8gSTE4bkVycm9yQ29kZXMuVU5FWFBFQ1RFRF9FUlJPUlxuICAgICAgICAgICAgICAgIDogSTE4bkVycm9yQ29kZXMuTk9UX0lOU1RBTExFRF9XSVRIX1BST1ZJREUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpMThuO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBnZXRTY29wZShvcHRpb25zLCBjb21wb25lbnRPcHRpb25zKSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgcmV0dXJuIGlzRW1wdHlPYmplY3Qob3B0aW9ucylcbiAgICAgICAgPyAoJ19faTE4bicgaW4gY29tcG9uZW50T3B0aW9ucylcbiAgICAgICAgICAgID8gJ2xvY2FsJ1xuICAgICAgICAgICAgOiAnZ2xvYmFsJ1xuICAgICAgICA6ICFvcHRpb25zLnVzZVNjb3BlXG4gICAgICAgICAgICA/ICdsb2NhbCdcbiAgICAgICAgICAgIDogb3B0aW9ucy51c2VTY29wZTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbENvbXBvc2VyKGkxOG4pIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICByZXR1cm4gaTE4bi5tb2RlID09PSAnY29tcG9zaXRpb24nXG4gICAgICAgICAgICA/IGkxOG4uZ2xvYmFsXG4gICAgICAgICAgICA6IGkxOG4uZ2xvYmFsLl9fY29tcG9zZXJcbiAgICAgICAgO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9zZXIoaTE4biwgdGFyZ2V0LCB1c2VDb21wb25lbnQgPSBmYWxzZSkge1xuICAgIGxldCBjb21wb3NlciA9IG51bGw7XG4gICAgY29uc3Qgcm9vdCA9IHRhcmdldC5yb290O1xuICAgIGxldCBjdXJyZW50ID0gZ2V0UGFyZW50Q29tcG9uZW50SW5zdGFuY2UodGFyZ2V0LCB1c2VDb21wb25lbnQpO1xuICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaTE4bkludGVybmFsID0gaTE4bjtcbiAgICAgICAgaWYgKGkxOG4ubW9kZSA9PT0gJ2NvbXBvc2l0aW9uJykge1xuICAgICAgICAgICAgY29tcG9zZXIgPSBpMThuSW50ZXJuYWwuX19nZXRJbnN0YW5jZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfX1ZVRV9JMThOX0xFR0FDWV9BUElfXykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZ1ZUkxOG4gPSBpMThuSW50ZXJuYWwuX19nZXRJbnN0YW5jZShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodnVlSTE4biAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2VyID0gdnVlSTE4blxuICAgICAgICAgICAgICAgICAgICAgICAgLl9fY29tcG9zZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VDb21wb25lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2VyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhY29tcG9zZXJbSW5lamN0V2l0aE9wdGlvbl0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9zZXI7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRDb21wb25lbnRJbnN0YW5jZSh0YXJnZXQsIHVzZUNvbXBvbmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB7XG4gICAgICAgIC8vIGlmIGB1c2VDb21wb25lbnQ6IHRydWVgIHdpbGwgYmUgc3BlY2lmaWVkLCB3ZSBnZXQgbGV4aWNhbCBzY29wZSBvd25lciBpbnN0YW5jZSBmb3IgdXNlLWNhc2Ugc2xvdHNcbiAgICAgICAgcmV0dXJuICF1c2VDb21wb25lbnRcbiAgICAgICAgICAgID8gdGFyZ2V0LnBhcmVudFxuICAgICAgICAgICAgOiB0YXJnZXQudm5vZGUuY3R4IHx8IHRhcmdldC5wYXJlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwTGlmZUN5Y2xlKGkxOG4sIHRhcmdldCwgY29tcG9zZXIpIHtcbiAgICBsZXQgZW1pdHRlciA9IG51bGw7XG4gICAge1xuICAgICAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvc2VyIGluc3RhbmNlIHRvIERPTSBmb3IgaW50bGlmeS1kZXZ0b29sc1xuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJlxuICAgICAgICAgICAgICAgICFmYWxzZSAmJlxuICAgICAgICAgICAgICAgIHRhcmdldC52bm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC52bm9kZS5lbC5fX1ZVRV9JMThOX18gPSBjb21wb3NlcjtcbiAgICAgICAgICAgICAgICBlbWl0dGVyID0gY3JlYXRlRW1pdHRlcigpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgX2NvbXBvc2VyID0gY29tcG9zZXI7XG4gICAgICAgICAgICAgICAgX2NvbXBvc2VyW0VuYWJsZUVtaXR0ZXJdICYmIF9jb21wb3NlcltFbmFibGVFbWl0dGVyXShlbWl0dGVyKTtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLm9uKCcqJywgYWRkVGltZWxpbmVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRhcmdldCk7XG4gICAgICAgIG9uVW5tb3VudGVkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjb21wb3NlciBpbnN0YW5jZSBmcm9tIERPTSBmb3IgaW50bGlmeS1kZXZ0b29sc1xuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJlxuICAgICAgICAgICAgICAgICFmYWxzZSAmJlxuICAgICAgICAgICAgICAgIHRhcmdldC52bm9kZS5lbCAmJlxuICAgICAgICAgICAgICAgIHRhcmdldC52bm9kZS5lbC5fX1ZVRV9JMThOX18pIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyICYmIGVtaXR0ZXIub2ZmKCcqJywgYWRkVGltZWxpbmVFdmVudCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCBfY29tcG9zZXIgPSBjb21wb3NlcjtcbiAgICAgICAgICAgICAgICBfY29tcG9zZXJbRGlzYWJsZUVtaXR0ZXJdICYmIF9jb21wb3NlcltEaXNhYmxlRW1pdHRlcl0oKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0LnZub2RlLmVsLl9fVlVFX0kxOE5fXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkxOG4uX19kZWxldGVJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgICB9LCB0YXJnZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZUkxOG5Gb3JMZWdhY3koaW5zdGFuY2UsIHNjb3BlLCByb290LCBvcHRpb25zID0ge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICBjb25zdCBpc0xvY2FsU2NvcGUgPSBzY29wZSA9PT0gJ2xvY2FsJztcbiAgICBjb25zdCBfY29tcG9zZXIgPSBzaGFsbG93UmVmKG51bGwpO1xuICAgIGlmIChpc0xvY2FsU2NvcGUgJiZcbiAgICAgICAgaW5zdGFuY2UucHJveHkgJiZcbiAgICAgICAgIShpbnN0YW5jZS5wcm94eS4kb3B0aW9ucy5pMThuIHx8IGluc3RhbmNlLnByb3h5LiRvcHRpb25zLl9faTE4bikpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLk1VU1RfREVGSU5FX0kxOE5fT1BUSU9OX0lOX0FMTE9XX0NPTVBPU0lUSU9OKTtcbiAgICB9XG4gICAgY29uc3QgX2luaGVyaXRMb2NhbGUgPSBpc0Jvb2xlYW4ob3B0aW9ucy5pbmhlcml0TG9jYWxlKVxuICAgICAgICA/IG9wdGlvbnMuaW5oZXJpdExvY2FsZVxuICAgICAgICA6ICFpc1N0cmluZyhvcHRpb25zLmxvY2FsZSk7XG4gICAgY29uc3QgX2xvY2FsZSA9IHJlZihcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAhaXNMb2NhbFNjb3BlIHx8IF9pbmhlcml0TG9jYWxlXG4gICAgICAgID8gcm9vdC5sb2NhbGUudmFsdWVcbiAgICAgICAgOiBpc1N0cmluZyhvcHRpb25zLmxvY2FsZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgIDogREVGQVVMVF9MT0NBTEUpO1xuICAgIGNvbnN0IF9mYWxsYmFja0xvY2FsZSA9IHJlZihcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAhaXNMb2NhbFNjb3BlIHx8IF9pbmhlcml0TG9jYWxlXG4gICAgICAgID8gcm9vdC5mYWxsYmFja0xvY2FsZS52YWx1ZVxuICAgICAgICA6IGlzU3RyaW5nKG9wdGlvbnMuZmFsbGJhY2tMb2NhbGUpIHx8XG4gICAgICAgICAgICBpc0FycmF5KG9wdGlvbnMuZmFsbGJhY2tMb2NhbGUpIHx8XG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KG9wdGlvbnMuZmFsbGJhY2tMb2NhbGUpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmZhbGxiYWNrTG9jYWxlID09PSBmYWxzZVxuICAgICAgICAgICAgPyBvcHRpb25zLmZhbGxiYWNrTG9jYWxlXG4gICAgICAgICAgICA6IF9sb2NhbGUudmFsdWUpO1xuICAgIGNvbnN0IF9tZXNzYWdlcyA9IHJlZihnZXRMb2NhbGVNZXNzYWdlcyhfbG9jYWxlLnZhbHVlLCBvcHRpb25zKSk7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgX2RhdGV0aW1lRm9ybWF0cyA9IHJlZihpc1BsYWluT2JqZWN0KG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzKVxuICAgICAgICA/IG9wdGlvbnMuZGF0ZXRpbWVGb3JtYXRzXG4gICAgICAgIDogeyBbX2xvY2FsZS52YWx1ZV06IHt9IH0pO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF9udW1iZXJGb3JtYXRzID0gcmVmKGlzUGxhaW5PYmplY3Qob3B0aW9ucy5udW1iZXJGb3JtYXRzKVxuICAgICAgICA/IG9wdGlvbnMubnVtYmVyRm9ybWF0c1xuICAgICAgICA6IHsgW19sb2NhbGUudmFsdWVdOiB7fSB9KTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfbWlzc2luZ1dhcm4gPSBpc0xvY2FsU2NvcGVcbiAgICAgICAgPyByb290Lm1pc3NpbmdXYXJuXG4gICAgICAgIDogaXNCb29sZWFuKG9wdGlvbnMubWlzc2luZ1dhcm4pIHx8IGlzUmVnRXhwKG9wdGlvbnMubWlzc2luZ1dhcm4pXG4gICAgICAgICAgICA/IG9wdGlvbnMubWlzc2luZ1dhcm5cbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfZmFsbGJhY2tXYXJuID0gaXNMb2NhbFNjb3BlXG4gICAgICAgID8gcm9vdC5mYWxsYmFja1dhcm5cbiAgICAgICAgOiBpc0Jvb2xlYW4ob3B0aW9ucy5mYWxsYmFja1dhcm4pIHx8IGlzUmVnRXhwKG9wdGlvbnMuZmFsbGJhY2tXYXJuKVxuICAgICAgICAgICAgPyBvcHRpb25zLmZhbGxiYWNrV2FyblxuICAgICAgICAgICAgOiB0cnVlO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF9mYWxsYmFja1Jvb3QgPSBpc0xvY2FsU2NvcGVcbiAgICAgICAgPyByb290LmZhbGxiYWNrUm9vdFxuICAgICAgICA6IGlzQm9vbGVhbihvcHRpb25zLmZhbGxiYWNrUm9vdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5mYWxsYmFja1Jvb3RcbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAvLyBjb25maWd1cmUgZmFsbCBiYWNrIHRvIHJvb3RcbiAgICBjb25zdCBfZmFsbGJhY2tGb3JtYXQgPSAhIW9wdGlvbnMuZmFsbGJhY2tGb3JtYXQ7XG4gICAgLy8gcnVudGltZSBtaXNzaW5nXG4gICAgY29uc3QgX21pc3NpbmcgPSBpc0Z1bmN0aW9uKG9wdGlvbnMubWlzc2luZykgPyBvcHRpb25zLm1pc3NpbmcgOiBudWxsO1xuICAgIC8vIHBvc3RUcmFuc2xhdGlvbiBoYW5kbGVyXG4gICAgY29uc3QgX3Bvc3RUcmFuc2xhdGlvbiA9IGlzRnVuY3Rpb24ob3B0aW9ucy5wb3N0VHJhbnNsYXRpb24pXG4gICAgICAgID8gb3B0aW9ucy5wb3N0VHJhbnNsYXRpb25cbiAgICAgICAgOiBudWxsO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF93YXJuSHRtbE1lc3NhZ2UgPSBpc0xvY2FsU2NvcGVcbiAgICAgICAgPyByb290Lndhcm5IdG1sTWVzc2FnZVxuICAgICAgICA6IGlzQm9vbGVhbihvcHRpb25zLndhcm5IdG1sTWVzc2FnZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy53YXJuSHRtbE1lc3NhZ2VcbiAgICAgICAgICAgIDogdHJ1ZTtcbiAgICBjb25zdCBfZXNjYXBlUGFyYW1ldGVyID0gISFvcHRpb25zLmVzY2FwZVBhcmFtZXRlcjtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfbW9kaWZpZXJzID0gaXNMb2NhbFNjb3BlXG4gICAgICAgID8gcm9vdC5tb2RpZmllcnNcbiAgICAgICAgOiBpc1BsYWluT2JqZWN0KG9wdGlvbnMubW9kaWZpZXJzKVxuICAgICAgICAgICAgPyBvcHRpb25zLm1vZGlmaWVyc1xuICAgICAgICAgICAgOiB7fTtcbiAgICAvLyBwbHVyYWxSdWxlc1xuICAgIGNvbnN0IF9wbHVyYWxSdWxlcyA9IG9wdGlvbnMucGx1cmFsUnVsZXMgfHwgKGlzTG9jYWxTY29wZSAmJiByb290LnBsdXJhbFJ1bGVzKTtcbiAgICAvLyB0cmFjayByZWFjdGl2aXR5XG4gICAgZnVuY3Rpb24gdHJhY2tSZWFjdGl2aXR5VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgX2xvY2FsZS52YWx1ZSxcbiAgICAgICAgICAgIF9mYWxsYmFja0xvY2FsZS52YWx1ZSxcbiAgICAgICAgICAgIF9tZXNzYWdlcy52YWx1ZSxcbiAgICAgICAgICAgIF9kYXRldGltZUZvcm1hdHMudmFsdWUsXG4gICAgICAgICAgICBfbnVtYmVyRm9ybWF0cy52YWx1ZVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBsb2NhbGVcbiAgICBjb25zdCBsb2NhbGUgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZSA/IF9jb21wb3Nlci52YWx1ZS5sb2NhbGUudmFsdWUgOiBfbG9jYWxlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHZhbCA9PiB7XG4gICAgICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLmxvY2FsZS52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9sb2NhbGUudmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBmYWxsYmFja0xvY2FsZVxuICAgIGNvbnN0IGZhbGxiYWNrTG9jYWxlID0gY29tcHV0ZWQoe1xuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWVcbiAgICAgICAgICAgICAgICA/IF9jb21wb3Nlci52YWx1ZS5mYWxsYmFja0xvY2FsZS52YWx1ZVxuICAgICAgICAgICAgICAgIDogX2ZhbGxiYWNrTG9jYWxlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHZhbCA9PiB7XG4gICAgICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLmZhbGxiYWNrTG9jYWxlLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZhbGxiYWNrTG9jYWxlLnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gbWVzc2FnZXNcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUubWVzc2FnZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcmV0dXJuIF9tZXNzYWdlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGV0aW1lRm9ybWF0cyA9IGNvbXB1dGVkKCgpID0+IF9kYXRldGltZUZvcm1hdHMudmFsdWUpO1xuICAgIGNvbnN0IG51bWJlckZvcm1hdHMgPSBjb21wdXRlZCgoKSA9PiBfbnVtYmVyRm9ybWF0cy52YWx1ZSk7XG4gICAgZnVuY3Rpb24gZ2V0UG9zdFRyYW5zbGF0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZVxuICAgICAgICAgICAgPyBfY29tcG9zZXIudmFsdWUuZ2V0UG9zdFRyYW5zbGF0aW9uSGFuZGxlcigpXG4gICAgICAgICAgICA6IF9wb3N0VHJhbnNsYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvc3RUcmFuc2xhdGlvbkhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICBfY29tcG9zZXIudmFsdWUuc2V0UG9zdFRyYW5zbGF0aW9uSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNaXNzaW5nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZSA/IF9jb21wb3Nlci52YWx1ZS5nZXRNaXNzaW5nSGFuZGxlcigpIDogX21pc3Npbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldE1pc3NpbmdIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLnNldE1pc3NpbmdIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcnBXaXRoRGVwcyhmbikge1xuICAgICAgICB0cmFja1JlYWN0aXZpdHlWYWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlXG4gICAgICAgICAgICA/IHdhcnBXaXRoRGVwcygoKSA9PiBSZWZsZWN0LmFwcGx5KF9jb21wb3Nlci52YWx1ZS50LCBudWxsLCBbLi4uYXJnc10pKVxuICAgICAgICAgICAgOiB3YXJwV2l0aERlcHMoKCkgPT4gJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWVcbiAgICAgICAgICAgID8gUmVmbGVjdC5hcHBseShfY29tcG9zZXIudmFsdWUucnQsIG51bGwsIFsuLi5hcmdzXSlcbiAgICAgICAgICAgIDogJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlXG4gICAgICAgICAgICA/IHdhcnBXaXRoRGVwcygoKSA9PiBSZWZsZWN0LmFwcGx5KF9jb21wb3Nlci52YWx1ZS5kLCBudWxsLCBbLi4uYXJnc10pKVxuICAgICAgICAgICAgOiB3YXJwV2l0aERlcHMoKCkgPT4gJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZVxuICAgICAgICAgICAgPyB3YXJwV2l0aERlcHMoKCkgPT4gUmVmbGVjdC5hcHBseShfY29tcG9zZXIudmFsdWUubiwgbnVsbCwgWy4uLmFyZ3NdKSlcbiAgICAgICAgICAgIDogd2FycFdpdGhEZXBzKCgpID0+ICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG0oa2V5KSB7XG4gICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUudG0oa2V5KSA6IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZShrZXksIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLnRlKGtleSwgbG9jYWxlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMb2NhbGVNZXNzYWdlKGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLmdldExvY2FsZU1lc3NhZ2UobG9jYWxlKSA6IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRMb2NhbGVNZXNzYWdlKGxvY2FsZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICBfY29tcG9zZXIudmFsdWUuc2V0TG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgX21lc3NhZ2VzLnZhbHVlW2xvY2FsZV0gPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlTG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLm1lcmdlTG9jYWxlTWVzc2FnZShsb2NhbGUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSkgOiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLnNldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIF9kYXRldGltZUZvcm1hdHMudmFsdWVbbG9jYWxlXSA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZURhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChfY29tcG9zZXIudmFsdWUpIHtcbiAgICAgICAgICAgIF9jb21wb3Nlci52YWx1ZS5tZXJnZURhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUuZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSkgOiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChfY29tcG9zZXIudmFsdWUpIHtcbiAgICAgICAgICAgIF9jb21wb3Nlci52YWx1ZS5zZXROdW1iZXJGb3JtYXQobG9jYWxlLCBmb3JtYXQpO1xuICAgICAgICAgICAgX251bWJlckZvcm1hdHMudmFsdWVbbG9jYWxlXSA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZU51bWJlckZvcm1hdChsb2NhbGUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICBfY29tcG9zZXIudmFsdWUubWVyZ2VOdW1iZXJGb3JtYXQobG9jYWxlLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZXIgPSB7XG4gICAgICAgIGdldCBpZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUuaWQgOiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBmYWxsYmFja0xvY2FsZSxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIGRhdGV0aW1lRm9ybWF0cyxcbiAgICAgICAgbnVtYmVyRm9ybWF0cyxcbiAgICAgICAgZ2V0IGluaGVyaXRMb2NhbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLmluaGVyaXRMb2NhbGUgOiBfaW5oZXJpdExvY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGluaGVyaXRMb2NhbGUodmFsKSB7XG4gICAgICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLmluaGVyaXRMb2NhbGUgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBhdmFpbGFibGVMb2NhbGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZVxuICAgICAgICAgICAgICAgID8gX2NvbXBvc2VyLnZhbHVlLmF2YWlsYWJsZUxvY2FsZXNcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5rZXlzKF9tZXNzYWdlcy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBtb2RpZmllcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9jb21wb3Nlci52YWx1ZSA/IF9jb21wb3Nlci52YWx1ZS5tb2RpZmllcnMgOiBfbW9kaWZpZXJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHBsdXJhbFJ1bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUucGx1cmFsUnVsZXMgOiBfcGx1cmFsUnVsZXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNHbG9iYWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLmlzR2xvYmFsIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBtaXNzaW5nV2FybigpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUubWlzc2luZ1dhcm4gOiBfbWlzc2luZ1dhcm47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBtaXNzaW5nV2Fybih2YWwpIHtcbiAgICAgICAgICAgIGlmIChfY29tcG9zZXIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfY29tcG9zZXIudmFsdWUubWlzc2luZ1dhcm4gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBmYWxsYmFja1dhcm4oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlID8gX2NvbXBvc2VyLnZhbHVlLmZhbGxiYWNrV2FybiA6IF9mYWxsYmFja1dhcm47XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmYWxsYmFja1dhcm4odmFsKSB7XG4gICAgICAgICAgICBpZiAoX2NvbXBvc2VyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvc2VyLnZhbHVlLm1pc3NpbmdXYXJuID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQgZmFsbGJhY2tSb290KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21wb3Nlci52YWx1ZSA/IF9jb21wb3Nlci52YWx1ZS5mYWxsYmFja1Jvb3QgOiBfZmFsbGJhY2tSb290O1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZmFsbGJhY2tSb290KHZhbCkge1xuICAgICAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb3Nlci52YWx1ZS5mYWxsYmFja1Jvb3QgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBmYWxsYmFja0Zvcm1hdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29tcG9zZXIudmFsdWUgPyBfY29tcG9zZXIudmFsdWUuZmFsbGJhY2tGb3JtYXQgOiBfZmFsbGJhY2tGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBmYWxsYmFja0Zvcm1hdCh2YWwpIHtcbiAgICAgICAgICAgIGlmIChfY29tcG9zZXIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfY29tcG9zZXIudmFsdWUuZmFsbGJhY2tGb3JtYXQgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB3YXJuSHRtbE1lc3NhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlXG4gICAgICAgICAgICAgICAgPyBfY29tcG9zZXIudmFsdWUud2Fybkh0bWxNZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBfd2Fybkh0bWxNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgd2Fybkh0bWxNZXNzYWdlKHZhbCkge1xuICAgICAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb3Nlci52YWx1ZS53YXJuSHRtbE1lc3NhZ2UgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBlc2NhcGVQYXJhbWV0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NvbXBvc2VyLnZhbHVlXG4gICAgICAgICAgICAgICAgPyBfY29tcG9zZXIudmFsdWUuZXNjYXBlUGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgOiBfZXNjYXBlUGFyYW1ldGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgZXNjYXBlUGFyYW1ldGVyKHZhbCkge1xuICAgICAgICAgICAgaWYgKF9jb21wb3Nlci52YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9jb21wb3Nlci52YWx1ZS5lc2NhcGVQYXJhbWV0ZXIgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHQsXG4gICAgICAgIGdldFBvc3RUcmFuc2xhdGlvbkhhbmRsZXIsXG4gICAgICAgIHNldFBvc3RUcmFuc2xhdGlvbkhhbmRsZXIsXG4gICAgICAgIGdldE1pc3NpbmdIYW5kbGVyLFxuICAgICAgICBzZXRNaXNzaW5nSGFuZGxlcixcbiAgICAgICAgcnQsXG4gICAgICAgIGQsXG4gICAgICAgIG4sXG4gICAgICAgIHRtLFxuICAgICAgICB0ZSxcbiAgICAgICAgZ2V0TG9jYWxlTWVzc2FnZSxcbiAgICAgICAgc2V0TG9jYWxlTWVzc2FnZSxcbiAgICAgICAgbWVyZ2VMb2NhbGVNZXNzYWdlLFxuICAgICAgICBnZXREYXRlVGltZUZvcm1hdCxcbiAgICAgICAgc2V0RGF0ZVRpbWVGb3JtYXQsXG4gICAgICAgIG1lcmdlRGF0ZVRpbWVGb3JtYXQsXG4gICAgICAgIGdldE51bWJlckZvcm1hdCxcbiAgICAgICAgc2V0TnVtYmVyRm9ybWF0LFxuICAgICAgICBtZXJnZU51bWJlckZvcm1hdFxuICAgIH07XG4gICAgZnVuY3Rpb24gc3luYyhjb21wb3Nlcikge1xuICAgICAgICBjb21wb3Nlci5sb2NhbGUudmFsdWUgPSBfbG9jYWxlLnZhbHVlO1xuICAgICAgICBjb21wb3Nlci5mYWxsYmFja0xvY2FsZS52YWx1ZSA9IF9mYWxsYmFja0xvY2FsZS52YWx1ZTtcbiAgICAgICAgT2JqZWN0LmtleXMoX21lc3NhZ2VzLnZhbHVlKS5mb3JFYWNoKGxvY2FsZSA9PiB7XG4gICAgICAgICAgICBjb21wb3Nlci5tZXJnZUxvY2FsZU1lc3NhZ2UobG9jYWxlLCBfbWVzc2FnZXMudmFsdWVbbG9jYWxlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyhfZGF0ZXRpbWVGb3JtYXRzLnZhbHVlKS5mb3JFYWNoKGxvY2FsZSA9PiB7XG4gICAgICAgICAgICBjb21wb3Nlci5tZXJnZURhdGVUaW1lRm9ybWF0KGxvY2FsZSwgX2RhdGV0aW1lRm9ybWF0cy52YWx1ZVtsb2NhbGVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKF9udW1iZXJGb3JtYXRzLnZhbHVlKS5mb3JFYWNoKGxvY2FsZSA9PiB7XG4gICAgICAgICAgICBjb21wb3Nlci5tZXJnZU51bWJlckZvcm1hdChsb2NhbGUsIF9udW1iZXJGb3JtYXRzLnZhbHVlW2xvY2FsZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29tcG9zZXIuZXNjYXBlUGFyYW1ldGVyID0gX2VzY2FwZVBhcmFtZXRlcjtcbiAgICAgICAgY29tcG9zZXIuZmFsbGJhY2tGb3JtYXQgPSBfZmFsbGJhY2tGb3JtYXQ7XG4gICAgICAgIGNvbXBvc2VyLmZhbGxiYWNrUm9vdCA9IF9mYWxsYmFja1Jvb3Q7XG4gICAgICAgIGNvbXBvc2VyLmZhbGxiYWNrV2FybiA9IF9mYWxsYmFja1dhcm47XG4gICAgICAgIGNvbXBvc2VyLm1pc3NpbmdXYXJuID0gX21pc3NpbmdXYXJuO1xuICAgICAgICBjb21wb3Nlci53YXJuSHRtbE1lc3NhZ2UgPSBfd2Fybkh0bWxNZXNzYWdlO1xuICAgIH1cbiAgICBvbkJlZm9yZU1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3h5ID09IG51bGwgfHwgaW5zdGFuY2UucHJveHkuJGkxOG4gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLk5PVF9BVkFJTEFCTEVfQ09NUE9TSVRJT05fSU5fTEVHQUNZKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjb21wb3NlciA9IChfY29tcG9zZXIudmFsdWUgPSBpbnN0YW5jZS5wcm94eS4kaTE4blxuICAgICAgICAgICAgLl9fY29tcG9zZXIpO1xuICAgICAgICBpZiAoc2NvcGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICBfbG9jYWxlLnZhbHVlID0gY29tcG9zZXIubG9jYWxlLnZhbHVlO1xuICAgICAgICAgICAgX2ZhbGxiYWNrTG9jYWxlLnZhbHVlID0gY29tcG9zZXIuZmFsbGJhY2tMb2NhbGUudmFsdWU7XG4gICAgICAgICAgICBfbWVzc2FnZXMudmFsdWUgPSBjb21wb3Nlci5tZXNzYWdlcy52YWx1ZTtcbiAgICAgICAgICAgIF9kYXRldGltZUZvcm1hdHMudmFsdWUgPSBjb21wb3Nlci5kYXRldGltZUZvcm1hdHMudmFsdWU7XG4gICAgICAgICAgICBfbnVtYmVyRm9ybWF0cy52YWx1ZSA9IGNvbXBvc2VyLm51bWJlckZvcm1hdHMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMb2NhbFNjb3BlKSB7XG4gICAgICAgICAgICBzeW5jKGNvbXBvc2VyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVyO1xufVxuY29uc3QgZ2xvYmFsRXhwb3J0UHJvcHMgPSBbXG4gICAgJ2xvY2FsZScsXG4gICAgJ2ZhbGxiYWNrTG9jYWxlJyxcbiAgICAnYXZhaWxhYmxlTG9jYWxlcydcbl07XG5jb25zdCBnbG9iYWxFeHBvcnRNZXRob2RzID0gWyd0JywgJ3J0JywgJ2QnLCAnbicsICd0bScsICd0ZSddXG4gICAgO1xuZnVuY3Rpb24gaW5qZWN0R2xvYmFsRmllbGRzKGFwcCwgY29tcG9zZXIpIHtcbiAgICBjb25zdCBpMThuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBnbG9iYWxFeHBvcnRQcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb21wb3NlciwgcHJvcCk7XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgdGhyb3cgY3JlYXRlSTE4bkVycm9yKEkxOG5FcnJvckNvZGVzLlVORVhQRUNURURfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1JlZihkZXNjLnZhbHVlKSAvLyBjaGVjayBjb21wdXRlZCBwcm9wc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzYy52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjLnZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0ICYmIGRlc2MuZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGkxOG4sIHByb3AsIHdyYXApO1xuICAgIH0pO1xuICAgIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcy4kaTE4biA9IGkxOG47XG4gICAgZ2xvYmFsRXhwb3J0TWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbXBvc2VyLCBtZXRob2QpO1xuICAgICAgICBpZiAoIWRlc2MgfHwgIWRlc2MudmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUkxOG5FcnJvcihJMThuRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBgJCR7bWV0aG9kfWAsIGRlc2MpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlbGVhc2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGRlbGV0ZSBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJGkxOG47XG4gICAgICAgIGdsb2JhbEV4cG9ydE1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGRlbGV0ZSBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXNbYCQke21ldGhvZH1gXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVsZWFzZTtcbn1cblxue1xuICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcbn1cbi8vIHJlZ2lzdGVyIG1lc3NhZ2UgY29tcGlsZXIgYXQgdnVlLWkxOG5cbmlmICghX19JTlRMSUZZX0pJVF9DT01QSUxBVElPTl9fKSB7XG4gICAgcmVnaXN0ZXJNZXNzYWdlQ29tcGlsZXIoY29tcGlsZVRvRnVuY3Rpb24pO1xufVxuZWxzZSB7XG4gICAgcmVnaXN0ZXJNZXNzYWdlQ29tcGlsZXIoY29tcGlsZSk7XG59XG4vLyByZWdpc3RlciBtZXNzYWdlIHJlc29sdmVyIGF0IHZ1ZS1pMThuXG5yZWdpc3Rlck1lc3NhZ2VSZXNvbHZlcihyZXNvbHZlVmFsdWUpO1xuLy8gcmVnaXN0ZXIgZmFsbGJhY2sgbG9jYWxlIGF0IHZ1ZS1pMThuXG5yZWdpc3RlckxvY2FsZUZhbGxiYWNrZXIoZmFsbGJhY2tXaXRoTG9jYWxlQ2hhaW4pO1xuLy8gTk9URTogZXhwZXJpbWVudGFsICEhXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fSU5UTElGWV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gICAgdGFyZ2V0Ll9fSU5UTElGWV9fID0gdHJ1ZTtcbiAgICBzZXREZXZUb29sc0hvb2sodGFyZ2V0Ll9fSU5UTElGWV9ERVZUT09MU19HTE9CQUxfSE9PS19fKTtcbn1cbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcblxuZXhwb3J0IHsgRGF0ZXRpbWVGb3JtYXQsIEkxOG5ELCBJMThuSW5qZWN0aW9uS2V5LCBJMThuTiwgSTE4blQsIE51bWJlckZvcm1hdCwgVHJhbnNsYXRpb24sIFZFUlNJT04sIGNhc3RUb1Z1ZUkxOG4sIGNyZWF0ZUkxOG4sIHVzZUkxOG4sIHZURGlyZWN0aXZlIH07XG4iLCJjb25zdCB0cmFuc2xhdGlvbnMgPSB7XG4gIGZpOiByZXF1aXJlKCdAL2kxOG4vZmkuanNvbicpLFxuICBzdjogcmVxdWlyZSgnQC9pMThuL3N2Lmpzb24nKSxcbiAgZW46IHJlcXVpcmUoJ0AvaTE4bi9maS5qc29uJyksXG4gIHNlOiByZXF1aXJlKCdAL2kxOG4vc2UuanNvbicpLFxufVxuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2xhdGlvbnM7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGEgcm9sZT1cImJ1dHRvblwiIEBjbGljaz1cImlzT3BlbmVkID0gIWlzT3BlbmVkXCIgaWQ9XCJmb3JkaXJlY3RuZXdcIiA6aHJlZj1cImAke3BhZ2VVcmwuc3BsaXQoJyMnKVswXX0jc3VnZ2VzdGlvbmBcIj5cbiAgICAgIDxzcGFuPlxuICAgICAgICA8ZGl2IGlkPVwidm9jYWItaW5mb1wiPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aDM+e3sgJHQoJ25ldy5idXR0b24nKSB9fTwvaDM+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zcGFuPlxuICAgIDwvYT5cbiAgICA8Y2VudGVyZWQtZGlhbG9nIHYtaWY9XCJpc09wZW5lZFwiIEBjbG9zZT1cImNsb3NlRGlhbG9nKClcIj5cbiAgICAgIDxuZXctc3VnZ2VzdGlvblxuICAgICAgICA6Y29uY2VwdFR5cGVJc1NlbGVjdGVkPVwiY29uY2VwdFR5cGVJc1NlbGVjdGVkXCJcbiAgICAgICAgOnByZWZMYWJlbE9rYXk9XCJwcmVmTGFiZWxPa2F5XCJcbiAgICAgICAgOmV4cGxhbmF0aW9uT2theT1cImV4cGxhbmF0aW9uT2theVwiXG4gICAgICAgIDpuZWVkZWRGb3JPa2F5PVwibmVlZGVkRm9yT2theVwiXG4gICAgICAgIDpzZW5kaW5nPVwic2VuZGluZ1wiXG4gICAgICAgIEB1cGRhdGU6Y29uY2VwdFR5cGVJc1NlbGVjdGVkPVwiY29uY2VwdFR5cGVJc1NlbGVjdGVkID0gdHJ1ZVwiXG4gICAgICAgIEB1cGRhdGU6cHJlZkxhYmVsT2theT1cInByZWZMYWJlbE9rYXkgPSB0cnVlXCJcbiAgICAgICAgQHVwZGF0ZTpleHBsYW5hdGlvbk9rYXk9XCJleHBsYW5hdGlvbk9rYXkgPSB0cnVlXCJcbiAgICAgICAgQHVwZGF0ZTpuZWVkZWRGb3JPa2F5PVwibmVlZGVkRm9yT2theSA9IHRydWVcIlxuICAgICAgICB2LWlmPVwiIXNob3dTdWNjZXNzTWVzc2FnZSAmJiAhc2hvd0ZhaWx1cmVNZXNzYWdlXCJcbiAgICAgICAgOmQ9XCJmb3JtRGF0YVwiXG4gICAgICAgIEB1cGRhdGU6dm9jYWJ1bGFyeT1cImZvcm1EYXRhLnZvY2FidWxhcnkgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOmNvbmNlcHRUeXBlPVwiZm9ybURhdGEuY29uY2VwdFR5cGUudmFsdWUgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOnByaW1hcnlQcmVmTGFiZWw9XCJmb3JtRGF0YS5wcmVmTGFiZWwucHJpbWFyeSA9ICRldmVudFwiXG4gICAgICAgIEB1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsPVwiZm9ybURhdGEucHJlZkxhYmVsLnNlY29uZGFyeSA9ICRldmVudFwiXG4gICAgICAgIEB1cGRhdGU6ZW5QcmVmTGFiZWw9XCJmb3JtRGF0YS5wcmVmTGFiZWwuZW4gPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOmFsdExhYmVscz1cImZvcm1EYXRhLmFsdExhYmVscyA9ICRldmVudFwiXG4gICAgICAgIEB1cGRhdGU6YnJvYWRlckxhYmVscz1cImZvcm1EYXRhLmJyb2FkZXJMYWJlbHMgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOm5hcnJvd2VyTGFiZWxzPVwiZm9ybURhdGEubmFycm93ZXJMYWJlbHMgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOnJlbGF0ZWRMYWJlbHM9XCJmb3JtRGF0YS5yZWxhdGVkTGFiZWxzID0gJGV2ZW50XCJcbiAgICAgICAgQHVwZGF0ZTpncm91cHM9XCJmb3JtRGF0YS5ncm91cHMuc2VsZWN0ZWRHcm91cHMgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOmV4YWN0TWF0Y2hlcz1cImZvcm1EYXRhLmV4YWN0TWF0Y2hlcyA9ICRldmVudFwiXG4gICAgICAgIEB1cGRhdGU6c2NvcGVOb3RlPVwiZm9ybURhdGEuc2NvcGVOb3RlID0gJGV2ZW50XCJcbiAgICAgICAgQHVwZGF0ZTpleHBsYW5hdGlvbj1cImZvcm1EYXRhLmV4cGxhbmF0aW9uID0gJGV2ZW50XCJcbiAgICAgICAgQHVwZGF0ZTpuZWVkZWRGb3I9XCJmb3JtRGF0YS5uZWVkZWRGb3IgPSAkZXZlbnRcIlxuICAgICAgICBAdXBkYXRlOmZyb21Pcmc9XCJmb3JtRGF0YS5mcm9tT3JnID0gJGV2ZW50XCJcbiAgICAgICAgQHN1Ym1pdEZvcm09XCJzdWJtaXRGb3JtKClcIlxuICAgICAgLz5cblxuICAgICAgPHN1Y2Nlc3MtbWVzc2FnZSB2LWlmPVwic2hvd1N1Y2Nlc3NNZXNzYWdlXCIgOnN1Z2dlc3Rpb25Vcmw9XCJzdWdnZXN0aW9uVXJsXCIgOnVybD1cInVybFwiIC8+XG4gICAgICA8ZmFpbHVyZS1tZXNzYWdlIHYtaWY9XCJzaG93RmFpbHVyZU1lc3NhZ2VcIiAvPlxuICAgIDwvY2VudGVyZWQtZGlhbG9nPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBkZWZpbmVDb21wb25lbnQsIHJlZiwgcmVhY3RpdmUsIHdhdGNoRWZmZWN0LCBpbmplY3QsIHdhdGNoIH0gZnJvbSAndnVlJztcbmltcG9ydCBOZXdTdWdnZXN0aW9uIGZyb20gJy4vTmV3U3VnZ2VzdGlvbi52dWUnO1xuaW1wb3J0IENlbnRlcmVkRGlhbG9nIGZyb20gJy4vY29tbW9uL0NlbnRlcmVkRGlhbG9nLnZ1ZSc7XG5pbXBvcnQgU3VjY2Vzc01lc3NhZ2UgZnJvbSAnLi9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlJztcbmltcG9ydCBGYWlsdXJlTWVzc2FnZSBmcm9tICcuL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWUnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB1cmxUb1ByeCBmcm9tIFwiLi4vcHJ4Lmpzb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29tcG9uZW50KHtcbiAgY29tcG9uZW50czoge1xuICAgIE5ld1N1Z2dlc3Rpb24sXG4gICAgQ2VudGVyZWREaWFsb2csXG4gICAgU3VjY2Vzc01lc3NhZ2UsXG4gICAgRmFpbHVyZU1lc3NhZ2UsXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbGFuZzogU3RyaW5nLFxuICAgIHZvY2FiOiBTdHJpbmcsXG4gIH0sXG4gIHNldHVwKHByb3BzKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgfSwgNTAwKVxuXG4gICAgLy8gSW5qZWN0IHRoZSBpMThuICR0IGZ1bmN0aW9uIGFuZCBwYWdlVXJsIHZhcmlhYmxlXG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XG4gICAgY29uc3QgdGVzdGkgPSBpbmplY3QoJ3Rlc3RpJylcbiAgICBjb25zdCBwYWdlVXJsID0gaW5qZWN0KCdwYWdlVXJsJyk7XG4gICAgY29uc3QgaXNPcGVuZWQgPSByZWYoZmFsc2UpO1xuICAgIGNvbnN0IHNob3dTdWNjZXNzTWVzc2FnZSA9IHJlZihmYWxzZSk7XG4gICAgY29uc3Qgc2hvd0ZhaWx1cmVNZXNzYWdlID0gcmVmKGZhbHNlKTtcbiAgICBjb25zdCBzdWdnZXN0aW9uVXJsID0gcmVmKCcnKTtcbiAgICBsZXQgY29uY2VwdFR5cGVJc1NlbGVjdGVkID0gcmVmKGZhbHNlKVxuICAgIGxldCBwcmVmTGFiZWxPa2F5ID0gcmVmKGZhbHNlKVxuICAgIGxldCBleHBsYW5hdGlvbk9rYXkgPSByZWYoZmFsc2UpXG4gICAgbGV0IG5lZWRlZEZvck9rYXkgPSByZWYoZmFsc2UpXG4gICAgbGV0IGRhdGFDYW5CZVNlbnRBcnJheSA9IHJlZihbXSlcbiAgICBsZXQgc2VuZGluZyA9IHJlZihmYWxzZSlcblxuICAgIGNvbnN0IGZvcm1EYXRhID0gcmVhY3RpdmUoe1xuICAgICAgdm9jYWJ1bGFyeTogJ3lzbycsXG4gICAgICBjb25jZXB0VHlwZToge1xuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICB7IHZhbHVlOiAnJywgdm9jYWI6ICd5c28nIH0sXG4gICAgICAgICAgeyB2YWx1ZTogJycsIHZvY2FiOiAneXNvLXBhaWthdCcgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBwcmVmTGFiZWw6IHtcbiAgICAgICAgcHJpbWFyeTogJycsXG4gICAgICAgIHNlY29uZGFyeTogJycsXG4gICAgICAgIGZpOiB7IHZhbHVlOiAnJyB9LFxuICAgICAgICBzdjogeyB2YWx1ZTogJycgfSxcbiAgICAgICAgZW46ICcnLFxuICAgICAgfSxcbiAgICAgIGFsdExhYmVsczogW3sgdmFsdWU6ICcnLCBpc1RvdWNoZWQ6IGZhbHNlIH1dLFxuICAgICAgYnJvYWRlckxhYmVsczogW3sgdmFsdWU6ICcnLCB1cmk6ICcnLCBpc1RvdWNoZWQ6IGZhbHNlIH1dLFxuICAgICAgbmFycm93ZXJMYWJlbHM6IFt7IHZhbHVlOiAnJywgdXJpOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XSxcbiAgICAgIHJlbGF0ZWRMYWJlbHM6IFt7IHZhbHVlOiAnJywgdXJpOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XSxcbiAgICAgIGdyb3VwczogeyBhbGxHcm91cHM6IFtdLCBzZWxlY3RlZEdyb3VwczogW10gfSxcbiAgICAgIGV4YWN0TWF0Y2hlczogW3sgdm9jYWI6ICcnLCB2YWx1ZTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV0sXG4gICAgICBzY29wZU5vdGU6ICcnLFxuICAgICAgZXhwbGFuYXRpb246ICcnLFxuICAgICAgbmVlZGVkRm9yOiAnJyxcbiAgICAgIGZyb21Pcmc6ICcnLFxuICAgICAgdGFnczogW10sXG4gICAgfSk7XG5cbiAgICB3YXRjaChcbiAgICAgICAgKCkgPT4gW2Zvcm1EYXRhLmNvbmNlcHRUeXBlLnZhbHVlLCBmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZS5sZW5ndGhdLFxuICAgICAgICAobmV3VmFsdWVzLCBvbGRWYWx1ZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBjb25jZXB0VHlwZUxlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcblxuICAgICAgICAgIGlmIChjb25jZXB0VHlwZUxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbmNlcHRUeXBlSXNTZWxlY3RlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMF0gPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmNlcHRUeXBlSXNTZWxlY3RlZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YUNhbkJlU2VudEFycmF5LnZhbHVlWzBdID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgKTtcblxuICAgIHdhdGNoKFxuICAgICAgICAoKSA9PiBbZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnksIGZvcm1EYXRhLnByZWZMYWJlbC5wcmltYXJ5Lmxlbmd0aF0sXG4gICAgICAgIChuZXdWYWx1ZXMsIG9sZFZhbHVlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHByaW1hcnlMYWJlbExlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcbiAgICAgICAgICBpZiAocHJpbWFyeUxhYmVsTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcHJlZkxhYmVsT2theS52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMV0gPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWZMYWJlbE9rYXkudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRhdGFDYW5CZVNlbnRBcnJheS52YWx1ZVsxXSA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxuICAgICk7XG5cbiAgICB3YXRjaChcbiAgICAgICAgKCkgPT4gW2Zvcm1EYXRhLmV4cGxhbmF0aW9uLCBmb3JtRGF0YS5leHBsYW5hdGlvbi5sZW5ndGhdLFxuICAgICAgICAobmV3VmFsdWVzLCBvbGRWYWx1ZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBleHBsYW5hdGlvbkxlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcbiAgICAgICAgICBpZiAoZXhwbGFuYXRpb25MZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBleHBsYW5hdGlvbk9rYXkudmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgZGF0YUNhbkJlU2VudEFycmF5LnZhbHVlWzJdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwbGFuYXRpb25Pa2F5LnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMl0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgKTtcblxuICAgIHdhdGNoKFxuICAgICAgICAoKSA9PiBbZm9ybURhdGEubmVlZGVkRm9yLCBmb3JtRGF0YS5uZWVkZWRGb3IubGVuZ3RoXSxcbiAgICAgICAgKG5ld1ZhbHVlcywgb2xkVmFsdWVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmVlZGRGb3JMZW5ndGggPSBuZXdWYWx1ZXNbMV07XG4gICAgICAgICAgaWYgKG5lZWRkRm9yTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbmVlZGVkRm9yT2theS52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbM10gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkZWRGb3JPa2F5LnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbM10gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgKTtcblxuICAgIC8vIE1ldGhvZHNcbiAgICBjb25zdCBzZXREcm9wRG93biA9ICgpID0+IHtcbiAgICAgIGZvcm1EYXRhLmNvbmNlcHRUeXBlLm9wdGlvbnNbMF0udmFsdWUgPSAnbmV3LmNvbW1vbi5jb25jZXB0JztcbiAgICAgIGZvcm1EYXRhLmNvbmNlcHRUeXBlLm9wdGlvbnNbMV0udmFsdWUgPSAnbmV3LmNvbW1vbi5nZW8nO1xuICAgIH07XG5cbiAgICBjb25zdCBhZGRIVFRQT3JIVFRQUyA9IChzdHIpID0+IHtcbiAgICAgIGlmICghL14oaHR0cChzPykpOlxcL1xcLy8udGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBgaHR0cDovLyR7c3RyfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7c3RyfWA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgICAvLyAkdi4kdG91Y2goKTtcbiAgICAgIHNlbmRpbmcudmFsdWUgPSB0cnVlXG5cbiAgICAgIGNvbnN0IGNvdW50VHJ1ZVZhbHVlcyA9IGRhdGFDYW5CZVNlbnRBcnJheS52YWx1ZS5yZWR1Y2UoKGNvdW50LCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcblxuICAgICAgaWYgKGNvdW50VHJ1ZVZhbHVlcyA9PT0gNCkge1xuICAgICAgICBzZW5kRGF0YSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RhdGEgbm90IHNlbnQ6IHJlcXVpcmVkIGRhdGEgb2YgdGhlIGZvcm0gd2FzIG5vdCBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICBoYW5kbGVQcmVmTGFiZWxMYW5ndWFnZXMoKTtcbiAgICAgIGxldCBvbnRUeXBlSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtID0gJyc7XG4gICAgICBjb25zdCBsYWJlbHNJblRhcmdldFN1Z2dlc3Rpb25TeXN0ZW0gPSBbXTtcbiAgICAgIGlmIChmb3JtRGF0YS52b2NhYnVsYXJ5ID09PSAneXNvLXBhaWthdCcpIHtcbiAgICAgICAgbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLnB1c2goJ3V1c2knKTtcbiAgICAgICAgbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLnB1c2goJ01BQU5USUVURUVMTElORU4nKTtcbiAgICAgICAgb250VHlwZUluVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbSA9ICdHRU8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLnB1c2goJ3V1c2knKTtcbiAgICAgICAgb250VHlwZUluVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbSA9ICdDT05DRVBUJztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWx0VGVybXMgPSBbXTtcbiAgICAgIGZvcm1EYXRhLmFsdExhYmVscy5mb3JFYWNoKChpdGVtKSA9PiAoaXRlbS52YWx1ZSAhPT0gJycgPyBhbHRUZXJtcy5wdXNoKGAgJHtpdGVtLnZhbHVlfWApIDogbnVsbCkpO1xuXG4gICAgICBjb25zdCBicmRMYWJscyA9IFtdO1xuICAgICAgZm9ybURhdGEuYnJvYWRlckxhYmVscy5mb3JFYWNoKChpdGVtKSA9PlxuICAgICAgICAgIGl0ZW0udmFsdWUgIT09ICcnID8gYnJkTGFibHMucHVzaChgIFske2l0ZW0udmFsdWV9XSgke2l0ZW0udXJpfSlgKSA6IG51bGxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuICAgICAgZm9ybURhdGEuZ3JvdXBzLnNlbGVjdGVkR3JvdXBzLmZvckVhY2goKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS5wcmVmTGFiZWwgIT09ICcnID8gZ3JvdXBzLnB1c2goYCBbJHtpdGVtLnByZWZMYWJlbH1dKCR7aXRlbS51cml9KWApIDogbnVsbFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbnJyTGFibHMgPSBbXTtcbiAgICAgIGZvcm1EYXRhLm5hcnJvd2VyTGFiZWxzLmZvckVhY2goKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS52YWx1ZSAhPT0gJycgPyBucnJMYWJscy5wdXNoKGAgWyR7aXRlbS52YWx1ZX1dKCR7aXRlbS51cml9KWApIDogbnVsbFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgcmx0ZExhYmxzID0gW107XG4gICAgICBmb3JtRGF0YS5yZWxhdGVkTGFiZWxzLmZvckVhY2goKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS52YWx1ZSAhPT0gJycgPyBybHRkTGFibHMucHVzaChgIFske2l0ZW0udmFsdWV9XSgke2l0ZW0udXJpfSlgKSA6IG51bGxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV4Y3RMYWJscyA9IFtdO1xuICAgICAgZm9ybURhdGEuZXhhY3RNYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS52YWx1ZSAhPT0gJycgPyBleGN0TGFibHMucHVzaChgIFske2l0ZW0udm9jYWJ9XSgke2FkZEhUVFBPckhUVFBTKGl0ZW0udmFsdWUpfSlgKSA6IG51bGxcbiAgICAgICk7XG5cbiAgICAgIGxldCBkYXRhID0gYFxuKipLw6RzaXR0ZWVuIHR5eXBwaSoqXG5cbiR7b250VHlwZUluVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbX1cblxuKipFaGRvdGV0dHUgdGVybWkgc3VvbWVrc2kqKlxuXG4ke2Zvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZX1cblxuKipFaGRvdGV0dHUgdGVybWkgcnVvdHNpa3NpKipcblxuJHtmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWV9XG5cbioqRWhkb3RldHR1IHRlcm1pIGVuZ2xhbm5pa3NpKipcblxuJHtmb3JtRGF0YS5wcmVmTGFiZWwuZW59XG5cbioqVGFya29pdHVzdGEgdMOkc21lbnTDpHbDpCBzZWxpdGUqKlxuXG4ke2Zvcm1EYXRhLnNjb3BlTm90ZX1cblxuKipQZXJ1c3RlbHV0IGVoZG90dWtzZWxsZSoqXG5cbiR7Zm9ybURhdGEuZXhwbGFuYXRpb259XG5cbioqRWhkb3RldHR1IHlsw6Rrw6RzaXRlIFlTT3NzYSAoTFQpKipcblxuJHticmRMYWJsc31cblxuKipFaGRvdGV0dXQgdGVtYWF0dGlzZXQgcnlobcOkdCoqXG5cbiR7Z3JvdXBzfVxuXG4qKlZhaWh0b2VodG9pc2V0IHRlcm1pdCoqXG5cbiR7YWx0VGVybXN9XG5cbioqQWxha8Okc2l0dGVldCAoUlQpKipcblxuJHtucnJMYWJsc31cblxuKipBc3Nvc2lhdGlpdmlzZXQgKFJUKSoqXG5cbiR7cmx0ZExhYmxzfVxuXG4qKlZhc3RhYXZhIGvDpHNpdGUgbXV1c3NhIHNhbmFzdG9zc2EqKlxuXG4ke2V4Y3RMYWJsc31cblxuKipBaW5laXN0byBqb25rYSBrdXZhaWx1c3NhIGvDpHNpdGV0dMOkIHRhcnZpdGFhbiAoZXNpbS4gbmltZWtlIHRhaSBVUkwpKipcblxuJHtmb3JtRGF0YS5uZWVkZWRGb3J9XG5cbioqRWhkb3R0YWphbiBvcmdhbmlzYWF0aW8qKlxuXG4ke2Zvcm1EYXRhLmZyb21Pcmd9XG5gO1xuXG4gICAgICBsZXQgZGF0YUJ1bmRsZSA9IHtcbiAgICAgICAgLy8gdGl0bGU6IGZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSAhPT0gJycgPyBmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWUgOiBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUsXG4gICAgICAgIHRpdGxlOiAgd2luZG93LmxhbmcgPT09ICdzdicgPyBmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWUgOiBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUsXG4gICAgICAgIGJvZHk6IGRhdGEsXG4gICAgICAgIHN0YXRlOiAnb3BlbicsXG4gICAgICAgIGxhYmVsczogbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZGF0YUJ1bmRsZSkpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJwYXlsb2FkXCIsIHBheWxvYWQpXG4gICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVybFRvUHJ4ID0gcmVxdWlyZSgnLi4vcHJ4Lmpzb24nKTtcbiAgICAgIGF3YWl0IGF4aW9zXG4gICAgICAvLyBodHRwczovL2ZpbnRvLmZpL3BsdWdpbnMvc3VnZ2VzdGlvbnMvZ2hfcHJ4LnBocFxuICAgICAgLy8gaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy86b3duZXIvOnJlcG9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW50by1laGRvdHVzL1lTRVxuICAgICAgICAgIC5wb3N0KGAke3VybFRvUHJ4WzBdLnVybH0/cGF5bG9hZD0ke3BheWxvYWR9YCwge30sIHsgaGVhZGVycyB9KVxuICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1Jlc3BvbnNlOicsIHJlc3BvbnNlKVxuICAgICAgICAgICAgLy8gdG9nZ2xlU3VjY2Vzc01lc3NhZ2UoYGh0dHBzOi8vZ2l0aHViLmNvbS9GaW50by1laGRvdHVzL1lTRWApO1xuICAgICAgICAgICAgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UoYCR7cmVzcG9uc2UuZGF0YS51cmwucmVwbGFjZSgnL3JlcG9zJywgJycpLnJlcGxhY2UoJ2FwaS4nLCAnJyl9YCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0b2dnbGVGYWlsdXJlTWVzc2FnZSgpO1xuICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UgPSAocmVzcG9uc2VVcmwpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZVVybCAmJiByZXNwb25zZVVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25VcmwudmFsdWUgPSByZXNwb25zZVVybDtcbiAgICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNob3dTdWNjZXNzTWVzc2FnZS52YWx1ZSA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVGYWlsdXJlTWVzc2FnZSA9ICgpID0+IHtcbiAgICAgIHNob3dGYWlsdXJlTWVzc2FnZS52YWx1ZSA9IHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVByZWZMYWJlbExhbmd1YWdlcyA9ICgpID0+IHtcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSA9IGZvcm1EYXRhLnByZWZMYWJlbC5wcmltYXJ5O1xuICAgICAgaWYgKHdpbmRvdy5sYW5nID09PSAnZmknIHx8IHdpbmRvdy5sYW5nID09PSAnZW4nKSB7IC8vIG11dXRvcyAyMDIzLTA5LTE4IGxpc8OkdHRpaW4gZW4gZWh0b1xuICAgICAgICBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUgPSBmb3JtRGF0YS5wcmVmTGFiZWwucHJpbWFyeTtcbiAgICAgICAgZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlID0gZm9ybURhdGEucHJlZkxhYmVsLnNlY29uZGFyeTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93LmxhbmcgPT09ICdzdicpIHtcbiAgICAgICAgZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlID0gZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnk7XG4gICAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSA9IGZvcm1EYXRhLnByZWZMYWJlbC5zZWNvbmRhcnk7XG4gICAgICB9XG4gICAgICAvLyBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUgPyBjb25zb2xlLmxvZyhcImZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZVwiLCBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUpIDogY29uc29sZS5sb2coXCJmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUgWFwiKVxuICAgICAgLy8gZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlID8gY29uc29sZS5sb2coXCJmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWVcIiwgZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlKSA6IGNvbnNvbGUubG9nKFwiZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlIFhcIilcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvc2VEaWFsb2cgPSAoKSA9PiB7XG4gICAgICBpc09wZW5lZC52YWx1ZSA9ICFpc09wZW5lZC52YWx1ZTtcbiAgICAgIHNob3dTdWNjZXNzTWVzc2FnZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gZmFsc2U7XG4gICAgICBzdWdnZXN0aW9uVXJsLnZhbHVlID0gJyc7XG4gICAgICBmb3JtRGF0YS52b2NhYnVsYXJ5ID0gJ3lzbyc7XG4gICAgICBmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZSA9ICcnO1xuICAgICAgZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnkgPSAnJztcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5zZWNvbmRhcnkgPSAnJztcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSA9ICcnO1xuICAgICAgZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlID0gJyc7XG4gICAgICBmb3JtRGF0YS5wcmVmTGFiZWwuZW4gPSAnJztcbiAgICAgIGZvcm1EYXRhLmFsdExhYmVscyA9IFt7IHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XTtcbiAgICAgIGZvcm1EYXRhLmJyb2FkZXJMYWJlbHMgPSBbeyB2YWx1ZTogJycsIHVyaTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV07XG4gICAgICBmb3JtRGF0YS5uYXJyb3dlckxhYmVscyA9IFt7IHZhbHVlOiAnJywgdXJpOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XTtcbiAgICAgIGZvcm1EYXRhLnJlbGF0ZWRMYWJlbHMgPSBbeyB2YWx1ZTogJycsIHVyaTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV07XG4gICAgICBmb3JtRGF0YS5ncm91cHMuc2VsZWN0ZWRHcm91cHMgPSBbXTtcbiAgICAgIGZvcm1EYXRhLmV4YWN0TWF0Y2hlcyA9IFt7IHZvY2FiOiAnJywgdmFsdWU6ICcnLCBpc1RvdWNoZWQ6IGZhbHNlIH1dO1xuICAgICAgZm9ybURhdGEuc2NvcGVOb3RlID0gJyc7XG4gICAgICBmb3JtRGF0YS5leHBsYW5hdGlvbiA9ICcnO1xuICAgICAgZm9ybURhdGEubmVlZGVkRm9yID0gJyc7XG4gICAgICBmb3JtRGF0YS5mcm9tT3JnID0gJyc7XG4gICAgICBzZXREcm9wRG93bigpO1xuICAgICAgLy8gJHYuJHJlc2V0KCk7XG4gICAgICBnZXRHcm91cHMoKTtcbiAgICAgIHNlbmRpbmcudmFsdWUgPSBmYWxzZVxuICAgIH07XG5cbiAgICBjb25zdCBnZXRVcmwgPSBhc3luYyAoKSA9PiB7XG4gICAgICBwYWdlVXJsLnZhbHVlID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldEdyb3VwcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGF4aW9zXG4gICAgICAgICAgLmdldChgaHR0cHM6Ly9hcGkuZmludG8uZmkvcmVzdC92MS8ke2Zvcm1EYXRhLnZvY2FidWxhcnl9L2dyb3Vwc2AsIHtcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAvLyBsYW5nOiBwcm9wcy5sYW5nLFxuICAgICAgICAgICAgICBsYW5nOiB3aW5kb3cubGFuZyA9PT0gJ2VuJyA/ICdmaScgOiB3aW5kb3cubGFuZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gKGZvcm1EYXRhLmdyb3Vwcy5hbGxHcm91cHMgPSByZXNwb25zZS5kYXRhLmdyb3VwcykpO1xuICAgIH07XG5cbiAgICAvLyBMaWZlY3ljbGUgaG9va3NcbiAgICB3YXRjaEVmZmVjdCgoKSA9PiB7XG4gIC8qICAgIGlmIChwcm9wcy5sYW5nID09PSAnc3YnKSB7XG4gICAgICAgIC8vIE5vdGU6ICd0aGlzJyBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBzZXR1cCBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW5zdGVhZCwgeW91IGNhbiB1c2UgJ3Byb3BzJyBkaXJlY3RseS5cbiAgICAgIH0qL1xuICAgICAgc2V0RHJvcERvd24oKTtcbiAgICAgIGdldEdyb3VwcygpO1xuICAgIH0pO1xuXG4gICAgZ2V0R3JvdXBzKCk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHZhcmlhYmxlcyBhbmQgbWV0aG9kcyB5b3Ugd2FudCB0byBleHBvc2UgdG8gdGhlIHRlbXBsYXRlXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VVcmwsXG4gICAgICBpc09wZW5lZCxcbiAgICAgIHNob3dTdWNjZXNzTWVzc2FnZSxcbiAgICAgIHNob3dGYWlsdXJlTWVzc2FnZSxcbiAgICAgIHN1Z2dlc3Rpb25VcmwsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGNvbmNlcHRUeXBlSXNTZWxlY3RlZCxcbiAgICAgIHByZWZMYWJlbE9rYXksXG4gICAgICBleHBsYW5hdGlvbk9rYXksXG4gICAgICBuZWVkZWRGb3JPa2F5LFxuICAgICAgc2V0RHJvcERvd24sXG4gICAgICBhZGRIVFRQT3JIVFRQUyxcbiAgICAgIHN1Ym1pdEZvcm0sXG4gICAgICBzZW5kRGF0YSxcbiAgICAgIHRvZ2dsZVN1Y2Nlc3NNZXNzYWdlLFxuICAgICAgdG9nZ2xlRmFpbHVyZU1lc3NhZ2UsXG4gICAgICBoYW5kbGVQcmVmTGFiZWxMYW5ndWFnZXMsXG4gICAgICBjbG9zZURpYWxvZyxcbiAgICAgIGdldFVybCxcbiAgICAgIGdldEdyb3VwcyxcbiAgICAgIGRhdGFDYW5CZVNlbnRBcnJheSxcbiAgICAgIHNlbmRpbmcsXG4gICAgICB0ZXN0aVxuICAgIH07XG4gIH0sXG59KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4uZXJyb3Ige1xuICBjb2xvcjogI2U4M2EzMDtcbiAgdGV4dC1pbmRlbnQ6IDJweDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBtYXJnaW4tdG9wOiAtMTBweDtcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcbn1cbjo6cGxhY2Vob2xkZXIge1xuICBjb2xvcjogIzVlYThCNztcbiAgb3BhY2l0eTogMTtcbn1cblxuOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gIGNvbG9yOiAjNWVhOEI3O1xuICBvcGFjaXR5OiAxO1xufVxuXG46Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gIGNvbG9yOiAjNWVhOEI3O1xuICBvcGFjaXR5OiAxO1xufVxuPC9zdHlsZT5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0TmV3QnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xNTA3MjdhZVwiIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+XG4gICAgPGxhYmVsIDpmb3I9XCJsYWJlbC5mb3JcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cbiAgICA8ZGl2XG4gICAgICAgIEBjbGljaz1cImlzT3BlbmVkID0gIWlzT3BlbmVkXCJcbiAgICAgICAgOmNsYXNzPVwiW2lzT3BlbmVkID8gJ29wZW5lZCcgOiAnJywgJ3NlbGVjdC1idXR0b24nXVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdC1jb250ZW50XCI+XG4gICAgICAgIDxzcGFuIHYtaWY9XCIhdmFsdWVcIj57eyAkdCgnbmV3LmNvbmNlcHRUeXBlLnBsYWNlaG9sZGVyJykgfX08L3NwYW4+XG4gICAgICAgIDxzcGFuIHYtaWY9XCJ2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwXCIgY2xhc3M9XCJzZWxlY3RlZFwiPnt7IHZhbHVlIH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3ZnLWljb24gaWNvbi1uYW1lPVwidHJpYW5nbGVcIj48aWNvbi10cmlhbmdsZSAvPjwvc3ZnLWljb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgICB2LWlmPVwiaXNPcGVuZWQgJiYgb3B0aW9ucy5sZW5ndGggPT09IDBcIlxuICAgICAgICBjbGFzcz1cImRyb3AtZG93bi1vcHRpb25zIGVtcHR5LW9wdGlvbnNcIlxuICAgICAgICB2LW9uLWNsaWNrLWF3YXk9XCJjbG9zZURyb3BEb3duXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwib3B0aW9uXCIgc3R5bGU9XCJwYWRkaW5nLWxlZnQ6IDE2cHg7XCI+XG4gICAgICAgIDxzcGFuPnt7IG5vT3B0aW9uc01lc3NhZ2UgfX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHYtaWY9XCJpc09wZW5lZCAmJiBvcHRpb25zLmxlbmd0aCA+IDBcIlxuICAgICAgICAgY2xhc3M9XCJkcm9wLWRvd24tb3B0aW9uc1wiXG4gICAgICAgICB2LW9uLWNsaWNrLWF3YXk9XCJjbG9zZURyb3BEb3duXCI+XG4gICAgICA8ZGl2IHYtZm9yPVwiKG9wdGlvbiwgaSkgaW4gb3B0aW9uc1wiXG4gICAgICAgICAgIDprZXk9XCJvcHRpb24uaWRcIlxuICAgICAgICAgICBAY2xpY2s9XCJzZWxlY3RPcHRpb24oaSlcIlxuICAgICAgICAgICA6Y2xhc3M9XCJbaXNTZWxlY3RlZChpKSA/ICdzZWxlY3RlZCcgOiAnJywgJ29wdGlvbiddXCI+XG4gICAgICAgIDxzdmctaWNvblxuICAgICAgICAgICAgOmNsYXNzPVwiW2lzU2VsZWN0ZWQoaSkgPyAnJyA6ICdoaWRkZW4tY2hlY2ttYXJrJ11cIlxuICAgICAgICAgICAgaWNvbi1uYW1lPVwiY2hlY2tcIj48aWNvbi1jaGVjayAvPlxuICAgICAgICA8L3N2Zy1pY29uPlxuICAgICAgICA8cD57eyAkdChvcHRpb24udmFsdWUpIH19PC9wPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7cmVmLCBvbk1vdW50ZWQsIG9uQmVmb3JlVW5tb3VudCwgaW5qZWN0fSBmcm9tICd2dWUnO1xuaW1wb3J0IFN2Z0ljb24gZnJvbSAnLi4vaWNvbnMvU3ZnSWNvbi52dWUnO1xuaW1wb3J0IEljb25UcmlhbmdsZSBmcm9tICcuLi9pY29ucy9JY29uVHJpYW5nbGUudnVlJztcbmltcG9ydCBJY29uQ2hlY2sgZnJvbSAnLi4vaWNvbnMvSWNvbkNoZWNrLnZ1ZSc7XG5pbXBvcnQgeyBkaXJlY3RpdmUgYXMgb25DbGlja0F3YXkgfSBmcm9tICd2dWUzLWNsaWNrLWF3YXknO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBTdmdJY29uLFxuICAgIEljb25UcmlhbmdsZSxcbiAgICBJY29uQ2hlY2tcbiAgfSxcbiAgZGlyZWN0aXZlczoge1xuICAgIG9uQ2xpY2tBd2F5XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBvcHRpb25zOiBBcnJheSxcbiAgICBsYWJlbDogT2JqZWN0XG4gIH0sXG4gIHNldHVwKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHJlZigtMSk7XG4gICAgY29uc3QgaXNPcGVuZWQgPSByZWYoZmFsc2UpO1xuICAgIGNvbnN0IGNvdW50ID0gcmVmKDApXG4gICAgY29uc3Qgbm9PcHRpb25zTWVzc2FnZSA9IGNvbnRleHQuYXR0cnNbJ29uVXBkYXRlOm5vT3B0aW9uc01lc3NhZ2UnXSB8fCAnTm8gb3B0aW9ucyBhdmFpbGFibGUnO1xuICAgIGNvbnN0IHNlbGVjdE9wdGlvbiA9IChpbmRleCkgPT4ge1xuICAgICAgc2VsZWN0ZWRJbmRleC52YWx1ZSA9IGluZGV4O1xuICAgICAgaXNPcGVuZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQuZW1pdCgnY2hhbmdlVm9jYWJ1bGFyeScsIHByb3BzLm9wdGlvbnNbaW5kZXhdLnZvY2FiKTtcbiAgICAgIGNvbnRleHQuZW1pdCgnc2VsZWN0JywgJHQocHJvcHMub3B0aW9uc1tpbmRleF0udmFsdWUpKTsgLy8gcGF0aFxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdCRUZPUkU6IENsaWNrZWQhIGlzT3BlbmVkOicsIGlzT3BlbmVkLnZhbHVlKTtcbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gIWlzT3BlbmVkLnZhbHVlO1xuICAgICAgY29uc29sZS5sb2coJ0FGVEVSOiBDbGlja2VkISBpc09wZW5lZDonLCBpc09wZW5lZC52YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIGNvbnN0IGlzU2VsZWN0ZWQgPSAoaW5kZXgpID0+IHNlbGVjdGVkSW5kZXgudmFsdWUgPT09IGluZGV4O1xuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSAoaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBzZWxlY3RlZEluZGV4LnZhbHVlID09PSBpbmRleDtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvc2VEcm9wRG93biA9ICgpID0+IHtcbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc09wZW5lZCxcbiAgICAgIG5vT3B0aW9uc01lc3NhZ2UsXG4gICAgICBjb3VudCxcbiAgICAgIHNlbGVjdE9wdGlvbixcbiAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICBjbG9zZURyb3BEb3duLFxuICAgICAgaGFuZGxlQ2xpY2tcbiAgICB9O1xuICB9XG59O1xuPC9zY3JpcHQ+XG5cblxuXG48c3R5bGUgc2NvcGVkPlxuLmlucHV0LWNvbnRhaW5lciB7XG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gIHdpZHRoOiA1MCU7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLmlucHV0LWNvbnRhaW5lciBsYWJlbCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBmb250LXdlaWdodDogNTAwO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGNvbG9yOiAjMTExMTExO1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG5cbi5zZWxlY3QtYnV0dG9uIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiA0MHB4O1xuICBjb2xvcjogIzAwNzQ4ZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcbiAgYm9yZGVyOiBub25lO1xuICBib3JkZXItcmFkaXVzOiAxcHg7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgb3V0bGluZTogbm9uZTtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbn1cblxuLnNlbGVjdC1idXR0b24gLnNlbGVjdC1jb250ZW50IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDU1JTtcbiAgbGVmdDogMTRweDtcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgY29sb3I6ICMwMDc0OGY7XG59XG5cbi5zZWxlY3QtYnV0dG9uIHN2ZyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA2MCU7XG4gIHJpZ2h0OiAxMHB4O1xuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcbiAgaGVpZ2h0OiAxNnB4O1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcbn1cblxuLm9wZW5lZCBzdmcge1xuICB0b3A6IDI1JTtcbiAgdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xufVxuXG4uZHJvcC1kb3duLW9wdGlvbnMge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNjhweDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDJweCk7XG4gIHotaW5kZXg6IDQ7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XG4gIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XG4gIGJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XG59XG5cbi5vcHRpb24ge1xuICBwYWRkaW5nOiAxMHB4IDEycHggNnB4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVmNTtcbiAgY29sb3I6ICM1NTU1NTU7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG59XG5cbi5vcHRpb246aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmYmZhO1xuICBjb2xvcjogIzExMTExMTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjdXJzb3I6IGhhbmQ7XG59XG5cbi5vcHRpb24gcCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgbWFyZ2luOiAwO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG59XG5cbi5vcHRpb24gc3ZnIHtcbiAgaGVpZ2h0OiAxMHB4O1xuICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuLnNlbGVjdGVkIHtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cblxuLmhpZGRlbi1jaGVja21hcmsge1xuICBvcGFjaXR5OiAwO1xufVxuXG4uZW1wdHktb3B0aW9ucyB7XG4gIG1pbi13aWR0aDogMjUwcHg7XG59XG5cbkBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xuICAuaW5wdXQtY29udGFpbmVyIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5vcHRpb24ge1xuICAgIHBhZGRpbmc6IDEycHggNnB4IDExcHg7XG4gIH1cbn1cbjwvc3R5bGU+XG4iLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vQmFzaWNEcm9wRG93bi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZWFmYmM5NjAmc2NvcGVkPXRydWVcIiIsIjx0ZW1wbGF0ZT5cbiAgPHN2Z1xuICAgIDp3aWR0aD1cIndpZHRoXCJcbiAgICA6aGVpZ2h0PVwiaGVpZ2h0XCJcbiAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICA6YXJpYS1sYWJlbGxlZGJ5PVwiaWNvbk5hbWVcIlxuICAgIHJvbGU9XCJwcmVzZW50YXRpb25cIlxuICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICAgIDx0aXRsZSA6aWQ9XCJpY29uTmFtZVwiIGxhbmc9XCJlblwiPnt7aWNvbk5hbWV9fSBpY29uPC90aXRsZT5cbiAgICA8ZyA6ZmlsbD1cImljb25Db2xvclwiPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L2c+XG4gIDwvc3ZnPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IHtcbiAgICBpY29uTmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogMjRcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDI0XG4gICAgfSxcbiAgICBpY29uQ29sb3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdjdXJyZW50Q29sb3InXG4gICAgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5zdmc6aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbn1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdmdJY29uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N2Z0ljb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N2Z0ljb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MmZkYTE0YzEmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1N2Z0ljb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJmZGExNGMxJnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vU3ZnSWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vU3ZnSWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL1N2Z0ljb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MmZkYTE0YzEmc2NvcGVkPXRydWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvc3J2L3Nrb3Ntb3MvcGx1Z2lucy9zdWdnZXN0aW9ucy9jb21wb25lbnQtYnVuZGxlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LTJmZGExNGMxXCJdXSlcblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCI8dGVtcGxhdGU+XG4gIDxnIHN0cm9rZS13aWR0aD1cIjJcIj5cbiAgICA8cGF0aCBkPVwiTTQuMDgzMDEgNS44MzMzNEg5LjkxNjM0TDYuOTk5NjcgOC43NUw0LjA4MzAxIDUuODMzMzRaXCIvPlxuICA8L2c+XG48L3RlbXBsYXRlPlxuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0ljb25UcmlhbmdsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWMzZDYzYmNcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0ljb25UcmlhbmdsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWMzZDYzYmNcIlxuY29uc3Qgc2NyaXB0ID0ge31cblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL3Nydi9za29zbW9zL3BsdWdpbnMvc3VnZ2VzdGlvbnMvY29tcG9uZW50LWJ1bmRsZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdXSlcblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCI8dGVtcGxhdGU+XG4gIDxnPlxuICAgIDxwYXRoIGQ9XCJNMjEgNkw5IDE4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+XG4gICAgPHBhdGggZD1cIk00IDEzTDkgMThcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz5cbiAgPC9nPlxuPC90ZW1wbGF0ZT5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9JY29uQ2hlY2sudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI3ZjJjZjZlXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9JY29uQ2hlY2sudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI3ZjJjZjZlXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiY29uc3QgY2xpY2tFdmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkb2N1bWVudC5vbnRvdWNoc3RhcnQgIT09IG51bGwgPyBcImNsaWNrXCIgOiBcInRvdWNoc3RhcnRcIjtcbn07XG5cbmNvbnN0IFVOSVFVRV9JRCA9IFwiX192dWVfY2xpY2tfYXdheV9fXCI7XG5cbmNvbnN0IG9uTW91bnRlZCA9IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgb25Vbm1vdW50ZWQoZWwpO1xuICBsZXQgdm0gPSB2bm9kZS5jb250ZXh0O1xuICBsZXQgY2FsbGJhY2sgPSBiaW5kaW5nLnZhbHVlO1xuICBsZXQgbmV4dFRpY2sgPSBmYWxzZTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgbmV4dFRpY2sgPSB0cnVlO1xuICB9LCAwKTtcblxuICBlbFtVTklRVUVfSURdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCghZWwgfHwgIWVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpICYmIGNhbGxiYWNrICYmIG5leHRUaWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh2bSwgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGNsaWNrRXZlbnRUeXBlKCksIGVsW1VOSVFVRV9JRF0sIGZhbHNlKTtcbn07XG5cbmNvbnN0IG9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGVsKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoY2xpY2tFdmVudFR5cGUoKSwgZWxbVU5JUVVFX0lEXSwgZmFsc2UpO1xuICBkZWxldGUgZWxbVU5JUVVFX0lEXTtcbn07XG5cbmNvbnN0IG9uVXBkYXRlZCA9IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgaWYgKGJpbmRpbmcudmFsdWUgPT09IGJpbmRpbmcub2xkVmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvbk1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbn07XG5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgaW5zdGFsbDogZnVuY3Rpb24gKGFwcCkge1xuICAgIGFwcC5kaXJlY3RpdmUoJ2NsaWNrLWF3YXknLCBkaXJlY3RpdmUpO1xuICB9XG59O1xuY29uc3QgZGlyZWN0aXZlID0ge1xuICBtb3VudGVkOiBvbk1vdW50ZWQsXG4gIHVwZGF0ZWQ6IG9uVXBkYXRlZCxcbiAgdW5tb3VudGVkOiBvblVubW91bnRlZFxufTtcbmNvbnN0IG1peGluID0ge1xuICBkaXJlY3RpdmVzOiB7XG4gICAgQ2xpY2tBd2F5OiBkaXJlY3RpdmVcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGx1Z2luO1xuZXhwb3J0IHsgZGlyZWN0aXZlLCBtaXhpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLmpzLm1hcFxuIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vQmFzaWNEcm9wRG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWVhZmJjOTYwJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lYWZiYzk2MCZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0Jhc2ljRHJvcERvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0Jhc2ljRHJvcERvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWVhZmJjOTYwJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL3Nydi9za29zbW9zL3BsdWdpbnMvc3VnZ2VzdGlvbnMvY29tcG9uZW50LWJ1bmRsZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19zY29wZUlkJyxcImRhdGEtdi1lYWZiYzk2MFwiXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiPHRlbXBsYXRlPlxuPGRpdj5cbiAgPGxhYmVsIDpmb3I9XCJsYWJlbC5mb3JcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cbiAgPGRpdiB2LWlmPVwic2VhcmNoUmVzdWx0XG4gICAgJiYgc2VhcmNoUmVzdWx0LnVyaS5sZW5ndGggPiAwXG4gICAgJiYgc2VhcmNoU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IHNlYXJjaFJlc3VsdC5wcmVmTGFiZWwudG9Mb3dlckNhc2UoKVwiPlxuICAgICAgPGRpdiB2LWlmPVwic2VhcmNoUmVzdWx0LnZvY2FiID09PSAneXNlJ1wiPlxuICAgICAgICA8cD5cbiAgICAgICAgICB7eyAkdCgnbmV3LmNvbW1vbi5pZnlzZTEnKSB9fVxuICAgICAgICAgIDxzdHJvbmc+PGEgdGFyZ2V0PVwiX2JsYW5rXCIgOmhyZWY9XCJzZWFyY2hSZXN1bHQudXJpXCI+e3sgc2VhcmNoUmVzdWx0LmxhbmcgPT09IGxhbmd1YWdlID8gc2VhcmNoUmVzdWx0LnByZWZMYWJlbCA6ICcnfX08L2E+PC9zdHJvbmc+XG4gICAgICAgICAge3sgJHQoJ25ldy5jb21tb24uaWZ5c2UyJykgfX1cbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgPGRpdiB2LWlmPVwic2VhcmNoUmVzdWx0LnZvY2FiID09PSAneXNvJ1wiPlxuICAgICAgPHA+XG4gICAgICAgIHt7ICR0KCduZXcuY29tbW9uLmlmeXNvJykgfX1cbiAgICAgICAgPHN0cm9uZz48YSB0YXJnZXQ9XCJfYmxhbmtcIiA6aHJlZj1cInNlYXJjaFJlc3VsdC51cmlcIj57eyBzZWFyY2hSZXN1bHQubGFuZyA9PT0gbGFuZ3VhZ2UgPyBzZWFyY2hSZXN1bHQucHJlZkxhYmVsIDogJyd9fTwvYT48L3N0cm9uZz5cbiAgICAgIDwvcD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IHYtaWY9XCJzZWFyY2hSZXN1bHQudm9jYWIgPT09ICd5c28tcGFpa2F0J1wiPlxuICAgICAgPHA+XG4gICAgICAgIHt7ICR0KCduZXcuY29tbW9uLmlmeXNvcGFpa2F0JykgfX1cbiAgICAgICAgPHN0cm9uZz48YSB0YXJnZXQ9XCJfYmxhbmtcIiA6aHJlZj1cInNlYXJjaFJlc3VsdC51cmlcIj57eyBzZWFyY2hSZXN1bHQubGFuZyA9PT0gbGFuZ3VhZ2UgPyBzZWFyY2hSZXN1bHQucHJlZkxhYmVsIDogJyd9fTwvYT48L3N0cm9uZz5cbiAgICAgIDwvcD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJpbnB1dC1jb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiYXV0by1jb21wbGV0ZVwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIHYtbW9kZWwudHJpbT1cInNlYXJjaFN0cmluZ1wiXG4gICAgICAgIGNsYXNzPVwiYXV0by1jb21wbGV0ZS1pbnB1dFwiXG4gICAgICAgIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICAgIDxkaXYgQGNsaWNrPVwic2VhcmNoU3RyaW5nID0gJydcIiBjbGFzcz1cImNsZWFyLWlucHV0XCI+XG4gICAgICAgIDxzdmctaWNvblxuICAgICAgICAgIHYtaWY9XCJzZWFyY2hTdHJpbmcubGVuZ3RoID4gMFwiXG4gICAgICAgICAgaWNvbi1uYW1lPVwiY3Jvc3NcIj5cbiAgICAgICAgICA8aWNvbi1jcm9zcyAvPlxuICAgICAgICA8L3N2Zy1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgZGVmaW5lQ29tcG9uZW50LCByZWYsIHJlYWN0aXZlLCB3YXRjaEVmZmVjdCwgaW5qZWN0LCB3YXRjaCB9IGZyb20gJ3Z1ZSc7XG5pbXBvcnQgU3ZnSWNvbiBmcm9tICcuLi9pY29ucy9TdmdJY29uLnZ1ZSc7XG5pbXBvcnQgSWNvbkNyb3NzIGZyb20gJy4uL2ljb25zL0ljb25Dcm9zcy52dWUnO1xuaW1wb3J0IEljb25DaGVjayBmcm9tICcuLi9pY29ucy9JY29uQ2hlY2sudnVlJztcbi8vIGltcG9ydCB7IGRpcmVjdGl2ZSBhcyBvbkNsaWNrYXdheSB9IGZyb20gJ3Z1ZS1jbGlja2F3YXknO1xuLy8gaW1wb3J0IHsgb25DbGlja2F3YXkgfSBmcm9tIFwidnVlMy1jbGljay1hd2F5XCI7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIFN2Z0ljb24sXG4gICAgSWNvbkNyb3NzLFxuICAgIEljb25DaGVja1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlczogQXJyYXksXG4gICAgdm9jYWJ1bGFyeTogU3RyaW5nLFxuICAgIGxhYmVsOiBPYmplY3QsXG4gICAgLy8gdm9jYWJ1bGFyeTogU3RyaW5nLFxuICAgIGxhbmd1YWdlOiBTdHJpbmcsXG4gICAgY29uY2VwdFR5cGU6IFN0cmluZ1xuICB9LFxuXG4gIHNldHVwIChwcm9wcywgY29udGV4dCkge1xuXG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XG5cbiAgICBsZXQgc2VhcmNoU3RyaW5nID0gcmVmKCcnKVxuICAgIGxldCBzZWFyY2hSZXN1bHQgPSByZWYobnVsbClcblxuICAgIHdhdGNoKHNlYXJjaFN0cmluZywgKCkgPT4ge1xuICAgICAgc2VhcmNoTGFiZWwoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNlYXJjaExhYmVsID0gZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VhcmNoU3RyaW5nLnZhbHVlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGhhbmRsZVJlc3VsdChjaGVja0NhcGl0YWxpemF0aW9uKHNlYXJjaFN0cmluZy52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5lbWl0KCdpbnB1dCcsIHNlYXJjaFN0cmluZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgMTUwMClcbiAgICBjb25zdCBoYW5kbGVSZXN1bHQgPSBhc3luYyAoaW5wdXRWYWx1ZSkgPT4ge1xuICAgICAgY29uc3Qgdm9jcyA9IFtcInlzby1wYWlrYXRcIiwgXCJ5c29cIiwgXCJ5c2VcIl07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZvY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcyh7XG4gICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICB1cmw6ICdodHRwczovL2FwaS5maW50by5maS9yZXN0L3YxL3NlYXJjaCcsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2b2NhYjogdm9jc1tpXSxcbiAgICAgICAgICAgIGxhbmc6IHByb3BzLmxhbmd1YWdlLFxuICAgICAgICAgICAgcXVlcnk6IGlucHV0VmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IGNvbnNvbGUubG9nKGVycm9yKSk7XG4gICAgICAgIC8vIEZvciB0aGUgZnV0dXJlOiB0aGlzIGlzIGFzc2lnbmVkIG9ubHkgaWYgdGhlIHRlcm0gaXMgZm91bmQgYW5kIGlzIG51bGwgb3RoZXJ3aXNlXG4gICAgICAgIHNlYXJjaFJlc3VsdC52YWx1ZSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0c1swXVxuICAgICAgICBjb250ZXh0LmVtaXQoJ2lucHV0Jywgc2VhcmNoU3RyaW5nLnZhbHVlKTtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuZW1pdCgnaW5wdXQnLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrQ2FwaXRhbGl6YXRpb24gPSAoaW5wdXRWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGlucHV0VmFsdWUgJiYgcHJvcHMudm9jYWJ1bGFyeSA9PT0gJHQoJ25ldy5jb21tb24ucGxhY2VzJykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpbnB1dFZhbHVlLnN1YnN0cigxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hMYWJlbCxcbiAgICAgIHNlYXJjaFN0cmluZyAsXG4gICAgICBzZWFyY2hSZXN1bHQsXG4gICAgICBjYXBpdGFsaXplRmlyc3RMZXR0ZXIsXG4gICAgICBjaGVja0NhcGl0YWxpemF0aW9uLFxuICAgICAgaGFuZGxlUmVzdWx0XG4gICAgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5hLCBhOmhvdmVyLCBhOmFjdGl2ZSwgYTp2aXNpdGVkIHtcbiAgY29sb3I6ICMwMDc0OGY7XG59XG5cbmxhYmVsIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgY29sb3I6ICMxMTExMTE7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cblxuLmlucHV0LWNvbnRhaW5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5jaGlwLWxpc3Qge1xuICBtYXJnaW46IDE2cHggMCA4cHg7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLmNoaXAtbGlzdCAuY2hpcCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgYmFja2dyb3VuZC1jb2xvcjogIzA2YTc5ODtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIG1hcmdpbjogMCA4cHggOHB4IDA7XG4gIHBhZGRpbmc6IDEwcHggMzJweCA3cHggMTJweDtcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbn1cblxuLmNoaXAtbGlzdCAuY2hpcCBzdmcge1xuICBoZWlnaHQ6IDE2cHg7XG4gIHotaW5kZXg6IDQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA1MCU7XG4gIHJpZ2h0OiA4cHg7XG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uYXV0by1jb21wbGV0ZSB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDQwcHg7XG4gIGNvbG9yOiAjMDA3NDhmO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xuICBib3JkZXItcmFkaXVzOiAxcHg7XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cblxuLmF1dG8tY29tcGxldGUtaW5wdXQge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTMuNSU7XG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiAxMDAlO1xuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIGJvcmRlcjogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbn1cblxuLmF1dG8tY29tcGxldGUgc3ZnIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDUyJTtcbiAgcmlnaHQ6IDEwcHg7XG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xuICBoZWlnaHQ6IDE4cHg7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIG1hcmdpbjogMCAwIC00cHggNnB4O1xufVxuXG4uZHJvcC1kb3duLW9wdGlvbnMge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNDJweDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xuICBvdmVyZmxvdy15OiBzY3JvbGw7XG4gIHotaW5kZXg6IDI7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XG4gIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XG4gIGJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XG59XG5cbi5vcHRpb24ge1xuICBwYWRkaW5nOiAxMHB4IDEycHggNnB4O1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVmNTtcbiAgY29sb3I6ICM1NTU1NTU7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG59XG5cbi5vcHRpb246aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmYmZhO1xuICBjb2xvcjogIzExMTExMTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjdXJzb3I6IGhhbmQ7XG59XG5cbi5vcHRpb24gcCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgbWFyZ2luOiAwO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG59XG5cbi5zZWxlY3RlZCB7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG59XG5cbi5lbXB0eS1vcHRpb25zIHtcbiAgbWluLXdpZHRoOiAyNTBweDtcbn1cblxuQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XG4gIC5pbnB1dC1jb250YWluZXIsIC5kcm9wLWRvd24tb3B0aW9ucyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAub3B0aW9uIHtcbiAgICBwYWRkaW5nOiAxMnB4IDZweCAxMXB4O1xuICB9XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaElucHV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lMDYyYjBhYyZzY29wZWQ9dHJ1ZVwiIiwiPHRlbXBsYXRlPlxuICA8ZyBzdHJva2Utd2lkdGg9XCIyXCI+XG4gICAgPHBhdGggZD1cIk0xOSw1IEw1LDE5XCI+PC9wYXRoPlxuICAgIDwhLS0gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIC0tPlxuICAgIDxwYXRoIGQ9XCJNMTksNSBMNSwxOVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMi4wMDAwMDAsIDEyLjAwMDAwMCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTIuMDAwMDAwLCAtMTIuMDAwMDAwKVwiPjwvcGF0aD5cbiAgPC9nPlxuPC90ZW1wbGF0ZT5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9JY29uQ3Jvc3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY2Zjg0M2MyXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9JY29uQ3Jvc3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY2Zjg0M2MyXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU2VhcmNoSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU2VhcmNoSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaElucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWUwNjJiMGFjJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9TZWFyY2hJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZTA2MmIwYWMmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TZWFyY2hJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vU2VhcmNoSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9TZWFyY2hJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1lMDYyYjBhYyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtZTA2MmIwYWNcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8bGFiZWwgOmZvcj1cImxhYmVsLmZvclwiPnt7IGxhYmVsLnRleHQgfX08L2xhYmVsPlxuICAgIDxkaXYgdi1pZj1cInNlbGVjdGVkT3B0aW9ucyAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID4gMFwiIGNsYXNzPVwiY2hpcC1saXN0XCI+XG4gICAgICA8ZGl2IHYtZm9yPVwib3B0aW9uIGluIHNlbGVjdGVkT3B0aW9uc1wiIEBjbGljaz1cInJlbW92ZUxhYmVsU2VsZWN0aW9uKG9wdGlvbilcIiA6a2V5PVwib3B0aW9uLmlkXCIgY2xhc3M9XCJjaGlwXCI+XG4gICAgICAgIDxzcGFuPnt7IG9wdGlvbi52YWx1ZSB9fTwvc3Bhbj5cbiAgICAgICAgPHN2Zy1pY29uIGljb24tbmFtZT1cImNyb3NzXCI+PGljb24tY3Jvc3MgLz48L3N2Zy1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImF1dG8tY29tcGxldGVcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB2LW1vZGVsLnRyaW09XCJzZWFyY2hTdHJpbmdcIlxuICAgICAgICAgICAgY2xhc3M9XCJhdXRvLWNvbXBsZXRlLWlucHV0XCJcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGRpdiBAY2xpY2s9XCJjbGVhcklucHV0XCIgY2xhc3M9XCJjbGVhci1pbnB1dFwiPlxuICAgICAgICAgIDxzdmctaWNvbiB2LWlmPVwic2VhcmNoU3RyaW5nLmxlbmd0aCA+IDBcIiBpY29uLW5hbWU9XCJjcm9zc1wiPlxuICAgICAgICAgICAgPGljb24tY3Jvc3MgLz5cbiAgICAgICAgICA8L3N2Zy1pY29uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiB2LWlmPVwiaXNPcGVuZWQgJiYgb3B0aW9ucy5sZW5ndGggPiAwXCIgY2xhc3M9XCJkcm9wLWRvd24tb3B0aW9uc1wiIHYtb24tY2xpY2thd2F5PVwiY2xvc2VEcm9wRG93blwiPlxuICAgICAgICA8ZGl2IHYtZm9yPVwib3B0aW9uIGluIG9wdGlvbnNcIiA6a2V5PVwib3B0aW9uLmlkXCIgQGNsaWNrPVwiYWRkTGFiZWxTZWxlY3Rpb24ob3B0aW9uKVwiIGNsYXNzPVwib3B0aW9uXCI+XG4gICAgICAgICAgPHA+e3sgb3B0aW9uLnByZWZMYWJlbCB9fTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgdi1pZj1cIm9wdGlvbnMubGVuZ3RoID09IDAgJiYgaXNPcGVuZWRcIiBjbGFzcz1cImRyb3AtZG93bi1vcHRpb25zIGVtcHR5LW9wdGlvbnNcIiB2LW9uLWNsaWNrYXdheT1cImNsb3NlRHJvcERvd25cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm9wdGlvblwiIHN0eWxlPVwicGFkZGluZy1sZWZ0OiAxNnB4O1wiPlxuICAgICAgICAgIDxzcGFuPnt7IG5vT3B0aW9uc01lc3NhZ2UgfX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL2ljb25zL1N2Z0ljb24udnVlJztcbmltcG9ydCBJY29uQ3Jvc3MgZnJvbSAnLi4vaWNvbnMvSWNvbkNyb3NzLnZ1ZSc7XG5pbXBvcnQgSWNvbkNoZWNrIGZyb20gJy4uL2ljb25zL0ljb25DaGVjay52dWUnO1xuaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2thd2F5IH0gZnJvbSAndnVlMy1jbGljay1hd2F5JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoL2RlYm91bmNlJztcbmltcG9ydCB7cmVmLCB3YXRjaCwgb25Nb3VudGVkLCBkZWZpbmVFbWl0cywgaW5qZWN0fSBmcm9tICd2dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBTdmdJY29uLFxuICAgIEljb25Dcm9zcyxcbiAgICBJY29uQ2hlY2ssXG4gIH0sXG4gIGRpcmVjdGl2ZXM6IHtcbiAgICBvbkNsaWNrYXdheTogb25DbGlja2F3YXksXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWVzOiBBcnJheSxcbiAgICB2b2NhYnVsYXJ5OiBTdHJpbmcsXG4gICAgbGFuZ3VhZ2U6IFN0cmluZyxcbiAgICBsYWJlbDogT2JqZWN0LFxuICAgIGhhc1VuaXF1ZVZhbHVlOiBCb29sZWFuLFxuICB9LFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0ICR0ID0gaW5qZWN0KCckdCcpO1xuICAgIGNvbnN0IGlzT3BlbmVkID0gcmVmKGZhbHNlKTtcbiAgICBjb25zdCBub09wdGlvbnNNZXNzYWdlID0gJHQoJ25ldy5jb21tb24ubm9uZScpOyAvLyBQcm92aWRlIHRoZSB0cmFuc2xhdGlvbiBrZXlcbiAgICBjb25zdCBvcHRpb25zID0gcmVmKFtdKTtcbiAgICBjb25zdCBzZWFyY2hTdHJpbmcgPSByZWYoJycpO1xuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IHJlZihbXSk7XG5cbiAgICBjb25zdCBzZWFyY2hMYWJlbCA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgIGlmIChzZWFyY2hTdHJpbmcudmFsdWUubGVuZ3RoID49IDMpIHtcbiAgICAgICAgZmV0Y2hSZXN1bHRzKGNoZWNrQ2FwaXRhbGl6YXRpb24oc2VhcmNoU3RyaW5nLnZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc09wZW5lZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnZhbHVlID0gW107XG4gICAgICB9XG4gICAgfSwgMjAwKTtcblxuICAgIGNvbnN0IGZldGNoUmVzdWx0cyA9IGFzeW5jIChpbnB1dFZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldCgnaHR0cHM6Ly9hcGkuZmludG8uZmkvcmVzdC92MS9zZWFyY2gnLCB7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2b2NhYjogcHJvcHMudm9jYWJ1bGFyeSxcbiAgICAgICAgICAgIGxhbmc6IHByb3BzLmxhbmd1YWdlLFxuICAgICAgICAgICAgcXVlcnk6IGlucHV0VmFsdWUgKyAnKicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMudmFsdWUgPSByZXNwb25zZS5kYXRhLnJlc3VsdHM7XG4gICAgICAgIGlzT3BlbmVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjaGVja0NhcGl0YWxpemF0aW9uID0gKGlucHV0VmFsdWUpID0+IHtcbiAgICAgIGlmIChpbnB1dFZhbHVlICYmIHByb3BzLnZvY2FidWxhcnkgPT09ICduZXcuY29tbW9uLnBsYWNlcycpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpbnB1dFZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdCBhZGRMYWJlbFNlbGVjdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gZmFsc2U7XG4gICAgICBjb25zdCBvID0ge1xuICAgICAgICB2YWx1ZTogb3B0aW9uLnByZWZMYWJlbCxcbiAgICAgICAgdXJpOiBvcHRpb24udXJpLFxuICAgICAgfTtcbiAgICAgIGlmIChwcm9wcy5oYXNVbmlxdWVWYWx1ZSkge1xuICAgICAgICBzZWxlY3RlZE9wdGlvbnMudmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZWN0ZWRPcHRpb25zLnZhbHVlLnNvbWUoKGl0ZW0pID0+IGl0ZW0udmFsdWUgPT09IG8udmFsdWUpKSB7XG4gICAgICAgIHNlbGVjdGVkT3B0aW9ucy52YWx1ZS5wdXNoKG8pO1xuICAgICAgfVxuICAgICAgc2VhcmNoU3RyaW5nLnZhbHVlID0gJyc7XG4gICAgICBjb250ZXh0LmVtaXQoJ3VwZGF0ZTpzZWxlY3RlZE9wdGlvbnMnLCBzZWxlY3RlZE9wdGlvbnMudmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZW1vdmVMYWJlbFNlbGVjdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0ZWRPcHRpb25zLnZhbHVlLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS51cmkgPT09IG9wdGlvbi51cmkpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zLnZhbHVlLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmVtaXQoJ3VwZGF0ZTpzZWxlY3RlZE9wdGlvbnMnLCBzZWxlY3RlZE9wdGlvbnMudmFsdWUpOyAvLyBFbWl0IHRoZSBldmVudFxuICAgIH07XG5cbiAgICBjb25zdCBjbG9zZURyb3BEb3duID0gKCkgPT4ge1xuICAgICAgaXNPcGVuZWQudmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xlYXJJbnB1dCA9ICgpID0+IHtcbiAgICAgIHNlYXJjaFN0cmluZy52YWx1ZSA9ICcnO1xuICAgIH07XG5cbiAgICB3YXRjaChzZWFyY2hTdHJpbmcsIHNlYXJjaExhYmVsKTtcblxuICAgIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgICAvLyBJbml0aWFsaXplIGRhdGEgb3IgcGVyZm9ybSBhY3Rpb25zIGFmdGVyIGluaXRpYWwgcmVuZGVyXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNPcGVuZWQsXG4gICAgICBub09wdGlvbnNNZXNzYWdlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHNlYXJjaFN0cmluZyxcbiAgICAgIHNlbGVjdGVkT3B0aW9ucyxcbiAgICAgIGFkZExhYmVsU2VsZWN0aW9uLFxuICAgICAgcmVtb3ZlTGFiZWxTZWxlY3Rpb24sXG4gICAgICBjbG9zZURyb3BEb3duLFxuICAgICAgY2xlYXJJbnB1dCxcbiAgICB9O1xuICB9LFxufTtcbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBzY29wZWQ+XG5sYWJlbCB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBmb250LXdlaWdodDogNTAwO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGNvbG9yOiAjMTExMTExO1xuICBtYXJnaW4tYm90dG9tOiA4cHg7XG59XG5cbi5pbnB1dC1jb250YWluZXIge1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uY2hpcC1saXN0IHtcbiAgbWFyZ2luOiAxNnB4IDAgOHB4O1xuICBmb250LXNpemU6IDEycHg7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLyogRmlyZWZveCAqL1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5cbi5jaGlwLWxpc3QgLmNoaXAge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGJhY2tncm91bmQtY29sb3I6ICMwNmE3OTg7XG4gIGNvbG9yOiAjZmZmZmZmO1xuICBtYXJnaW46IDAgOHB4IDhweCAwO1xuICBwYWRkaW5nOiAxMHB4IDMycHggN3B4IDEycHg7XG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjdXJzb3I6IGhhbmQ7XG59XG5cbi5jaGlwLWxpc3QgLmNoaXAgc3ZnIHtcbiAgaGVpZ2h0OiAxNnB4O1xuICB6LWluZGV4OiA0O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTAlO1xuICByaWdodDogOHB4O1xuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcbn1cblxuLmF1dG8tY29tcGxldGUge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiA0MHB4O1xuICBjb2xvcjogIzAwNzQ4ZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcbiAgYm9yZGVyLXJhZGl1czogMXB4O1xuICBmb250LXNpemU6IDE0cHg7XG59XG5cbi5hdXRvLWNvbXBsZXRlLWlucHV0IHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDU1JTtcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XG4gIGhlaWdodDogMTAwJTtcbiAgd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmctbGVmdDogMTBweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBmb250LXdlaWdodDogNDAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xuICBjb2xvcjogIzAwNzQ4ZjtcbiAgYm9yZGVyOiBub25lO1xuICBvdXRsaW5lOiBub25lO1xuICB6LWluZGV4OiAxO1xufVxuXG4uYXV0by1jb21wbGV0ZSBzdmcge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNTIlO1xuICByaWdodDogMTBweDtcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XG4gIGhlaWdodDogMThweDtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgbWFyZ2luOiAwIDAgLTRweCA2cHg7XG59XG5cbi5kcm9wLWRvd24tb3B0aW9ucyB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA0MnB4O1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgbWF4LWhlaWdodDogMjAwcHg7XG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgei1pbmRleDogMjtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgYm9yZGVyOiAxcHggc29saWQgI2UxZTFlMTtcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAtd2Via2l0LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XG4gIC1tb3otYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcbiAgYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcbn1cblxuLm9wdGlvbiB7XG4gIHBhZGRpbmc6IDEwcHggMTJweCA2cHg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZjVmNWY1O1xuICBjb2xvcjogIzU1NTU1NTtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuLm9wdGlvbjpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmM2ZiZmE7XG4gIGNvbG9yOiAjMTExMTExO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbn1cblxuLm9wdGlvbiBwIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBtYXJnaW46IDA7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcbn1cblxuLnNlbGVjdGVkIHtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cblxuLmVtcHR5LW9wdGlvbnMge1xuICBtaW4td2lkdGg6IDI1MHB4O1xufVxuXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcbiAgLmlucHV0LWNvbnRhaW5lciwgLmRyb3AtZG93bi1vcHRpb25zIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5vcHRpb24ge1xuICAgIHBhZGRpbmc6IDEycHggNnB4IDExcHg7XG4gIH1cbn1cbjwvc3R5bGU+XG5cblxuXG5cblxuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2VhZTdiOTMmc2NvcGVkPXRydWVcIiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWFyY2hBdXRvQ29tcGxldGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03ZWFlN2I5MyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03ZWFlN2I5MyZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTdlYWU3YjkzJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL3Nydi9za29zbW9zL3BsdWdpbnMvc3VnZ2VzdGlvbnMvY29tcG9uZW50LWJ1bmRsZXIvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanNcIlxuY29uc3QgX19leHBvcnRzX18gPSAvKiNfX1BVUkVfXyovZXhwb3J0Q29tcG9uZW50KHNjcmlwdCwgW1sncmVuZGVyJyxyZW5kZXJdLFsnX19zY29wZUlkJyxcImRhdGEtdi03ZWFlN2I5M1wiXV0pXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+XG4gICAgPGxhYmVsIDpmb3I9XCJsYWJlbC5mb3JcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cbiAgICA8aW5wdXRcbiAgICAgICAgdi1pZj1cIiFpc1RleHRBcmVhXCJcbiAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICBAaW5wdXQ9XCJlbWl0RXZlbnQoJ2lucHV0OmJhc2ljJywgJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgICB0eXBlPVwidGV4dFwiIC8+XG4gICAgPHRleHRhcmVhXG4gICAgICAgIHYtaWY9XCJpc1RleHRBcmVhXCJcbiAgICAgICAgOnZhbHVlPVwidmFsdWVcIlxuICAgICAgICBAaW5wdXQ9XCJlbWl0RXZlbnQoJ2lucHV0OmJhc2ljJywgJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgICByb3dzPVwiM1wiPlxuICAgIDwvdGV4dGFyZWE+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IGRlZmluZVByb3BzLCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlIH0gZnJvbSAndnVlJztcblxuY29uc3QgcHJvcHMgPSBkZWZpbmVQcm9wcyh7XG4gIHZhbHVlOiBTdHJpbmcsXG4gIGxhYmVsOiB7XG4gICAgdHlwZTogT2JqZWN0LFxuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIGRlZmF1bHQ6ICgpID0+ICh7IHRleHQ6ICcnLCBmb3I6ICcnIH0pXG4gIH0sXG4gIGlzVGV4dEFyZWE6IEJvb2xlYW5cbn0pO1xuXG5jb25zdCBlbWl0RXZlbnQgPSAoZXZlbnROYW1lLCBwYXlsb2FkKSA9PiB7XG4gIGVtaXQoZXZlbnROYW1lLCBwYXlsb2FkKTtcbn07XG5cbmNvbnN0IGVtaXQgPSBkZWZpbmVFbWl0cygpO1xuXG5kZWZpbmVFeHBvc2Uoe1xuICBlbWl0RXZlbnQsXG59KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLmlucHV0LWNvbnRhaW5lciB7XG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XG59XG5cbi5pbnB1dC1jb250YWluZXIgbGFiZWwge1xuICBkaXNwbGF5OiBibG9jaztcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogIzExMTExMTtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xufVxuXG4uaW5wdXQtY29udGFpbmVyIGlucHV0LFxuLmlucHV0LWNvbnRhaW5lciB0ZXh0YXJlYSB7XG4gIGhlaWdodDogNDBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XG4gIGJvcmRlcjogbm9uZTtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIHBhZGRpbmctbGVmdDogMTBweDtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBib3JkZXItcmFkaXVzOiAxcHg7XG4gIG91dGxpbmU6IG5vbmU7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbn1cblxuLmlucHV0LWNvbnRhaW5lciB0ZXh0YXJlYSB7XG4gIGhlaWdodDogNzBweDtcbiAgbWluLWhlaWdodDogNzBweDtcbiAgcGFkZGluZy10b3A6IDhweDtcbiAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcbn1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0lucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZjMzk2MjQ5JnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgc2NyaXB0IGZyb20gXCIuL0Jhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02YzM5NjI0OSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNmMzOTYyNDlcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiPlxuICAgIDxsYWJlbCA6Zm9yPVwibGFiZWwuZm9yXCI+e3sgbGFiZWwudGV4dCB9fTwvbGFiZWw+XG4gICAgPGRpdiB2LWZvcj1cIihpdGVtLCBpKSBpbiB2YWx1ZXNcIiA6a2V5PVwiaXRlbS5pZFwiIGNsYXNzPVwiaW5wdXRzXCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgICB2LW1vZGVsPVwiaXRlbS52YWx1ZVwiXG4gICAgICAgICAgQGlucHV0PVwiaGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSwgaSlcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgcmVmIH0gZnJvbSAndnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHZhbHVlczogQXJyYXksXG4gICAgbGFiZWw6IHtcbiAgICAgIHRleHQ6IFN0cmluZyxcbiAgICAgIGZvcjogU3RyaW5nXG4gICAgfVxuICB9LFxuICBzZXR1cChwcm9wcywgeyBlbWl0IH0pIHtcbiAgICBjb25zdCBoYW5kbGVJbnB1dCA9IChpbnB1dFZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSBwcm9wcy52YWx1ZXMubGVuZ3RoIC0gMSAmJiBpbnB1dFZhbHVlICE9PSAnJykge1xuICAgICAgICBwcm9wcy52YWx1ZXMucHVzaCh7IHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICAgIGVtaXQoJ3VwZGF0ZTp2YWx1ZXMnLCBbLi4ucHJvcHMudmFsdWVzXSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IGhhbmRsZUlucHV0IH07XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLmlucHV0LWNvbnRhaW5lciB7XG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XG59XG5cbi5pbnB1dC1jb250YWluZXIgbGFiZWwge1xuICBkaXNwbGF5OiBibG9jaztcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogIzExMTExMTtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xufVxuXG4uaW5wdXRzIHtcbiAgbWFyZ2luLXRvcDogOHB4O1xufVxuXG4uaW5wdXRzOmZpcnN0LW9mLXR5cGUge1xuICBtYXJnaW4tdG9wOiAwO1xufVxuXG4uaW5wdXRzIGlucHV0IHtcbiAgaGVpZ2h0OiA0MHB4O1xuICB3aWR0aDogMTAwJTtcbiAgYm9yZGVyOiBub25lO1xuICBib3JkZXItcmFkaXVzOiAxcHg7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XG4gIGNvbG9yOiAjMDA3NDhmO1xuICBmb250LXNpemU6IDE0cHg7XG4gIHBhZGRpbmctbGVmdDogMTBweDtcbiAgb3V0bGluZTogbm9uZTtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xufVxuPC9zdHlsZT5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTQzOGFjYzg3JnNjb3BlZD10cnVlXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDM4YWNjODcmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDM4YWNjODcmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD00MzhhY2M4NyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNDM4YWNjODdcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8bGFiZWwgOmZvcj1cImxhYmVsLmZvclwiPnt7IGxhYmVsLnRleHQgfX08L2xhYmVsPlxuICAgIDxkaXYgdi1pZj1cInNlbGVjdGVkT3B0aW9ucyAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID4gMFwiIGNsYXNzPVwiY2hpcC1saXN0XCI+XG4gICAgICA8ZGl2IHYtZm9yPVwib3B0aW9uIGluIHNlbGVjdGVkT3B0aW9uc1wiIEBjbGljaz1cInJlbW92ZU9wdGlvbihvcHRpb24pXCIgOmtleT1cIm9wdGlvbi5pZFwiIGNsYXNzPVwiY2hpcFwiPlxuICAgICAgICA8c3Bhbj57eyBvcHRpb24ucHJlZkxhYmVsIH19PC9zcGFuPlxuICAgICAgICA8c3ZnLWljb24gaWNvbi1uYW1lPVwiY3Jvc3NcIj48aWNvbi1jcm9zcyAvPjwvc3ZnLWljb24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgICAgQGNsaWNrPVwiaXNPcGVuZWQgPSAhaXNPcGVuZWRcIlxuICAgICAgICAgIDpjbGFzcz1cIltpc09wZW5lZCA/ICdvcGVuZWQnIDogJycsICdzZWxlY3QtYnV0dG9uJ11cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdC1jb250ZW50XCI+XG4gICAgICAgICAgPHNwYW4gdi1pZj1cInZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDBcIiBjbGFzcz1cInNlbGVjdGVkXCI+e3sgdmFsdWUgfX08L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8c3ZnLWljb24gaWNvbi1uYW1lPVwidHJpYW5nbGVcIj48aWNvbi10cmlhbmdsZSAvPjwvc3ZnLWljb24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXZcbiAgICAgICAgICB2LWlmPVwiaXNPcGVuZWQgJiYgc2VsZWN0YWJsZU9wdGlvbnMubGVuZ3RoID09PSAwXCIgY2xhc3M9XCJkcm9wLWRvd24tb3B0aW9ucyBlbXB0eS1vcHRpb25zXCIgdi1vbi1jbGlja2F3YXk9XCJjbG9zZURyb3BEb3duXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJvcHRpb25cIiBzdHlsZT1cInBhZGRpbmctbGVmdDogMTZweDtcIj5cbiAgICAgICAgICA8c3Bhbj57eyBub09wdGlvbnNNZXNzYWdlIH19PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiB2LWlmPVwiaXNPcGVuZWQgJiYgc2VsZWN0YWJsZU9wdGlvbnMubGVuZ3RoID4gMFwiIGNsYXNzPVwiZHJvcC1kb3duLW9wdGlvbnNcIiB2LW9uLWNsaWNrYXdheT1cImNsb3NlRHJvcERvd25cIj5cbiAgICAgICAgPGRpdiB2LWZvcj1cIm9wdGlvbiBpbiBzZWxlY3RhYmxlT3B0aW9uc1wiXG4gICAgICAgICAgICAgOmtleT1cIm9wdGlvbi5pZFwiXG4gICAgICAgICAgICAgQGNsaWNrPVwic2VsZWN0T3B0aW9uKG9wdGlvbilcIlxuICAgICAgICAgICAgIGNsYXNzPVwib3B0aW9uXCI+XG4gICAgICAgICAgPHA+e3sgb3B0aW9uLnByZWZMYWJlbCB9fTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFN2Z0ljb24gZnJvbSAnLi4vaWNvbnMvU3ZnSWNvbi52dWUnO1xuaW1wb3J0IEljb25UcmlhbmdsZSBmcm9tICcuLi9pY29ucy9JY29uVHJpYW5nbGUudnVlJztcbmltcG9ydCBJY29uQ3Jvc3MgZnJvbSAnLi4vaWNvbnMvSWNvbkNyb3NzLnZ1ZSc7XG5pbXBvcnQgSWNvbkNoZWNrIGZyb20gJy4uL2ljb25zL0ljb25DaGVjay52dWUnO1xuaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2thd2F5IH0gZnJvbSAndnVlMy1jbGljay1hd2F5JzsgLy8gYWxtb3N0IHdvcmtpbmdcbmltcG9ydCB7IHJlZiwgb25Nb3VudGVkLCBpbmplY3QgfSBmcm9tICd2dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBTdmdJY29uLFxuICAgIEljb25UcmlhbmdsZSxcbiAgICBJY29uQ3Jvc3MsXG4gICAgSWNvbkNoZWNrXG4gIH0sXG4gIGRpcmVjdGl2ZXM6IHtcbiAgICBvbkNsaWNrYXdheTogb25DbGlja2F3YXksXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBvcHRpb25zOiBBcnJheSxcbiAgICBsYWJlbDogT2JqZWN0XG4gIH0sXG5cbiAgc2V0dXAgKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0JylcbiAgICBjb25zdCBpc09wZW5lZCA9IHJlZihmYWxzZSk7XG4gICAgY29uc3Qgbm9PcHRpb25zTWVzc2FnZSA9IHJlZigkdCgnbmV3Lmdyb3Vwcy5ub25lJykpXG4gICAgbGV0IHNlbGVjdGFibGVPcHRpb25zID0gcmVmKFtdKVxuICAgIGxldCBzZWxlY3RlZE9wdGlvbnMgPSByZWYoW10pXG5cbiAgICBvbk1vdW50ZWQoKCkgPT4geyBzZWxlY3RhYmxlT3B0aW9ucy52YWx1ZSA9IHByb3BzLm9wdGlvbnMgfSlcblxuICAgIGNvbnN0IHNlbGVjdE9wdGlvbiA9IG9wdGlvbiA9PiB7XG4gICAgICBzZWxlY3RlZE9wdGlvbnMudmFsdWUucHVzaChvcHRpb24pO1xuICAgICAgLy8gaWYgKHNlbGVjdGFibGVPcHRpb25zICYmIHNlbGVjdGFibGVPcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChzZWxlY3RhYmxlT3B0aW9ucykge1xuICAgICAgICBzZWxlY3RhYmxlT3B0aW9ucy52YWx1ZS5zcGxpY2UoZmluZE9wdGlvbkluZGV4KG9wdGlvbiwgc2VsZWN0YWJsZU9wdGlvbnMudmFsdWUpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gZmFsc2U7XG4gICAgICBjb250ZXh0LmVtaXQoJ3NlbGVjdCcsIHNlbGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuXG5cbiAgICBjb25zdCByZW1vdmVPcHRpb24gPSAob3B0aW9uKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHNlbGVjdGVkT3B0aW9ucy52YWx1ZS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IG9wdGlvbi5pZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHNlbGVjdGFibGVPcHRpb25zLnZhbHVlLnB1c2goc2VsZWN0ZWRPcHRpb25zLnZhbHVlW2luZGV4XSk7XG4gICAgICAgIHNlbGVjdGVkT3B0aW9ucy52YWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5lbWl0KCdzZWxlY3QnLCBzZWxlY3RlZE9wdGlvbnMpO1xuICAgIH07XG5cblxuICAgIGNvbnN0IGZpbmRPcHRpb25JbmRleCA9IChvcHRpb24sIG9wdGlvbkxpc3QpID0+IHtcbiAgICAgIHJldHVybiBvcHRpb25MaXN0LmluZGV4T2Yob3B0aW9uKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbG9zZURyb3BEb3duID0gKCkgPT4ge1xuICAgICAgaXNPcGVuZWQudmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNPcGVuZWQsXG4gICAgICBub09wdGlvbnNNZXNzYWdlLFxuICAgICAgc2VsZWN0YWJsZU9wdGlvbnMsXG4gICAgICBzZWxlY3RlZE9wdGlvbnMsXG4gICAgICAvLyBvbkNsaWNrQXdheURpcmVjdGl2ZSxcbiAgICAgIHNlbGVjdE9wdGlvbixcbiAgICAgIHJlbW92ZU9wdGlvbixcbiAgICAgIGNsb3NlRHJvcERvd25cbiAgICB9XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbmxhYmVsIHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgY29sb3I6ICMxMTExMTE7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cblxuLmlucHV0LWNvbnRhaW5lciB7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5jaGlwLWxpc3Qge1xuICBtYXJnaW46IDE2cHggMCA4cHg7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLmNoaXAtbGlzdCAuY2hpcCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgYmFja2dyb3VuZC1jb2xvcjogIzA2YTc5ODtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIG1hcmdpbjogMCA4cHggOHB4IDA7XG4gIHBhZGRpbmc6IDEwcHggMzJweCA3cHggMTJweDtcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbn1cblxuLmNoaXAtbGlzdCAuY2hpcCBzdmcge1xuICBoZWlnaHQ6IDE2cHg7XG4gIHotaW5kZXg6IDQ7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA1MCU7XG4gIHJpZ2h0OiA4cHg7XG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xufVxuXG4uc2VsZWN0LWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGhlaWdodDogNDBweDtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XG4gIGJvcmRlcjogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMXB4O1xuICBmb250LXNpemU6IDE0cHg7XG4gIG91dGxpbmU6IG5vbmU7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjdXJzb3I6IGhhbmQ7XG59XG5cbi5zZWxlY3QtYnV0dG9uIC5zZWxlY3QtY29udGVudCB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiA1NSU7XG4gIGxlZnQ6IDE0cHg7XG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIGNvbG9yOiAjMDA3NDhmO1xufVxuXG4uc2VsZWN0LWJ1dHRvbiBzdmcge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogNjAlO1xuICByaWdodDogMTBweDtcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XG4gIGhlaWdodDogMTZweDtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgbWFyZ2luOiAwIDAgLTRweCA2cHg7XG59XG5cbi5vcGVuZWQgc3ZnIHtcbiAgdG9wOiAyNSU7XG4gIHRyYW5zZm9ybTogc2NhbGVZKC0xKTtcbn1cblxuLmRyb3AtZG93bi1vcHRpb25zIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDQycHg7XG4gIGxlZnQ6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBtYXgtaGVpZ2h0OiAyMDBweDtcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICB6LWluZGV4OiAyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICBib3JkZXI6IDFweCBzb2xpZCAjZTFlMWUxO1xuICBib3JkZXItcmFkaXVzOiAycHg7XG4gIC13ZWJraXQtYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcbiAgLW1vei1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xuICBib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xufVxuXG4ub3B0aW9uIHtcbiAgcGFkZGluZzogMTBweCAxMnB4IDZweDtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1ZjU7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgY29sb3I6ICM1NTU1NTU7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG59XG5cbi5vcHRpb246aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmYmZhO1xuICBjb2xvcjogIzExMTExMTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjdXJzb3I6IGhhbmQ7XG59XG5cbi5vcHRpb24gcCB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgbWFyZ2luOiAwO1xuICBmb250LXNpemU6IDEzcHg7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG59XG5cbi5zZWxlY3RlZCB7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG59XG5cbi5oaWRkZW4tY2hlY2ttYXJrIHtcbiAgb3BhY2l0eTogMDtcbn1cblxuLmVtcHR5LW9wdGlvbnMge1xuICBtaW4td2lkdGg6IDI1MHB4O1xufVxuXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcbiAgLmlucHV0LWNvbnRhaW5lciwgLmRyb3AtZG93bi1vcHRpb25zIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5vcHRpb24ge1xuICAgIHBhZGRpbmc6IDEycHggNnB4IDExcHg7XG4gIH1cbn1cbjwvc3R5bGU+XG5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWUzNGJiMzBlJnNjb3BlZD10cnVlXCIiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU2VsZWN0V2l0aENoaXBzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTM0YmIzMGUmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1NlbGVjdFdpdGhDaGlwcy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZTM0YmIzMGUmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1NlbGVjdFdpdGhDaGlwcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL1NlbGVjdFdpdGhDaGlwcy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1lMzRiYjMwZSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtZTM0YmIzMGVcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImlucHV0cy1jb250YWluZXJcIj5cbiAgICA8bGFiZWwgOmZvcj1cImxhYmVsLmZvclwiPnt7IGxhYmVsLnRleHQgfX08L2xhYmVsPlxuICAgIDxkaXYgdi1pZj1cInZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID4gMFwiPlxuICAgICAgPGRpdiB2LWZvcj1cIihpdGVtLCBpKSBpbiB2YWx1ZXNcIiA6a2V5PVwiaXRlbS5pZFwiIGNsYXNzPVwiaW5wdXQtcGFpclwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIDp2YWx1ZT1cIml0ZW0udm9jYWJcIlxuICAgICAgICAgICAgQGlucHV0PVwiaGFuZGxlVm9jYWJJbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlLCBpKVwiXG4gICAgICAgICAgICA6cGxhY2Vob2xkZXI9XCIkdCgnbmV3LmV4YWN0TWF0Y2hlcy52b2NhYicpXCJcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgLz5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICA6dmFsdWU9XCJpdGVtLnZhbHVlXCJcbiAgICAgICAgICAgIEBpbnB1dD1cImhhbmRsZVZhbHVlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSwgaSlcIlxuICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVwiJHQoJ25ldy5leGFjdE1hdGNoZXMudXJpJylcIlxuICAgICAgICAgICAgdHlwZT1cInRleHRcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IGRlZmluZVByb3BzLCBkZWZpbmVFbWl0cyB9IGZyb20gJ3Z1ZSc7XG5cbmNvbnN0IHByb3BzID0gZGVmaW5lUHJvcHMoe1xuICB2YWx1ZXM6IEFycmF5LFxuICBsYWJlbDoge1xuICAgIHRleHQ6IFN0cmluZyxcbiAgICBmb3I6IFN0cmluZ1xuICB9XG59KTtcblxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKCk7XG5cbmNvbnN0IGhhbmRsZVZvY2FiSW5wdXQgPSAoaW5wdXRWb2NhYiwgaW5kZXgpID0+IHtcbiAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IFsuLi5wcm9wcy52YWx1ZXNdO1xuICBpZiAoIXByb3BzLnZhbHVlc1tpbmRleF0uaXNUb3VjaGVkKSB7XG4gICAgdXBkYXRlZFZhbHVlcy5wdXNoKHsgdm9jYWI6ICcnLCB2YWx1ZTogJycsIGlzVG91Y2hlZDogZmFsc2UgfSk7XG4gIH1cbiAgdXBkYXRlZFZhbHVlc1tpbmRleF0udm9jYWIgPSBpbnB1dFZvY2FiO1xuICB1cGRhdGVkVmFsdWVzW2luZGV4XS5pc1RvdWNoZWQgPSB0cnVlO1xuICBlbWl0KCdpbnB1dGV4bScsIHVwZGF0ZWRWYWx1ZXMpO1xufTtcblxuY29uc3QgaGFuZGxlVmFsdWVJbnB1dCA9IChpbnB1dFZhbHVlLCBpbmRleCkgPT4ge1xuICBjb25zdCB1cGRhdGVkVmFsdWVzID0gWy4uLnByb3BzLnZhbHVlc107XG4gIGlmICghcHJvcHMudmFsdWVzW2luZGV4XS5pc1RvdWNoZWQpIHtcbiAgICB1cGRhdGVkVmFsdWVzLnB1c2goeyB2b2NhYjogJycsIHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9KTtcbiAgfVxuICB1cGRhdGVkVmFsdWVzW2luZGV4XS52YWx1ZSA9IGlucHV0VmFsdWU7XG4gIHVwZGF0ZWRWYWx1ZXNbaW5kZXhdLmlzVG91Y2hlZCA9IHRydWU7XG4gIGVtaXQoJ2lucHV0ZXhtJywgdXBkYXRlZFZhbHVlcyk7XG59O1xuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIHNjb3BlZD5cbiAgLmlucHV0cy1jb250YWluZXIge1xuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gIH1cblxuICAuaW5wdXRzLWNvbnRhaW5lciBsYWJlbCB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBmb250LXNpemU6IDEzcHg7XG4gICAgY29sb3I6ICMxMTExMTE7XG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICB9XG5cbiAgLmlucHV0LXBhaXIge1xuICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICBtYXJnaW4tdG9wOiA4cHg7XG4gIH1cblxuICAuaW5wdXQtcGFpcjpmaXJzdC1vZi10eXBlIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLmlucHV0LXBhaXIgaW5wdXQge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgd2lkdGg6IDQ4JTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYm9yZGVyLXJhZGl1czogMXB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XG4gICAgY29sb3I6ICMwMDc0OGY7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIHBhZGRpbmctbGVmdDogMTBweDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgfVxuXG4gIC5pbnB1dC1wYWlyIGlucHV0Omxhc3Qtb2YtdHlwZSB7XG4gICAgbWFyZ2luLWxlZnQ6IDMlO1xuICB9XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XG4gICAgLmlucHV0LXBhaXIge1xuICAgICAgbWFyZ2luLXRvcDogMTZweDtcbiAgICB9XG5cbiAgICAuaW5wdXQtcGFpciBpbnB1dCxcbiAgICAuaW5wdXQtcGFpciBpbnB1dDpsYXN0LW9mLXR5cGUge1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICBtYXJnaW46IDhweCAwIDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVFeGFjdE1hdGNoZXNJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTNmMWMyNTRmJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgc2NyaXB0IGZyb20gXCIuL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1RoZUV4YWN0TWF0Y2hlc0lucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9UaGVFeGFjdE1hdGNoZXNJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zZjFjMjU0ZiZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ19fc2NvcGVJZCcsXCJkYXRhLXYtM2YxYzI1NGZcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cblxuPGRpdiBjbGFzcz1cInN1Z2dlc3Rpb24tY29udGFpbmVyXCI+XG4gIDwhLS0gPGJ1dHRvbiBvbmNsaWNrPVwibmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQod2luZG93LmxvY2F0aW9uLmhyZWYpXCI+S29waW9pIGxlaWtlcMO2eWTDpGxsZTwvYnV0dG9uPiAtLT5cbiAgPGRpdiBjbGFzcz1cInN1Z2dlc3Rpb24taGVhZGVyXCI+XG4gICAgPGg0IHYtaWY9XCJ2b2NhYiA9PT0gJ3lzbydcIj57eyAkdCgnbmV3LmhlYWRlcicpIH19PC9oND5cbiAgICA8aDQgdi1lbHNlLWlmPVwidm9jYWIgPT09ICd5c28tcGFpa2F0J1wiPnt7ICR0KCduZXcuaGVhZGVyLWdlbycpIH19PC9oND5cbiAgICA8cD57eyAkdCgnbmV3LnAxJykgfX08L3A+XG4gICAgPHA+e3sgJHQoJ25ldy5wMicpIH19PC9wPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInN1Z2dlc3Rpb24tZm9ybVwiPlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtLWlucHV0c1wiPlxuICAgICAgPGJhc2ljLWRyb3AtZG93blxuICAgICAgICA6dmFsdWU9XCJkLmNvbmNlcHRUeXBlLnZhbHVlXCJcbiAgICAgICAgOm9wdGlvbnM9XCJkLmNvbmNlcHRUeXBlLm9wdGlvbnNcIlxuICAgICAgICBAY2hhbmdlVm9jYWJ1bGFyeT1cIiRlbWl0KCd1cGRhdGU6dm9jYWJ1bGFyeScsICRldmVudClcIlxuICAgICAgQHNlbGVjdD1cImhhbmRsZVNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcuY29uY2VwdFR5cGUubGFiZWwnKSwgZm9yOiAkdCgnbmV3LmNvbmNlcHRUeXBlLmZvcicpfVwiXG4gICAgICAvPlxuICAgICAgPHAgdi1pZj1cIiFjb25jZXB0VHlwZUlzU2VsZWN0ZWQgJiYgc2VuZGluZ1wiIGNsYXNzPVwiZXJyb3JcIj57eyAkdCgnbmV3LmNvbmNlcHRUeXBlLmVycm9yJykgfX08L3A+XG4gICAgICA8ZGl2IHYtaWY9XCIkaTE4bi5sb2NhbGUgPT09ICdmaSdcIj5cbiAgICAgICAgPHNlYXJjaC1pbnB1dFxuICAgICAgICAgIDp2YWx1ZT1cImQucHJlZkxhYmVsLnByaW1hcnlcIlxuICAgICAgICAgIDpjb25jZXB0VHlwZT1cImQuY29uY2VwdFR5cGUudmFsdWVcIlxuICAgICAgICAgIDp2b2NhYnVsYXJ5PVwiZC52b2NhYnVsYXJ5XCJcbiAgICAgICAgICA6bGFuZ3VhZ2U9XCInZmknXCJcbiAgICAgICAgICBAaW5wdXQ9XCJoYW5kbGVQcmVmTGFiZWwoJGV2ZW50KVwiXG4gICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmZpLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZmkuZm9yJyl9XCIgLz5cbiAgICAgICAgPHAgdi1pZj1cIiFwcmVmTGFiZWxPa2F5ICYmIHNlbmRpbmdcIiBjbGFzcz1cImVycm9yXCI+e3sgJHQoJ25ldy5wcmVmTGFiZWwuZXJyb3InKSB9fTwvcD5cblxuICAgICAgICA8c2VhcmNoLWlucHV0XG4gICAgICAgICAgOnZhbHVlPVwiZC5wcmVmTGFiZWwuc2Vjb25kYXJ5XCJcbiAgICAgICAgICA6Y29uY2VwdFR5cGU9XCJkLmNvbmNlcHRUeXBlLnZhbHVlXCJcbiAgICAgICAgICA6dm9jYWJ1bGFyeT1cImQudm9jYWJ1bGFyeVwiXG4gICAgICAgICAgOmxhbmd1YWdlPVwiJ3N2J1wiXG4gICAgICAgICAgQGlucHV0PVwiZW1pdEV2ZW50KCd1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsJywgJGV2ZW50KVwiXG4gICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLnN2LmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuc3YuZm9yJyl9XCIgLz5cblxuICAgICAgICA8IS0tbGlzw6R0dHkgMjAyMy0wOS0xOC0tPlxuICAgICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgICAgIDp2YWx1ZT1cImQucHJlZkxhYmVsLmVuXCJcbiAgICAgICAgICAgIEBpbnB1dDpiYXNpYz1cImVtaXRFdmVudCgndXBkYXRlOmVuUHJlZkxhYmVsJywgJGV2ZW50KVwiXG4gICAgICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZW4ubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5lbi5mb3InKX1cIlxuICAgICAgICAgICAgOmlzVGV4dEFyZWE9XCJmYWxzZVwiIC8+XG5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IHYtaWY9XCIkaTE4bi5sb2NhbGUgPT09ICdzdidcIj5cbiAgICAgICAgPHNlYXJjaC1pbnB1dFxuICAgICAgICAgIDp2YWx1ZT1cImQucHJlZkxhYmVsLnByaW1hcnlcIlxuICAgICAgICAgIDp2b2NhYnVsYXJ5PVwiZC52b2NhYnVsYXJ5XCJcbiAgICAgICAgICA6Y29uY2VwdFR5cGU9XCJkLmNvbmNlcHRUeXBlLnZhbHVlXCJcbiAgICAgICAgICA6bGFuZ3VhZ2U9XCInc3YnXCJcbiAgICAgICAgICBAaW5wdXQ9XCJoYW5kbGVQcmVmTGFiZWwoJGV2ZW50KVwiXG4gICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLnN2LmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuc3YuZm9yJyl9XCIgLz5cbiAgICAgICAgPHAgdi1pZj1cIiFwcmVmTGFiZWxPa2F5ICYmIHNlbmRpbmdcIiBjbGFzcz1cImVycm9yXCI+e3sgJHQoJ25ldy5wcmVmTGFiZWwuZXJyb3InKSB9fTwvcD5cblxuICAgICAgICA8c2VhcmNoLWlucHV0XG4gICAgICAgICAgOnZhbHVlPVwiZC5wcmVmTGFiZWwuc2Vjb25kYXJ5XCJcbiAgICAgICAgICA6dm9jYWJ1bGFyeT1cImQudm9jYWJ1bGFyeVwiXG4gICAgICAgICAgOmNvbmNlcHRUeXBlPVwiZC5jb25jZXB0VHlwZS52YWx1ZVwiXG4gICAgICAgICAgOmxhbmd1YWdlPVwiJ2ZpJ1wiXG4gICAgICAgICAgQGlucHV0PVwiZW1pdEV2ZW50KCd1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsJywgJGV2ZW50KVwiXG4gICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmZpLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZmkuZm9yJyl9XCIgLz5cblxuPCEtLWxpc8OkdHR5IDIwMjMtMDktMTgtLT5cbiAgICAgICAgPGJhc2ljLWlucHV0XG4gICAgICAgICAgICA6dmFsdWU9XCJkLnByZWZMYWJlbC5lblwiXG4gICAgICAgICAgICBAaW5wdXQ6YmFzaWM9XCJlbWl0RXZlbnQoJ3VwZGF0ZTplblByZWZMYWJlbCcsICRldmVudClcIlxuICAgICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmVuLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZW4uZm9yJyl9XCJcbiAgICAgICAgICAgIDppc1RleHRBcmVhPVwiZmFsc2VcIiAvPlxuXG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiB2LWlmPVwiJGkxOG4ubG9jYWxlID09PSAnc2UnIHx8ICRpMThuLmxvY2FsZSA9PT0gJ2VuJ1wiPlxuICAgICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgICAgIDp2YWx1ZT1cImQucHJlZkxhYmVsLmVuXCJcbiAgICAgICAgICAgIEBpbnB1dDpiYXNpYz1cImVtaXRFdmVudCgndXBkYXRlOmVuUHJlZkxhYmVsJywgJGV2ZW50KVwiXG4gICAgICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZW4ubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5lbi5mb3InKX1cIlxuICAgICAgICAgICAgOmlzVGV4dEFyZWE9XCJmYWxzZVwiIC8+XG5cbiAgICAgICAgPHNlYXJjaC1pbnB1dFxuICAgICAgICAgICAgOnZhbHVlPVwiZC5wcmVmTGFiZWwucHJpbWFyeVwiXG4gICAgICAgICAgICA6Y29uY2VwdFR5cGU9XCJkLmNvbmNlcHRUeXBlLnZhbHVlXCJcbiAgICAgICAgICAgIDp2b2NhYnVsYXJ5PVwiZC52b2NhYnVsYXJ5XCJcbiAgICAgICAgICAgIDpsYW5ndWFnZT1cIidmaSdcIlxuICAgICAgICAgICAgQGlucHV0PVwiaGFuZGxlUHJlZkxhYmVsKCRldmVudClcIlxuICAgICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmZpLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZmkuZm9yJyl9XCIgLz5cbiAgICAgICAgPHAgdi1pZj1cIiFwcmVmTGFiZWxPa2F5ICYmIHNlbmRpbmdcIiBjbGFzcz1cImVycm9yXCI+e3sgJHQoJ25ldy5wcmVmTGFiZWwuZXJyb3InKSB9fTwvcD5cblxuICAgICAgICA8c2VhcmNoLWlucHV0XG4gICAgICAgICAgICA6dmFsdWU9XCJkLnByZWZMYWJlbC5zZWNvbmRhcnlcIlxuICAgICAgICAgICAgOmNvbmNlcHRUeXBlPVwiZC5jb25jZXB0VHlwZS52YWx1ZVwiXG4gICAgICAgICAgICA6dm9jYWJ1bGFyeT1cImQudm9jYWJ1bGFyeVwiXG4gICAgICAgICAgICA6bGFuZ3VhZ2U9XCInc3YnXCJcbiAgICAgICAgICAgIEBpbnB1dD1cImVtaXRFdmVudCgndXBkYXRlOnNlY29uZGFyeVByZWZMYWJlbCcsICRldmVudClcIlxuICAgICAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLnN2LmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuc3YuZm9yJyl9XCIgLz5cblxuICAgICAgPC9kaXY+XG5cbiAgICAgIDx0aGUtbXVsdGlwbGUtYmFzaWMtaW5wdXRcbiAgICAgICAgOnZhbHVlcz1cImQuYWx0TGFiZWxzXCJcbiAgICAgICAgQGlucHV0LW11bHRpPVwiZW1pdEV2ZW50KCd1cGRhdGU6YWx0TGFiZWxzJywgJGV2ZW50KVwiXG4gICAgICAgIDpsYWJlbD1cInt0ZXh0OiAkdCgnbmV3LmFsdExhYmVscy5sYWJlbCcpLCBmb3I6ICR0KCduZXcuYWx0TGFiZWxzLmZvcicpfVwiIC8+XG5cbiAgICAgIDxzZWFyY2gtYXV0by1jb21wbGV0ZVxuICAgICAgICA6dmFsdWVzPVwiZC5icm9hZGVyTGFiZWxzXCJcbiAgICAgICAgOnZvY2FidWxhcnk9XCJkLnZvY2FidWxhcnlcIlxuICAgICAgICA6bGFuZ3VhZ2U9XCIkaTE4bi5sb2NhbGVcIlxuICAgICAgICBAdXBkYXRlOnNlbGVjdGVkT3B0aW9ucz1cImVtaXRFdmVudCgndXBkYXRlOmJyb2FkZXJMYWJlbHMnLCAkZXZlbnQpXCJcbiAgICAgICAgOmxhYmVsPVwie3RleHQ6ICR0KCduZXcuYnJvYWRlckxhYmVscy5sYWJlbCcpLCBmb3I6ICR0KCduZXcuYnJvYWRlckxhYmVscy5mb3InKX1cIlxuICAgICAgICA6aGFzVW5pcXVlVmFsdWU9XCJmYWxzZVwiIC8+XG5cbiAgICAgIDxzZWFyY2gtYXV0by1jb21wbGV0ZVxuICAgICAgICA6dmFsdWVzPVwiZC5uYXJyb3dlckxhYmVsc1wiXG4gICAgICAgIDp2b2NhYnVsYXJ5PVwiZC52b2NhYnVsYXJ5XCJcbiAgICAgICAgOmxhbmd1YWdlPVwiJGkxOG4ubG9jYWxlXCJcbiAgICAgICAgQHVwZGF0ZTpzZWxlY3RlZE9wdGlvbnM9XCJlbWl0RXZlbnQoJ3VwZGF0ZTpuYXJyb3dlckxhYmVscycsICRldmVudClcIlxuICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5uYXJyb3dlckxhYmVscy5sYWJlbCcpLCBmb3I6ICR0KCduZXcubmFycm93ZXJMYWJlbHMuZm9yJyl9XCJcbiAgICAgICAgOmhhc1VuaXF1ZVZhbHVlPVwiZmFsc2VcIiAvPlxuXG4gICAgICA8c2VhcmNoLWF1dG8tY29tcGxldGVcbiAgICAgICAgOnZhbHVlcz1cImQucmVsYXRlZExhYmVsc1wiXG4gICAgICAgIDp2b2NhYnVsYXJ5PVwiZC52b2NhYnVsYXJ5XCJcbiAgICAgICAgOmxhbmd1YWdlPVwiJGkxOG4ubG9jYWxlXCJcbiAgICAgICAgQHVwZGF0ZTpzZWxlY3RlZE9wdGlvbnM9XCJlbWl0RXZlbnQoJ3VwZGF0ZTpyZWxhdGVkTGFiZWxzJywgJGV2ZW50KVwiXG4gICAgICAgIDpsYWJlbD1cInt0ZXh0OiAkdCgnbmV3LnJlbGF0ZWRMYWJlbHMubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnJlbGF0ZWRMYWJlbHMuZm9yJyl9XCJcbiAgICAgICAgOmhhc1VuaXF1ZVZhbHVlPVwiZmFsc2VcIiAvPlxuXG4gICAgICAgIDwhLS0gOmNsYXNzPVwieydoaWRkZW4nOiBkLnZvY2FidWxhcnkgPT09ICR0KCduZXcuY29tbW9uLnBsYWNlcycpfVwiIC0tPlxuICAgICAgPHNlbGVjdC13aXRoLWNoaXBzXG4gICAgICAgIDpjbGFzcz1cInsnaGlkZGVuJzogZC52b2NhYnVsYXJ5ID09PSAneXNvLXBhaWthdCd9XCJcbiAgICAgICAgOnZhbHVlPVwiJHQoJ25ldy5ncm91cHMucGxhY2Vob2xkZXInKVwiXG4gICAgICAgIDpvcHRpb25zPVwiZC5ncm91cHMuYWxsR3JvdXBzXCJcbiAgICAgICAgQHNlbGVjdD1cImVtaXRFdmVudCgndXBkYXRlOmdyb3VwcycsICRldmVudClcIlxuICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5ncm91cHMubGFiZWwnKSwgZm9yOiAkdCgnbmV3Lmdyb3Vwcy5mb3InKX1cIiAvPlxuXG4gICAgICA8dGhlLWV4YWN0LW1hdGNoZXMtaW5wdXRcbiAgICAgICAgOnZhbHVlcz1cImQuZXhhY3RNYXRjaGVzXCJcbiAgICAgICAgQGlucHV0ZXhtPVwiZW1pdEV2ZW50KCd1cGRhdGU6ZXhhY3RNYXRjaGVzJywgJGV2ZW50KVwiXG4gICAgICAgIDpsYWJlbD1cInt0ZXh0OiAkdCgnbmV3LmV4YWN0TWF0Y2hlcy5sYWJlbCcpLCBmb3I6ICR0KCduZXcuZXhhY3RNYXRjaGVzLmZvcicpfVwiXG4gICAgICAgIC8+XG5cbiAgICAgIDxiYXNpYy1pbnB1dFxuICAgICAgICA6dmFsdWU9XCJkLnNjb3BlTm90ZVwiXG4gICAgICAgIEBpbnB1dDpiYXNpYz1cImVtaXRFdmVudCgndXBkYXRlOnNjb3BlTm90ZScsICRldmVudClcIlxuICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5zY29wZU5vdGUubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnNjb3BlTm90ZS5mb3InKX1cIlxuICAgICAgICA6aXNUZXh0QXJlYT1cInRydWVcIiAvPlxuXG4gICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgOnZhbHVlPVwiZC5leHBsYW5hdGlvblwiXG4gICAgICAgIEBpbnB1dDpiYXNpYz1cImhhbmRsZUV4cGxhbmF0aW9uKCRldmVudClcIlxuICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5leHBsYW5hdGlvbi5sYWJlbCcpLCBmb3I6ICR0KCduZXcuZXhwbGFuYXRpb24ubGFiZWwnKX1cIlxuICAgICAgOmlzVGV4dEFyZWE9XCJ0cnVlXCIgLz5cbiAgICAgIDxwIHYtaWY9XCIhZXhwbGFuYXRpb25Pa2F5ICYmIHNlbmRpbmdcIiBjbGFzcz1cImVycm9yXCI+e3sgJHQoJ25ldy5leHBsYW5hdGlvbi5lcnJvcicpIH19PC9wPlxuXG4gICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgOnZhbHVlPVwiZC5uZWVkZWRGb3JcIlxuICAgICAgICBAaW5wdXQ6YmFzaWM9XCJoYW5kbGVOZWVkZWRGb3IoJGV2ZW50KVwiXG4gICAgICAgIDpsYWJlbD1cInt0ZXh0OiAkdCgnbmV3Lm5lZWRlZEZvci5sYWJlbCcpLCBmb3I6ICR0KCduZXcubmVlZGVkRm9yLmZvcicpfVwiXG4gICAgICAgIDppc1RleHRBcmVhPVwidHJ1ZVwiIC8+XG4gICAgICAgICAgICA8cCB2LWlmPVwiIW5lZWRlZEZvck9rYXkgJiYgc2VuZGluZ1wiIGNsYXNzPVwiZXJyb3JcIj57eyAkdCgnbmV3Lm5lZWRlZEZvci5lcnJvcicpIH19PC9wPlxuXG4gICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgOnZhbHVlPVwiZC5mcm9tT3JnXCJcbiAgICAgICAgQGlucHV0OmJhc2ljPVwiZW1pdEV2ZW50KCd1cGRhdGU6ZnJvbU9yZycsICRldmVudClcIlxuICAgICAgICA6bGFiZWw9XCJ7dGV4dDogJHQoJ25ldy5mcm9tT3JnLmxhYmVsJyksIGZvcjogJHQoJ25ldy5mcm9tT3JnLmZvcicpfVwiXG4gICAgICAgIDppc1RleHRBcmVhPVwiZmFsc2VcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZvcm0tc3VibWl0XCI+XG4gICAgICA8YSBAY2xpY2s9XCJzdWJtaXRGb3JtKClcIj5cbiAgICAgICAge3sgJHQoJ25ldy5zdWJtaXQnKSB9fVxuICAgICAgPC9hPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IGRlZmluZVByb3BzLCBkZWZpbmVFbWl0cywgcmVmLCBjb21wdXRlZCB9IGZyb20gJ3Z1ZSc7XG5pbXBvcnQgQmFzaWNEcm9wRG93biBmcm9tICcuL2Zvcm0vQmFzaWNEcm9wRG93bi52dWUnO1xuaW1wb3J0IFNlYXJjaElucHV0IGZyb20gJy4vZm9ybS9TZWFyY2hJbnB1dC52dWUnO1xuaW1wb3J0IFNlYXJjaEF1dG9Db21wbGV0ZSBmcm9tICcuL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZSc7XG5pbXBvcnQgQmFzaWNJbnB1dCBmcm9tICcuL2Zvcm0vQmFzaWNJbnB1dC52dWUnO1xuaW1wb3J0IFRoZU11bHRpcGxlQmFzaWNJbnB1dCBmcm9tICcuL2Zvcm0vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZSc7XG5pbXBvcnQgU2VsZWN0V2l0aENoaXBzIGZyb20gJy4vZm9ybS9TZWxlY3RXaXRoQ2hpcHMudnVlJztcbmltcG9ydCBUaGVFeGFjdE1hdGNoZXNJbnB1dCBmcm9tICcuL2Zvcm0vVGhlRXhhY3RNYXRjaGVzSW5wdXQudnVlJztcblxuY29uc3Qgdm9jYWIgPSB3aW5kb3cudm9jYWJcblxuY29uc3QgdGVzdExhbmcgPSByZWYod2luZG93LmxhbmcpO1xuXG5jb25zdCBwcm9wcyA9IGRlZmluZVByb3BzKHtcbiAgZDogT2JqZWN0LFxuICB2OiBPYmplY3QsXG4gIGNvbmNlcHRUeXBlSXNTZWxlY3RlZDogQm9vbGVhbixcbiAgcHJlZkxhYmVsT2theTogQm9vbGVhbixcbiAgZXhwbGFuYXRpb25Pa2F5OiBCb29sZWFuLFxuICBuZWVkZWRGb3JPa2F5OiBCb29sZWFuLFxuICBzZW5kaW5nOiBCb29sZWFuXG59KTtcblxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKCk7XG5cbmNvbnN0IGVtaXRFdmVudCA9IChldmVudE5hbWUsIHBheWxvYWQpID0+IHtcbiAgZW1pdChldmVudE5hbWUsIHBheWxvYWQpO1xufTtcblxuY29uc3QgaGFuZGxlU2VsZWN0ID0gKHZhbHVlKSA9PiB7XG4gIGVtaXRFdmVudCgndXBkYXRlOmNvbmNlcHRUeXBlJywgdmFsdWUpXG4gIGVtaXRFdmVudCgndXBkYXRlOmNvbmNlcHRUeXBlSXNTZWxlY3RlZCcsIHZhbHVlKVxuXG59XG5jb25zdCBoYW5kbGVQcmVmTGFiZWwgPSAodmFsdWUpID0+IHtcbiAgZW1pdEV2ZW50KCd1cGRhdGU6cHJpbWFyeVByZWZMYWJlbCcsIHZhbHVlKVxuICBlbWl0RXZlbnQoJ3VwZGF0ZTpwcmVmTGFiZWxPa2F5JywgdmFsdWUpXG59XG5cbmNvbnN0IGhhbmRsZUV4cGxhbmF0aW9uID0gKHZhbHVlKSA9PiB7XG4gIGVtaXRFdmVudCgndXBkYXRlOmV4cGxhbmF0aW9uJywgdmFsdWUpXG4gIGVtaXRFdmVudCgndXBkYXRlOmV4cGxhbmF0aW9uT2theScsIHZhbHVlKVxufVxuXG5jb25zdCBoYW5kbGVOZWVkZWRGb3IgPSAodmFsdWUpID0+IHtcbiAgZW1pdEV2ZW50KCd1cGRhdGU6bmVlZGVkRm9yJywgdmFsdWUpXG4gIGVtaXRFdmVudCgndXBkYXRlOm5lZWRlZEZvck9rYXknLCB2YWx1ZSlcbn1cblxuXG5jb25zdCBzdWJtaXRGb3JtID0gKCkgPT4ge1xuICBlbWl0KCdzdWJtaXRGb3JtJyk7XG59O1xuXG5kZWZpbmVFeHBvc2Uoe1xuICBlbWl0RXZlbnQsXG4gIHN1Ym1pdEZvcm0sXG59KTtcbjwvc2NyaXB0PlxuXG5cblxuPHN0eWxlIHNjb3BlZD5cbi5oaWRkZW4ge1xuICBkaXNwbGF5OiBub25lO1xufVxuLnN1Z2dlc3Rpb24taGVhZGVyIHtcbiAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWVlZWU7XG59XG5cbi5zdWdnZXN0aW9uLWZvcm0ge1xuICBtYXJnaW4tdG9wOiAyMHB4O1xufVxuXG4uZm9ybS1zdWJtaXQge1xuICB0ZXh0LWFsaWduOiByaWdodDtcbiAgcGFkZGluZzogMjBweCAwO1xuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC8qIGlPUyBTYWZhcmkgKi9cbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cbiAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAvKiBJbnRlcm5ldCBFeHBsb3Jlci9FZGdlICovXG4gIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG4uZm9ybS1zdWJtaXQgYSB7XG4gIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIGJhY2tncm91bmQtY29sb3I6ICMzYTQ1NTM7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgY3Vyc29yOiBoYW5kO1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMXM7XG59XG5cbi5mb3JtLXN1Ym1pdCBhOmhvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzRkNTc2NDtcbn1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9OZXdTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vTmV3U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9OZXdTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM5Mjg4NzIxJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgc2NyaXB0IGZyb20gXCIuL05ld1N1Z2dlc3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vTmV3U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0JnNldHVwPXRydWUmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vTmV3U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zOTI4ODcyMSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ19fc2NvcGVJZCcsXCJkYXRhLXYtMzkyODg3MjFcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cInRlbXBsYXRlXCI+XG4gICAgPGRpdiBjbGFzcz1cImRpYWxvZy1vdmVybGF5XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tb2RhbFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctY2xvc2VcIiBAY2xpY2s9XCJjbG9zZVwiPlxuICAgICAgICAgIDxzdmctaWNvbiBpY29uLW5hbWU9XCJjcm9zc1wiPjxpY29uLWNyb3NzIC8+PC9zdmctaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyByZWYsIG9uTW91bnRlZCwgb25CZWZvcmVVbm1vdW50IH0gZnJvbSAndnVlJztcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL2ljb25zL1N2Z0ljb24udnVlJztcbmltcG9ydCBJY29uQ3Jvc3MgZnJvbSAnLi4vaWNvbnMvSWNvbkNyb3NzLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcG9uZW50czoge1xuICAgIFN2Z0ljb24sXG4gICAgSWNvbkNyb3NzXG4gIH0sXG4gIHNldHVwKF8sIHsgZW1pdCB9KSB7XG4gICAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgICBlbWl0KCdjbG9zZScpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVFc2NLZXkgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVFc2NLZXkpO1xuICAgIH0pO1xuXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVFc2NLZXkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlXG4gICAgfTtcbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuaDUge1xuICBmb250LXdlaWdodDogNTAwICFpbXBvcnRhbnQ7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgbWF4LXdpZHRoOiA2MCU7XG59XG5zdHJvbmcge1xuICBmb250LXdlaWdodDogNjAwICFpbXBvcnRhbnQ7XG59XG5hIHtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIGZvbnQtd2VpZ2h0OiA1MDAgIWltcG9ydGFudDtcbn1cbi5kaWFsb2ctb3ZlcmxheSB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgei1pbmRleDogMTAwMDA7XG59XG5cbi5kaWFsb2ctbW9kYWwge1xuICBmb250LXNpemU6IDE0cHg7XG4gIGNvbG9yOiAjNDc0YjRmO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHRvcDogNTAlO1xuICBsZWZ0OiA1MCU7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICBtaW4taGVpZ2h0OiA2MHB4O1xuICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSA4MHB4KTtcbiAgd2lkdGg6IDY1MHB4O1xuICBvdmVyZmxvdy15OiBhdXRvO1xuICB6LWluZGV4OiAxMDAwMTtcbiAgcGFkZGluZzogMDtcbiAgYm9yZGVyLXRvcDogMnB4IHNvbGlkICMwMDAwMDA7XG59XG5cbi5kaWFsb2ctY29udGVudCB7XG4gIHBhZGRpbmc6IDI1cHggMzBweCAyMHB4O1xufVxuXG4uZGlhbG9nLWNsb3NlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDI1cHg7XG4gIHJpZ2h0OiAzMHB4O1xuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG59XG5cbkBtZWRpYSAobWF4LXdpZHRoOiA4NTBweCkge1xuICAuZGlhbG9nLW1vZGFsIHtcbiAgICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDEwMHB4KTtcbiAgICB3aWR0aDogODB2dztcbiAgICBtaW4td2lkdGg6IDIwMHB4O1xuICB9XG4gIC5kaWFsb2ctY29udGVudCB7XG4gICAgcGFkZGluZzogNDBweCAyMHB4IDI1cHg7XG4gIH1cblxuICAuZGlhbG9nLWNsb3NlIHtcbiAgICByaWdodDogMjBweDtcbiAgfVxufVxuPC9zdHlsZT5cbiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9DZW50ZXJlZERpYWxvZy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OGRkZmM4ODAmc2NvcGVkPXRydWVcIiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0NlbnRlcmVkRGlhbG9nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0NlbnRlcmVkRGlhbG9nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9DZW50ZXJlZERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD04ZGRmYzg4MCZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQ2VudGVyZWREaWFsb2cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPThkZGZjODgwJnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQ2VudGVyZWREaWFsb2cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0NlbnRlcmVkRGlhbG9nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vQ2VudGVyZWREaWFsb2cudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9OGRkZmM4ODAmc2NvcGVkPXRydWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvc3J2L3Nrb3Ntb3MvcGx1Z2lucy9zdWdnZXN0aW9ucy9jb21wb25lbnQtYnVuZGxlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LThkZGZjODgwXCJdXSlcblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCI8dGVtcGxhdGU+XG48ZGl2PlxuICA8aDI+e3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MuaDInKSB9fTwvaDI+XG4gIDxwPnt7ICR0KCdtZXNzYWdlcy5zdWNjZXNzLnBfMScpIH19PC9wPlxuICA8cCB2LWlmPVwiIXN1Z2dlc3Rpb25VcmwgfHwgc3VnZ2VzdGlvblVybC5sZW5ndGggPT09IDBcIj5cbiAgICB7eyAkdCgnbWVzc2FnZXMuc3VjY2Vzcy5wXzJhJykgfX1cbiAgICA8YSA6aHJlZj1cInVybFwiPnt7ICR0KCdtZXNzYWdlcy5zdWNjZXNzLnBfMmInKSB9fTwvYT4uXG4gIDwvcD5cbiAgPHAgdi1pZj1cInN1Z2dlc3Rpb25VcmwgJiYgc3VnZ2VzdGlvblVybC5sZW5ndGggPiAwXCI+XG4gICAge3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MucF8yYScpIH19XG4gICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgOmhyZWY9XCJzdWdnZXN0aW9uVXJsXCI+e3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MucF8yYicpIH19PC9hPi5cbiAgPC9wPlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBwcm9wczoge1xuICAgIHN1Z2dlc3Rpb25Vcmw6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZ1xuICB9XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuaDIge1xuICBtYXJnaW4tdG9wOiA2cHg7XG59XG5cbnAge1xuICBtYXJnaW4tdG9wOiAxNnB4O1xufVxuXG5hIHtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIGZvbnQtd2VpZ2h0OiA1MDA7XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Y2Nlc3NNZXNzYWdlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01YWI1YjNkYSZzY29wZWQ9dHJ1ZVwiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Y2Nlc3NNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVhYjViM2RhJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9TdWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWFiNWIzZGEmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9TdWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vU3VjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9TdWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01YWI1YjNkYSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtNWFiNWIzZGFcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbjxkaXY+XG4gIDxoMj57eyAkdCgnbWVzc2FnZXMuZmFpbGVkLmgyJykgfX08L2gyPlxuICA8cD57eyAkdCgnbWVzc2FnZXMuZmFpbGVkLnBfMWEnKSB9fTwvcD5cbiAgPHA+e3sgJHQoJ21lc3NhZ2VzLmZhaWxlZC5wXzFiJykgfX08L3A+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG5cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuaDIge1xuICBtYXJnaW4tdG9wOiA2cHg7XG59XG5cbnAge1xuICBtYXJnaW4tdG9wOiAxNnB4O1xufVxuPC9zdHlsZT5cbiIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0ZhaWx1cmVNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0ZhaWx1cmVNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9GYWlsdXJlTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1iYjk5ZjU1MiZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiIiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vRmFpbHVyZU1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWJiOTlmNTUyJnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRmFpbHVyZU1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0ZhaWx1cmVNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vRmFpbHVyZU1lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9YmI5OWY1NTImc2NvcGVkPXRydWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvc3J2L3Nrb3Ntb3MvcGx1Z2lucy9zdWdnZXN0aW9ucy9jb21wb25lbnQtYnVuZGxlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LWJiOTlmNTUyXCJdXSlcblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0TmV3QnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Z2dlc3ROZXdCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Z2dlc3ROZXdCdXR0b24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTUwNzI3YWUmbGFuZz1jc3NcIiIsImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1N1Z2dlc3ROZXdCdXR0b24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE1MDcyN2FlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vU3VnZ2VzdE5ld0J1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vU3VnZ2VzdE5ld0J1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL1N1Z2dlc3ROZXdCdXR0b24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MTUwNzI3YWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvc3J2L3Nrb3Ntb3MvcGx1Z2lucy9zdWdnZXN0aW9ucy9jb21wb25lbnQtYnVuZGxlci9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8YSByb2xlPVwiYnV0dG9uXCIgQGNsaWNrPVwiaXNPcGVuZWQgPSAhaXNPcGVuZWRcIiBpZD1cImZvcmRpcmVjdG1vZGlmeVwiIDpocmVmPVwiYCR7cGFnZVVybC5zcGxpdCgnIycpWzBdfSNzdWdnZXN0aW9uYFwiPlxuICAgICAgPHNwYW4+e3sgJHQoJ2VkaXQuYnV0dG9uJykgfX08L3NwYW4+XG4gICAgPC9hPlxuICAgIDxjZW50ZXJlZC1kaWFsb2cgdi1pZj1cImlzT3BlbmVkXCIgQGNsb3NlPVwiY2xvc2VEaWFsb2coKVwiPlxuICAgICAgPGVkaXQtc3VnZ2VzdGlvblxuICAgICAgICAgIHYtaWY9XCIhc2hvd1N1Y2Nlc3NNZXNzYWdlICYmICFzaG93RmFpbHVyZU1lc3NhZ2VcIlxuICAgICAgICAgIDpkPVwiZm9ybURhdGFcIlxuICAgICAgICAgIDpsYWJlbD1cImxhYmVsWFwiXG4gICAgICAgICAgOnVyaT1cInVyaVhcIlxuICAgICAgICAgIEB1cGRhdGU6Y29uY2VwdFR5cGU9XCJmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZSA9ICRldmVudFwiXG4gICAgICAgICAgQHVwZGF0ZTpwcmltYXJ5UHJlZkxhYmVsPVwiZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnkgPSAkZXZlbnRcIlxuICAgICAgICAgIEB1cGRhdGU6ZGVzY3JpcHRpb249XCJmb3JtRGF0YS5kZXNjcmlwdGlvbiA9ICRldmVudFwiXG4gICAgICAgICAgQHVwZGF0ZTpyZWFzb249XCJmb3JtRGF0YS5yZWFzb24gPSAkZXZlbnRcIlxuICAgICAgICAgIEB1cGRhdGU6ZnJvbU9yZz1cImZvcm1EYXRhLmZyb21PcmcgPSAkZXZlbnRcIlxuICAgICAgICAgIEBzdWJtaXRGb3JtPVwic3VibWl0Rm9ybVwiXG4gICAgICAvPlxuICAgICAgPHN1Y2Nlc3MtbWVzc2FnZSB2LWlmPVwic2hvd1N1Y2Nlc3NNZXNzYWdlXCIgOnN1Z2dlc3Rpb25Vcmw9XCJzdWdnZXN0aW9uVXJsXCIgOnVybD1cInVybFwiIC8+XG4gICAgICA8ZmFpbHVyZS1tZXNzYWdlIHYtaWY9XCJzaG93RmFpbHVyZU1lc3NhZ2VcIiAvPlxuICAgIDwvY2VudGVyZWQtZGlhbG9nPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgRWRpdFN1Z2dlc3Rpb24gZnJvbSAnLi9FZGl0U3VnZ2VzdGlvbi52dWUnO1xuaW1wb3J0IENlbnRlcmVkRGlhbG9nIGZyb20gJy4vY29tbW9uL0NlbnRlcmVkRGlhbG9nLnZ1ZSc7XG5pbXBvcnQgU3VjY2Vzc01lc3NhZ2UgZnJvbSAnLi9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlJztcbmltcG9ydCBGYWlsdXJlTWVzc2FnZSBmcm9tICcuL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWUnO1xuaW1wb3J0IHsgcmVxdWlyZWQgfSBmcm9tICd2dWVsaWRhdGUnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IGRlZmluZUNvbXBvbmVudCwgcmVmLCByZWFjdGl2ZSwgd2F0Y2hFZmZlY3QsIGluamVjdCwgd2F0Y2ggfSBmcm9tICd2dWUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBFZGl0U3VnZ2VzdGlvbixcbiAgICBDZW50ZXJlZERpYWxvZyxcbiAgICBTdWNjZXNzTWVzc2FnZSxcbiAgICBGYWlsdXJlTWVzc2FnZSxcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBsYW5nOiBTdHJpbmcsXG4gICAgdm9jYWI6IFN0cmluZyxcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIHVyaTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIG1vaWtrZWxpczogU3RyaW5nLFxuICB9LFxuICBzZXR1cChwcm9wcykge1xuICAgIGNvbnN0IHRlc3RpID0gaW5qZWN0KCd0ZXN0aScpXG4gICAgY29uc3QgbGFiZWxYID0gaW5qZWN0KCdsYWJlbFgnLCBudWxsKTtcbiAgICBjb25zdCB1cmlYID0gaW5qZWN0KCd1cmlYJywgbnVsbCk7XG4gICAgY29uc3QgcGFnZVVybFggPSBpbmplY3QoJ3BhZ2VVcmxYJywgbnVsbCk7XG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XG4gICAgbGV0IHBhZ2VVcmwgPSByZWYocGFnZVVybFgpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdwYWdlVXJsIGF0IHJlZnMnLCBwYWdlVXJsKVxuICAgIGNvbnN0IGlzT3BlbmVkID0gcmVmKGZhbHNlKTtcbiAgICBjb25zdCBzaG93U3VjY2Vzc01lc3NhZ2UgPSByZWYoZmFsc2UpO1xuICAgIGNvbnN0IHNob3dGYWlsdXJlTWVzc2FnZSA9IHJlZihmYWxzZSk7XG4gICAgY29uc3Qgc3VnZ2VzdGlvblVybCA9IHJlZignJyk7XG4gICAgY29uc3QgZm9ybURhdGEgPSByZWFjdGl2ZSh7XG4gICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICByZWFzb246ICcnLFxuICAgICAgZnJvbU9yZzogJycsXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRVcmwgPSBhc3luYyAoKSA9PiB7XG4gICAgICBwYWdlVXJsLnZhbHVlID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfTtcblxuICAgIGNvbnN0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICBzZW5kRGF0YSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RhdGEgbm90IHNlbnQ6IHJlcXVpcmVkIGRhdGEgb2YgdGhlIGZvcm0gd2FzIG5vdCBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IGBcbioqS8Okc2l0dGVlbiB0eXlwcGkqKlxuXG5NdXV0b3Mgb2xlbWFzc2Egb2xldmFhbiBrw6RzaXR0ZWVzZWVuXG5cbioqcHJlZmFiZWwqKlxuXG5bJHtsYWJlbFh9XSgke3VyaVh9KVxuXG4qKlRpbGEqKlxuXG5Lw6RzaXR0ZWx5c3PDpFxuXG4qKkVoZG90ZXR0dSBtdXV0b3MqKlxuXG4ke2Zvcm1EYXRhLmRlc2NyaXB0aW9ufVxuXG4qKlBlcnVzdGVsdXQgZWhkb3R1a3NlbGxlKipcblxuJHtmb3JtRGF0YS5yZWFzb259XG5cbioqRWhkb3R0YWphbiBvcmdhbmlzYWF0aW8qKlxuXG4ke2Zvcm1EYXRhLmZyb21Pcmd9XG5gO1xuXG4gICAgICBsZXQgZGF0YUJ1bmRsZSA9IHtcbiAgICAgICAgdGl0bGU6IGxhYmVsWCxcbiAgICAgICAgYm9keTogZGF0YSxcbiAgICAgICAgc3RhdGU6ICdvcGVuJyxcbiAgICAgICAgbGFiZWxzOiBbJ211dXRvcyddLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcGF5bG9hZCA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShkYXRhQnVuZGxlKSk7XG5cbiAgICAgIHZhciB1cmxUb1ByeCA9IHJlcXVpcmUoJy4uL3ByeC5qc29uJyk7XG4gICAgICBhd2FpdCBheGlvc1xuICAgICAgICAgIC5wb3N0KGAke3VybFRvUHJ4WzBdLnVybH0/cGF5bG9hZD0ke3BheWxvYWR9YClcbiAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZVN1Y2Nlc3NNZXNzYWdlKGAke3Jlc3BvbnNlLmRhdGEudXJsLnJlcGxhY2UoJy9yZXBvcycsICcnKS5yZXBsYWNlKCdhcGkuJywgJycpfWApO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdG9nZ2xlRmFpbHVyZU1lc3NhZ2UoKTtcbiAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UgPSAocmVzcG9uc2VVcmwpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZVVybCAmJiByZXNwb25zZVVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25VcmwudmFsdWUgPSByZXNwb25zZVVybDtcbiAgICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNob3dTdWNjZXNzTWVzc2FnZS52YWx1ZSA9IHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IHRvZ2dsZUZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzID0gKCkgPT4ge1xuICAgICAgaWYgKGxhbmcgPT09ICdzdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdjoge1xuICAgICAgICAgICAgdmFsdWU6IGxhYmVsWCxcbiAgICAgICAgICAgIHVyaTogdXJpWCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuOiAnJyxcbiAgICAgICAgICBmaToge1xuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgdXJpOiAnJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmk6IHtcbiAgICAgICAgICB2YWx1ZTogbGFiZWxYLFxuICAgICAgICAgIHVyaTogdXJpWCxcbiAgICAgICAgfSxcbiAgICAgICAgZW46ICcnLFxuICAgICAgICBzdjoge1xuICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICB1cmk6ICcnLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xvc2VEaWFsb2cgPSAoKSA9PiB7XG4gICAgICBpc09wZW5lZC52YWx1ZSA9ICFpc09wZW5lZC52YWx1ZTtcbiAgICAgIHNob3dTdWNjZXNzTWVzc2FnZS52YWx1ZSA9IGZhbHNlO1xuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gZmFsc2U7XG4gICAgICBzdWdnZXN0aW9uVXJsLnZhbHVlID0gJyc7XG4gICAgICAvLyAkdi5mb3JtRGF0YS4kcmVzZXQoKTtcbiAgICAgIGZvcm1EYXRhLmRlc2NyaXB0aW9uID0gJyc7XG4gICAgICBmb3JtRGF0YS5yZWFzb24gPSAnJztcbiAgICAgIGZvcm1EYXRhLmZyb21PcmcgPSAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VVcmwsXG4gICAgICBwYWdlVXJsWCxcbiAgICAgIGlzT3BlbmVkLFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLFxuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLFxuICAgICAgc3VnZ2VzdGlvblVybCxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgZ2V0VXJsLFxuICAgICAgc3VibWl0Rm9ybSxcbiAgICAgIHRvZ2dsZUZhaWx1cmVNZXNzYWdlLFxuICAgICAgaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzLFxuICAgICAgY2xvc2VEaWFsb2csXG4gICAgICBsYWJlbFgsXG4gICAgICB0ZXN0aVxuICAgIH07XG4gIH0sXG4gIHZhbGlkYXRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtRGF0YToge1xuICAgICAgICBkZXNjcmlwdGlvbjogeyByZXF1aXJlZCB9LFxuICAgICAgICByZWFzb246IHsgcmVxdWlyZWQgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICA6OnBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogIzVlYThCNztcbiAgICBvcGFjaXR5OiAxO1xuICB9XG5cbiAgOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6ICM1ZWE4Qjc7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIDo6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogIzVlYThCNztcbiAgICBvcGFjaXR5OiAxO1xuICB9XG48L3N0eWxlPlxuXG48c3R5bGUgc2NvcGVkPlxuICBhIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgY3Vyc29yOiBoYW5kO1xuICB9XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdWdnZXN0aW9uLWhlYWRlclwiPlxuICAgICAgPGg0Pnt7ICR0KCdlZGl0LmhlYWRlcicpIH19IDxhIDpocmVmPVwidXJpXCI+e3sgbGFiZWwgfX08L2E+PC9oND5cbiAgICAgIDxwPnt7ICR0KCdlZGl0LnBhcmFncmFwaCcpIH19PC9wPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzdWdnZXN0aW9uLWZvcm1cIj5cbiAgICAgIDxkaXY+XG4gICAgICAgIDxiYXNpYy1pbnB1dFxuICAgICAgICAgICAgOnZhbHVlPVwiZm9ybURhdGEuZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgQGlucHV0OmJhc2ljPVwidXBkYXRlRGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgOmxhYmVsPVwieyB0ZXh0OiAkdCgnZWRpdC5kZXNjcmlwdGlvbi5sYWJlbCcpLCBmb3I6ICR0KCdlZGl0LmRlc2NyaXB0aW9uLmxhYmVsJykgfVwiXG4gICAgICAgICAgICA6aXNUZXh0QXJlYT1cInRydWVcIlxuICAgICAgICAvPlxuICAgICAgICAgPHAgdi1pZj1cIiFkZXNjcmlwdGlvbkNhbkJlU2VudCAmJiBzdWJtaXR0ZWRcIiBjbGFzcz1cImVycm9yXCI+e3sgJHQoJ2VkaXQuZGVzY3JpcHRpb24uZXJyb3InKSB9fTwvcD5cblxuICAgICAgICA8YmFzaWMtaW5wdXRcbiAgICAgICAgICAgIDp2YWx1ZT1cImZvcm1EYXRhLnJlYXNvblwiXG4gICAgICAgICAgICBAaW5wdXQ6YmFzaWM9XCJ1cGRhdGVSZWFzb25cIlxuICAgICAgICAgICAgOmxhYmVsPVwieyB0ZXh0OiAkdCgnZWRpdC5yZWFzb24ubGFiZWwnKSwgZm9yOiAkdCgnZWRpdC5yZWFzb24uZm9yJykgfVwiXG4gICAgICAgICAgICA6aXNUZXh0QXJlYT1cInRydWVcIlxuICAgICAgICAvPlxuICAgICAgICAgPHAgdi1pZj1cIiFyZWFzb25DYW5CZVNlbnQgJiYgc3VibWl0dGVkXCIgY2xhc3M9XCJlcnJvclwiPnt7ICR0KCdlZGl0LnJlYXNvbi5lcnJvcicpIH19PC9wPlxuXG4gICAgICAgIDxiYXNpYy1pbnB1dFxuICAgICAgICAgICAgOnZhbHVlPVwiZm9ybURhdGEuZnJvbU9yZ1wiXG4gICAgICAgICAgICBAaW5wdXQ6YmFzaWM9XCJ1cGRhdGVGcm9tT3JnXCJcbiAgICAgICAgICAgIDpsYWJlbD1cInsgdGV4dDogJHQoJ2VkaXQuZnJvbU9yZy5sYWJlbCcpLCBmb3I6ICR0KCdlZGl0LmZyb21PcmcuZm9yJykgfVwiXG4gICAgICAgICAgICA6aXNUZXh0QXJlYT1cImZhbHNlXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1zdWJtaXRcIj5cbiAgICAgICAgPGEgQGNsaWNrPVwic3VibWl0Rm9ybVwiPnt7ICR0KCdlZGl0LnN1Ym1pdCcpIH19PC9hPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCYXNpY0lucHV0IGZyb20gJy4vZm9ybS9CYXNpY0lucHV0LnZ1ZSc7XG5pbXBvcnQgeyBkZWZpbmVDb21wb25lbnQsIHJlZiwgcmVhY3RpdmUsIHdhdGNoRWZmZWN0LCBpbmplY3QsIHdhdGNoIH0gZnJvbSAndnVlJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb21wb25lbnRzOiB7XG4gICAgQmFzaWNJbnB1dCxcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBkOiBPYmplY3QsXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICB1cmk6IFN0cmluZyxcbiAgfSxcbiAgc2V0dXAocHJvcHMsIHsgZW1pdCB9KSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSByZWYocHJvcHMuZCk7XG4gICAgY29uc3QgZGVzY3JpcHRpb25DYW5CZVNlbnQgPSByZWYoZmFsc2UpXG4gICAgY29uc3QgcmVhc29uQ2FuQmVTZW50ID0gcmVmKGZhbHNlKVxuICAgIGNvbnN0IHN1Ym1pdHRlZCA9IHJlZihmYWxzZSlcblxuICAgIGNvbnN0IHVwZGF0ZURlc2NyaXB0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgICBmb3JtRGF0YS52YWx1ZS5kZXNjcmlwdGlvbiA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVSZWFzb24gPSAodmFsdWUpID0+IHtcbiAgICAgIGZvcm1EYXRhLnZhbHVlLnJlYXNvbiA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVGcm9tT3JnID0gKHZhbHVlKSA9PiB7XG4gICAgICBmb3JtRGF0YS52YWx1ZS5mcm9tT3JnID0gdmFsdWU7XG4gICAgfTtcblxuICAgIHdhdGNoKFxuICAgICAgICAoKSA9PiBbZm9ybURhdGEudmFsdWUuZGVzY3JpcHRpb24sIGZvcm1EYXRhLnZhbHVlLmRlc2NyaXB0aW9uLmxlbmd0aF0sXG4gICAgICAgIChuZXdWYWx1ZXMsIG9sZFZhbHVlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uTGVuZ3RoID0gbmV3VmFsdWVzWzFdO1xuXG4gICAgICAgICAgaWYgKGRlc2NyaXB0aW9uTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25DYW5CZVNlbnQudmFsdWUgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uQ2FuQmVTZW50LnZhbHVlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XG4gICAgKVxuXG4gICAgd2F0Y2goXG4gICAgICAgICgpID0+IFtmb3JtRGF0YS52YWx1ZS5yZWFzb24sIGZvcm1EYXRhLnZhbHVlLnJlYXNvbi5sZW5ndGhdLFxuICAgICAgICAobmV3VmFsdWVzLCBvbGRWYWx1ZXMpID0+IHtcbiAgICAgICAgICBjb25zdCByZWFzb25MZW5ndGggPSBuZXdWYWx1ZXNbMV07XG5cbiAgICAgICAgICBpZiAocmVhc29uTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcmVhc29uQ2FuQmVTZW50LnZhbHVlID0gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWFzb25DYW5CZVNlbnQudmFsdWUgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBkZWVwOiB0cnVlIH1cbiAgICApXG5cblxuICAgIGNvbnN0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XG4gICAgc3VibWl0dGVkLnZhbHVlID0gdHJ1ZVxuICAgICAgaWYgKGRlc2NyaXB0aW9uQ2FuQmVTZW50LnZhbHVlID09IHRydWUgJiYgcmVhc29uQ2FuQmVTZW50LnZhbHVlID09IHRydWUpIHtcbiAgICAgICAgZW1pdCgnc3VibWl0Rm9ybScpXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtRGF0YSxcbiAgICAgIHVwZGF0ZURlc2NyaXB0aW9uLFxuICAgICAgdXBkYXRlUmVhc29uLFxuICAgICAgdXBkYXRlRnJvbU9yZyxcbiAgICAgIHN1Ym1pdEZvcm0sXG4gICAgICBkZXNjcmlwdGlvbkNhbkJlU2VudCxcbiAgICAgIHJlYXNvbkNhbkJlU2VudCxcbiAgICAgIHN1Ym1pdHRlZFxuICAgIH07XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5hIHtcbiAgY29sb3I6ICMwMDc0OGY7XG4gIGZvbnQtd2VpZ2h0OiA1MDAgIWltcG9ydGFudDtcbn1cblxuLmVycm9yIHtcbiAgY29sb3I6ICNlODNhMzA7XG4gIHRleHQtaW5kZW50OiAycHg7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgbWFyZ2luLXRvcDogLTEwcHg7XG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XG59XG5cbi5zdWdnZXN0aW9uLWhlYWRlciB7XG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlZWVlO1xufVxuXG4uc3VnZ2VzdGlvbi1mb3JtIHtcbiAgbWFyZ2luLXRvcDogMjBweDtcbn1cblxuLmZvcm0tc3VibWl0IHtcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gIHBhZGRpbmc6IDIwcHggMDtcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLmZvcm0tc3VibWl0IGEge1xuICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gIGNvbG9yOiAjZmZmZmZmO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2E0NTUzO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIGN1cnNvcjogaGFuZDtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjFzO1xufVxuXG4uZm9ybS1zdWJtaXQgYTpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICM0ZDU3NjQ7XG59XG48L3N0eWxlPlxuIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0VkaXRTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMmQzMWU1YSZzY29wZWQ9dHJ1ZVwiIiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vRWRpdFN1Z2dlc3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vRWRpdFN1Z2dlc3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0VkaXRTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTMyZDMxZTVhJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9FZGl0U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzJkMzFlNWEmc2NvcGVkPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9FZGl0U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vRWRpdFN1Z2dlc3Rpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9FZGl0U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zMmQzMWU1YSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtMzJkMzFlNWFcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIiIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wZTViZDdhNSZsYW5nPWNzc1wiIiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0xJmlkPTBlNWJkN2E1JnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIiLCJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wZTViZDdhNSZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcblxuaW1wb3J0IFwiLi9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTBlNWJkN2E1Jmxhbmc9Y3NzXCJcbmltcG9ydCBcIi4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD0wZTViZDdhNSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5cbmltcG9ydCBleHBvcnRDb21wb25lbnQgZnJvbSBcIi9zcnYvc2tvc21vcy9wbHVnaW5zL3N1Z2dlc3Rpb25zL2NvbXBvbmVudC1idW5kbGVyL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzXCJcbmNvbnN0IF9fZXhwb3J0c19fID0gLyojX19QVVJFX18qL2V4cG9ydENvbXBvbmVudChzY3JpcHQsIFtbJ3JlbmRlcicscmVuZGVyXSxbJ19fc2NvcGVJZCcsXCJkYXRhLXYtMGU1YmQ3YTVcIl1dKVxuXG5leHBvcnQgZGVmYXVsdCBfX2V4cG9ydHNfXyIsImltcG9ydCB7IGNyZWF0ZUFwcCwgcmVmIH0gZnJvbSAndnVlJztcbmltcG9ydCB7IGNyZWF0ZUkxOG4gfSBmcm9tICd2dWUtaTE4bic7XG5pbXBvcnQgdHJhbnNsYXRpb25zIGZyb20gJy4vaTE4bi9pMThuJztcbi8vIGltcG9ydCBWdWVsaWRhdGUgZnJvbSAndnVlbGlkYXRlJztcbmltcG9ydCBTdWdnZXN0TmV3QnV0dG9uIGZyb20gJ0AvY29tcG9uZW50cy9TdWdnZXN0TmV3QnV0dG9uLnZ1ZSc7XG5pbXBvcnQgU3VnZ2VzdENoYW5nZUJ1dHRvbiBmcm9tICdAL2NvbXBvbmVudHMvU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWUnO1xuXG5jb25zdCBpMThuID0gY3JlYXRlSTE4bih7XG4gICAgbG9jYWxlOiB3aW5kb3cubGFuZyxcbiAgICBtZXNzYWdlczogdHJhbnNsYXRpb25zLFxufSk7XG5cbmNvbnN0IGFwcCA9IGNyZWF0ZUFwcChTdWdnZXN0TmV3QnV0dG9uKTtcbmNvbnN0IGFwcDIgPSBjcmVhdGVBcHAoU3VnZ2VzdENoYW5nZUJ1dHRvbik7XG5cbmFwcC5wcm92aWRlKCckdCcsIGkxOG4uZ2xvYmFsLnQpO1xuYXBwLnByb3ZpZGUoJ3BhZ2VVcmwnLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG5hcHAyLnByb3ZpZGUoJyR0JywgaTE4bi5nbG9iYWwudCk7XG5hcHAyLnByb3ZpZGUoJ3BhZ2VVcmxYJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG5jb25zdCB0ZXN0aSA9IHJlZignVGhpcyBpcyBhIHJlZiB2YXJpYWJsZScpO1xuYXBwLnByb3ZpZGUoJ3Rlc3RpJywgdGVzdGkpO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXJpLWlucHV0LWJveCcpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHVyaVRleHQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICBhcHAyLnByb3ZpZGUoJ3VyaVgnLCB1cmlUZXh0KTtcbiAgICB9XG59KVxuXG4gLy8gUmVnaXN0ZXIgZ2xvYmFsIGkxOG5cbmFwcC51c2UoaTE4bik7XG5hcHAyLnVzZShpMThuKTtcblxuLy8gRGVmaW5lIHRoZSBjdXN0b20gZWxlbWVudHNcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnc3VnZ2VzdC1uZXctYnV0dG9uJywgY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcHAubW91bnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50LiRlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBlbGVtZW50IG5vdCBmb3VuZFwiKVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cmktaW5wdXQtYm94Jyk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgdXJpVGV4dCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgIGFwcDIucHJvdmlkZSgndXJpWCcsIHVyaVRleHQpO1xuICAgIH1cbn0pXG5cbmxldCBlbGVtZW50OyBcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdWdnZXN0LWNoYW5nZS1idXR0b24nLCBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblxuICAgIC8vIEt1c3RvaW1vaWR1aWxsZSBlbGVtZW50ZWlsbGUgdGFya29pdGV0dHUgTGlmZWN5Y2xlLW1ldG9kaSwgam9rYSBoecO2ZHludMOkw6QgV2ViIENvbXBvbmVudHMgQVBJYS4gU2l0w6Qga3V0c3V0YWFuIGt1biBjdXN0b21vaXR1IGVsZW1lbnR0aVxuICAgIC8vIChzdWdnZXN0LWNoYW5nZS1idXR0b24pIGxpaXRldMOkw6RuIERPTWlpbiwga8OkeXTDpG5uw7Zzc8OkIGxpc8OkdHR5IGRva3VtZW50dGlpbiAod2luZG93LmRvY3VtZW50KS5cbiAgICAvLyBUw6Rzc8OkIHZhaWhlZXNzYSBvbGlzaSBtYWhkb2xsaXN0YSB0b3RldXR0YWEgYWx1c3RhdmlhIHRvaW1lbnBpdGVpdMOkIHRhaSB2YWlra2EgYXNldHRhYVxuICAgIC8vIGV2ZW50IGxpc3RlbmVyZWl0w6QsIGpvaWRlbiBoYWx1dGFhbiBvbGV2YW4gYWt0aWl2aXNpYSwga3VuIGVsZW1lbnR0aSBvbiBkb2t1bWVudGlzc2EuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRBQkMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlZi1sYWJlbCcpO1xuXG4gICAgICAgIC8vIEFpZW1taW4gbHVvdGlpbiBhcHAyIGVsaSBjb25zdCBhcHAyID0gY3JlYXRlQXBwKFN1Z2dlc3RDaGFuZ2VCdXR0b24pO1xuICAgICAgICAvLyBBbGxhIHNpaWhlbiBsaWl0ZXTDpMOkbiBkaXYtZWxlbWVudHRpLCBqb2hvbiBzb3ZlbGx1cywgU3VnZ2VzdENoYW5nZUJ1dHRvbmlpbiBwZXJ1c3R1dmEgYXBwMiBpbXBsZW1lbnRvaSBrYWlra2kgdG9pbWludG9uc2FcbiAgICAgICAgLy8gY29uc3QgZWxlbWVudCA9IGFwcDIubW91bnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICAgICAgY29uc3QgYXBwMyA9IGNyZWF0ZUFwcChTdWdnZXN0Q2hhbmdlQnV0dG9uKTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRVcmkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXJpLWlucHV0LWJveCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlZi1sYWJlbCcpO1xuICAgICAgICAgICAgaWYgKHByZWZFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gcHJlZkVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgYXBwMy5wcm92aWRlKCdsYWJlbFgnLCBsYWJlbFRleHQpO1xuICAgICAgICAgICAgICAgIGFwcDMucHJvdmlkZSgndGVzdGknLCB0ZXN0aS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudFVyaSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVyaVRleHQgPSBlbGVtZW50VXJpLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgIGFwcDMucHJvdmlkZSgndXJpWCcsIHVyaVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwMy5wcm92aWRlKCckdCcsIGkxOG4uZ2xvYmFsLnQpO1xuICAgICAgICAgICAgYXBwMy5wcm92aWRlKCdwYWdlVXJsWCcsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGFwcDMudXNlKGkxOG4pOyAvLyBSZWdpc3RlciBnbG9iYWwgaTE4blxuICAgICAgICAgICAgZWxlbWVudCA9IGFwcDMubW91bnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudC4kZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaGUgZWxlbWVudCBub3QgZm91bmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3VuZGVmaW5lZCcpIHtcbi8qICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdWdnZXN0LWNoYW5nZS1idXR0b24nLCBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFIC0gbWFpbi5qcywgc3VnZ2VzdC1jaGFuZ2UtYnV0dG9uXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcHAyLm1vdW50KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbGVtZW50IGluIG1haW4uanNcIiwgZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50LiRlbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsqL1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIFPDpGlsacO2IG1lbGtlaW4gdG9pbWl2YXN0YVxuLypjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicsIGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkUgLSBtYWluLmpzLCBzdWdnZXN0LWNoYW5nZS1idXR0b25cIilcbiAgICAgICAgLy8gY29uc29sZS5sb2cocHJlZkxhYmVscykgQUFBXG4gICAgICAgIC8vIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVBcHAoU3VnZ2VzdENoYW5nZUJ1dHRvbikubW91bnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpOyAvLyBjYXNlIDE6IHN3w6Rww6R0dHkgYWxsYSBvbGV2YW4ga2Fuc3NhXG5cblxuICAgICAgICAvLyBpZiAoY3VzdG9tRWxlbWVudHMuZ2V0KCdzdWdnZXN0LWNoYW5nZS1idXR0b24nKSkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJ0b2ltaWlcIik7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcImVpIHRvaW1pXCIpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicpID8gXCJzdWdnZXN0LWNoYW5nZS1idXR0b24gbMO2eXR5aVwiIDogXCJzdWdnZXN0LWNoYW5nZS1idXR0b24gZWkgbMO2eXR5bnl0XCJcblxuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXBwMi5tb3VudChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZWxlbWVudCBpbiBtYWluLmpzXCIsIGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgLy8gaWYgKGVsZW1lbnQpIHtcblxuXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudC4kZWwpO1xuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiVGhlIGVsZW1lbnQgbm90IGZvdW5kXCIpXG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgICAgLy8gaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gICAgIC8vICAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQuJGVsKTtcbiAgICAgICAgLy8gICAgIC8vIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAvLyAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlRoZSBlbGVtZW50IG5vdCBmb3VuZFwiKVxuICAgICAgICAvLyAgICAgLy8gfVxuICAgICAgICAvLyB9LCA1MDAwKTsgLy8gNTAwMCBtaWxsaXNlY29uZHMgPSA1IHNlY29uZHNcbiAgICB9XG59KTsqL1xuXG4vLyBDaGVjayBpZiAnc3VnZ2VzdC1uZXctYnV0dG9uJyBpcyByZWdpc3RlcmVkXG5pZiAoY3VzdG9tRWxlbWVudHMuZ2V0KCdzdWdnZXN0LW5ldy1idXR0b24nKSkge1xuICAgIGNvbnNvbGUubG9nKFwiJ3N1Z2dlc3QtbmV3LWJ1dHRvbicgaXMgcmVnaXN0ZXJlZC5cIik7XG59IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwiJ3N1Z2dlc3QtbmV3LWJ1dHRvbicgaXMgTk9UIHJlZ2lzdGVyZWQuXCIpO1xufVxuXG5pZiAoY3VzdG9tRWxlbWVudHMuZ2V0KCdzdWdnZXN0LWNoYW5nZS1idXR0b24nKSkge1xuICAgIGNvbnNvbGUubG9nKFwiJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicgaXMgcmVnaXN0ZXJlZC5cIik7XG59IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwiJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicgaXMgTk9UIHJlZ2lzdGVyZWQuXCIpO1xufVxuXG5cblxuLy8gVMOkbcOkIG9uIGtvb2RpLCBqb3NzYSB1dWRlbiBsw6RoZXR0w6RtaW5lbiB0b2ltaWkga29rb25hYW5cbi8qXG5pbXBvcnQgeyBjcmVhdGVBcHAgfSBmcm9tICd2dWUnO1xuaW1wb3J0IHsgY3JlYXRlSTE4biB9IGZyb20gJ3Z1ZS1pMThuJztcbmltcG9ydCB0cmFuc2xhdGlvbnMgZnJvbSAnLi9pMThuL2kxOG4nO1xuLy8gaW1wb3J0IFZ1ZWxpZGF0ZSBmcm9tICd2dWVsaWRhdGUnO1xuaW1wb3J0IHsgdXNlVnVlbGlkYXRlIH0gZnJvbSAnQHZ1ZWxpZGF0ZS9jb3JlJzsgLy8gSW1wb3J0IHVzZVZ1ZWxpZGF0ZSBmdW5jdGlvblxuaW1wb3J0IFN1Z2dlc3ROZXdCdXR0b24gZnJvbSAnQC9jb21wb25lbnRzL1N1Z2dlc3ROZXdCdXR0b24udnVlJztcbmltcG9ydCBTdWdnZXN0Q2hhbmdlQnV0dG9uIGZyb20gJ0AvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZSc7XG5cbmNvbnN0IGkxOG4gPSBjcmVhdGVJMThuKHtcbiAgICAvLyBsb2NhbGU6ICdmaScsXG4gICAgbG9jYWxlOiB3aW5kb3cubGFuZyxcbiAgICBtZXNzYWdlczogdHJhbnNsYXRpb25zLFxufSk7XG5cbmNvbnN0IGFwcCA9IGNyZWF0ZUFwcChTdWdnZXN0TmV3QnV0dG9uKTtcblxuLy8gUHJvdmlkZSBpMThuIGluc3RhbmNlIHRvIGNvbXBvbmVudHNcbi8vIGFwcC5wcm92aWRlKCckdCcsIGkxOG4uZ2xvYmFsLnQpO1xuYXBwLnByb3ZpZGUoJyR0JywgaTE4bi5nbG9iYWwudCk7XG5hcHAucHJvdmlkZSgncGFnZVVybCcsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbi8vIGFwcC5wcm92aWRlKCd1c2VWdWVsaWRhdGUnLCB1c2VWdWVsaWRhdGUpO1xuXG5hcHAudXNlKGkxOG4pOyAvLyBSZWdpc3RlciBnbG9iYWwgaTE4blxuLy8gYXBwLnVzZSh1c2VWdWVsaWRhdGUpOyAvLyBVc2UgVnVlbGlkYXRlIHBsdWdpblxuXG4vLyBEZWZpbmUgdGhlIGN1c3RvbSBlbGVtZW50c1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdzdWdnZXN0LW5ldy1idXR0b24nLCBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFwcC5tb3VudChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZWxlbWVudC4kZWwpO1xuICAgIH1cbn0pO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicsIGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlQXBwKFN1Z2dlc3RDaGFuZ2VCdXR0b24pLm1vdW50KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50LiRlbCk7XG4gICAgfVxufSk7XG5cbi8vIENoZWNrIGlmICdzdWdnZXN0LW5ldy1idXR0b24nIGlzIHJlZ2lzdGVyZWRcbmlmIChjdXN0b21FbGVtZW50cy5nZXQoJ3N1Z2dlc3QtbmV3LWJ1dHRvbicpKSB7XG4gICAgY29uc29sZS5sb2coXCInc3VnZ2VzdC1uZXctYnV0dG9uJyBpcyByZWdpc3RlcmVkLlwiKTtcbn0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCInc3VnZ2VzdC1uZXctYnV0dG9uJyBpcyBOT1QgcmVnaXN0ZXJlZC5cIik7XG59Ki9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbi8vIHN1cHBvcnQgZm9yIG9sZGVyIGJyb3dzZXJzXG5pbXBvcnQgJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQvYnVpbGQvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudCc7XG5pbXBvcnQgXCJjb3JlLWpzL3N0YWJsZVwiO1xuaW1wb3J0IFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCI7XG5cbmltcG9ydCB7IGNyZWF0ZUFwcCB9IGZyb20gJ3Z1ZSdcbmltcG9ydCB7IGNyZWF0ZUkxOG4gfSBmcm9tICd2dWUtaTE4bic7XG5pbXBvcnQgdHJhbnNsYXRpb25zIGZyb20gJy4vaTE4bi9pMThuJztcblxuLy8gaW1wb3J0IHlvdXIgY29tcG9uZW50KHMpXG5pbXBvcnQgU3VnZ2VzdE5ld0J1dHRvbiBmcm9tICdAL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWUnO1xuaW1wb3J0IFN1Z2dlc3RDaGFuZ2VCdXR0b24gZnJvbSAnQC9jb21wb25lbnRzL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlJztcblxuY29uc3QgaTE4biA9IGNyZWF0ZUkxOG4oe1xuICAgIGxvY2FsZTogJ2ZpJyxcbiAgICBtZXNzYWdlczogdHJhbnNsYXRpb25zLFxufSk7XG5cbmNvbnN0IGFwcCA9IGNyZWF0ZUFwcChTdWdnZXN0TmV3QnV0dG9uKTtcblxuLy8gUmVnaXN0ZXIgZ2xvYmFsIGkxOG5cbmFwcC51c2UoaTE4bik7XG5cbi8vIFJlZ2lzdGVyIGNvbXBvbmVudHMgZ2xvYmFsbHkgaWYgbmVlZGVkXG5hcHAuY29tcG9uZW50KCdzdWdnZXN0LW5ldy1idXR0b24nLCBTdWdnZXN0TmV3QnV0dG9uKTtcbmFwcC5jb21wb25lbnQoJ3N1Z2dlc3QtY2hhbmdlLWJ1dHRvbicsIFN1Z2dlc3RDaGFuZ2VCdXR0b24pO1xuXG5jb25zb2xlLmxvZygnVnVlIGFwcDonLCBhcHApO1xuXG5hcHAubW91bnQoJyNhcHAnKTsgLy8gUmVwbGFjZSAnI2FwcCcgd2l0aCB5b3VyIHJvb3QgZWxlbWVudCBJRFxuLy8gYXBwLm1vdW50KCcjc3VnZ2VzdGlvbnMtbmV3Jyk7XG4qL1xuXG5cblxuXG4vLyBUaGUgb3JpZ2luYWwgYmVmb3JlIHZ1ZTNcbi8qXG4vLyBzdXBwb3J0IGZvciBvbGRlciBicm93c2Vyc1xuaW1wb3J0ICdkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50L2J1aWxkL2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQnO1xuaW1wb3J0IFwiY29yZS1qcy9zdGFibGVcIjtcbmltcG9ydCBcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbmltcG9ydCBWdWVsaWRhdGUgZnJvbSAndnVlbGlkYXRlJztcblZ1ZS51c2UoVnVlbGlkYXRlKTtcblxuaW1wb3J0IFZ1ZUkxOG4gZnJvbSAndnVlLWkxOG4nO1xuVnVlLnVzZShWdWVJMThuKTtcbmltcG9ydCB0cmFuc2xhdGlvbnMgZnJvbSAnLi9pMThuL2kxOG4nO1xuXG4vLyBpbmNsdWRlIHZ1ZS1jdXN0b20tZWxlbWVudCBwbHVnaW4gdG8gVnVlXG5pbXBvcnQgVnVlQ3VzdG9tRWxlbWVudCBmcm9tICd2dWUtY3VzdG9tLWVsZW1lbnQnO1xuVnVlLnVzZShWdWVDdXN0b21FbGVtZW50KTtcblxuLy8gaW1wb3J0IGFuZCByZWdpc3RlciB5b3VyIGNvbXBvbmVudChzKVxuaW1wb3J0IFN1Z2dlc3ROZXdCdXR0b24gZnJvbSAnQC9jb21wb25lbnRzL1N1Z2dlc3ROZXdCdXR0b24udnVlJztcblN1Z2dlc3ROZXdCdXR0b24uaTE4biA9IG5ldyBWdWVJMThuKHsgbG9jYWxlOiAnZmknLCBtZXNzYWdlczogdHJhbnNsYXRpb25zIH0pO1xuVnVlLmN1c3RvbUVsZW1lbnQoJ3N1Z2dlc3QtbmV3LWJ1dHRvbicsIFN1Z2dlc3ROZXdCdXR0b24pO1xuXG4vLyBpbXBvcnQgYW5kIHJlZ2lzdGVyIHlvdXIgY29tcG9uZW50KHMpXG5pbXBvcnQgU3VnZ2VzdENoYW5nZUJ1dHRvbiBmcm9tICdAL2NvbXBvbmVudHMvU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWUnO1xuU3VnZ2VzdENoYW5nZUJ1dHRvbi5pMThuID0gbmV3IFZ1ZUkxOG4oeyBsb2NhbGU6ICdmaScsIG1lc3NhZ2VzOiB0cmFuc2xhdGlvbnMgfSk7XG5WdWUuY3VzdG9tRWxlbWVudCgnc3VnZ2VzdC1jaGFuZ2UtYnV0dG9uJywgU3VnZ2VzdENoYW5nZUJ1dHRvbik7XG4qL1xuIl0sIm5hbWVzIjpbInRyYW5zbGF0aW9ucyIsImZpIiwicmVxdWlyZSIsInN2IiwiZW4iLCJzZSIsImlkIiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9jcmVhdGVFbGVtZW50Vk5vZGUiLCJyb2xlIiwib25DbGljayIsIl9jYWNoZSIsIiRldmVudCIsIl9jdHgiLCJpc09wZW5lZCIsImhyZWYiLCJjb25jYXQiLCJwYWdlVXJsIiwic3BsaXQiLCJfaG9pc3RlZF8yIiwiX3RvRGlzcGxheVN0cmluZyIsIiR0IiwiX2NyZWF0ZUJsb2NrIiwiX2NvbXBvbmVudF9jZW50ZXJlZF9kaWFsb2ciLCJvbkNsb3NlIiwiY2xvc2VEaWFsb2ciLCJzaG93U3VjY2Vzc01lc3NhZ2UiLCJzaG93RmFpbHVyZU1lc3NhZ2UiLCJfY29tcG9uZW50X25ld19zdWdnZXN0aW9uIiwiY29uY2VwdFR5cGVJc1NlbGVjdGVkIiwicHJlZkxhYmVsT2theSIsImV4cGxhbmF0aW9uT2theSIsIm5lZWRlZEZvck9rYXkiLCJzZW5kaW5nIiwiZCIsImZvcm1EYXRhIiwidm9jYWJ1bGFyeSIsImNvbmNlcHRUeXBlIiwidmFsdWUiLCJwcmVmTGFiZWwiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwiYWx0TGFiZWxzIiwiYnJvYWRlckxhYmVscyIsIm5hcnJvd2VyTGFiZWxzIiwicmVsYXRlZExhYmVscyIsImdyb3VwcyIsInNlbGVjdGVkR3JvdXBzIiwiZXhhY3RNYXRjaGVzIiwic2NvcGVOb3RlIiwiZXhwbGFuYXRpb24iLCJuZWVkZWRGb3IiLCJmcm9tT3JnIiwib25TdWJtaXRGb3JtIiwic3VibWl0Rm9ybSIsIl9jb21wb25lbnRfc3VjY2Vzc19tZXNzYWdlIiwic3VnZ2VzdGlvblVybCIsInVybCIsIl9jb21wb25lbnRfZmFpbHVyZV9tZXNzYWdlIiwia2V5IiwiY2xhc3MiLCJzdHlsZSIsIl9ob2lzdGVkXzEiLCJmb3IiLCIkcHJvcHMiLCJsYWJlbCIsInRleHQiLCIkc2V0dXAiLCJfbm9ybWFsaXplQ2xhc3MiLCJfaG9pc3RlZF8zIiwiX2hvaXN0ZWRfNCIsImxlbmd0aCIsIl9ob2lzdGVkXzUiLCJfY3JlYXRlVk5vZGUiLCJfY29tcG9uZW50X3N2Z19pY29uIiwiX2NvbXBvbmVudF9pY29uX3RyaWFuZ2xlIiwib3B0aW9ucyIsIl9ob2lzdGVkXzYiLCJfaG9pc3RlZF83Iiwibm9PcHRpb25zTWVzc2FnZSIsImNsb3NlRHJvcERvd24iLCJfaG9pc3RlZF84IiwiX0ZyYWdtZW50IiwiX3JlbmRlckxpc3QiLCJvcHRpb24iLCJpIiwic2VsZWN0T3B0aW9uIiwiaXNTZWxlY3RlZCIsIl9jb21wb25lbnRfaWNvbl9jaGVjayIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsImljb25OYW1lIiwic3Ryb2tlIiwibGFuZyIsImZpbGwiLCJpY29uQ29sb3IiLCJfcmVuZGVyU2xvdCIsIiRzbG90cyIsInVuZGVmaW5lZCIsInByb3BzIiwidHlwZSIsIlN0cmluZyIsImRlZmF1bHQiLCJOdW1iZXIiLCJyZWYiLCJvbk1vdW50ZWQiLCJvbkJlZm9yZVVubW91bnQiLCJpbmplY3QiLCJTdmdJY29uIiwiSWNvblRyaWFuZ2xlIiwiSWNvbkNoZWNrIiwiZGlyZWN0aXZlIiwib25DbGlja0F3YXkiLCJjb21wb25lbnRzIiwiZGlyZWN0aXZlcyIsIkFycmF5IiwiT2JqZWN0Iiwic2V0dXAiLCJjb250ZXh0Iiwic2VsZWN0ZWRJbmRleCIsImNvdW50IiwiYXR0cnMiLCJpbmRleCIsImVtaXQiLCJ2b2NhYiIsImhhbmRsZUNsaWNrIiwiY29uc29sZSIsImxvZyIsInNlYXJjaFJlc3VsdCIsInVyaSIsInNlYXJjaFN0cmluZyIsInRvTG93ZXJDYXNlIiwidGFyZ2V0IiwibGFuZ3VhZ2UiLCJfaG9pc3RlZF85IiwiX2hvaXN0ZWRfMTAiLCJfY29tcG9uZW50X2ljb25fY3Jvc3MiLCJ0cmFuc2Zvcm0iLCJfY3JlYXRlQ29tbWVudFZOb2RlIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImV4cG9ydHMiLCJPcCIsInByb3RvdHlwZSIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJkZXNjIiwiJFN5bWJvbCIsIlN5bWJvbCIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwidG9TdHJpbmdUYWciLCJkZWZpbmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJlcnIiLCJ3cmFwIiwiaW5uZXJGbiIsIm91dGVyRm4iLCJzZWxmIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsImNyZWF0ZSIsIkNvbnRleHQiLCJtYWtlSW52b2tlTWV0aG9kIiwidHJ5Q2F0Y2giLCJmbiIsImFyZyIsImNhbGwiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwibWV0aG9kIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfdHlwZW9mIiwiX19hd2FpdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwic3RhdGUiLCJFcnJvciIsImRvbmVSZXN1bHQiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwiZG9uZSIsIm1ldGhvZE5hbWUiLCJyZXR1cm4iLCJUeXBlRXJyb3IiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHQiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsImVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicHVzaCIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpdGVyYWJsZSIsIml0ZXJhdG9yTWV0aG9kIiwiaXNOYU4iLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJpdGVyIiwia2V5cyIsInZhbCIsIm9iamVjdCIsInJldmVyc2UiLCJwb3AiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJjYXRjaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJfbmV4dCIsIl90aHJvdyIsIl9hc3luY1RvR2VuZXJhdG9yIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiZGVmaW5lQ29tcG9uZW50IiwicmVhY3RpdmUiLCJ3YXRjaEVmZmVjdCIsIndhdGNoIiwiSWNvbkNyb3NzIiwiYXhpb3MiLCJkZWJvdW5jZSIsInNlYXJjaExhYmVsIiwiaGFuZGxlUmVzdWx0IiwiY2hlY2tDYXBpdGFsaXphdGlvbiIsIl9yZWYiLCJfY2FsbGVlIiwiaW5wdXRWYWx1ZSIsInZvY3MiLCJyZXNwb25zZSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJwYXJhbXMiLCJxdWVyeSIsImRhdGEiLCJyZXN1bHRzIiwiX3giLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHJpbmciLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsInNlbGVjdGVkT3B0aW9ucyIsInJlbW92ZUxhYmVsU2VsZWN0aW9uIiwiY2xlYXJJbnB1dCIsImFkZExhYmVsU2VsZWN0aW9uIiwib25DbGlja2F3YXkiLCJkZWZpbmVFbWl0cyIsImhhc1VuaXF1ZVZhbHVlIiwiQm9vbGVhbiIsImZldGNoUmVzdWx0cyIsImdldCIsInQwIiwic3Vic3RyaW5nIiwibyIsInNvbWUiLCJpdGVtIiwiZmluZEluZGV4Iiwic3BsaWNlIiwiZW1pdEV2ZW50IiwiZXZlbnROYW1lIiwicGF5bG9hZCIsImV4cG9zZSIsIm9uSW5wdXQiLCJoYW5kbGVJbnB1dCIsImlzVG91Y2hlZCIsIl90b0NvbnN1bWFibGVBcnJheSIsInJlbW92ZU9wdGlvbiIsInNlbGVjdGFibGVPcHRpb25zIiwiZmluZE9wdGlvbkluZGV4Iiwib3B0aW9uTGlzdCIsImluZGV4T2YiLCJoYW5kbGVWb2NhYklucHV0IiwiaW5wdXRWb2NhYiIsInVwZGF0ZWRWYWx1ZXMiLCJoYW5kbGVWYWx1ZUlucHV0IiwiY29tcHV0ZWQiLCJCYXNpY0Ryb3BEb3duIiwiU2VhcmNoSW5wdXQiLCJTZWFyY2hBdXRvQ29tcGxldGUiLCJCYXNpY0lucHV0IiwiVGhlTXVsdGlwbGVCYXNpY0lucHV0IiwiU2VsZWN0V2l0aENoaXBzIiwiVGhlRXhhY3RNYXRjaGVzSW5wdXQiLCJ3aW5kb3ciLCJ0ZXN0TGFuZyIsImhhbmRsZVNlbGVjdCIsImhhbmRsZVByZWZMYWJlbCIsImhhbmRsZUV4cGxhbmF0aW9uIiwiaGFuZGxlTmVlZGVkRm9yIiwiY2xvc2UiLCJfIiwiaGFuZGxlRXNjS2V5IiwiZSIsImtleUNvZGUiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTmV3U3VnZ2VzdGlvbiIsIkNlbnRlcmVkRGlhbG9nIiwiU3VjY2Vzc01lc3NhZ2UiLCJGYWlsdXJlTWVzc2FnZSIsInVybFRvUHJ4Iiwic2V0VGltZW91dCIsInRlc3RpIiwiZGF0YUNhbkJlU2VudEFycmF5IiwiYWxsR3JvdXBzIiwidGFncyIsIm5ld1ZhbHVlcyIsIm9sZFZhbHVlcyIsImNvbmNlcHRUeXBlTGVuZ3RoIiwiZGVlcCIsInByaW1hcnlMYWJlbExlbmd0aCIsImV4cGxhbmF0aW9uTGVuZ3RoIiwibmVlZGRGb3JMZW5ndGgiLCJzZXREcm9wRG93biIsImFkZEhUVFBPckhUVFBTIiwic3RyIiwidGVzdCIsImNvdW50VHJ1ZVZhbHVlcyIsInJlZHVjZSIsImN1cnJlbnRWYWx1ZSIsInNlbmREYXRhIiwib250VHlwZUluVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbSIsImxhYmVsc0luVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbSIsImFsdFRlcm1zIiwiYnJkTGFibHMiLCJucnJMYWJscyIsInJsdGRMYWJscyIsImV4Y3RMYWJscyIsImRhdGFCdW5kbGUiLCJoZWFkZXJzIiwiaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzIiwidGl0bGUiLCJib2R5IiwibGFiZWxzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInBvc3QiLCJ0b2dnbGVTdWNjZXNzTWVzc2FnZSIsInJlcGxhY2UiLCJ0b2dnbGVGYWlsdXJlTWVzc2FnZSIsInJlc3BvbnNlVXJsIiwiZ2V0R3JvdXBzIiwiZ2V0VXJsIiwiX3JlZjIiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImxvY2F0aW9uIiwiX3JlZjMiLCJfY2FsbGVlMyIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsIl9jb21wb25lbnRfZWRpdF9zdWdnZXN0aW9uIiwibGFiZWxYIiwidXJpWCIsImRlc2NyaXB0aW9uIiwicmVhc29uIiwiX2NvbXBvbmVudF9iYXNpY19pbnB1dCIsInVwZGF0ZURlc2NyaXB0aW9uIiwiaXNUZXh0QXJlYSIsImRlc2NyaXB0aW9uQ2FuQmVTZW50Iiwic3VibWl0dGVkIiwidXBkYXRlUmVhc29uIiwicmVhc29uQ2FuQmVTZW50IiwidXBkYXRlRnJvbU9yZyIsImRlc2NyaXB0aW9uTGVuZ3RoIiwicmVhc29uTGVuZ3RoIiwiRWRpdFN1Z2dlc3Rpb24iLCJyZXF1aXJlZCIsIm1vaWtrZWxpcyIsInBhZ2VVcmxYIiwidmFsaWRhdGlvbnMiLCJjcmVhdGVBcHAiLCJjcmVhdGVJMThuIiwiU3VnZ2VzdE5ld0J1dHRvbiIsIlN1Z2dlc3RDaGFuZ2VCdXR0b24iLCJpMThuIiwibG9jYWxlIiwibWVzc2FnZXMiLCJhcHAiLCJhcHAyIiwicHJvdmlkZSIsImdsb2JhbCIsInQiLCJlbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ1cmlUZXh0IiwidGV4dENvbnRlbnQiLCJ1c2UiLCJjdXN0b21FbGVtZW50cyIsIl9IVE1MRWxlbWVudCIsIl9pbmhlcml0cyIsIl9jbGFzcyIsIl9zdXBlciIsIl9jcmVhdGVTdXBlciIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImNvbm5lY3RlZENhbGxiYWNrIiwibW91bnQiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCIkZWwiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiSFRNTEVsZW1lbnQiLCJfSFRNTEVsZW1lbnQyIiwiX2NsYXNzMiIsIl9zdXBlcjIiLCJlbGVtZW50QUJDIiwiYXBwMyIsImVsZW1lbnRVcmkiLCJwcmVmRWxlbWVudCIsImxhYmVsVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5800\n");

/***/ }),

/***/ 1899:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\na[data-v-32d31e5a] {\\n  color: #00748f;\\n  font-weight: 500 !important;\\n}\\n.error[data-v-32d31e5a] {\\n  color: #e83a30;\\n  text-indent: 2px;\\n  font-size: 13px;\\n  margin-top: -10px;\\n  margin-bottom: 16px;\\n}\\n.suggestion-header[data-v-32d31e5a] {\\n  padding-bottom: 8px;\\n  border-bottom: 1px solid #eeeeee;\\n}\\n.suggestion-form[data-v-32d31e5a] {\\n  margin-top: 20px;\\n}\\n.form-submit[data-v-32d31e5a] {\\n  text-align: right;\\n  padding: 20px 0;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n.form-submit a[data-v-32d31e5a] {\\n  padding: 10px 15px;\\n  color: #ffffff;\\n  background-color: #3a4553;\\n  cursor: pointer;\\n  cursor: hand;\\n  transition: background-color 0.1s;\\n}\\n.form-submit a[data-v-32d31e5a]:hover {\\n  background-color: #4d5764;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/EditSuggestion.vue\"],\"names\":[],\"mappings\":\";AAyHA;EACE,cAAc;EACd,2BAA2B;AAC7B;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,iBAAiB;EACjB,mBAAmB;AACrB;AAEA;EACE,mBAAmB;EACnB,gCAAgC;AAClC;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,iBAAiB;EACjB,eAAe;EACf,2BAA2B,EAAE,eAAe;EAC5C,yBAAyB,EAAE,WAAW;EACtC,sBAAsB,EAAE,YAAY;EACpC,qBAAqB,EAAE,2BAA2B;EAClD,iBAAiB;AACnB;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,yBAAyB;EACzB,eAAe;EACf,YAAY;EACZ,iCAAiC;AACnC;AAEA;EACE,yBAAyB;AAC3B\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <div class=\\\"suggestion-header\\\">\\n      <h4>{{ $t('edit.header') }} <a :href=\\\"uri\\\">{{ label }}</a></h4>\\n      <p>{{ $t('edit.paragraph') }}</p>\\n    </div>\\n    <div class=\\\"suggestion-form\\\">\\n      <div>\\n        <basic-input\\n            :value=\\\"formData.description\\\"\\n            @input:basic=\\\"updateDescription\\\"\\n            :label=\\\"{ text: $t('edit.description.label'), for: $t('edit.description.label') }\\\"\\n            :isTextArea=\\\"true\\\"\\n        />\\n         <p v-if=\\\"!descriptionCanBeSent && submitted\\\" class=\\\"error\\\">{{ $t('edit.description.error') }}</p>\\n\\n        <basic-input\\n            :value=\\\"formData.reason\\\"\\n            @input:basic=\\\"updateReason\\\"\\n            :label=\\\"{ text: $t('edit.reason.label'), for: $t('edit.reason.for') }\\\"\\n            :isTextArea=\\\"true\\\"\\n        />\\n         <p v-if=\\\"!reasonCanBeSent && submitted\\\" class=\\\"error\\\">{{ $t('edit.reason.error') }}</p>\\n\\n        <basic-input\\n            :value=\\\"formData.fromOrg\\\"\\n            @input:basic=\\\"updateFromOrg\\\"\\n            :label=\\\"{ text: $t('edit.fromOrg.label'), for: $t('edit.fromOrg.for') }\\\"\\n            :isTextArea=\\\"false\\\"\\n        />\\n      </div>\\n\\n      <div class=\\\"form-submit\\\">\\n        <a @click=\\\"submitForm\\\">{{ $t('edit.submit') }}</a>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport BasicInput from './form/BasicInput.vue';\\nimport { defineComponent, ref, reactive, watchEffect, inject, watch } from 'vue';\\n\\nexport default {\\n  components: {\\n    BasicInput,\\n  },\\n  props: {\\n    d: Object,\\n    label: String,\\n    uri: String,\\n  },\\n  setup(props, { emit }) {\\n    const formData = ref(props.d);\\n    const descriptionCanBeSent = ref(false)\\n    const reasonCanBeSent = ref(false)\\n    const submitted = ref(false)\\n\\n    const updateDescription = (value) => {\\n      formData.value.description = value;\\n    };\\n\\n    const updateReason = (value) => {\\n      formData.value.reason = value;\\n    };\\n\\n    const updateFromOrg = (value) => {\\n      formData.value.fromOrg = value;\\n    };\\n\\n    watch(\\n        () => [formData.value.description, formData.value.description.length],\\n        (newValues, oldValues) => {\\n          const descriptionLength = newValues[1];\\n\\n          if (descriptionLength > 2) {\\n            descriptionCanBeSent.value = true\\n          } else {\\n            descriptionCanBeSent.value = false\\n          }\\n        },\\n        { deep: true }\\n    )\\n\\n    watch(\\n        () => [formData.value.reason, formData.value.reason.length],\\n        (newValues, oldValues) => {\\n          const reasonLength = newValues[1];\\n\\n          if (reasonLength > 2) {\\n            reasonCanBeSent.value = true\\n          } else {\\n            reasonCanBeSent.value = false\\n          }\\n        },\\n        { deep: true }\\n    )\\n\\n\\n    const submitForm = () => {\\n    submitted.value = true\\n      if (descriptionCanBeSent.value == true && reasonCanBeSent.value == true) {\\n        emit('submitForm')\\n      }\\n    };\\n\\n    return {\\n      formData,\\n      updateDescription,\\n      updateReason,\\n      updateFromOrg,\\n      submitForm,\\n      descriptionCanBeSent,\\n      reasonCanBeSent,\\n      submitted\\n    };\\n  },\\n};\\n</script>\\n\\n<style scoped>\\na {\\n  color: #00748f;\\n  font-weight: 500 !important;\\n}\\n\\n.error {\\n  color: #e83a30;\\n  text-indent: 2px;\\n  font-size: 13px;\\n  margin-top: -10px;\\n  margin-bottom: 16px;\\n}\\n\\n.suggestion-header {\\n  padding-bottom: 8px;\\n  border-bottom: 1px solid #eeeeee;\\n}\\n\\n.suggestion-form {\\n  margin-top: 20px;\\n}\\n\\n.form-submit {\\n  text-align: right;\\n  padding: 20px 0;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n\\n.form-submit a {\\n  padding: 10px 15px;\\n  color: #ffffff;\\n  background-color: #3a4553;\\n  cursor: pointer;\\n  cursor: hand;\\n  transition: background-color 0.1s;\\n}\\n\\n.form-submit a:hover {\\n  background-color: #4d5764;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3lIO0FBQzdCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxnRUFBZ0UsbUJBQW1CLGdDQUFnQyxHQUFHLDJCQUEyQixtQkFBbUIscUJBQXFCLG9CQUFvQixzQkFBc0Isd0JBQXdCLEdBQUcsdUNBQXVDLHdCQUF3QixxQ0FBcUMsR0FBRyxxQ0FBcUMscUJBQXFCLEdBQUcsaUNBQWlDLHNCQUFzQixvQkFBb0IsaUNBQWlDLCtDQUErQyx3Q0FBd0Msd0NBQXdDLGtEQUFrRCxHQUFHLG1DQUFtQyx1QkFBdUIsbUJBQW1CLDhCQUE4QixvQkFBb0IsaUJBQWlCLHNDQUFzQyxHQUFHLHlDQUF5Qyw4QkFBOEIsR0FBRyxTQUFTLGdHQUFnRyxNQUFNLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksV0FBVyxzQkFBc0IsdUJBQXVCLHVCQUF1Qix5QkFBeUIsYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksTUFBTSxLQUFLLFlBQVksbUdBQW1HLHFCQUFxQixvQkFBb0IsUUFBUSx1QkFBdUIsdUJBQXVCLDhNQUE4TSx1RUFBdUUsNkhBQTZILCtCQUErQix3SUFBd0ksMkRBQTJELHdIQUF3SCwwQkFBMEIsMElBQTBJLDZEQUE2RCwwSUFBMEksb0JBQW9CLGtIQUFrSCxXQUFXLDZEQUE2RCxXQUFXLG9CQUFvQixpQkFBaUIsc0JBQXNCLGFBQWEsMkRBQTJELG9CQUFvQixNQUFNLEdBQUcsb0NBQW9DLHFLQUFxSywyQ0FBMkMsUUFBUSx5Q0FBeUMsc0NBQXNDLFFBQVEsMENBQTBDLHVDQUF1QyxRQUFRLG1JQUFtSSxtREFBbUQsMENBQTBDLDZEQUE2RCxNQUFNLDZEQUE2RCxXQUFXLGFBQWEsWUFBWSxnSUFBZ0ksOENBQThDLHFDQUFxQyx3REFBd0QsTUFBTSx3REFBd0QsV0FBVyxhQUFhLFlBQVksMkNBQTJDLDhHQUE4RyxxQ0FBcUMsUUFBUSxnQkFBZ0IsdUxBQXVMLEtBQUssS0FBSyxrQ0FBa0MsbUJBQW1CLGdDQUFnQyxHQUFHLFlBQVksbUJBQW1CLHFCQUFxQixvQkFBb0Isc0JBQXNCLHdCQUF3QixHQUFHLHdCQUF3Qix3QkFBd0IscUNBQXFDLEdBQUcsc0JBQXNCLHFCQUFxQixHQUFHLGtCQUFrQixzQkFBc0Isb0JBQW9CLGlDQUFpQywrQ0FBK0Msd0NBQXdDLHdDQUF3QyxrREFBa0QsR0FBRyxvQkFBb0IsdUJBQXVCLG1CQUFtQiw4QkFBOEIsb0JBQW9CLGlCQUFpQixzQ0FBc0MsR0FBRywwQkFBMEIsOEJBQThCLEdBQUcsK0JBQStCO0FBQzkrSztBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL0VkaXRTdWdnZXN0aW9uLnZ1ZT9kZDhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuYVtkYXRhLXYtMzJkMzFlNWFdIHtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgZm9udC13ZWlnaHQ6IDUwMCAhaW1wb3J0YW50O1xcbn1cXG4uZXJyb3JbZGF0YS12LTMyZDMxZTVhXSB7XFxuICBjb2xvcjogI2U4M2EzMDtcXG4gIHRleHQtaW5kZW50OiAycHg7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBtYXJnaW4tdG9wOiAtMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcbi5zdWdnZXN0aW9uLWhlYWRlcltkYXRhLXYtMzJkMzFlNWFdIHtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZWVlZTtcXG59XFxuLnN1Z2dlc3Rpb24tZm9ybVtkYXRhLXYtMzJkMzFlNWFdIHtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxufVxcbi5mb3JtLXN1Ym1pdFtkYXRhLXYtMzJkMzFlNWFdIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgcGFkZGluZzogMjBweCAwO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi5mb3JtLXN1Ym1pdCBhW2RhdGEtdi0zMmQzMWU1YV0ge1xcbiAgcGFkZGluZzogMTBweCAxNXB4O1xcbiAgY29sb3I6ICNmZmZmZmY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2E0NTUzO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjFzO1xcbn1cXG4uZm9ybS1zdWJtaXQgYVtkYXRhLXYtMzJkMzFlNWFdOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0ZDU3NjQ7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jb21wb25lbnRzL0VkaXRTdWdnZXN0aW9uLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBeUhBO0VBQ0UsY0FBYztFQUNkLDJCQUEyQjtBQUM3QjtBQUVBO0VBQ0UsY0FBYztFQUNkLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLG1CQUFtQjtBQUNyQjtBQUVBO0VBQ0UsbUJBQW1CO0VBQ25CLGdDQUFnQztBQUNsQztBQUVBO0VBQ0UsZ0JBQWdCO0FBQ2xCO0FBRUE7RUFDRSxpQkFBaUI7RUFDakIsZUFBZTtFQUNmLDJCQUEyQixFQUFFLGVBQWU7RUFDNUMseUJBQXlCLEVBQUUsV0FBVztFQUN0QyxzQkFBc0IsRUFBRSxZQUFZO0VBQ3BDLHFCQUFxQixFQUFFLDJCQUEyQjtFQUNsRCxpQkFBaUI7QUFDbkI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixjQUFjO0VBQ2QseUJBQXlCO0VBQ3pCLGVBQWU7RUFDZixZQUFZO0VBQ1osaUNBQWlDO0FBQ25DO0FBRUE7RUFDRSx5QkFBeUI7QUFDM0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic3VnZ2VzdGlvbi1oZWFkZXJcXFwiPlxcbiAgICAgIDxoND57eyAkdCgnZWRpdC5oZWFkZXInKSB9fSA8YSA6aHJlZj1cXFwidXJpXFxcIj57eyBsYWJlbCB9fTwvYT48L2g0PlxcbiAgICAgIDxwPnt7ICR0KCdlZGl0LnBhcmFncmFwaCcpIH19PC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic3VnZ2VzdGlvbi1mb3JtXFxcIj5cXG4gICAgICA8ZGl2PlxcbiAgICAgICAgPGJhc2ljLWlucHV0XFxuICAgICAgICAgICAgOnZhbHVlPVxcXCJmb3JtRGF0YS5kZXNjcmlwdGlvblxcXCJcXG4gICAgICAgICAgICBAaW5wdXQ6YmFzaWM9XFxcInVwZGF0ZURlc2NyaXB0aW9uXFxcIlxcbiAgICAgICAgICAgIDpsYWJlbD1cXFwieyB0ZXh0OiAkdCgnZWRpdC5kZXNjcmlwdGlvbi5sYWJlbCcpLCBmb3I6ICR0KCdlZGl0LmRlc2NyaXB0aW9uLmxhYmVsJykgfVxcXCJcXG4gICAgICAgICAgICA6aXNUZXh0QXJlYT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICAgPHAgdi1pZj1cXFwiIWRlc2NyaXB0aW9uQ2FuQmVTZW50ICYmIHN1Ym1pdHRlZFxcXCIgY2xhc3M9XFxcImVycm9yXFxcIj57eyAkdCgnZWRpdC5kZXNjcmlwdGlvbi5lcnJvcicpIH19PC9wPlxcblxcbiAgICAgICAgPGJhc2ljLWlucHV0XFxuICAgICAgICAgICAgOnZhbHVlPVxcXCJmb3JtRGF0YS5yZWFzb25cXFwiXFxuICAgICAgICAgICAgQGlucHV0OmJhc2ljPVxcXCJ1cGRhdGVSZWFzb25cXFwiXFxuICAgICAgICAgICAgOmxhYmVsPVxcXCJ7IHRleHQ6ICR0KCdlZGl0LnJlYXNvbi5sYWJlbCcpLCBmb3I6ICR0KCdlZGl0LnJlYXNvbi5mb3InKSB9XFxcIlxcbiAgICAgICAgICAgIDppc1RleHRBcmVhPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgICA8cCB2LWlmPVxcXCIhcmVhc29uQ2FuQmVTZW50ICYmIHN1Ym1pdHRlZFxcXCIgY2xhc3M9XFxcImVycm9yXFxcIj57eyAkdCgnZWRpdC5yZWFzb24uZXJyb3InKSB9fTwvcD5cXG5cXG4gICAgICAgIDxiYXNpYy1pbnB1dFxcbiAgICAgICAgICAgIDp2YWx1ZT1cXFwiZm9ybURhdGEuZnJvbU9yZ1xcXCJcXG4gICAgICAgICAgICBAaW5wdXQ6YmFzaWM9XFxcInVwZGF0ZUZyb21PcmdcXFwiXFxuICAgICAgICAgICAgOmxhYmVsPVxcXCJ7IHRleHQ6ICR0KCdlZGl0LmZyb21PcmcubGFiZWwnKSwgZm9yOiAkdCgnZWRpdC5mcm9tT3JnLmZvcicpIH1cXFwiXFxuICAgICAgICAgICAgOmlzVGV4dEFyZWE9XFxcImZhbHNlXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJmb3JtLXN1Ym1pdFxcXCI+XFxuICAgICAgICA8YSBAY2xpY2s9XFxcInN1Ym1pdEZvcm1cXFwiPnt7ICR0KCdlZGl0LnN1Ym1pdCcpIH19PC9hPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgQmFzaWNJbnB1dCBmcm9tICcuL2Zvcm0vQmFzaWNJbnB1dC52dWUnO1xcbmltcG9ydCB7IGRlZmluZUNvbXBvbmVudCwgcmVmLCByZWFjdGl2ZSwgd2F0Y2hFZmZlY3QsIGluamVjdCwgd2F0Y2ggfSBmcm9tICd2dWUnO1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIGNvbXBvbmVudHM6IHtcXG4gICAgQmFzaWNJbnB1dCxcXG4gIH0sXFxuICBwcm9wczoge1xcbiAgICBkOiBPYmplY3QsXFxuICAgIGxhYmVsOiBTdHJpbmcsXFxuICAgIHVyaTogU3RyaW5nLFxcbiAgfSxcXG4gIHNldHVwKHByb3BzLCB7IGVtaXQgfSkge1xcbiAgICBjb25zdCBmb3JtRGF0YSA9IHJlZihwcm9wcy5kKTtcXG4gICAgY29uc3QgZGVzY3JpcHRpb25DYW5CZVNlbnQgPSByZWYoZmFsc2UpXFxuICAgIGNvbnN0IHJlYXNvbkNhbkJlU2VudCA9IHJlZihmYWxzZSlcXG4gICAgY29uc3Qgc3VibWl0dGVkID0gcmVmKGZhbHNlKVxcblxcbiAgICBjb25zdCB1cGRhdGVEZXNjcmlwdGlvbiA9ICh2YWx1ZSkgPT4ge1xcbiAgICAgIGZvcm1EYXRhLnZhbHVlLmRlc2NyaXB0aW9uID0gdmFsdWU7XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IHVwZGF0ZVJlYXNvbiA9ICh2YWx1ZSkgPT4ge1xcbiAgICAgIGZvcm1EYXRhLnZhbHVlLnJlYXNvbiA9IHZhbHVlO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCB1cGRhdGVGcm9tT3JnID0gKHZhbHVlKSA9PiB7XFxuICAgICAgZm9ybURhdGEudmFsdWUuZnJvbU9yZyA9IHZhbHVlO1xcbiAgICB9O1xcblxcbiAgICB3YXRjaChcXG4gICAgICAgICgpID0+IFtmb3JtRGF0YS52YWx1ZS5kZXNjcmlwdGlvbiwgZm9ybURhdGEudmFsdWUuZGVzY3JpcHRpb24ubGVuZ3RoXSxcXG4gICAgICAgIChuZXdWYWx1ZXMsIG9sZFZhbHVlcykgPT4ge1xcbiAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbkxlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcXG5cXG4gICAgICAgICAgaWYgKGRlc2NyaXB0aW9uTGVuZ3RoID4gMikge1xcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uQ2FuQmVTZW50LnZhbHVlID0gdHJ1ZVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uQ2FuQmVTZW50LnZhbHVlID0gZmFsc2VcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XFxuICAgIClcXG5cXG4gICAgd2F0Y2goXFxuICAgICAgICAoKSA9PiBbZm9ybURhdGEudmFsdWUucmVhc29uLCBmb3JtRGF0YS52YWx1ZS5yZWFzb24ubGVuZ3RoXSxcXG4gICAgICAgIChuZXdWYWx1ZXMsIG9sZFZhbHVlcykgPT4ge1xcbiAgICAgICAgICBjb25zdCByZWFzb25MZW5ndGggPSBuZXdWYWx1ZXNbMV07XFxuXFxuICAgICAgICAgIGlmIChyZWFzb25MZW5ndGggPiAyKSB7XFxuICAgICAgICAgICAgcmVhc29uQ2FuQmVTZW50LnZhbHVlID0gdHJ1ZVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJlYXNvbkNhbkJlU2VudC52YWx1ZSA9IGZhbHNlXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxcbiAgICApXFxuXFxuXFxuICAgIGNvbnN0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XFxuICAgIHN1Ym1pdHRlZC52YWx1ZSA9IHRydWVcXG4gICAgICBpZiAoZGVzY3JpcHRpb25DYW5CZVNlbnQudmFsdWUgPT0gdHJ1ZSAmJiByZWFzb25DYW5CZVNlbnQudmFsdWUgPT0gdHJ1ZSkge1xcbiAgICAgICAgZW1pdCgnc3VibWl0Rm9ybScpXFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGZvcm1EYXRhLFxcbiAgICAgIHVwZGF0ZURlc2NyaXB0aW9uLFxcbiAgICAgIHVwZGF0ZVJlYXNvbixcXG4gICAgICB1cGRhdGVGcm9tT3JnLFxcbiAgICAgIHN1Ym1pdEZvcm0sXFxuICAgICAgZGVzY3JpcHRpb25DYW5CZVNlbnQsXFxuICAgICAgcmVhc29uQ2FuQmVTZW50LFxcbiAgICAgIHN1Ym1pdHRlZFxcbiAgICB9O1xcbiAgfSxcXG59O1xcbjwvc2NyaXB0PlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuYSB7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGZvbnQtd2VpZ2h0OiA1MDAgIWltcG9ydGFudDtcXG59XFxuXFxuLmVycm9yIHtcXG4gIGNvbG9yOiAjZTgzYTMwO1xcbiAgdGV4dC1pbmRlbnQ6IDJweDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIG1hcmdpbi10b3A6IC0xMHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG59XFxuXFxuLnN1Z2dlc3Rpb24taGVhZGVyIHtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZWVlZTtcXG59XFxuXFxuLnN1Z2dlc3Rpb24tZm9ybSB7XFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG5cXG4uZm9ybS1zdWJtaXQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBwYWRkaW5nOiAyMHB4IDA7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC8qIGlPUyBTYWZhcmkgKi9cXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLyogRmlyZWZveCAqL1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAvKiBJbnRlcm5ldCBFeHBsb3Jlci9FZGdlICovXFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLmZvcm0tc3VibWl0IGEge1xcbiAgcGFkZGluZzogMTBweCAxNXB4O1xcbiAgY29sb3I6ICNmZmZmZmY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2E0NTUzO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjFzO1xcbn1cXG5cXG4uZm9ybS1zdWJtaXQgYTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNGQ1NzY0O1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1899\n");

/***/ }),

/***/ 9278:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.hidden[data-v-39288721] {\\n  display: none;\\n}\\n.suggestion-header[data-v-39288721] {\\n  padding-bottom: 8px;\\n  border-bottom: 1px solid #eeeeee;\\n}\\n.suggestion-form[data-v-39288721] {\\n  margin-top: 20px;\\n}\\n.form-submit[data-v-39288721] {\\n  text-align: right;\\n  padding: 20px 0;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n.form-submit a[data-v-39288721] {\\n  padding: 10px 15px;\\n  color: #ffffff;\\n  background-color: #3a4553;\\n  cursor: pointer;\\n  cursor: hand;\\n  transition: background-color 0.1s;\\n}\\n.form-submit a[data-v-39288721]:hover {\\n  background-color: #4d5764;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/NewSuggestion.vue\"],\"names\":[],\"mappings\":\";AAmPA;EACE,aAAa;AACf;AACA;EACE,mBAAmB;EACnB,gCAAgC;AAClC;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,iBAAiB;EACjB,eAAe;EACf,2BAA2B,EAAE,eAAe;EAC5C,yBAAyB,EAAE,WAAW;EACtC,sBAAsB,EAAE,YAAY;EACpC,qBAAqB,EAAE,2BAA2B;EAClD,iBAAiB;AACnB;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,yBAAyB;EACzB,eAAe;EACf,YAAY;EACZ,iCAAiC;AACnC;AAEA;EACE,yBAAyB;AAC3B\",\"sourcesContent\":[\"<template>\\n\\n<div class=\\\"suggestion-container\\\">\\n  <!-- <button onclick=\\\"navigator.clipboard.writeText(window.location.href)\\\">Kopioi leikepöydälle</button> -->\\n  <div class=\\\"suggestion-header\\\">\\n    <h4 v-if=\\\"vocab === 'yso'\\\">{{ $t('new.header') }}</h4>\\n    <h4 v-else-if=\\\"vocab === 'yso-paikat'\\\">{{ $t('new.header-geo') }}</h4>\\n    <p>{{ $t('new.p1') }}</p>\\n    <p>{{ $t('new.p2') }}</p>\\n  </div>\\n  <div class=\\\"suggestion-form\\\">\\n    <div class=\\\"form-inputs\\\">\\n      <basic-drop-down\\n        :value=\\\"d.conceptType.value\\\"\\n        :options=\\\"d.conceptType.options\\\"\\n        @changeVocabulary=\\\"$emit('update:vocabulary', $event)\\\"\\n      @select=\\\"handleSelect($event)\\\"\\n        :label=\\\"{text: $t('new.conceptType.label'), for: $t('new.conceptType.for')}\\\"\\n      />\\n      <p v-if=\\\"!conceptTypeIsSelected && sending\\\" class=\\\"error\\\">{{ $t('new.conceptType.error') }}</p>\\n      <div v-if=\\\"$i18n.locale === 'fi'\\\">\\n        <search-input\\n          :value=\\\"d.prefLabel.primary\\\"\\n          :conceptType=\\\"d.conceptType.value\\\"\\n          :vocabulary=\\\"d.vocabulary\\\"\\n          :language=\\\"'fi'\\\"\\n          @input=\\\"handlePrefLabel($event)\\\"\\n          :label=\\\"{text: $t('new.prefLabel.fi.label'), for: $t('new.prefLabel.fi.for')}\\\" />\\n        <p v-if=\\\"!prefLabelOkay && sending\\\" class=\\\"error\\\">{{ $t('new.prefLabel.error') }}</p>\\n\\n        <search-input\\n          :value=\\\"d.prefLabel.secondary\\\"\\n          :conceptType=\\\"d.conceptType.value\\\"\\n          :vocabulary=\\\"d.vocabulary\\\"\\n          :language=\\\"'sv'\\\"\\n          @input=\\\"emitEvent('update:secondaryPrefLabel', $event)\\\"\\n          :label=\\\"{text: $t('new.prefLabel.sv.label'), for: $t('new.prefLabel.sv.for')}\\\" />\\n\\n        <!--lisätty 2023-09-18-->\\n        <basic-input\\n            :value=\\\"d.prefLabel.en\\\"\\n            @input:basic=\\\"emitEvent('update:enPrefLabel', $event)\\\"\\n            :label=\\\"{text: $t('new.prefLabel.en.label'), for: $t('new.prefLabel.en.for')}\\\"\\n            :isTextArea=\\\"false\\\" />\\n\\n      </div>\\n\\n      <div v-if=\\\"$i18n.locale === 'sv'\\\">\\n        <search-input\\n          :value=\\\"d.prefLabel.primary\\\"\\n          :vocabulary=\\\"d.vocabulary\\\"\\n          :conceptType=\\\"d.conceptType.value\\\"\\n          :language=\\\"'sv'\\\"\\n          @input=\\\"handlePrefLabel($event)\\\"\\n          :label=\\\"{text: $t('new.prefLabel.sv.label'), for: $t('new.prefLabel.sv.for')}\\\" />\\n        <p v-if=\\\"!prefLabelOkay && sending\\\" class=\\\"error\\\">{{ $t('new.prefLabel.error') }}</p>\\n\\n        <search-input\\n          :value=\\\"d.prefLabel.secondary\\\"\\n          :vocabulary=\\\"d.vocabulary\\\"\\n          :conceptType=\\\"d.conceptType.value\\\"\\n          :language=\\\"'fi'\\\"\\n          @input=\\\"emitEvent('update:secondaryPrefLabel', $event)\\\"\\n          :label=\\\"{text: $t('new.prefLabel.fi.label'), for: $t('new.prefLabel.fi.for')}\\\" />\\n\\n<!--lisätty 2023-09-18-->\\n        <basic-input\\n            :value=\\\"d.prefLabel.en\\\"\\n            @input:basic=\\\"emitEvent('update:enPrefLabel', $event)\\\"\\n            :label=\\\"{text: $t('new.prefLabel.en.label'), for: $t('new.prefLabel.en.for')}\\\"\\n            :isTextArea=\\\"false\\\" />\\n\\n      </div>\\n\\n      <div v-if=\\\"$i18n.locale === 'se' || $i18n.locale === 'en'\\\">\\n        <basic-input\\n            :value=\\\"d.prefLabel.en\\\"\\n            @input:basic=\\\"emitEvent('update:enPrefLabel', $event)\\\"\\n            :label=\\\"{text: $t('new.prefLabel.en.label'), for: $t('new.prefLabel.en.for')}\\\"\\n            :isTextArea=\\\"false\\\" />\\n\\n        <search-input\\n            :value=\\\"d.prefLabel.primary\\\"\\n            :conceptType=\\\"d.conceptType.value\\\"\\n            :vocabulary=\\\"d.vocabulary\\\"\\n            :language=\\\"'fi'\\\"\\n            @input=\\\"handlePrefLabel($event)\\\"\\n            :label=\\\"{text: $t('new.prefLabel.fi.label'), for: $t('new.prefLabel.fi.for')}\\\" />\\n        <p v-if=\\\"!prefLabelOkay && sending\\\" class=\\\"error\\\">{{ $t('new.prefLabel.error') }}</p>\\n\\n        <search-input\\n            :value=\\\"d.prefLabel.secondary\\\"\\n            :conceptType=\\\"d.conceptType.value\\\"\\n            :vocabulary=\\\"d.vocabulary\\\"\\n            :language=\\\"'sv'\\\"\\n            @input=\\\"emitEvent('update:secondaryPrefLabel', $event)\\\"\\n            :label=\\\"{text: $t('new.prefLabel.sv.label'), for: $t('new.prefLabel.sv.for')}\\\" />\\n\\n      </div>\\n\\n      <the-multiple-basic-input\\n        :values=\\\"d.altLabels\\\"\\n        @input-multi=\\\"emitEvent('update:altLabels', $event)\\\"\\n        :label=\\\"{text: $t('new.altLabels.label'), for: $t('new.altLabels.for')}\\\" />\\n\\n      <search-auto-complete\\n        :values=\\\"d.broaderLabels\\\"\\n        :vocabulary=\\\"d.vocabulary\\\"\\n        :language=\\\"$i18n.locale\\\"\\n        @update:selectedOptions=\\\"emitEvent('update:broaderLabels', $event)\\\"\\n        :label=\\\"{text: $t('new.broaderLabels.label'), for: $t('new.broaderLabels.for')}\\\"\\n        :hasUniqueValue=\\\"false\\\" />\\n\\n      <search-auto-complete\\n        :values=\\\"d.narrowerLabels\\\"\\n        :vocabulary=\\\"d.vocabulary\\\"\\n        :language=\\\"$i18n.locale\\\"\\n        @update:selectedOptions=\\\"emitEvent('update:narrowerLabels', $event)\\\"\\n        :label=\\\"{text: $t('new.narrowerLabels.label'), for: $t('new.narrowerLabels.for')}\\\"\\n        :hasUniqueValue=\\\"false\\\" />\\n\\n      <search-auto-complete\\n        :values=\\\"d.relatedLabels\\\"\\n        :vocabulary=\\\"d.vocabulary\\\"\\n        :language=\\\"$i18n.locale\\\"\\n        @update:selectedOptions=\\\"emitEvent('update:relatedLabels', $event)\\\"\\n        :label=\\\"{text: $t('new.relatedLabels.label'), for: $t('new.relatedLabels.for')}\\\"\\n        :hasUniqueValue=\\\"false\\\" />\\n\\n        <!-- :class=\\\"{'hidden': d.vocabulary === $t('new.common.places')}\\\" -->\\n      <select-with-chips\\n        :class=\\\"{'hidden': d.vocabulary === 'yso-paikat'}\\\"\\n        :value=\\\"$t('new.groups.placeholder')\\\"\\n        :options=\\\"d.groups.allGroups\\\"\\n        @select=\\\"emitEvent('update:groups', $event)\\\"\\n        :label=\\\"{text: $t('new.groups.label'), for: $t('new.groups.for')}\\\" />\\n\\n      <the-exact-matches-input\\n        :values=\\\"d.exactMatches\\\"\\n        @inputexm=\\\"emitEvent('update:exactMatches', $event)\\\"\\n        :label=\\\"{text: $t('new.exactMatches.label'), for: $t('new.exactMatches.for')}\\\"\\n        />\\n\\n      <basic-input\\n        :value=\\\"d.scopeNote\\\"\\n        @input:basic=\\\"emitEvent('update:scopeNote', $event)\\\"\\n        :label=\\\"{text: $t('new.scopeNote.label'), for: $t('new.scopeNote.for')}\\\"\\n        :isTextArea=\\\"true\\\" />\\n\\n      <basic-input\\n        :value=\\\"d.explanation\\\"\\n        @input:basic=\\\"handleExplanation($event)\\\"\\n        :label=\\\"{text: $t('new.explanation.label'), for: $t('new.explanation.label')}\\\"\\n      :isTextArea=\\\"true\\\" />\\n      <p v-if=\\\"!explanationOkay && sending\\\" class=\\\"error\\\">{{ $t('new.explanation.error') }}</p>\\n\\n      <basic-input\\n        :value=\\\"d.neededFor\\\"\\n        @input:basic=\\\"handleNeededFor($event)\\\"\\n        :label=\\\"{text: $t('new.neededFor.label'), for: $t('new.neededFor.for')}\\\"\\n        :isTextArea=\\\"true\\\" />\\n            <p v-if=\\\"!neededForOkay && sending\\\" class=\\\"error\\\">{{ $t('new.neededFor.error') }}</p>\\n\\n      <basic-input\\n        :value=\\\"d.fromOrg\\\"\\n        @input:basic=\\\"emitEvent('update:fromOrg', $event)\\\"\\n        :label=\\\"{text: $t('new.fromOrg.label'), for: $t('new.fromOrg.for')}\\\"\\n        :isTextArea=\\\"false\\\" />\\n    </div>\\n\\n    <div class=\\\"form-submit\\\">\\n      <a @click=\\\"submitForm()\\\">\\n        {{ $t('new.submit') }}\\n      </a>\\n    </div>\\n  </div>\\n</div>\\n</template>\\n\\n<script setup>\\nimport { defineProps, defineEmits, ref, computed } from 'vue';\\nimport BasicDropDown from './form/BasicDropDown.vue';\\nimport SearchInput from './form/SearchInput.vue';\\nimport SearchAutoComplete from './form/SearchAutoComplete.vue';\\nimport BasicInput from './form/BasicInput.vue';\\nimport TheMultipleBasicInput from './form/TheMultipleBasicInput.vue';\\nimport SelectWithChips from './form/SelectWithChips.vue';\\nimport TheExactMatchesInput from './form/TheExactMatchesInput.vue';\\n\\nconst vocab = window.vocab\\n\\nconst testLang = ref(window.lang);\\n\\nconst props = defineProps({\\n  d: Object,\\n  v: Object,\\n  conceptTypeIsSelected: Boolean,\\n  prefLabelOkay: Boolean,\\n  explanationOkay: Boolean,\\n  neededForOkay: Boolean,\\n  sending: Boolean\\n});\\n\\nconst emit = defineEmits();\\n\\nconst emitEvent = (eventName, payload) => {\\n  emit(eventName, payload);\\n};\\n\\nconst handleSelect = (value) => {\\n  emitEvent('update:conceptType', value)\\n  emitEvent('update:conceptTypeIsSelected', value)\\n\\n}\\nconst handlePrefLabel = (value) => {\\n  emitEvent('update:primaryPrefLabel', value)\\n  emitEvent('update:prefLabelOkay', value)\\n}\\n\\nconst handleExplanation = (value) => {\\n  emitEvent('update:explanation', value)\\n  emitEvent('update:explanationOkay', value)\\n}\\n\\nconst handleNeededFor = (value) => {\\n  emitEvent('update:neededFor', value)\\n  emitEvent('update:neededForOkay', value)\\n}\\n\\n\\nconst submitForm = () => {\\n  emit('submitForm');\\n};\\n\\ndefineExpose({\\n  emitEvent,\\n  submitForm,\\n});\\n</script>\\n\\n\\n\\n<style scoped>\\n.hidden {\\n  display: none;\\n}\\n.suggestion-header {\\n  padding-bottom: 8px;\\n  border-bottom: 1px solid #eeeeee;\\n}\\n\\n.suggestion-form {\\n  margin-top: 20px;\\n}\\n\\n.form-submit {\\n  text-align: right;\\n  padding: 20px 0;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n\\n.form-submit a {\\n  padding: 10px 15px;\\n  color: #ffffff;\\n  background-color: #3a4553;\\n  cursor: pointer;\\n  cursor: hand;\\n  transition: background-color 0.1s;\\n}\\n\\n.form-submit a:hover {\\n  background-color: #4d5764;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI3OC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3lIO0FBQzdCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxzRUFBc0Usa0JBQWtCLEdBQUcsdUNBQXVDLHdCQUF3QixxQ0FBcUMsR0FBRyxxQ0FBcUMscUJBQXFCLEdBQUcsaUNBQWlDLHNCQUFzQixvQkFBb0IsaUNBQWlDLCtDQUErQyx3Q0FBd0Msd0NBQXdDLGtEQUFrRCxHQUFHLG1DQUFtQyx1QkFBdUIsbUJBQW1CLDhCQUE4QixvQkFBb0IsaUJBQWlCLHNDQUFzQyxHQUFHLHlDQUF5Qyw4QkFBOEIsR0FBRyxTQUFTLCtGQUErRixNQUFNLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLHNCQUFzQix1QkFBdUIsdUJBQXVCLHlCQUF5QixhQUFhLE1BQU0sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSx5UUFBeVEsbUJBQW1CLHVEQUF1RCx1QkFBdUIsaUJBQWlCLGVBQWUsZ0JBQWdCLGVBQWUsNFRBQTRULGtFQUFrRSxxRkFBcUYsOEJBQThCLDJTQUEyUyxvRUFBb0Usd0VBQXdFLDRCQUE0QiwwUkFBMFIsb0VBQW9FLHFNQUFxTSxvRUFBb0UsaVdBQWlXLG9FQUFvRSx3RUFBd0UsNEJBQTRCLDBSQUEwUixvRUFBb0UsNkxBQTZMLG9FQUFvRSwwUkFBMFIsb0VBQW9FLGlUQUFpVCxvRUFBb0Usd0VBQXdFLDRCQUE0QixzU0FBc1Msb0VBQW9FLDZLQUE2Syw4REFBOEQsc1BBQXNQLHNFQUFzRSwyUkFBMlIsd0VBQXdFLHlSQUF5UixzRUFBc0UsbUVBQW1FLG1EQUFtRCxvREFBb0Qsd0NBQXdDLHdLQUF3Syx3REFBd0QsK0pBQStKLG9FQUFvRSx3SkFBd0osOERBQThELG1LQUFtSyxvRUFBb0Usb0dBQW9HLDhCQUE4QixnSUFBZ0ksOERBQThELDBHQUEwRyw0QkFBNEIsMElBQTBJLDBEQUEwRCxtSUFBbUksbUJBQW1CLG9GQUFvRiwwQ0FBMEMsV0FBVyx1REFBdUQsbURBQW1ELGlFQUFpRSxpREFBaUQsdUVBQXVFLDJEQUEyRCxxRUFBcUUsb0VBQW9FLCtCQUErQix5S0FBeUssRUFBRSwrQkFBK0IsK0NBQStDLDZCQUE2QixJQUFJLHFDQUFxQyxtR0FBbUcsc0NBQXNDLDhGQUE4RiwwQ0FBMEMsMkZBQTJGLHdDQUF3Qyx1RkFBdUYsZ0NBQWdDLHVCQUF1QixJQUFJLGtCQUFrQixnQ0FBZ0MsRUFBRSw0Q0FBNEMsa0JBQWtCLEdBQUcsc0JBQXNCLHdCQUF3QixxQ0FBcUMsR0FBRyxzQkFBc0IscUJBQXFCLEdBQUcsa0JBQWtCLHNCQUFzQixvQkFBb0IsaUNBQWlDLCtDQUErQyx3Q0FBd0Msd0NBQXdDLGtEQUFrRCxHQUFHLG9CQUFvQix1QkFBdUIsbUJBQW1CLDhCQUE4QixvQkFBb0IsaUJBQWlCLHNDQUFzQyxHQUFHLDBCQUEwQiw4QkFBOEIsR0FBRywrQkFBK0I7QUFDaHdWO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvTmV3U3VnZ2VzdGlvbi52dWU/MzMzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5oaWRkZW5bZGF0YS12LTM5Mjg4NzIxXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uc3VnZ2VzdGlvbi1oZWFkZXJbZGF0YS12LTM5Mjg4NzIxXSB7XFxuICBwYWRkaW5nLWJvdHRvbTogOHB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWVlZWU7XFxufVxcbi5zdWdnZXN0aW9uLWZvcm1bZGF0YS12LTM5Mjg4NzIxXSB7XFxuICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG4uZm9ybS1zdWJtaXRbZGF0YS12LTM5Mjg4NzIxXSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIHBhZGRpbmc6IDIwcHggMDtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG4uZm9ybS1zdWJtaXQgYVtkYXRhLXYtMzkyODg3MjFdIHtcXG4gIHBhZGRpbmc6IDEwcHggMTVweDtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNhNDU1MztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xcztcXG59XFxuLmZvcm0tc3VibWl0IGFbZGF0YS12LTM5Mjg4NzIxXTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNGQ1NzY0O1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9OZXdTdWdnZXN0aW9uLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBbVBBO0VBQ0UsYUFBYTtBQUNmO0FBQ0E7RUFDRSxtQkFBbUI7RUFDbkIsZ0NBQWdDO0FBQ2xDO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixlQUFlO0VBQ2YsMkJBQTJCLEVBQUUsZUFBZTtFQUM1Qyx5QkFBeUIsRUFBRSxXQUFXO0VBQ3RDLHNCQUFzQixFQUFFLFlBQVk7RUFDcEMscUJBQXFCLEVBQUUsMkJBQTJCO0VBQ2xELGlCQUFpQjtBQUNuQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGNBQWM7RUFDZCx5QkFBeUI7RUFDekIsZUFBZTtFQUNmLFlBQVk7RUFDWixpQ0FBaUM7QUFDbkM7QUFFQTtFQUNFLHlCQUF5QjtBQUMzQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuXFxuPGRpdiBjbGFzcz1cXFwic3VnZ2VzdGlvbi1jb250YWluZXJcXFwiPlxcbiAgPCEtLSA8YnV0dG9uIG9uY2xpY2s9XFxcIm5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxcXCI+S29waW9pIGxlaWtlcMO2eWTDpGxsZTwvYnV0dG9uPiAtLT5cXG4gIDxkaXYgY2xhc3M9XFxcInN1Z2dlc3Rpb24taGVhZGVyXFxcIj5cXG4gICAgPGg0IHYtaWY9XFxcInZvY2FiID09PSAneXNvJ1xcXCI+e3sgJHQoJ25ldy5oZWFkZXInKSB9fTwvaDQ+XFxuICAgIDxoNCB2LWVsc2UtaWY9XFxcInZvY2FiID09PSAneXNvLXBhaWthdCdcXFwiPnt7ICR0KCduZXcuaGVhZGVyLWdlbycpIH19PC9oND5cXG4gICAgPHA+e3sgJHQoJ25ldy5wMScpIH19PC9wPlxcbiAgICA8cD57eyAkdCgnbmV3LnAyJykgfX08L3A+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcInN1Z2dlc3Rpb24tZm9ybVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0taW5wdXRzXFxcIj5cXG4gICAgICA8YmFzaWMtZHJvcC1kb3duXFxuICAgICAgICA6dmFsdWU9XFxcImQuY29uY2VwdFR5cGUudmFsdWVcXFwiXFxuICAgICAgICA6b3B0aW9ucz1cXFwiZC5jb25jZXB0VHlwZS5vcHRpb25zXFxcIlxcbiAgICAgICAgQGNoYW5nZVZvY2FidWxhcnk9XFxcIiRlbWl0KCd1cGRhdGU6dm9jYWJ1bGFyeScsICRldmVudClcXFwiXFxuICAgICAgQHNlbGVjdD1cXFwiaGFuZGxlU2VsZWN0KCRldmVudClcXFwiXFxuICAgICAgICA6bGFiZWw9XFxcInt0ZXh0OiAkdCgnbmV3LmNvbmNlcHRUeXBlLmxhYmVsJyksIGZvcjogJHQoJ25ldy5jb25jZXB0VHlwZS5mb3InKX1cXFwiXFxuICAgICAgLz5cXG4gICAgICA8cCB2LWlmPVxcXCIhY29uY2VwdFR5cGVJc1NlbGVjdGVkICYmIHNlbmRpbmdcXFwiIGNsYXNzPVxcXCJlcnJvclxcXCI+e3sgJHQoJ25ldy5jb25jZXB0VHlwZS5lcnJvcicpIH19PC9wPlxcbiAgICAgIDxkaXYgdi1pZj1cXFwiJGkxOG4ubG9jYWxlID09PSAnZmknXFxcIj5cXG4gICAgICAgIDxzZWFyY2gtaW5wdXRcXG4gICAgICAgICAgOnZhbHVlPVxcXCJkLnByZWZMYWJlbC5wcmltYXJ5XFxcIlxcbiAgICAgICAgICA6Y29uY2VwdFR5cGU9XFxcImQuY29uY2VwdFR5cGUudmFsdWVcXFwiXFxuICAgICAgICAgIDp2b2NhYnVsYXJ5PVxcXCJkLnZvY2FidWxhcnlcXFwiXFxuICAgICAgICAgIDpsYW5ndWFnZT1cXFwiJ2ZpJ1xcXCJcXG4gICAgICAgICAgQGlucHV0PVxcXCJoYW5kbGVQcmVmTGFiZWwoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZmkubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5maS5mb3InKX1cXFwiIC8+XFxuICAgICAgICA8cCB2LWlmPVxcXCIhcHJlZkxhYmVsT2theSAmJiBzZW5kaW5nXFxcIiBjbGFzcz1cXFwiZXJyb3JcXFwiPnt7ICR0KCduZXcucHJlZkxhYmVsLmVycm9yJykgfX08L3A+XFxuXFxuICAgICAgICA8c2VhcmNoLWlucHV0XFxuICAgICAgICAgIDp2YWx1ZT1cXFwiZC5wcmVmTGFiZWwuc2Vjb25kYXJ5XFxcIlxcbiAgICAgICAgICA6Y29uY2VwdFR5cGU9XFxcImQuY29uY2VwdFR5cGUudmFsdWVcXFwiXFxuICAgICAgICAgIDp2b2NhYnVsYXJ5PVxcXCJkLnZvY2FidWxhcnlcXFwiXFxuICAgICAgICAgIDpsYW5ndWFnZT1cXFwiJ3N2J1xcXCJcXG4gICAgICAgICAgQGlucHV0PVxcXCJlbWl0RXZlbnQoJ3VwZGF0ZTpzZWNvbmRhcnlQcmVmTGFiZWwnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICA6bGFiZWw9XFxcInt0ZXh0OiAkdCgnbmV3LnByZWZMYWJlbC5zdi5sYWJlbCcpLCBmb3I6ICR0KCduZXcucHJlZkxhYmVsLnN2LmZvcicpfVxcXCIgLz5cXG5cXG4gICAgICAgIDwhLS1saXPDpHR0eSAyMDIzLTA5LTE4LS0+XFxuICAgICAgICA8YmFzaWMtaW5wdXRcXG4gICAgICAgICAgICA6dmFsdWU9XFxcImQucHJlZkxhYmVsLmVuXFxcIlxcbiAgICAgICAgICAgIEBpbnB1dDpiYXNpYz1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6ZW5QcmVmTGFiZWwnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmVuLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZW4uZm9yJyl9XFxcIlxcbiAgICAgICAgICAgIDppc1RleHRBcmVhPVxcXCJmYWxzZVxcXCIgLz5cXG5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IHYtaWY9XFxcIiRpMThuLmxvY2FsZSA9PT0gJ3N2J1xcXCI+XFxuICAgICAgICA8c2VhcmNoLWlucHV0XFxuICAgICAgICAgIDp2YWx1ZT1cXFwiZC5wcmVmTGFiZWwucHJpbWFyeVxcXCJcXG4gICAgICAgICAgOnZvY2FidWxhcnk9XFxcImQudm9jYWJ1bGFyeVxcXCJcXG4gICAgICAgICAgOmNvbmNlcHRUeXBlPVxcXCJkLmNvbmNlcHRUeXBlLnZhbHVlXFxcIlxcbiAgICAgICAgICA6bGFuZ3VhZ2U9XFxcIidzdidcXFwiXFxuICAgICAgICAgIEBpbnB1dD1cXFwiaGFuZGxlUHJlZkxhYmVsKCRldmVudClcXFwiXFxuICAgICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLnN2LmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuc3YuZm9yJyl9XFxcIiAvPlxcbiAgICAgICAgPHAgdi1pZj1cXFwiIXByZWZMYWJlbE9rYXkgJiYgc2VuZGluZ1xcXCIgY2xhc3M9XFxcImVycm9yXFxcIj57eyAkdCgnbmV3LnByZWZMYWJlbC5lcnJvcicpIH19PC9wPlxcblxcbiAgICAgICAgPHNlYXJjaC1pbnB1dFxcbiAgICAgICAgICA6dmFsdWU9XFxcImQucHJlZkxhYmVsLnNlY29uZGFyeVxcXCJcXG4gICAgICAgICAgOnZvY2FidWxhcnk9XFxcImQudm9jYWJ1bGFyeVxcXCJcXG4gICAgICAgICAgOmNvbmNlcHRUeXBlPVxcXCJkLmNvbmNlcHRUeXBlLnZhbHVlXFxcIlxcbiAgICAgICAgICA6bGFuZ3VhZ2U9XFxcIidmaSdcXFwiXFxuICAgICAgICAgIEBpbnB1dD1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsJywgJGV2ZW50KVxcXCJcXG4gICAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZmkubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5maS5mb3InKX1cXFwiIC8+XFxuXFxuPCEtLWxpc8OkdHR5IDIwMjMtMDktMTgtLT5cXG4gICAgICAgIDxiYXNpYy1pbnB1dFxcbiAgICAgICAgICAgIDp2YWx1ZT1cXFwiZC5wcmVmTGFiZWwuZW5cXFwiXFxuICAgICAgICAgICAgQGlucHV0OmJhc2ljPVxcXCJlbWl0RXZlbnQoJ3VwZGF0ZTplblByZWZMYWJlbCcsICRldmVudClcXFwiXFxuICAgICAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZW4ubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5lbi5mb3InKX1cXFwiXFxuICAgICAgICAgICAgOmlzVGV4dEFyZWE9XFxcImZhbHNlXFxcIiAvPlxcblxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgdi1pZj1cXFwiJGkxOG4ubG9jYWxlID09PSAnc2UnIHx8ICRpMThuLmxvY2FsZSA9PT0gJ2VuJ1xcXCI+XFxuICAgICAgICA8YmFzaWMtaW5wdXRcXG4gICAgICAgICAgICA6dmFsdWU9XFxcImQucHJlZkxhYmVsLmVuXFxcIlxcbiAgICAgICAgICAgIEBpbnB1dDpiYXNpYz1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6ZW5QcmVmTGFiZWwnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcucHJlZkxhYmVsLmVuLmxhYmVsJyksIGZvcjogJHQoJ25ldy5wcmVmTGFiZWwuZW4uZm9yJyl9XFxcIlxcbiAgICAgICAgICAgIDppc1RleHRBcmVhPVxcXCJmYWxzZVxcXCIgLz5cXG5cXG4gICAgICAgIDxzZWFyY2gtaW5wdXRcXG4gICAgICAgICAgICA6dmFsdWU9XFxcImQucHJlZkxhYmVsLnByaW1hcnlcXFwiXFxuICAgICAgICAgICAgOmNvbmNlcHRUeXBlPVxcXCJkLmNvbmNlcHRUeXBlLnZhbHVlXFxcIlxcbiAgICAgICAgICAgIDp2b2NhYnVsYXJ5PVxcXCJkLnZvY2FidWxhcnlcXFwiXFxuICAgICAgICAgICAgOmxhbmd1YWdlPVxcXCInZmknXFxcIlxcbiAgICAgICAgICAgIEBpbnB1dD1cXFwiaGFuZGxlUHJlZkxhYmVsKCRldmVudClcXFwiXFxuICAgICAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5wcmVmTGFiZWwuZmkubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnByZWZMYWJlbC5maS5mb3InKX1cXFwiIC8+XFxuICAgICAgICA8cCB2LWlmPVxcXCIhcHJlZkxhYmVsT2theSAmJiBzZW5kaW5nXFxcIiBjbGFzcz1cXFwiZXJyb3JcXFwiPnt7ICR0KCduZXcucHJlZkxhYmVsLmVycm9yJykgfX08L3A+XFxuXFxuICAgICAgICA8c2VhcmNoLWlucHV0XFxuICAgICAgICAgICAgOnZhbHVlPVxcXCJkLnByZWZMYWJlbC5zZWNvbmRhcnlcXFwiXFxuICAgICAgICAgICAgOmNvbmNlcHRUeXBlPVxcXCJkLmNvbmNlcHRUeXBlLnZhbHVlXFxcIlxcbiAgICAgICAgICAgIDp2b2NhYnVsYXJ5PVxcXCJkLnZvY2FidWxhcnlcXFwiXFxuICAgICAgICAgICAgOmxhbmd1YWdlPVxcXCInc3YnXFxcIlxcbiAgICAgICAgICAgIEBpbnB1dD1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsJywgJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICA6bGFiZWw9XFxcInt0ZXh0OiAkdCgnbmV3LnByZWZMYWJlbC5zdi5sYWJlbCcpLCBmb3I6ICR0KCduZXcucHJlZkxhYmVsLnN2LmZvcicpfVxcXCIgLz5cXG5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8dGhlLW11bHRpcGxlLWJhc2ljLWlucHV0XFxuICAgICAgICA6dmFsdWVzPVxcXCJkLmFsdExhYmVsc1xcXCJcXG4gICAgICAgIEBpbnB1dC1tdWx0aT1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6YWx0TGFiZWxzJywgJGV2ZW50KVxcXCJcXG4gICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcuYWx0TGFiZWxzLmxhYmVsJyksIGZvcjogJHQoJ25ldy5hbHRMYWJlbHMuZm9yJyl9XFxcIiAvPlxcblxcbiAgICAgIDxzZWFyY2gtYXV0by1jb21wbGV0ZVxcbiAgICAgICAgOnZhbHVlcz1cXFwiZC5icm9hZGVyTGFiZWxzXFxcIlxcbiAgICAgICAgOnZvY2FidWxhcnk9XFxcImQudm9jYWJ1bGFyeVxcXCJcXG4gICAgICAgIDpsYW5ndWFnZT1cXFwiJGkxOG4ubG9jYWxlXFxcIlxcbiAgICAgICAgQHVwZGF0ZTpzZWxlY3RlZE9wdGlvbnM9XFxcImVtaXRFdmVudCgndXBkYXRlOmJyb2FkZXJMYWJlbHMnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5icm9hZGVyTGFiZWxzLmxhYmVsJyksIGZvcjogJHQoJ25ldy5icm9hZGVyTGFiZWxzLmZvcicpfVxcXCJcXG4gICAgICAgIDpoYXNVbmlxdWVWYWx1ZT1cXFwiZmFsc2VcXFwiIC8+XFxuXFxuICAgICAgPHNlYXJjaC1hdXRvLWNvbXBsZXRlXFxuICAgICAgICA6dmFsdWVzPVxcXCJkLm5hcnJvd2VyTGFiZWxzXFxcIlxcbiAgICAgICAgOnZvY2FidWxhcnk9XFxcImQudm9jYWJ1bGFyeVxcXCJcXG4gICAgICAgIDpsYW5ndWFnZT1cXFwiJGkxOG4ubG9jYWxlXFxcIlxcbiAgICAgICAgQHVwZGF0ZTpzZWxlY3RlZE9wdGlvbnM9XFxcImVtaXRFdmVudCgndXBkYXRlOm5hcnJvd2VyTGFiZWxzJywgJGV2ZW50KVxcXCJcXG4gICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcubmFycm93ZXJMYWJlbHMubGFiZWwnKSwgZm9yOiAkdCgnbmV3Lm5hcnJvd2VyTGFiZWxzLmZvcicpfVxcXCJcXG4gICAgICAgIDpoYXNVbmlxdWVWYWx1ZT1cXFwiZmFsc2VcXFwiIC8+XFxuXFxuICAgICAgPHNlYXJjaC1hdXRvLWNvbXBsZXRlXFxuICAgICAgICA6dmFsdWVzPVxcXCJkLnJlbGF0ZWRMYWJlbHNcXFwiXFxuICAgICAgICA6dm9jYWJ1bGFyeT1cXFwiZC52b2NhYnVsYXJ5XFxcIlxcbiAgICAgICAgOmxhbmd1YWdlPVxcXCIkaTE4bi5sb2NhbGVcXFwiXFxuICAgICAgICBAdXBkYXRlOnNlbGVjdGVkT3B0aW9ucz1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6cmVsYXRlZExhYmVscycsICRldmVudClcXFwiXFxuICAgICAgICA6bGFiZWw9XFxcInt0ZXh0OiAkdCgnbmV3LnJlbGF0ZWRMYWJlbHMubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnJlbGF0ZWRMYWJlbHMuZm9yJyl9XFxcIlxcbiAgICAgICAgOmhhc1VuaXF1ZVZhbHVlPVxcXCJmYWxzZVxcXCIgLz5cXG5cXG4gICAgICAgIDwhLS0gOmNsYXNzPVxcXCJ7J2hpZGRlbic6IGQudm9jYWJ1bGFyeSA9PT0gJHQoJ25ldy5jb21tb24ucGxhY2VzJyl9XFxcIiAtLT5cXG4gICAgICA8c2VsZWN0LXdpdGgtY2hpcHNcXG4gICAgICAgIDpjbGFzcz1cXFwieydoaWRkZW4nOiBkLnZvY2FidWxhcnkgPT09ICd5c28tcGFpa2F0J31cXFwiXFxuICAgICAgICA6dmFsdWU9XFxcIiR0KCduZXcuZ3JvdXBzLnBsYWNlaG9sZGVyJylcXFwiXFxuICAgICAgICA6b3B0aW9ucz1cXFwiZC5ncm91cHMuYWxsR3JvdXBzXFxcIlxcbiAgICAgICAgQHNlbGVjdD1cXFwiZW1pdEV2ZW50KCd1cGRhdGU6Z3JvdXBzJywgJGV2ZW50KVxcXCJcXG4gICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcuZ3JvdXBzLmxhYmVsJyksIGZvcjogJHQoJ25ldy5ncm91cHMuZm9yJyl9XFxcIiAvPlxcblxcbiAgICAgIDx0aGUtZXhhY3QtbWF0Y2hlcy1pbnB1dFxcbiAgICAgICAgOnZhbHVlcz1cXFwiZC5leGFjdE1hdGNoZXNcXFwiXFxuICAgICAgICBAaW5wdXRleG09XFxcImVtaXRFdmVudCgndXBkYXRlOmV4YWN0TWF0Y2hlcycsICRldmVudClcXFwiXFxuICAgICAgICA6bGFiZWw9XFxcInt0ZXh0OiAkdCgnbmV3LmV4YWN0TWF0Y2hlcy5sYWJlbCcpLCBmb3I6ICR0KCduZXcuZXhhY3RNYXRjaGVzLmZvcicpfVxcXCJcXG4gICAgICAgIC8+XFxuXFxuICAgICAgPGJhc2ljLWlucHV0XFxuICAgICAgICA6dmFsdWU9XFxcImQuc2NvcGVOb3RlXFxcIlxcbiAgICAgICAgQGlucHV0OmJhc2ljPVxcXCJlbWl0RXZlbnQoJ3VwZGF0ZTpzY29wZU5vdGUnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5zY29wZU5vdGUubGFiZWwnKSwgZm9yOiAkdCgnbmV3LnNjb3BlTm90ZS5mb3InKX1cXFwiXFxuICAgICAgICA6aXNUZXh0QXJlYT1cXFwidHJ1ZVxcXCIgLz5cXG5cXG4gICAgICA8YmFzaWMtaW5wdXRcXG4gICAgICAgIDp2YWx1ZT1cXFwiZC5leHBsYW5hdGlvblxcXCJcXG4gICAgICAgIEBpbnB1dDpiYXNpYz1cXFwiaGFuZGxlRXhwbGFuYXRpb24oJGV2ZW50KVxcXCJcXG4gICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcuZXhwbGFuYXRpb24ubGFiZWwnKSwgZm9yOiAkdCgnbmV3LmV4cGxhbmF0aW9uLmxhYmVsJyl9XFxcIlxcbiAgICAgIDppc1RleHRBcmVhPVxcXCJ0cnVlXFxcIiAvPlxcbiAgICAgIDxwIHYtaWY9XFxcIiFleHBsYW5hdGlvbk9rYXkgJiYgc2VuZGluZ1xcXCIgY2xhc3M9XFxcImVycm9yXFxcIj57eyAkdCgnbmV3LmV4cGxhbmF0aW9uLmVycm9yJykgfX08L3A+XFxuXFxuICAgICAgPGJhc2ljLWlucHV0XFxuICAgICAgICA6dmFsdWU9XFxcImQubmVlZGVkRm9yXFxcIlxcbiAgICAgICAgQGlucHV0OmJhc2ljPVxcXCJoYW5kbGVOZWVkZWRGb3IoJGV2ZW50KVxcXCJcXG4gICAgICAgIDpsYWJlbD1cXFwie3RleHQ6ICR0KCduZXcubmVlZGVkRm9yLmxhYmVsJyksIGZvcjogJHQoJ25ldy5uZWVkZWRGb3IuZm9yJyl9XFxcIlxcbiAgICAgICAgOmlzVGV4dEFyZWE9XFxcInRydWVcXFwiIC8+XFxuICAgICAgICAgICAgPHAgdi1pZj1cXFwiIW5lZWRlZEZvck9rYXkgJiYgc2VuZGluZ1xcXCIgY2xhc3M9XFxcImVycm9yXFxcIj57eyAkdCgnbmV3Lm5lZWRlZEZvci5lcnJvcicpIH19PC9wPlxcblxcbiAgICAgIDxiYXNpYy1pbnB1dFxcbiAgICAgICAgOnZhbHVlPVxcXCJkLmZyb21PcmdcXFwiXFxuICAgICAgICBAaW5wdXQ6YmFzaWM9XFxcImVtaXRFdmVudCgndXBkYXRlOmZyb21PcmcnLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgOmxhYmVsPVxcXCJ7dGV4dDogJHQoJ25ldy5mcm9tT3JnLmxhYmVsJyksIGZvcjogJHQoJ25ldy5mcm9tT3JnLmZvcicpfVxcXCJcXG4gICAgICAgIDppc1RleHRBcmVhPVxcXCJmYWxzZVxcXCIgLz5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImZvcm0tc3VibWl0XFxcIj5cXG4gICAgICA8YSBAY2xpY2s9XFxcInN1Ym1pdEZvcm0oKVxcXCI+XFxuICAgICAgICB7eyAkdCgnbmV3LnN1Ym1pdCcpIH19XFxuICAgICAgPC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdCBzZXR1cD5cXG5pbXBvcnQgeyBkZWZpbmVQcm9wcywgZGVmaW5lRW1pdHMsIHJlZiwgY29tcHV0ZWQgfSBmcm9tICd2dWUnO1xcbmltcG9ydCBCYXNpY0Ryb3BEb3duIGZyb20gJy4vZm9ybS9CYXNpY0Ryb3BEb3duLnZ1ZSc7XFxuaW1wb3J0IFNlYXJjaElucHV0IGZyb20gJy4vZm9ybS9TZWFyY2hJbnB1dC52dWUnO1xcbmltcG9ydCBTZWFyY2hBdXRvQ29tcGxldGUgZnJvbSAnLi9mb3JtL1NlYXJjaEF1dG9Db21wbGV0ZS52dWUnO1xcbmltcG9ydCBCYXNpY0lucHV0IGZyb20gJy4vZm9ybS9CYXNpY0lucHV0LnZ1ZSc7XFxuaW1wb3J0IFRoZU11bHRpcGxlQmFzaWNJbnB1dCBmcm9tICcuL2Zvcm0vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZSc7XFxuaW1wb3J0IFNlbGVjdFdpdGhDaGlwcyBmcm9tICcuL2Zvcm0vU2VsZWN0V2l0aENoaXBzLnZ1ZSc7XFxuaW1wb3J0IFRoZUV4YWN0TWF0Y2hlc0lucHV0IGZyb20gJy4vZm9ybS9UaGVFeGFjdE1hdGNoZXNJbnB1dC52dWUnO1xcblxcbmNvbnN0IHZvY2FiID0gd2luZG93LnZvY2FiXFxuXFxuY29uc3QgdGVzdExhbmcgPSByZWYod2luZG93LmxhbmcpO1xcblxcbmNvbnN0IHByb3BzID0gZGVmaW5lUHJvcHMoe1xcbiAgZDogT2JqZWN0LFxcbiAgdjogT2JqZWN0LFxcbiAgY29uY2VwdFR5cGVJc1NlbGVjdGVkOiBCb29sZWFuLFxcbiAgcHJlZkxhYmVsT2theTogQm9vbGVhbixcXG4gIGV4cGxhbmF0aW9uT2theTogQm9vbGVhbixcXG4gIG5lZWRlZEZvck9rYXk6IEJvb2xlYW4sXFxuICBzZW5kaW5nOiBCb29sZWFuXFxufSk7XFxuXFxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKCk7XFxuXFxuY29uc3QgZW1pdEV2ZW50ID0gKGV2ZW50TmFtZSwgcGF5bG9hZCkgPT4ge1xcbiAgZW1pdChldmVudE5hbWUsIHBheWxvYWQpO1xcbn07XFxuXFxuY29uc3QgaGFuZGxlU2VsZWN0ID0gKHZhbHVlKSA9PiB7XFxuICBlbWl0RXZlbnQoJ3VwZGF0ZTpjb25jZXB0VHlwZScsIHZhbHVlKVxcbiAgZW1pdEV2ZW50KCd1cGRhdGU6Y29uY2VwdFR5cGVJc1NlbGVjdGVkJywgdmFsdWUpXFxuXFxufVxcbmNvbnN0IGhhbmRsZVByZWZMYWJlbCA9ICh2YWx1ZSkgPT4ge1xcbiAgZW1pdEV2ZW50KCd1cGRhdGU6cHJpbWFyeVByZWZMYWJlbCcsIHZhbHVlKVxcbiAgZW1pdEV2ZW50KCd1cGRhdGU6cHJlZkxhYmVsT2theScsIHZhbHVlKVxcbn1cXG5cXG5jb25zdCBoYW5kbGVFeHBsYW5hdGlvbiA9ICh2YWx1ZSkgPT4ge1xcbiAgZW1pdEV2ZW50KCd1cGRhdGU6ZXhwbGFuYXRpb24nLCB2YWx1ZSlcXG4gIGVtaXRFdmVudCgndXBkYXRlOmV4cGxhbmF0aW9uT2theScsIHZhbHVlKVxcbn1cXG5cXG5jb25zdCBoYW5kbGVOZWVkZWRGb3IgPSAodmFsdWUpID0+IHtcXG4gIGVtaXRFdmVudCgndXBkYXRlOm5lZWRlZEZvcicsIHZhbHVlKVxcbiAgZW1pdEV2ZW50KCd1cGRhdGU6bmVlZGVkRm9yT2theScsIHZhbHVlKVxcbn1cXG5cXG5cXG5jb25zdCBzdWJtaXRGb3JtID0gKCkgPT4ge1xcbiAgZW1pdCgnc3VibWl0Rm9ybScpO1xcbn07XFxuXFxuZGVmaW5lRXhwb3NlKHtcXG4gIGVtaXRFdmVudCxcXG4gIHN1Ym1pdEZvcm0sXFxufSk7XFxuPC9zY3JpcHQ+XFxuXFxuXFxuXFxuPHN0eWxlIHNjb3BlZD5cXG4uaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5zdWdnZXN0aW9uLWhlYWRlciB7XFxuICBwYWRkaW5nLWJvdHRvbTogOHB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWVlZWU7XFxufVxcblxcbi5zdWdnZXN0aW9uLWZvcm0ge1xcbiAgbWFyZ2luLXRvcDogMjBweDtcXG59XFxuXFxuLmZvcm0tc3VibWl0IHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgcGFkZGluZzogMjBweCAwO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5mb3JtLXN1Ym1pdCBhIHtcXG4gIHBhZGRpbmc6IDEwcHggMTVweDtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNhNDU1MztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4xcztcXG59XFxuXFxuLmZvcm0tc3VibWl0IGE6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzRkNTc2NDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9278\n");

/***/ }),

/***/ 8533:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n::placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n}\\n:-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n}\\n::-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/SuggestChangeButton.vue\"],\"names\":[],\"mappings\":\";AA4ME;IACE,cAAc;IACd,UAAU;AACZ;AAEA;IACE,cAAc;IACd,UAAU;AACZ;AAEA;IACE,cAAc;IACd,UAAU;AACZ\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <a role=\\\"button\\\" @click=\\\"isOpened = !isOpened\\\" id=\\\"fordirectmodify\\\" :href=\\\"`${pageUrl.split('#')[0]}#suggestion`\\\">\\n      <span>{{ $t('edit.button') }}</span>\\n    </a>\\n    <centered-dialog v-if=\\\"isOpened\\\" @close=\\\"closeDialog()\\\">\\n      <edit-suggestion\\n          v-if=\\\"!showSuccessMessage && !showFailureMessage\\\"\\n          :d=\\\"formData\\\"\\n          :label=\\\"labelX\\\"\\n          :uri=\\\"uriX\\\"\\n          @update:conceptType=\\\"formData.conceptType.value = $event\\\"\\n          @update:primaryPrefLabel=\\\"formData.prefLabel.primary = $event\\\"\\n          @update:description=\\\"formData.description = $event\\\"\\n          @update:reason=\\\"formData.reason = $event\\\"\\n          @update:fromOrg=\\\"formData.fromOrg = $event\\\"\\n          @submitForm=\\\"submitForm\\\"\\n      />\\n      <success-message v-if=\\\"showSuccessMessage\\\" :suggestionUrl=\\\"suggestionUrl\\\" :url=\\\"url\\\" />\\n      <failure-message v-if=\\\"showFailureMessage\\\" />\\n    </centered-dialog>\\n  </div>\\n</template>\\n\\n<script>\\nimport EditSuggestion from './EditSuggestion.vue';\\nimport CenteredDialog from './common/CenteredDialog.vue';\\nimport SuccessMessage from './common/SuccessMessage.vue';\\nimport FailureMessage from './common/FailureMessage.vue';\\nimport { required } from 'vuelidate';\\nimport axios from 'axios';\\nimport { defineComponent, ref, reactive, watchEffect, inject, watch } from 'vue';\\n\\nexport default {\\n  components: {\\n    EditSuggestion,\\n    CenteredDialog,\\n    SuccessMessage,\\n    FailureMessage,\\n  },\\n  props: {\\n    lang: String,\\n    vocab: String,\\n    label: String,\\n    uri: String,\\n    url: String,\\n    moikkelis: String,\\n  },\\n  setup(props) {\\n    const testi = inject('testi')\\n    const labelX = inject('labelX', null);\\n    const uriX = inject('uriX', null);\\n    const pageUrlX = inject('pageUrlX', null);\\n    const $t = inject('$t');\\n    let pageUrl = ref(pageUrlX);\\n    // console.log('pageUrl at refs', pageUrl)\\n    const isOpened = ref(false);\\n    const showSuccessMessage = ref(false);\\n    const showFailureMessage = ref(false);\\n    const suggestionUrl = ref('');\\n    const formData = reactive({\\n      description: '',\\n      reason: '',\\n      fromOrg: '',\\n    });\\n\\n    const getUrl = async () => {\\n      pageUrl.value = window.location.href;\\n    };\\n\\n    const submitForm = () => {\\n      if (true) {\\n        sendData();\\n      } else {\\n        console.log('Data not sent: required data of the form was not provided.');\\n      }\\n    };\\n\\n    const sendData = async () => {\\n      let data = `\\n**Käsitteen tyyppi**\\n\\nMuutos olemassa olevaan käsitteeseen\\n\\n**prefabel**\\n\\n[${labelX}](${uriX})\\n\\n**Tila**\\n\\nKäsittelyssä\\n\\n**Ehdotettu muutos**\\n\\n${formData.description}\\n\\n**Perustelut ehdotukselle**\\n\\n${formData.reason}\\n\\n**Ehdottajan organisaatio**\\n\\n${formData.fromOrg}\\n`;\\n\\n      let dataBundle = {\\n        title: labelX,\\n        body: data,\\n        state: 'open',\\n        labels: ['muutos'],\\n      };\\n\\n      const payload = encodeURIComponent(JSON.stringify(dataBundle));\\n\\n      var urlToPrx = require('../prx.json');\\n      await axios\\n          .post(`${urlToPrx[0].url}?payload=${payload}`)\\n          .then((response) => {\\n            toggleSuccessMessage(`${response.data.url.replace('/repos', '').replace('api.', '')}`);\\n          })\\n          .catch((error) => {\\n            toggleFailureMessage();\\n          });\\n    };\\n\\n    const toggleSuccessMessage = (responseUrl) => {\\n      if (responseUrl && responseUrl.length > 0) {\\n        suggestionUrl.value = responseUrl;\\n        showSuccessMessage.value = true;\\n      }\\n      showSuccessMessage.value = true;\\n    };\\n\\n    const toggleFailureMessage = () => {\\n      showFailureMessage.value = true;\\n    };\\n\\n    const handlePrefLabelLanguages = () => {\\n      if (lang === 'sv') {\\n        return {\\n          sv: {\\n            value: labelX,\\n            uri: uriX,\\n          },\\n          en: '',\\n          fi: {\\n            value: '',\\n            uri: '',\\n          },\\n        };\\n      }\\n      return {\\n        fi: {\\n          value: labelX,\\n          uri: uriX,\\n        },\\n        en: '',\\n        sv: {\\n          value: '',\\n          uri: '',\\n        },\\n      };\\n    };\\n\\n    const closeDialog = () => {\\n      isOpened.value = !isOpened.value;\\n      showSuccessMessage.value = false;\\n      showFailureMessage.value = false;\\n      suggestionUrl.value = '';\\n      // $v.formData.$reset();\\n      formData.description = '';\\n      formData.reason = '';\\n      formData.fromOrg = '';\\n    };\\n\\n    return {\\n      pageUrl,\\n      pageUrlX,\\n      isOpened,\\n      showSuccessMessage,\\n      showFailureMessage,\\n      suggestionUrl,\\n      formData,\\n      getUrl,\\n      submitForm,\\n      toggleFailureMessage,\\n      handlePrefLabelLanguages,\\n      closeDialog,\\n      labelX,\\n      testi\\n    };\\n  },\\n  validations() {\\n    return {\\n      formData: {\\n        description: { required },\\n        reason: { required },\\n      },\\n    };\\n  },\\n};\\n</script>\\n\\n<style>\\n  ::placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n\\n  :-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n\\n  ::-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n</style>\\n\\n<style scoped>\\n  a {\\n    cursor: pointer;\\n    cursor: hand;\\n  }\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUzMy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3lIO0FBQzdCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSwyREFBMkQscUJBQXFCLGlCQUFpQixHQUFHLDBCQUEwQixxQkFBcUIsaUJBQWlCLEdBQUcsMkJBQTJCLHFCQUFxQixpQkFBaUIsR0FBRyxTQUFTLHFHQUFxRyxNQUFNLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsdUlBQXVJLHNCQUFzQixnQ0FBZ0Msb0JBQW9CLDAzQkFBMDNCLDJEQUEyRCwyREFBMkQsMkRBQTJELFdBQVcsV0FBVyxpQkFBaUIsNEJBQTRCLFdBQVcsNkRBQTZELFdBQVcsb0JBQW9CLGlCQUFpQix5RkFBeUYsYUFBYSw0SEFBNEgsbUJBQW1CLCtFQUErRSx3Q0FBd0MsZ0RBQWdELDhCQUE4QixrQ0FBa0Msa0ZBQWtGLDRDQUE0Qyw0Q0FBNEMsb0NBQW9DLGlDQUFpQyxzRUFBc0UsRUFBRSxvQ0FBb0MsNkNBQTZDLFFBQVEsa0NBQWtDLG1CQUFtQixxQkFBcUIsVUFBVSxNQUFNLG9GQUFvRixTQUFTLFFBQVEsc0NBQXNDLHlHQUF5RyxPQUFPLElBQUksS0FBSywyREFBMkQscUJBQXFCLHFDQUFxQyxnQkFBZ0IscUNBQXFDLGlCQUFpQixJQUFJLDRCQUE0Qiw0R0FBNEcseUVBQXlFLGdEQUFnRCx3Q0FBd0MsZ0JBQWdCLFdBQVcsUUFBUSxtQ0FBbUMsc0NBQXNDLDREQUE0RCxHQUFHLGFBQWEsZ0NBQWdDLHFDQUFxQyxhQUFhLEVBQUUsUUFBUSx1REFBdUQsb0RBQW9ELDRDQUE0QywwQ0FBMEMsU0FBUyx3Q0FBd0MsUUFBUSw0Q0FBNEMsd0NBQXdDLFFBQVEsZ0RBQWdELDRCQUE0QixrQkFBa0IsaUJBQWlCLGlFQUFpRSxxQ0FBcUMsMkRBQTJELGFBQWEsU0FBUyxnQkFBZ0IsZUFBZSwyREFBMkQsaUNBQWlDLHFEQUFxRCxXQUFXLFFBQVEsbUNBQW1DLHlDQUF5Qyx5Q0FBeUMseUNBQXlDLGlDQUFpQyxnQ0FBZ0Msa0NBQWtDLDZCQUE2Qiw4QkFBOEIsUUFBUSxnQkFBZ0IsdVNBQXVTLEtBQUssb0JBQW9CLGNBQWMsbUJBQW1CLHlCQUF5QixVQUFVLHFCQUFxQixVQUFVLFVBQVUsU0FBUyxLQUFLLEtBQUsseUNBQXlDLHFCQUFxQixpQkFBaUIsS0FBSyw4QkFBOEIscUJBQXFCLGlCQUFpQixLQUFLLCtCQUErQixxQkFBcUIsaUJBQWlCLEtBQUssbUNBQW1DLHNCQUFzQixtQkFBbUIsS0FBSywrQkFBK0I7QUFDdHRMO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/MjIxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbjo6cGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogIzVlYThCNztcXG4gICAgb3BhY2l0eTogMTtcXG59XFxuOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjNWVhOEI3O1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG46Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjNWVhOEI3O1xcbiAgICBvcGFjaXR5OiAxO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBNE1FO0lBQ0UsY0FBYztJQUNkLFVBQVU7QUFDWjtBQUVBO0lBQ0UsY0FBYztJQUNkLFVBQVU7QUFDWjtBQUVBO0lBQ0UsY0FBYztJQUNkLFVBQVU7QUFDWlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgICA8YSByb2xlPVxcXCJidXR0b25cXFwiIEBjbGljaz1cXFwiaXNPcGVuZWQgPSAhaXNPcGVuZWRcXFwiIGlkPVxcXCJmb3JkaXJlY3Rtb2RpZnlcXFwiIDpocmVmPVxcXCJgJHtwYWdlVXJsLnNwbGl0KCcjJylbMF19I3N1Z2dlc3Rpb25gXFxcIj5cXG4gICAgICA8c3Bhbj57eyAkdCgnZWRpdC5idXR0b24nKSB9fTwvc3Bhbj5cXG4gICAgPC9hPlxcbiAgICA8Y2VudGVyZWQtZGlhbG9nIHYtaWY9XFxcImlzT3BlbmVkXFxcIiBAY2xvc2U9XFxcImNsb3NlRGlhbG9nKClcXFwiPlxcbiAgICAgIDxlZGl0LXN1Z2dlc3Rpb25cXG4gICAgICAgICAgdi1pZj1cXFwiIXNob3dTdWNjZXNzTWVzc2FnZSAmJiAhc2hvd0ZhaWx1cmVNZXNzYWdlXFxcIlxcbiAgICAgICAgICA6ZD1cXFwiZm9ybURhdGFcXFwiXFxuICAgICAgICAgIDpsYWJlbD1cXFwibGFiZWxYXFxcIlxcbiAgICAgICAgICA6dXJpPVxcXCJ1cmlYXFxcIlxcbiAgICAgICAgICBAdXBkYXRlOmNvbmNlcHRUeXBlPVxcXCJmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZSA9ICRldmVudFxcXCJcXG4gICAgICAgICAgQHVwZGF0ZTpwcmltYXJ5UHJlZkxhYmVsPVxcXCJmb3JtRGF0YS5wcmVmTGFiZWwucHJpbWFyeSA9ICRldmVudFxcXCJcXG4gICAgICAgICAgQHVwZGF0ZTpkZXNjcmlwdGlvbj1cXFwiZm9ybURhdGEuZGVzY3JpcHRpb24gPSAkZXZlbnRcXFwiXFxuICAgICAgICAgIEB1cGRhdGU6cmVhc29uPVxcXCJmb3JtRGF0YS5yZWFzb24gPSAkZXZlbnRcXFwiXFxuICAgICAgICAgIEB1cGRhdGU6ZnJvbU9yZz1cXFwiZm9ybURhdGEuZnJvbU9yZyA9ICRldmVudFxcXCJcXG4gICAgICAgICAgQHN1Ym1pdEZvcm09XFxcInN1Ym1pdEZvcm1cXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3VjY2Vzcy1tZXNzYWdlIHYtaWY9XFxcInNob3dTdWNjZXNzTWVzc2FnZVxcXCIgOnN1Z2dlc3Rpb25Vcmw9XFxcInN1Z2dlc3Rpb25VcmxcXFwiIDp1cmw9XFxcInVybFxcXCIgLz5cXG4gICAgICA8ZmFpbHVyZS1tZXNzYWdlIHYtaWY9XFxcInNob3dGYWlsdXJlTWVzc2FnZVxcXCIgLz5cXG4gICAgPC9jZW50ZXJlZC1kaWFsb2c+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuaW1wb3J0IEVkaXRTdWdnZXN0aW9uIGZyb20gJy4vRWRpdFN1Z2dlc3Rpb24udnVlJztcXG5pbXBvcnQgQ2VudGVyZWREaWFsb2cgZnJvbSAnLi9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlJztcXG5pbXBvcnQgU3VjY2Vzc01lc3NhZ2UgZnJvbSAnLi9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlJztcXG5pbXBvcnQgRmFpbHVyZU1lc3NhZ2UgZnJvbSAnLi9jb21tb24vRmFpbHVyZU1lc3NhZ2UudnVlJztcXG5pbXBvcnQgeyByZXF1aXJlZCB9IGZyb20gJ3Z1ZWxpZGF0ZSc7XFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXG5pbXBvcnQgeyBkZWZpbmVDb21wb25lbnQsIHJlZiwgcmVhY3RpdmUsIHdhdGNoRWZmZWN0LCBpbmplY3QsIHdhdGNoIH0gZnJvbSAndnVlJztcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIEVkaXRTdWdnZXN0aW9uLFxcbiAgICBDZW50ZXJlZERpYWxvZyxcXG4gICAgU3VjY2Vzc01lc3NhZ2UsXFxuICAgIEZhaWx1cmVNZXNzYWdlLFxcbiAgfSxcXG4gIHByb3BzOiB7XFxuICAgIGxhbmc6IFN0cmluZyxcXG4gICAgdm9jYWI6IFN0cmluZyxcXG4gICAgbGFiZWw6IFN0cmluZyxcXG4gICAgdXJpOiBTdHJpbmcsXFxuICAgIHVybDogU3RyaW5nLFxcbiAgICBtb2lra2VsaXM6IFN0cmluZyxcXG4gIH0sXFxuICBzZXR1cChwcm9wcykge1xcbiAgICBjb25zdCB0ZXN0aSA9IGluamVjdCgndGVzdGknKVxcbiAgICBjb25zdCBsYWJlbFggPSBpbmplY3QoJ2xhYmVsWCcsIG51bGwpO1xcbiAgICBjb25zdCB1cmlYID0gaW5qZWN0KCd1cmlYJywgbnVsbCk7XFxuICAgIGNvbnN0IHBhZ2VVcmxYID0gaW5qZWN0KCdwYWdlVXJsWCcsIG51bGwpO1xcbiAgICBjb25zdCAkdCA9IGluamVjdCgnJHQnKTtcXG4gICAgbGV0IHBhZ2VVcmwgPSByZWYocGFnZVVybFgpO1xcbiAgICAvLyBjb25zb2xlLmxvZygncGFnZVVybCBhdCByZWZzJywgcGFnZVVybClcXG4gICAgY29uc3QgaXNPcGVuZWQgPSByZWYoZmFsc2UpO1xcbiAgICBjb25zdCBzaG93U3VjY2Vzc01lc3NhZ2UgPSByZWYoZmFsc2UpO1xcbiAgICBjb25zdCBzaG93RmFpbHVyZU1lc3NhZ2UgPSByZWYoZmFsc2UpO1xcbiAgICBjb25zdCBzdWdnZXN0aW9uVXJsID0gcmVmKCcnKTtcXG4gICAgY29uc3QgZm9ybURhdGEgPSByZWFjdGl2ZSh7XFxuICAgICAgZGVzY3JpcHRpb246ICcnLFxcbiAgICAgIHJlYXNvbjogJycsXFxuICAgICAgZnJvbU9yZzogJycsXFxuICAgIH0pO1xcblxcbiAgICBjb25zdCBnZXRVcmwgPSBhc3luYyAoKSA9PiB7XFxuICAgICAgcGFnZVVybC52YWx1ZSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBzdWJtaXRGb3JtID0gKCkgPT4ge1xcbiAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICBzZW5kRGF0YSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zb2xlLmxvZygnRGF0YSBub3Qgc2VudDogcmVxdWlyZWQgZGF0YSBvZiB0aGUgZm9ybSB3YXMgbm90IHByb3ZpZGVkLicpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgY29uc3Qgc2VuZERhdGEgPSBhc3luYyAoKSA9PiB7XFxuICAgICAgbGV0IGRhdGEgPSBgXFxuKipLw6RzaXR0ZWVuIHR5eXBwaSoqXFxuXFxuTXV1dG9zIG9sZW1hc3NhIG9sZXZhYW4ga8Okc2l0dGVlc2VlblxcblxcbioqcHJlZmFiZWwqKlxcblxcblske2xhYmVsWH1dKCR7dXJpWH0pXFxuXFxuKipUaWxhKipcXG5cXG5Lw6RzaXR0ZWx5c3PDpFxcblxcbioqRWhkb3RldHR1IG11dXRvcyoqXFxuXFxuJHtmb3JtRGF0YS5kZXNjcmlwdGlvbn1cXG5cXG4qKlBlcnVzdGVsdXQgZWhkb3R1a3NlbGxlKipcXG5cXG4ke2Zvcm1EYXRhLnJlYXNvbn1cXG5cXG4qKkVoZG90dGFqYW4gb3JnYW5pc2FhdGlvKipcXG5cXG4ke2Zvcm1EYXRhLmZyb21Pcmd9XFxuYDtcXG5cXG4gICAgICBsZXQgZGF0YUJ1bmRsZSA9IHtcXG4gICAgICAgIHRpdGxlOiBsYWJlbFgsXFxuICAgICAgICBib2R5OiBkYXRhLFxcbiAgICAgICAgc3RhdGU6ICdvcGVuJyxcXG4gICAgICAgIGxhYmVsczogWydtdXV0b3MnXSxcXG4gICAgICB9O1xcblxcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZGF0YUJ1bmRsZSkpO1xcblxcbiAgICAgIHZhciB1cmxUb1ByeCA9IHJlcXVpcmUoJy4uL3ByeC5qc29uJyk7XFxuICAgICAgYXdhaXQgYXhpb3NcXG4gICAgICAgICAgLnBvc3QoYCR7dXJsVG9QcnhbMF0udXJsfT9wYXlsb2FkPSR7cGF5bG9hZH1gKVxcbiAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcXG4gICAgICAgICAgICB0b2dnbGVTdWNjZXNzTWVzc2FnZShgJHtyZXNwb25zZS5kYXRhLnVybC5yZXBsYWNlKCcvcmVwb3MnLCAnJykucmVwbGFjZSgnYXBpLicsICcnKX1gKTtcXG4gICAgICAgICAgfSlcXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xcbiAgICAgICAgICAgIHRvZ2dsZUZhaWx1cmVNZXNzYWdlKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCB0b2dnbGVTdWNjZXNzTWVzc2FnZSA9IChyZXNwb25zZVVybCkgPT4ge1xcbiAgICAgIGlmIChyZXNwb25zZVVybCAmJiByZXNwb25zZVVybC5sZW5ndGggPiAwKSB7XFxuICAgICAgICBzdWdnZXN0aW9uVXJsLnZhbHVlID0gcmVzcG9uc2VVcmw7XFxuICAgICAgICBzaG93U3VjY2Vzc01lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBzaG93U3VjY2Vzc01lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCB0b2dnbGVGYWlsdXJlTWVzc2FnZSA9ICgpID0+IHtcXG4gICAgICBzaG93RmFpbHVyZU1lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBoYW5kbGVQcmVmTGFiZWxMYW5ndWFnZXMgPSAoKSA9PiB7XFxuICAgICAgaWYgKGxhbmcgPT09ICdzdicpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHN2OiB7XFxuICAgICAgICAgICAgdmFsdWU6IGxhYmVsWCxcXG4gICAgICAgICAgICB1cmk6IHVyaVgsXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGVuOiAnJyxcXG4gICAgICAgICAgZmk6IHtcXG4gICAgICAgICAgICB2YWx1ZTogJycsXFxuICAgICAgICAgICAgdXJpOiAnJyxcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBmaToge1xcbiAgICAgICAgICB2YWx1ZTogbGFiZWxYLFxcbiAgICAgICAgICB1cmk6IHVyaVgsXFxuICAgICAgICB9LFxcbiAgICAgICAgZW46ICcnLFxcbiAgICAgICAgc3Y6IHtcXG4gICAgICAgICAgdmFsdWU6ICcnLFxcbiAgICAgICAgICB1cmk6ICcnLFxcbiAgICAgICAgfSxcXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBjbG9zZURpYWxvZyA9ICgpID0+IHtcXG4gICAgICBpc09wZW5lZC52YWx1ZSA9ICFpc09wZW5lZC52YWx1ZTtcXG4gICAgICBzaG93U3VjY2Vzc01lc3NhZ2UudmFsdWUgPSBmYWxzZTtcXG4gICAgICBzaG93RmFpbHVyZU1lc3NhZ2UudmFsdWUgPSBmYWxzZTtcXG4gICAgICBzdWdnZXN0aW9uVXJsLnZhbHVlID0gJyc7XFxuICAgICAgLy8gJHYuZm9ybURhdGEuJHJlc2V0KCk7XFxuICAgICAgZm9ybURhdGEuZGVzY3JpcHRpb24gPSAnJztcXG4gICAgICBmb3JtRGF0YS5yZWFzb24gPSAnJztcXG4gICAgICBmb3JtRGF0YS5mcm9tT3JnID0gJyc7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgcGFnZVVybCxcXG4gICAgICBwYWdlVXJsWCxcXG4gICAgICBpc09wZW5lZCxcXG4gICAgICBzaG93U3VjY2Vzc01lc3NhZ2UsXFxuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLFxcbiAgICAgIHN1Z2dlc3Rpb25VcmwsXFxuICAgICAgZm9ybURhdGEsXFxuICAgICAgZ2V0VXJsLFxcbiAgICAgIHN1Ym1pdEZvcm0sXFxuICAgICAgdG9nZ2xlRmFpbHVyZU1lc3NhZ2UsXFxuICAgICAgaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzLFxcbiAgICAgIGNsb3NlRGlhbG9nLFxcbiAgICAgIGxhYmVsWCxcXG4gICAgICB0ZXN0aVxcbiAgICB9O1xcbiAgfSxcXG4gIHZhbGlkYXRpb25zKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGZvcm1EYXRhOiB7XFxuICAgICAgICBkZXNjcmlwdGlvbjogeyByZXF1aXJlZCB9LFxcbiAgICAgICAgcmVhc29uOiB7IHJlcXVpcmVkIH0sXFxuICAgICAgfSxcXG4gICAgfTtcXG4gIH0sXFxufTtcXG48L3NjcmlwdD5cXG5cXG48c3R5bGU+XFxuICA6OnBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICM1ZWE4Qjc7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXFxuICA6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICM1ZWE4Qjc7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXFxuICA6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjNWVhOEI3O1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbjwvc3R5bGU+XFxuXFxuPHN0eWxlIHNjb3BlZD5cXG4gIGEge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGN1cnNvcjogaGFuZDtcXG4gIH1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8533\n");

/***/ }),

/***/ 3602:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\na[data-v-0e5bd7a5] {\\n    cursor: pointer;\\n    cursor: hand;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/SuggestChangeButton.vue\"],\"names\":[],\"mappings\":\";AA6NE;IACE,eAAe;IACf,YAAY;AACd\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <a role=\\\"button\\\" @click=\\\"isOpened = !isOpened\\\" id=\\\"fordirectmodify\\\" :href=\\\"`${pageUrl.split('#')[0]}#suggestion`\\\">\\n      <span>{{ $t('edit.button') }}</span>\\n    </a>\\n    <centered-dialog v-if=\\\"isOpened\\\" @close=\\\"closeDialog()\\\">\\n      <edit-suggestion\\n          v-if=\\\"!showSuccessMessage && !showFailureMessage\\\"\\n          :d=\\\"formData\\\"\\n          :label=\\\"labelX\\\"\\n          :uri=\\\"uriX\\\"\\n          @update:conceptType=\\\"formData.conceptType.value = $event\\\"\\n          @update:primaryPrefLabel=\\\"formData.prefLabel.primary = $event\\\"\\n          @update:description=\\\"formData.description = $event\\\"\\n          @update:reason=\\\"formData.reason = $event\\\"\\n          @update:fromOrg=\\\"formData.fromOrg = $event\\\"\\n          @submitForm=\\\"submitForm\\\"\\n      />\\n      <success-message v-if=\\\"showSuccessMessage\\\" :suggestionUrl=\\\"suggestionUrl\\\" :url=\\\"url\\\" />\\n      <failure-message v-if=\\\"showFailureMessage\\\" />\\n    </centered-dialog>\\n  </div>\\n</template>\\n\\n<script>\\nimport EditSuggestion from './EditSuggestion.vue';\\nimport CenteredDialog from './common/CenteredDialog.vue';\\nimport SuccessMessage from './common/SuccessMessage.vue';\\nimport FailureMessage from './common/FailureMessage.vue';\\nimport { required } from 'vuelidate';\\nimport axios from 'axios';\\nimport { defineComponent, ref, reactive, watchEffect, inject, watch } from 'vue';\\n\\nexport default {\\n  components: {\\n    EditSuggestion,\\n    CenteredDialog,\\n    SuccessMessage,\\n    FailureMessage,\\n  },\\n  props: {\\n    lang: String,\\n    vocab: String,\\n    label: String,\\n    uri: String,\\n    url: String,\\n    moikkelis: String,\\n  },\\n  setup(props) {\\n    const testi = inject('testi')\\n    const labelX = inject('labelX', null);\\n    const uriX = inject('uriX', null);\\n    const pageUrlX = inject('pageUrlX', null);\\n    const $t = inject('$t');\\n    let pageUrl = ref(pageUrlX);\\n    // console.log('pageUrl at refs', pageUrl)\\n    const isOpened = ref(false);\\n    const showSuccessMessage = ref(false);\\n    const showFailureMessage = ref(false);\\n    const suggestionUrl = ref('');\\n    const formData = reactive({\\n      description: '',\\n      reason: '',\\n      fromOrg: '',\\n    });\\n\\n    const getUrl = async () => {\\n      pageUrl.value = window.location.href;\\n    };\\n\\n    const submitForm = () => {\\n      if (true) {\\n        sendData();\\n      } else {\\n        console.log('Data not sent: required data of the form was not provided.');\\n      }\\n    };\\n\\n    const sendData = async () => {\\n      let data = `\\n**Käsitteen tyyppi**\\n\\nMuutos olemassa olevaan käsitteeseen\\n\\n**prefabel**\\n\\n[${labelX}](${uriX})\\n\\n**Tila**\\n\\nKäsittelyssä\\n\\n**Ehdotettu muutos**\\n\\n${formData.description}\\n\\n**Perustelut ehdotukselle**\\n\\n${formData.reason}\\n\\n**Ehdottajan organisaatio**\\n\\n${formData.fromOrg}\\n`;\\n\\n      let dataBundle = {\\n        title: labelX,\\n        body: data,\\n        state: 'open',\\n        labels: ['muutos'],\\n      };\\n\\n      const payload = encodeURIComponent(JSON.stringify(dataBundle));\\n\\n      var urlToPrx = require('../prx.json');\\n      await axios\\n          .post(`${urlToPrx[0].url}?payload=${payload}`)\\n          .then((response) => {\\n            toggleSuccessMessage(`${response.data.url.replace('/repos', '').replace('api.', '')}`);\\n          })\\n          .catch((error) => {\\n            toggleFailureMessage();\\n          });\\n    };\\n\\n    const toggleSuccessMessage = (responseUrl) => {\\n      if (responseUrl && responseUrl.length > 0) {\\n        suggestionUrl.value = responseUrl;\\n        showSuccessMessage.value = true;\\n      }\\n      showSuccessMessage.value = true;\\n    };\\n\\n    const toggleFailureMessage = () => {\\n      showFailureMessage.value = true;\\n    };\\n\\n    const handlePrefLabelLanguages = () => {\\n      if (lang === 'sv') {\\n        return {\\n          sv: {\\n            value: labelX,\\n            uri: uriX,\\n          },\\n          en: '',\\n          fi: {\\n            value: '',\\n            uri: '',\\n          },\\n        };\\n      }\\n      return {\\n        fi: {\\n          value: labelX,\\n          uri: uriX,\\n        },\\n        en: '',\\n        sv: {\\n          value: '',\\n          uri: '',\\n        },\\n      };\\n    };\\n\\n    const closeDialog = () => {\\n      isOpened.value = !isOpened.value;\\n      showSuccessMessage.value = false;\\n      showFailureMessage.value = false;\\n      suggestionUrl.value = '';\\n      // $v.formData.$reset();\\n      formData.description = '';\\n      formData.reason = '';\\n      formData.fromOrg = '';\\n    };\\n\\n    return {\\n      pageUrl,\\n      pageUrlX,\\n      isOpened,\\n      showSuccessMessage,\\n      showFailureMessage,\\n      suggestionUrl,\\n      formData,\\n      getUrl,\\n      submitForm,\\n      toggleFailureMessage,\\n      handlePrefLabelLanguages,\\n      closeDialog,\\n      labelX,\\n      testi\\n    };\\n  },\\n  validations() {\\n    return {\\n      formData: {\\n        description: { required },\\n        reason: { required },\\n      },\\n    };\\n  },\\n};\\n</script>\\n\\n<style>\\n  ::placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n\\n  :-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n\\n  ::-ms-input-placeholder {\\n    color: #5ea8B7;\\n    opacity: 1;\\n  }\\n</style>\\n\\n<style scoped>\\n  a {\\n    cursor: pointer;\\n    cursor: hand;\\n  }\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYwMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3lIO0FBQzdCO0FBQzVGLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxnRUFBZ0Usc0JBQXNCLG1CQUFtQixHQUFHLFNBQVMscUdBQXFHLE1BQU0sVUFBVSxVQUFVLHVJQUF1SSxzQkFBc0IsZ0NBQWdDLG9CQUFvQiwwM0JBQTAzQiwyREFBMkQsMkRBQTJELDJEQUEyRCxXQUFXLFdBQVcsaUJBQWlCLDRCQUE0QixXQUFXLDZEQUE2RCxXQUFXLG9CQUFvQixpQkFBaUIseUZBQXlGLGFBQWEsNEhBQTRILG1CQUFtQiwrRUFBK0Usd0NBQXdDLGdEQUFnRCw4QkFBOEIsa0NBQWtDLGtGQUFrRiw0Q0FBNEMsNENBQTRDLG9DQUFvQyxpQ0FBaUMsc0VBQXNFLEVBQUUsb0NBQW9DLDZDQUE2QyxRQUFRLGtDQUFrQyxtQkFBbUIscUJBQXFCLFVBQVUsTUFBTSxvRkFBb0YsU0FBUyxRQUFRLHNDQUFzQyx5R0FBeUcsT0FBTyxJQUFJLEtBQUssMkRBQTJELHFCQUFxQixxQ0FBcUMsZ0JBQWdCLHFDQUFxQyxpQkFBaUIsSUFBSSw0QkFBNEIsNEdBQTRHLHlFQUF5RSxnREFBZ0Qsd0NBQXdDLGdCQUFnQixXQUFXLFFBQVEsbUNBQW1DLHNDQUFzQyw0REFBNEQsR0FBRyxhQUFhLGdDQUFnQyxxQ0FBcUMsYUFBYSxFQUFFLFFBQVEsdURBQXVELG9EQUFvRCw0Q0FBNEMsMENBQTBDLFNBQVMsd0NBQXdDLFFBQVEsNENBQTRDLHdDQUF3QyxRQUFRLGdEQUFnRCw0QkFBNEIsa0JBQWtCLGlCQUFpQixpRUFBaUUscUNBQXFDLDJEQUEyRCxhQUFhLFNBQVMsZ0JBQWdCLGVBQWUsMkRBQTJELGlDQUFpQyxxREFBcUQsV0FBVyxRQUFRLG1DQUFtQyx5Q0FBeUMseUNBQXlDLHlDQUF5QyxpQ0FBaUMsZ0NBQWdDLGtDQUFrQyw2QkFBNkIsOEJBQThCLFFBQVEsZ0JBQWdCLHVTQUF1UyxLQUFLLG9CQUFvQixjQUFjLG1CQUFtQix5QkFBeUIsVUFBVSxxQkFBcUIsVUFBVSxVQUFVLFNBQVMsS0FBSyxLQUFLLHlDQUF5QyxxQkFBcUIsaUJBQWlCLEtBQUssOEJBQThCLHFCQUFxQixpQkFBaUIsS0FBSywrQkFBK0IscUJBQXFCLGlCQUFpQixLQUFLLG1DQUFtQyxzQkFBc0IsbUJBQW1CLEtBQUssK0JBQStCO0FBQzNoTDtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlP2Y3OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG5hW2RhdGEtdi0wZTViZDdhNV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGN1cnNvcjogaGFuZDtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTZORTtJQUNFLGVBQWU7SUFDZixZQUFZO0FBQ2RcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdj5cXG4gICAgPGEgcm9sZT1cXFwiYnV0dG9uXFxcIiBAY2xpY2s9XFxcImlzT3BlbmVkID0gIWlzT3BlbmVkXFxcIiBpZD1cXFwiZm9yZGlyZWN0bW9kaWZ5XFxcIiA6aHJlZj1cXFwiYCR7cGFnZVVybC5zcGxpdCgnIycpWzBdfSNzdWdnZXN0aW9uYFxcXCI+XFxuICAgICAgPHNwYW4+e3sgJHQoJ2VkaXQuYnV0dG9uJykgfX08L3NwYW4+XFxuICAgIDwvYT5cXG4gICAgPGNlbnRlcmVkLWRpYWxvZyB2LWlmPVxcXCJpc09wZW5lZFxcXCIgQGNsb3NlPVxcXCJjbG9zZURpYWxvZygpXFxcIj5cXG4gICAgICA8ZWRpdC1zdWdnZXN0aW9uXFxuICAgICAgICAgIHYtaWY9XFxcIiFzaG93U3VjY2Vzc01lc3NhZ2UgJiYgIXNob3dGYWlsdXJlTWVzc2FnZVxcXCJcXG4gICAgICAgICAgOmQ9XFxcImZvcm1EYXRhXFxcIlxcbiAgICAgICAgICA6bGFiZWw9XFxcImxhYmVsWFxcXCJcXG4gICAgICAgICAgOnVyaT1cXFwidXJpWFxcXCJcXG4gICAgICAgICAgQHVwZGF0ZTpjb25jZXB0VHlwZT1cXFwiZm9ybURhdGEuY29uY2VwdFR5cGUudmFsdWUgPSAkZXZlbnRcXFwiXFxuICAgICAgICAgIEB1cGRhdGU6cHJpbWFyeVByZWZMYWJlbD1cXFwiZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnkgPSAkZXZlbnRcXFwiXFxuICAgICAgICAgIEB1cGRhdGU6ZGVzY3JpcHRpb249XFxcImZvcm1EYXRhLmRlc2NyaXB0aW9uID0gJGV2ZW50XFxcIlxcbiAgICAgICAgICBAdXBkYXRlOnJlYXNvbj1cXFwiZm9ybURhdGEucmVhc29uID0gJGV2ZW50XFxcIlxcbiAgICAgICAgICBAdXBkYXRlOmZyb21Pcmc9XFxcImZvcm1EYXRhLmZyb21PcmcgPSAkZXZlbnRcXFwiXFxuICAgICAgICAgIEBzdWJtaXRGb3JtPVxcXCJzdWJtaXRGb3JtXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN1Y2Nlc3MtbWVzc2FnZSB2LWlmPVxcXCJzaG93U3VjY2Vzc01lc3NhZ2VcXFwiIDpzdWdnZXN0aW9uVXJsPVxcXCJzdWdnZXN0aW9uVXJsXFxcIiA6dXJsPVxcXCJ1cmxcXFwiIC8+XFxuICAgICAgPGZhaWx1cmUtbWVzc2FnZSB2LWlmPVxcXCJzaG93RmFpbHVyZU1lc3NhZ2VcXFwiIC8+XFxuICAgIDwvY2VudGVyZWQtZGlhbG9nPlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCBFZGl0U3VnZ2VzdGlvbiBmcm9tICcuL0VkaXRTdWdnZXN0aW9uLnZ1ZSc7XFxuaW1wb3J0IENlbnRlcmVkRGlhbG9nIGZyb20gJy4vY29tbW9uL0NlbnRlcmVkRGlhbG9nLnZ1ZSc7XFxuaW1wb3J0IFN1Y2Nlc3NNZXNzYWdlIGZyb20gJy4vY29tbW9uL1N1Y2Nlc3NNZXNzYWdlLnZ1ZSc7XFxuaW1wb3J0IEZhaWx1cmVNZXNzYWdlIGZyb20gJy4vY29tbW9uL0ZhaWx1cmVNZXNzYWdlLnZ1ZSc7XFxuaW1wb3J0IHsgcmVxdWlyZWQgfSBmcm9tICd2dWVsaWRhdGUnO1xcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuaW1wb3J0IHsgZGVmaW5lQ29tcG9uZW50LCByZWYsIHJlYWN0aXZlLCB3YXRjaEVmZmVjdCwgaW5qZWN0LCB3YXRjaCB9IGZyb20gJ3Z1ZSc7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgY29tcG9uZW50czoge1xcbiAgICBFZGl0U3VnZ2VzdGlvbixcXG4gICAgQ2VudGVyZWREaWFsb2csXFxuICAgIFN1Y2Nlc3NNZXNzYWdlLFxcbiAgICBGYWlsdXJlTWVzc2FnZSxcXG4gIH0sXFxuICBwcm9wczoge1xcbiAgICBsYW5nOiBTdHJpbmcsXFxuICAgIHZvY2FiOiBTdHJpbmcsXFxuICAgIGxhYmVsOiBTdHJpbmcsXFxuICAgIHVyaTogU3RyaW5nLFxcbiAgICB1cmw6IFN0cmluZyxcXG4gICAgbW9pa2tlbGlzOiBTdHJpbmcsXFxuICB9LFxcbiAgc2V0dXAocHJvcHMpIHtcXG4gICAgY29uc3QgdGVzdGkgPSBpbmplY3QoJ3Rlc3RpJylcXG4gICAgY29uc3QgbGFiZWxYID0gaW5qZWN0KCdsYWJlbFgnLCBudWxsKTtcXG4gICAgY29uc3QgdXJpWCA9IGluamVjdCgndXJpWCcsIG51bGwpO1xcbiAgICBjb25zdCBwYWdlVXJsWCA9IGluamVjdCgncGFnZVVybFgnLCBudWxsKTtcXG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XFxuICAgIGxldCBwYWdlVXJsID0gcmVmKHBhZ2VVcmxYKTtcXG4gICAgLy8gY29uc29sZS5sb2coJ3BhZ2VVcmwgYXQgcmVmcycsIHBhZ2VVcmwpXFxuICAgIGNvbnN0IGlzT3BlbmVkID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc2hvd1N1Y2Nlc3NNZXNzYWdlID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc2hvd0ZhaWx1cmVNZXNzYWdlID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc3VnZ2VzdGlvblVybCA9IHJlZignJyk7XFxuICAgIGNvbnN0IGZvcm1EYXRhID0gcmVhY3RpdmUoe1xcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcXG4gICAgICByZWFzb246ICcnLFxcbiAgICAgIGZyb21Pcmc6ICcnLFxcbiAgICB9KTtcXG5cXG4gICAgY29uc3QgZ2V0VXJsID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIHBhZ2VVcmwudmFsdWUgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcXG4gICAgfTtcXG5cXG4gICAgY29uc3Qgc3VibWl0Rm9ybSA9ICgpID0+IHtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgc2VuZERhdGEoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5sb2coJ0RhdGEgbm90IHNlbnQ6IHJlcXVpcmVkIGRhdGEgb2YgdGhlIGZvcm0gd2FzIG5vdCBwcm92aWRlZC4nKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IHNlbmREYXRhID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIGxldCBkYXRhID0gYFxcbioqS8Okc2l0dGVlbiB0eXlwcGkqKlxcblxcbk11dXRvcyBvbGVtYXNzYSBvbGV2YWFuIGvDpHNpdHRlZXNlZW5cXG5cXG4qKnByZWZhYmVsKipcXG5cXG5bJHtsYWJlbFh9XSgke3VyaVh9KVxcblxcbioqVGlsYSoqXFxuXFxuS8Okc2l0dGVseXNzw6RcXG5cXG4qKkVoZG90ZXR0dSBtdXV0b3MqKlxcblxcbiR7Zm9ybURhdGEuZGVzY3JpcHRpb259XFxuXFxuKipQZXJ1c3RlbHV0IGVoZG90dWtzZWxsZSoqXFxuXFxuJHtmb3JtRGF0YS5yZWFzb259XFxuXFxuKipFaGRvdHRhamFuIG9yZ2FuaXNhYXRpbyoqXFxuXFxuJHtmb3JtRGF0YS5mcm9tT3JnfVxcbmA7XFxuXFxuICAgICAgbGV0IGRhdGFCdW5kbGUgPSB7XFxuICAgICAgICB0aXRsZTogbGFiZWxYLFxcbiAgICAgICAgYm9keTogZGF0YSxcXG4gICAgICAgIHN0YXRlOiAnb3BlbicsXFxuICAgICAgICBsYWJlbHM6IFsnbXV1dG9zJ10sXFxuICAgICAgfTtcXG5cXG4gICAgICBjb25zdCBwYXlsb2FkID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGRhdGFCdW5kbGUpKTtcXG5cXG4gICAgICB2YXIgdXJsVG9QcnggPSByZXF1aXJlKCcuLi9wcnguanNvbicpO1xcbiAgICAgIGF3YWl0IGF4aW9zXFxuICAgICAgICAgIC5wb3N0KGAke3VybFRvUHJ4WzBdLnVybH0/cGF5bG9hZD0ke3BheWxvYWR9YClcXG4gICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XFxuICAgICAgICAgICAgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UoYCR7cmVzcG9uc2UuZGF0YS51cmwucmVwbGFjZSgnL3JlcG9zJywgJycpLnJlcGxhY2UoJ2FwaS4nLCAnJyl9YCk7XFxuICAgICAgICAgIH0pXFxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcXG4gICAgICAgICAgICB0b2dnbGVGYWlsdXJlTWVzc2FnZSgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UgPSAocmVzcG9uc2VVcmwpID0+IHtcXG4gICAgICBpZiAocmVzcG9uc2VVcmwgJiYgcmVzcG9uc2VVcmwubGVuZ3RoID4gMCkge1xcbiAgICAgICAgc3VnZ2VzdGlvblVybC52YWx1ZSA9IHJlc3BvbnNlVXJsO1xcbiAgICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgdG9nZ2xlRmFpbHVyZU1lc3NhZ2UgPSAoKSA9PiB7XFxuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gdHJ1ZTtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzID0gKCkgPT4ge1xcbiAgICAgIGlmIChsYW5nID09PSAnc3YnKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBzdjoge1xcbiAgICAgICAgICAgIHZhbHVlOiBsYWJlbFgsXFxuICAgICAgICAgICAgdXJpOiB1cmlYLFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBlbjogJycsXFxuICAgICAgICAgIGZpOiB7XFxuICAgICAgICAgICAgdmFsdWU6ICcnLFxcbiAgICAgICAgICAgIHVyaTogJycsXFxuICAgICAgICAgIH0sXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgZmk6IHtcXG4gICAgICAgICAgdmFsdWU6IGxhYmVsWCxcXG4gICAgICAgICAgdXJpOiB1cmlYLFxcbiAgICAgICAgfSxcXG4gICAgICAgIGVuOiAnJyxcXG4gICAgICAgIHN2OiB7XFxuICAgICAgICAgIHZhbHVlOiAnJyxcXG4gICAgICAgICAgdXJpOiAnJyxcXG4gICAgICAgIH0sXFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgY2xvc2VEaWFsb2cgPSAoKSA9PiB7XFxuICAgICAgaXNPcGVuZWQudmFsdWUgPSAhaXNPcGVuZWQudmFsdWU7XFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gZmFsc2U7XFxuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gZmFsc2U7XFxuICAgICAgc3VnZ2VzdGlvblVybC52YWx1ZSA9ICcnO1xcbiAgICAgIC8vICR2LmZvcm1EYXRhLiRyZXNldCgpO1xcbiAgICAgIGZvcm1EYXRhLmRlc2NyaXB0aW9uID0gJyc7XFxuICAgICAgZm9ybURhdGEucmVhc29uID0gJyc7XFxuICAgICAgZm9ybURhdGEuZnJvbU9yZyA9ICcnO1xcbiAgICB9O1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHBhZ2VVcmwsXFxuICAgICAgcGFnZVVybFgsXFxuICAgICAgaXNPcGVuZWQsXFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLFxcbiAgICAgIHNob3dGYWlsdXJlTWVzc2FnZSxcXG4gICAgICBzdWdnZXN0aW9uVXJsLFxcbiAgICAgIGZvcm1EYXRhLFxcbiAgICAgIGdldFVybCxcXG4gICAgICBzdWJtaXRGb3JtLFxcbiAgICAgIHRvZ2dsZUZhaWx1cmVNZXNzYWdlLFxcbiAgICAgIGhhbmRsZVByZWZMYWJlbExhbmd1YWdlcyxcXG4gICAgICBjbG9zZURpYWxvZyxcXG4gICAgICBsYWJlbFgsXFxuICAgICAgdGVzdGlcXG4gICAgfTtcXG4gIH0sXFxuICB2YWxpZGF0aW9ucygpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBmb3JtRGF0YToge1xcbiAgICAgICAgZGVzY3JpcHRpb246IHsgcmVxdWlyZWQgfSxcXG4gICAgICAgIHJlYXNvbjogeyByZXF1aXJlZCB9LFxcbiAgICAgIH0sXFxuICAgIH07XFxuICB9LFxcbn07XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlPlxcbiAgOjpwbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjNWVhOEI3O1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjNWVhOEI3O1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgOjotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogIzVlYThCNztcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG48L3N0eWxlPlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuICBhIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBjdXJzb3I6IGhhbmQ7XFxuICB9XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3602\n");

/***/ }),

/***/ 8149:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.error {\\n  color: #e83a30;\\n  text-indent: 2px;\\n  font-size: 13px;\\n  margin-top: -10px;\\n  margin-bottom: 16px;\\n}\\n::placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n:-ms-input-placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n::-ms-input-placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/SuggestNewButton.vue\"],\"names\":[],\"mappings\":\";AA8bA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,iBAAiB;EACjB,mBAAmB;AACrB;AACA;EACE,cAAc;EACd,UAAU;AACZ;AAEA;EACE,cAAc;EACd,UAAU;AACZ;AAEA;EACE,cAAc;EACd,UAAU;AACZ\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <a role=\\\"button\\\" @click=\\\"isOpened = !isOpened\\\" id=\\\"fordirectnew\\\" :href=\\\"`${pageUrl.split('#')[0]}#suggestion`\\\">\\n      <span>\\n        <div id=\\\"vocab-info\\\">\\n          <div>\\n            <h3>{{ $t('new.button') }}</h3>\\n          </div>\\n        </div>\\n      </span>\\n    </a>\\n    <centered-dialog v-if=\\\"isOpened\\\" @close=\\\"closeDialog()\\\">\\n      <new-suggestion\\n        :conceptTypeIsSelected=\\\"conceptTypeIsSelected\\\"\\n        :prefLabelOkay=\\\"prefLabelOkay\\\"\\n        :explanationOkay=\\\"explanationOkay\\\"\\n        :neededForOkay=\\\"neededForOkay\\\"\\n        :sending=\\\"sending\\\"\\n        @update:conceptTypeIsSelected=\\\"conceptTypeIsSelected = true\\\"\\n        @update:prefLabelOkay=\\\"prefLabelOkay = true\\\"\\n        @update:explanationOkay=\\\"explanationOkay = true\\\"\\n        @update:neededForOkay=\\\"neededForOkay = true\\\"\\n        v-if=\\\"!showSuccessMessage && !showFailureMessage\\\"\\n        :d=\\\"formData\\\"\\n        @update:vocabulary=\\\"formData.vocabulary = $event\\\"\\n        @update:conceptType=\\\"formData.conceptType.value = $event\\\"\\n        @update:primaryPrefLabel=\\\"formData.prefLabel.primary = $event\\\"\\n        @update:secondaryPrefLabel=\\\"formData.prefLabel.secondary = $event\\\"\\n        @update:enPrefLabel=\\\"formData.prefLabel.en = $event\\\"\\n        @update:altLabels=\\\"formData.altLabels = $event\\\"\\n        @update:broaderLabels=\\\"formData.broaderLabels = $event\\\"\\n        @update:narrowerLabels=\\\"formData.narrowerLabels = $event\\\"\\n        @update:relatedLabels=\\\"formData.relatedLabels = $event\\\"\\n        @update:groups=\\\"formData.groups.selectedGroups = $event\\\"\\n        @update:exactMatches=\\\"formData.exactMatches = $event\\\"\\n        @update:scopeNote=\\\"formData.scopeNote = $event\\\"\\n        @update:explanation=\\\"formData.explanation = $event\\\"\\n        @update:neededFor=\\\"formData.neededFor = $event\\\"\\n        @update:fromOrg=\\\"formData.fromOrg = $event\\\"\\n        @submitForm=\\\"submitForm()\\\"\\n      />\\n\\n      <success-message v-if=\\\"showSuccessMessage\\\" :suggestionUrl=\\\"suggestionUrl\\\" :url=\\\"url\\\" />\\n      <failure-message v-if=\\\"showFailureMessage\\\" />\\n    </centered-dialog>\\n  </div>\\n</template>\\n\\n<script>\\nimport { defineComponent, ref, reactive, watchEffect, inject, watch } from 'vue';\\nimport NewSuggestion from './NewSuggestion.vue';\\nimport CenteredDialog from './common/CenteredDialog.vue';\\nimport SuccessMessage from './common/SuccessMessage.vue';\\nimport FailureMessage from './common/FailureMessage.vue';\\nimport axios from 'axios';\\nimport urlToPrx from \\\"../prx.json\\\";\\n\\nexport default defineComponent({\\n  components: {\\n    NewSuggestion,\\n    CenteredDialog,\\n    SuccessMessage,\\n    FailureMessage,\\n  },\\n  props: {\\n    lang: String,\\n    vocab: String,\\n  },\\n  setup(props) {\\n    setTimeout(() => {\\n    }, 500)\\n\\n    // Inject the i18n $t function and pageUrl variable\\n    const $t = inject('$t');\\n    const testi = inject('testi')\\n    const pageUrl = inject('pageUrl');\\n    const isOpened = ref(false);\\n    const showSuccessMessage = ref(false);\\n    const showFailureMessage = ref(false);\\n    const suggestionUrl = ref('');\\n    let conceptTypeIsSelected = ref(false)\\n    let prefLabelOkay = ref(false)\\n    let explanationOkay = ref(false)\\n    let neededForOkay = ref(false)\\n    let dataCanBeSentArray = ref([])\\n    let sending = ref(false)\\n\\n    const formData = reactive({\\n      vocabulary: 'yso',\\n      conceptType: {\\n        value: '',\\n        options: [\\n          { value: '', vocab: 'yso' },\\n          { value: '', vocab: 'yso-paikat' },\\n        ],\\n      },\\n      prefLabel: {\\n        primary: '',\\n        secondary: '',\\n        fi: { value: '' },\\n        sv: { value: '' },\\n        en: '',\\n      },\\n      altLabels: [{ value: '', isTouched: false }],\\n      broaderLabels: [{ value: '', uri: '', isTouched: false }],\\n      narrowerLabels: [{ value: '', uri: '', isTouched: false }],\\n      relatedLabels: [{ value: '', uri: '', isTouched: false }],\\n      groups: { allGroups: [], selectedGroups: [] },\\n      exactMatches: [{ vocab: '', value: '', isTouched: false }],\\n      scopeNote: '',\\n      explanation: '',\\n      neededFor: '',\\n      fromOrg: '',\\n      tags: [],\\n    });\\n\\n    watch(\\n        () => [formData.conceptType.value, formData.conceptType.value.length],\\n        (newValues, oldValues) => {\\n          const conceptTypeLength = newValues[1];\\n\\n          if (conceptTypeLength > 0) {\\n            conceptTypeIsSelected.value = true;\\n            dataCanBeSentArray.value[0] = true\\n          } else {\\n            conceptTypeIsSelected.value = false;\\n            dataCanBeSentArray.value[0] = false\\n          }\\n        },\\n        { deep: true }\\n    );\\n\\n    watch(\\n        () => [formData.prefLabel.primary, formData.prefLabel.primary.length],\\n        (newValues, oldValues) => {\\n          const primaryLabelLength = newValues[1];\\n          if (primaryLabelLength > 2) {\\n            prefLabelOkay.value = true;\\n            dataCanBeSentArray.value[1] = true\\n          } else {\\n            prefLabelOkay.value = false;\\n            dataCanBeSentArray.value[1] = false\\n          }\\n        },\\n        { deep: true }\\n    );\\n\\n    watch(\\n        () => [formData.explanation, formData.explanation.length],\\n        (newValues, oldValues) => {\\n          const explanationLength = newValues[1];\\n          if (explanationLength > 2) {\\n            explanationOkay.value = true;\\n            dataCanBeSentArray.value[2] = true;\\n          } else {\\n            explanationOkay.value = false;\\n            dataCanBeSentArray.value[2] = false;\\n          }\\n        },\\n        { deep: true }\\n    );\\n\\n    watch(\\n        () => [formData.neededFor, formData.neededFor.length],\\n        (newValues, oldValues) => {\\n          const needdForLength = newValues[1];\\n          if (needdForLength > 2) {\\n            neededForOkay.value = true;\\n            dataCanBeSentArray.value[3] = true;\\n          } else {\\n            neededForOkay.value = false;\\n            dataCanBeSentArray.value[3] = false;\\n          }\\n        },\\n        { deep: true }\\n    );\\n\\n    // Methods\\n    const setDropDown = () => {\\n      formData.conceptType.options[0].value = 'new.common.concept';\\n      formData.conceptType.options[1].value = 'new.common.geo';\\n    };\\n\\n    const addHTTPOrHTTPS = (str) => {\\n      if (!/^(http(s?)):\\\\/\\\\//.test(str)) {\\n        return `http://${str}`;\\n      } else {\\n        return `${str}`;\\n      }\\n    };\\n\\n    const submitForm = () => {\\n      // $v.$touch();\\n      sending.value = true\\n\\n      const countTrueValues = dataCanBeSentArray.value.reduce((count, currentValue) => {\\n        if (currentValue === true) {\\n          return count + 1;\\n        } else {\\n          return count;\\n        }\\n      }, 0);\\n\\n      if (countTrueValues === 4) {\\n        sendData();\\n      } else {\\n        console.log('Data not sent: required data of the form was not provided.');\\n      }\\n    };\\n\\n    const sendData = async () => {\\n      handlePrefLabelLanguages();\\n      let ontTypeInTargetSuggestionSystem = '';\\n      const labelsInTargetSuggestionSystem = [];\\n      if (formData.vocabulary === 'yso-paikat') {\\n        labelsInTargetSuggestionSystem.push('uusi');\\n        labelsInTargetSuggestionSystem.push('MAANTIETEELLINEN');\\n        ontTypeInTargetSuggestionSystem = 'GEO';\\n      } else {\\n        labelsInTargetSuggestionSystem.push('uusi');\\n        ontTypeInTargetSuggestionSystem = 'CONCEPT';\\n      }\\n\\n      const altTerms = [];\\n      formData.altLabels.forEach((item) => (item.value !== '' ? altTerms.push(` ${item.value}`) : null));\\n\\n      const brdLabls = [];\\n      formData.broaderLabels.forEach((item) =>\\n          item.value !== '' ? brdLabls.push(` [${item.value}](${item.uri})`) : null\\n      );\\n\\n      const groups = [];\\n      formData.groups.selectedGroups.forEach((item) =>\\n          item.prefLabel !== '' ? groups.push(` [${item.prefLabel}](${item.uri})`) : null\\n      );\\n\\n      const nrrLabls = [];\\n      formData.narrowerLabels.forEach((item) =>\\n          item.value !== '' ? nrrLabls.push(` [${item.value}](${item.uri})`) : null\\n      );\\n\\n      const rltdLabls = [];\\n      formData.relatedLabels.forEach((item) =>\\n          item.value !== '' ? rltdLabls.push(` [${item.value}](${item.uri})`) : null\\n      );\\n\\n      const exctLabls = [];\\n      formData.exactMatches.forEach((item) =>\\n          item.value !== '' ? exctLabls.push(` [${item.vocab}](${addHTTPOrHTTPS(item.value)})`) : null\\n      );\\n\\n      let data = `\\n**Käsitteen tyyppi**\\n\\n${ontTypeInTargetSuggestionSystem}\\n\\n**Ehdotettu termi suomeksi**\\n\\n${formData.prefLabel.fi.value}\\n\\n**Ehdotettu termi ruotsiksi**\\n\\n${formData.prefLabel.sv.value}\\n\\n**Ehdotettu termi englanniksi**\\n\\n${formData.prefLabel.en}\\n\\n**Tarkoitusta täsmentävä selite**\\n\\n${formData.scopeNote}\\n\\n**Perustelut ehdotukselle**\\n\\n${formData.explanation}\\n\\n**Ehdotettu yläkäsite YSOssa (LT)**\\n\\n${brdLabls}\\n\\n**Ehdotetut temaattiset ryhmät**\\n\\n${groups}\\n\\n**Vaihtoehtoiset termit**\\n\\n${altTerms}\\n\\n**Alakäsitteet (RT)**\\n\\n${nrrLabls}\\n\\n**Assosiatiiviset (RT)**\\n\\n${rltdLabls}\\n\\n**Vastaava käsite muussa sanastossa**\\n\\n${exctLabls}\\n\\n**Aineisto jonka kuvailussa käsitettä tarvitaan (esim. nimeke tai URL)**\\n\\n${formData.neededFor}\\n\\n**Ehdottajan organisaatio**\\n\\n${formData.fromOrg}\\n`;\\n\\n      let dataBundle = {\\n        // title: formData.prefLabel.sv.value !== '' ? formData.prefLabel.sv.value : formData.prefLabel.fi.value,\\n        title:  window.lang === 'sv' ? formData.prefLabel.sv.value : formData.prefLabel.fi.value,\\n        body: data,\\n        state: 'open',\\n        labels: labelsInTargetSuggestionSystem,\\n      };\\n      const payload = encodeURIComponent(JSON.stringify(dataBundle));\\n      // console.log(\\\"payload\\\", payload)\\n      const headers = {\\n        'Access-Control-Allow-Origin': '*',\\n      };\\n      const urlToPrx = require('../prx.json');\\n      await axios\\n      // https://finto.fi/plugins/suggestions/gh_prx.php\\n      // https://api.github.com/repos/:owner/:repo\\n      // https://github.com/Finto-ehdotus/YSE\\n          .post(`${urlToPrx[0].url}?payload=${payload}`, {}, { headers })\\n          .then((response) => {\\n            // console.log('Response:', response)\\n            // toggleSuccessMessage(`https://github.com/Finto-ehdotus/YSE`);\\n            toggleSuccessMessage(`${response.data.url.replace('/repos', '').replace('api.', '')}`);\\n          })\\n          .catch((error) => {\\n            toggleFailureMessage();\\n          });\\n    };\\n    const toggleSuccessMessage = (responseUrl) => {\\n      if (responseUrl && responseUrl.length > 0) {\\n        suggestionUrl.value = responseUrl;\\n        showSuccessMessage.value = true;\\n      }\\n      showSuccessMessage.value = true;\\n    };\\n    const toggleFailureMessage = () => {\\n      showFailureMessage.value = true;\\n    };\\n\\n    const handlePrefLabelLanguages = () => {\\n      formData.prefLabel.fi.value = formData.prefLabel.primary;\\n      if (window.lang === 'fi' || window.lang === 'en') { // muutos 2023-09-18 lisättiin en ehto\\n        formData.prefLabel.fi.value = formData.prefLabel.primary;\\n        formData.prefLabel.sv.value = formData.prefLabel.secondary;\\n      } else if (window.lang === 'sv') {\\n        formData.prefLabel.sv.value = formData.prefLabel.primary;\\n        formData.prefLabel.fi.value = formData.prefLabel.secondary;\\n      }\\n      // formData.prefLabel.fi.value ? console.log(\\\"formData.prefLabel.fi.value\\\", formData.prefLabel.fi.value) : console.log(\\\"formData.prefLabel.fi.value X\\\")\\n      // formData.prefLabel.sv.value ? console.log(\\\"formData.prefLabel.sv.value\\\", formData.prefLabel.sv.value) : console.log(\\\"formData.prefLabel.sv.value X\\\")\\n    };\\n\\n    const closeDialog = () => {\\n      isOpened.value = !isOpened.value;\\n      showSuccessMessage.value = false;\\n      showFailureMessage.value = false;\\n      suggestionUrl.value = '';\\n      formData.vocabulary = 'yso';\\n      formData.conceptType.value = '';\\n      formData.prefLabel.primary = '';\\n      formData.prefLabel.secondary = '';\\n      formData.prefLabel.fi.value = '';\\n      formData.prefLabel.sv.value = '';\\n      formData.prefLabel.en = '';\\n      formData.altLabels = [{ value: '', isTouched: false }];\\n      formData.broaderLabels = [{ value: '', uri: '', isTouched: false }];\\n      formData.narrowerLabels = [{ value: '', uri: '', isTouched: false }];\\n      formData.relatedLabels = [{ value: '', uri: '', isTouched: false }];\\n      formData.groups.selectedGroups = [];\\n      formData.exactMatches = [{ vocab: '', value: '', isTouched: false }];\\n      formData.scopeNote = '';\\n      formData.explanation = '';\\n      formData.neededFor = '';\\n      formData.fromOrg = '';\\n      setDropDown();\\n      // $v.$reset();\\n      getGroups();\\n      sending.value = false\\n    };\\n\\n    const getUrl = async () => {\\n      pageUrl.value = window.location.href;\\n    };\\n\\n    const getGroups = async () => {\\n      await axios\\n          .get(`https://api.finto.fi/rest/v1/${formData.vocabulary}/groups`, {\\n            params: {\\n              // lang: props.lang,\\n              lang: window.lang === 'en' ? 'fi' : window.lang\\n            },\\n          })\\n          .then((response) => (formData.groups.allGroups = response.data.groups));\\n    };\\n\\n    // Lifecycle hooks\\n    watchEffect(() => {\\n  /*    if (props.lang === 'sv') {\\n        // Note: 'this' is not available in the setup function.\\n        // Instead, you can use 'props' directly.\\n      }*/\\n      setDropDown();\\n      getGroups();\\n    });\\n\\n    getGroups();\\n\\n    // Return the variables and methods you want to expose to the template\\n    return {\\n      pageUrl,\\n      isOpened,\\n      showSuccessMessage,\\n      showFailureMessage,\\n      suggestionUrl,\\n      formData,\\n      conceptTypeIsSelected,\\n      prefLabelOkay,\\n      explanationOkay,\\n      neededForOkay,\\n      setDropDown,\\n      addHTTPOrHTTPS,\\n      submitForm,\\n      sendData,\\n      toggleSuccessMessage,\\n      toggleFailureMessage,\\n      handlePrefLabelLanguages,\\n      closeDialog,\\n      getUrl,\\n      getGroups,\\n      dataCanBeSentArray,\\n      sending,\\n      testi\\n    };\\n  },\\n});\\n</script>\\n\\n<style>\\n.error {\\n  color: #e83a30;\\n  text-indent: 2px;\\n  font-size: 13px;\\n  margin-top: -10px;\\n  margin-bottom: 16px;\\n}\\n::placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n\\n:-ms-input-placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n\\n::-ms-input-placeholder {\\n  color: #5ea8B7;\\n  opacity: 1;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUcsYUFBYSxnQ0FBZ0MscUNBQXFDLGFBQWEsRUFBRSxRQUFRLHFEQUFxRCxvREFBb0QsNENBQTRDLDBDQUEwQyxTQUFTLHdDQUF3QyxRQUFRLDBDQUEwQyx3Q0FBd0MsUUFBUSxnREFBZ0QsaUVBQWlFLDREQUE0RCx5R0FBeUcscUVBQXFFLFVBQVUsZ0NBQWdDLG1FQUFtRSxxRUFBcUUsU0FBUyw4VUFBOFUsbUNBQW1DLHlDQUF5Qyx5Q0FBeUMseUNBQXlDLGlDQUFpQyxvQ0FBb0Msd0NBQXdDLHdDQUF3QywwQ0FBMEMseUNBQXlDLHlDQUF5QyxtQ0FBbUMsZ0NBQWdDLDZCQUE2QixFQUFFLG9DQUFvQyxzQ0FBc0MsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUUsb0NBQW9DLHNDQUFzQyxFQUFFLDRDQUE0QyxtQ0FBbUMsd0NBQXdDLEVBQUUsZ0NBQWdDLGtDQUFrQyxnQ0FBZ0MsOEJBQThCLHNCQUFzQix1QkFBdUIsb0JBQW9CLHFDQUFxQyxvQ0FBb0MsNkNBQTZDLFFBQVEsdUNBQXVDLG9FQUFvRSxvQkFBb0IsV0FBVyx1QkFBdUIsa0hBQWtILGNBQWMscUZBQXFGLFFBQVEsbURBQW1ELG9DQUFvQyw2SEFBNkgsd0JBQXdCLG9CQUFvQixPQUFPLEVBQUUsb0JBQW9CLDRGQUE0RiwrZkFBK2YsS0FBSyxJQUFJLEVBQUUsZ0NBQWdDLG1CQUFtQixxQkFBcUIsb0JBQW9CLHNCQUFzQix3QkFBd0IsR0FBRyxpQkFBaUIsbUJBQW1CLGVBQWUsR0FBRyw0QkFBNEIsbUJBQW1CLGVBQWUsR0FBRyw2QkFBNkIsbUJBQW1CLGVBQWUsR0FBRywrQkFBK0I7QUFDMTdkO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdE5ld0J1dHRvbi52dWU/ZTdlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5lcnJvciB7XFxuICBjb2xvcjogI2U4M2EzMDtcXG4gIHRleHQtaW5kZW50OiAycHg7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBtYXJnaW4tdG9wOiAtMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcbjo6cGxhY2Vob2xkZXIge1xcbiAgY29sb3I6ICM1ZWE4Qjc7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG46LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gIGNvbG9yOiAjNWVhOEI3O1xcbiAgb3BhY2l0eTogMTtcXG59XFxuOjotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgY29sb3I6ICM1ZWE4Qjc7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0TmV3QnV0dG9uLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBOGJBO0VBQ0UsY0FBYztFQUNkLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLG1CQUFtQjtBQUNyQjtBQUNBO0VBQ0UsY0FBYztFQUNkLFVBQVU7QUFDWjtBQUVBO0VBQ0UsY0FBYztFQUNkLFVBQVU7QUFDWjtBQUVBO0VBQ0UsY0FBYztFQUNkLFVBQVU7QUFDWlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgICA8YSByb2xlPVxcXCJidXR0b25cXFwiIEBjbGljaz1cXFwiaXNPcGVuZWQgPSAhaXNPcGVuZWRcXFwiIGlkPVxcXCJmb3JkaXJlY3RuZXdcXFwiIDpocmVmPVxcXCJgJHtwYWdlVXJsLnNwbGl0KCcjJylbMF19I3N1Z2dlc3Rpb25gXFxcIj5cXG4gICAgICA8c3Bhbj5cXG4gICAgICAgIDxkaXYgaWQ9XFxcInZvY2FiLWluZm9cXFwiPlxcbiAgICAgICAgICA8ZGl2PlxcbiAgICAgICAgICAgIDxoMz57eyAkdCgnbmV3LmJ1dHRvbicpIH19PC9oMz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvYT5cXG4gICAgPGNlbnRlcmVkLWRpYWxvZyB2LWlmPVxcXCJpc09wZW5lZFxcXCIgQGNsb3NlPVxcXCJjbG9zZURpYWxvZygpXFxcIj5cXG4gICAgICA8bmV3LXN1Z2dlc3Rpb25cXG4gICAgICAgIDpjb25jZXB0VHlwZUlzU2VsZWN0ZWQ9XFxcImNvbmNlcHRUeXBlSXNTZWxlY3RlZFxcXCJcXG4gICAgICAgIDpwcmVmTGFiZWxPa2F5PVxcXCJwcmVmTGFiZWxPa2F5XFxcIlxcbiAgICAgICAgOmV4cGxhbmF0aW9uT2theT1cXFwiZXhwbGFuYXRpb25Pa2F5XFxcIlxcbiAgICAgICAgOm5lZWRlZEZvck9rYXk9XFxcIm5lZWRlZEZvck9rYXlcXFwiXFxuICAgICAgICA6c2VuZGluZz1cXFwic2VuZGluZ1xcXCJcXG4gICAgICAgIEB1cGRhdGU6Y29uY2VwdFR5cGVJc1NlbGVjdGVkPVxcXCJjb25jZXB0VHlwZUlzU2VsZWN0ZWQgPSB0cnVlXFxcIlxcbiAgICAgICAgQHVwZGF0ZTpwcmVmTGFiZWxPa2F5PVxcXCJwcmVmTGFiZWxPa2F5ID0gdHJ1ZVxcXCJcXG4gICAgICAgIEB1cGRhdGU6ZXhwbGFuYXRpb25Pa2F5PVxcXCJleHBsYW5hdGlvbk9rYXkgPSB0cnVlXFxcIlxcbiAgICAgICAgQHVwZGF0ZTpuZWVkZWRGb3JPa2F5PVxcXCJuZWVkZWRGb3JPa2F5ID0gdHJ1ZVxcXCJcXG4gICAgICAgIHYtaWY9XFxcIiFzaG93U3VjY2Vzc01lc3NhZ2UgJiYgIXNob3dGYWlsdXJlTWVzc2FnZVxcXCJcXG4gICAgICAgIDpkPVxcXCJmb3JtRGF0YVxcXCJcXG4gICAgICAgIEB1cGRhdGU6dm9jYWJ1bGFyeT1cXFwiZm9ybURhdGEudm9jYWJ1bGFyeSA9ICRldmVudFxcXCJcXG4gICAgICAgIEB1cGRhdGU6Y29uY2VwdFR5cGU9XFxcImZvcm1EYXRhLmNvbmNlcHRUeXBlLnZhbHVlID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTpwcmltYXJ5UHJlZkxhYmVsPVxcXCJmb3JtRGF0YS5wcmVmTGFiZWwucHJpbWFyeSA9ICRldmVudFxcXCJcXG4gICAgICAgIEB1cGRhdGU6c2Vjb25kYXJ5UHJlZkxhYmVsPVxcXCJmb3JtRGF0YS5wcmVmTGFiZWwuc2Vjb25kYXJ5ID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTplblByZWZMYWJlbD1cXFwiZm9ybURhdGEucHJlZkxhYmVsLmVuID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTphbHRMYWJlbHM9XFxcImZvcm1EYXRhLmFsdExhYmVscyA9ICRldmVudFxcXCJcXG4gICAgICAgIEB1cGRhdGU6YnJvYWRlckxhYmVscz1cXFwiZm9ybURhdGEuYnJvYWRlckxhYmVscyA9ICRldmVudFxcXCJcXG4gICAgICAgIEB1cGRhdGU6bmFycm93ZXJMYWJlbHM9XFxcImZvcm1EYXRhLm5hcnJvd2VyTGFiZWxzID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTpyZWxhdGVkTGFiZWxzPVxcXCJmb3JtRGF0YS5yZWxhdGVkTGFiZWxzID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTpncm91cHM9XFxcImZvcm1EYXRhLmdyb3Vwcy5zZWxlY3RlZEdyb3VwcyA9ICRldmVudFxcXCJcXG4gICAgICAgIEB1cGRhdGU6ZXhhY3RNYXRjaGVzPVxcXCJmb3JtRGF0YS5leGFjdE1hdGNoZXMgPSAkZXZlbnRcXFwiXFxuICAgICAgICBAdXBkYXRlOnNjb3BlTm90ZT1cXFwiZm9ybURhdGEuc2NvcGVOb3RlID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTpleHBsYW5hdGlvbj1cXFwiZm9ybURhdGEuZXhwbGFuYXRpb24gPSAkZXZlbnRcXFwiXFxuICAgICAgICBAdXBkYXRlOm5lZWRlZEZvcj1cXFwiZm9ybURhdGEubmVlZGVkRm9yID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHVwZGF0ZTpmcm9tT3JnPVxcXCJmb3JtRGF0YS5mcm9tT3JnID0gJGV2ZW50XFxcIlxcbiAgICAgICAgQHN1Ym1pdEZvcm09XFxcInN1Ym1pdEZvcm0oKVxcXCJcXG4gICAgICAvPlxcblxcbiAgICAgIDxzdWNjZXNzLW1lc3NhZ2Ugdi1pZj1cXFwic2hvd1N1Y2Nlc3NNZXNzYWdlXFxcIiA6c3VnZ2VzdGlvblVybD1cXFwic3VnZ2VzdGlvblVybFxcXCIgOnVybD1cXFwidXJsXFxcIiAvPlxcbiAgICAgIDxmYWlsdXJlLW1lc3NhZ2Ugdi1pZj1cXFwic2hvd0ZhaWx1cmVNZXNzYWdlXFxcIiAvPlxcbiAgICA8L2NlbnRlcmVkLWRpYWxvZz5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgeyBkZWZpbmVDb21wb25lbnQsIHJlZiwgcmVhY3RpdmUsIHdhdGNoRWZmZWN0LCBpbmplY3QsIHdhdGNoIH0gZnJvbSAndnVlJztcXG5pbXBvcnQgTmV3U3VnZ2VzdGlvbiBmcm9tICcuL05ld1N1Z2dlc3Rpb24udnVlJztcXG5pbXBvcnQgQ2VudGVyZWREaWFsb2cgZnJvbSAnLi9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlJztcXG5pbXBvcnQgU3VjY2Vzc01lc3NhZ2UgZnJvbSAnLi9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlJztcXG5pbXBvcnQgRmFpbHVyZU1lc3NhZ2UgZnJvbSAnLi9jb21tb24vRmFpbHVyZU1lc3NhZ2UudnVlJztcXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcbmltcG9ydCB1cmxUb1ByeCBmcm9tIFxcXCIuLi9wcnguanNvblxcXCI7XFxuXFxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29tcG9uZW50KHtcXG4gIGNvbXBvbmVudHM6IHtcXG4gICAgTmV3U3VnZ2VzdGlvbixcXG4gICAgQ2VudGVyZWREaWFsb2csXFxuICAgIFN1Y2Nlc3NNZXNzYWdlLFxcbiAgICBGYWlsdXJlTWVzc2FnZSxcXG4gIH0sXFxuICBwcm9wczoge1xcbiAgICBsYW5nOiBTdHJpbmcsXFxuICAgIHZvY2FiOiBTdHJpbmcsXFxuICB9LFxcbiAgc2V0dXAocHJvcHMpIHtcXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgIH0sIDUwMClcXG5cXG4gICAgLy8gSW5qZWN0IHRoZSBpMThuICR0IGZ1bmN0aW9uIGFuZCBwYWdlVXJsIHZhcmlhYmxlXFxuICAgIGNvbnN0ICR0ID0gaW5qZWN0KCckdCcpO1xcbiAgICBjb25zdCB0ZXN0aSA9IGluamVjdCgndGVzdGknKVxcbiAgICBjb25zdCBwYWdlVXJsID0gaW5qZWN0KCdwYWdlVXJsJyk7XFxuICAgIGNvbnN0IGlzT3BlbmVkID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc2hvd1N1Y2Nlc3NNZXNzYWdlID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc2hvd0ZhaWx1cmVNZXNzYWdlID0gcmVmKGZhbHNlKTtcXG4gICAgY29uc3Qgc3VnZ2VzdGlvblVybCA9IHJlZignJyk7XFxuICAgIGxldCBjb25jZXB0VHlwZUlzU2VsZWN0ZWQgPSByZWYoZmFsc2UpXFxuICAgIGxldCBwcmVmTGFiZWxPa2F5ID0gcmVmKGZhbHNlKVxcbiAgICBsZXQgZXhwbGFuYXRpb25Pa2F5ID0gcmVmKGZhbHNlKVxcbiAgICBsZXQgbmVlZGVkRm9yT2theSA9IHJlZihmYWxzZSlcXG4gICAgbGV0IGRhdGFDYW5CZVNlbnRBcnJheSA9IHJlZihbXSlcXG4gICAgbGV0IHNlbmRpbmcgPSByZWYoZmFsc2UpXFxuXFxuICAgIGNvbnN0IGZvcm1EYXRhID0gcmVhY3RpdmUoe1xcbiAgICAgIHZvY2FidWxhcnk6ICd5c28nLFxcbiAgICAgIGNvbmNlcHRUeXBlOiB7XFxuICAgICAgICB2YWx1ZTogJycsXFxuICAgICAgICBvcHRpb25zOiBbXFxuICAgICAgICAgIHsgdmFsdWU6ICcnLCB2b2NhYjogJ3lzbycgfSxcXG4gICAgICAgICAgeyB2YWx1ZTogJycsIHZvY2FiOiAneXNvLXBhaWthdCcgfSxcXG4gICAgICAgIF0sXFxuICAgICAgfSxcXG4gICAgICBwcmVmTGFiZWw6IHtcXG4gICAgICAgIHByaW1hcnk6ICcnLFxcbiAgICAgICAgc2Vjb25kYXJ5OiAnJyxcXG4gICAgICAgIGZpOiB7IHZhbHVlOiAnJyB9LFxcbiAgICAgICAgc3Y6IHsgdmFsdWU6ICcnIH0sXFxuICAgICAgICBlbjogJycsXFxuICAgICAgfSxcXG4gICAgICBhbHRMYWJlbHM6IFt7IHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XSxcXG4gICAgICBicm9hZGVyTGFiZWxzOiBbeyB2YWx1ZTogJycsIHVyaTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV0sXFxuICAgICAgbmFycm93ZXJMYWJlbHM6IFt7IHZhbHVlOiAnJywgdXJpOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XSxcXG4gICAgICByZWxhdGVkTGFiZWxzOiBbeyB2YWx1ZTogJycsIHVyaTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV0sXFxuICAgICAgZ3JvdXBzOiB7IGFsbEdyb3VwczogW10sIHNlbGVjdGVkR3JvdXBzOiBbXSB9LFxcbiAgICAgIGV4YWN0TWF0Y2hlczogW3sgdm9jYWI6ICcnLCB2YWx1ZTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV0sXFxuICAgICAgc2NvcGVOb3RlOiAnJyxcXG4gICAgICBleHBsYW5hdGlvbjogJycsXFxuICAgICAgbmVlZGVkRm9yOiAnJyxcXG4gICAgICBmcm9tT3JnOiAnJyxcXG4gICAgICB0YWdzOiBbXSxcXG4gICAgfSk7XFxuXFxuICAgIHdhdGNoKFxcbiAgICAgICAgKCkgPT4gW2Zvcm1EYXRhLmNvbmNlcHRUeXBlLnZhbHVlLCBmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZS5sZW5ndGhdLFxcbiAgICAgICAgKG5ld1ZhbHVlcywgb2xkVmFsdWVzKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IGNvbmNlcHRUeXBlTGVuZ3RoID0gbmV3VmFsdWVzWzFdO1xcblxcbiAgICAgICAgICBpZiAoY29uY2VwdFR5cGVMZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgY29uY2VwdFR5cGVJc1NlbGVjdGVkLnZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMF0gPSB0cnVlXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY29uY2VwdFR5cGVJc1NlbGVjdGVkLnZhbHVlID0gZmFsc2U7XFxuICAgICAgICAgICAgZGF0YUNhbkJlU2VudEFycmF5LnZhbHVlWzBdID0gZmFsc2VcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XFxuICAgICk7XFxuXFxuICAgIHdhdGNoKFxcbiAgICAgICAgKCkgPT4gW2Zvcm1EYXRhLnByZWZMYWJlbC5wcmltYXJ5LCBmb3JtRGF0YS5wcmVmTGFiZWwucHJpbWFyeS5sZW5ndGhdLFxcbiAgICAgICAgKG5ld1ZhbHVlcywgb2xkVmFsdWVzKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IHByaW1hcnlMYWJlbExlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcXG4gICAgICAgICAgaWYgKHByaW1hcnlMYWJlbExlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgICBwcmVmTGFiZWxPa2F5LnZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMV0gPSB0cnVlXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcHJlZkxhYmVsT2theS52YWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgICAgIGRhdGFDYW5CZVNlbnRBcnJheS52YWx1ZVsxXSA9IGZhbHNlXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICB7IGRlZXA6IHRydWUgfVxcbiAgICApO1xcblxcbiAgICB3YXRjaChcXG4gICAgICAgICgpID0+IFtmb3JtRGF0YS5leHBsYW5hdGlvbiwgZm9ybURhdGEuZXhwbGFuYXRpb24ubGVuZ3RoXSxcXG4gICAgICAgIChuZXdWYWx1ZXMsIG9sZFZhbHVlcykgPT4ge1xcbiAgICAgICAgICBjb25zdCBleHBsYW5hdGlvbkxlbmd0aCA9IG5ld1ZhbHVlc1sxXTtcXG4gICAgICAgICAgaWYgKGV4cGxhbmF0aW9uTGVuZ3RoID4gMikge1xcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uT2theS52YWx1ZSA9IHRydWU7XFxuICAgICAgICAgICAgZGF0YUNhbkJlU2VudEFycmF5LnZhbHVlWzJdID0gdHJ1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBleHBsYW5hdGlvbk9rYXkudmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbMl0gPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XFxuICAgICk7XFxuXFxuICAgIHdhdGNoKFxcbiAgICAgICAgKCkgPT4gW2Zvcm1EYXRhLm5lZWRlZEZvciwgZm9ybURhdGEubmVlZGVkRm9yLmxlbmd0aF0sXFxuICAgICAgICAobmV3VmFsdWVzLCBvbGRWYWx1ZXMpID0+IHtcXG4gICAgICAgICAgY29uc3QgbmVlZGRGb3JMZW5ndGggPSBuZXdWYWx1ZXNbMV07XFxuICAgICAgICAgIGlmIChuZWVkZEZvckxlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgICBuZWVkZWRGb3JPa2F5LnZhbHVlID0gdHJ1ZTtcXG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbM10gPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG5lZWRlZEZvck9rYXkudmFsdWUgPSBmYWxzZTtcXG4gICAgICAgICAgICBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWVbM10gPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgZGVlcDogdHJ1ZSB9XFxuICAgICk7XFxuXFxuICAgIC8vIE1ldGhvZHNcXG4gICAgY29uc3Qgc2V0RHJvcERvd24gPSAoKSA9PiB7XFxuICAgICAgZm9ybURhdGEuY29uY2VwdFR5cGUub3B0aW9uc1swXS52YWx1ZSA9ICduZXcuY29tbW9uLmNvbmNlcHQnO1xcbiAgICAgIGZvcm1EYXRhLmNvbmNlcHRUeXBlLm9wdGlvbnNbMV0udmFsdWUgPSAnbmV3LmNvbW1vbi5nZW8nO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBhZGRIVFRQT3JIVFRQUyA9IChzdHIpID0+IHtcXG4gICAgICBpZiAoIS9eKGh0dHAocz8pKTpcXFxcL1xcXFwvLy50ZXN0KHN0cikpIHtcXG4gICAgICAgIHJldHVybiBgaHR0cDovLyR7c3RyfWA7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IHN1Ym1pdEZvcm0gPSAoKSA9PiB7XFxuICAgICAgLy8gJHYuJHRvdWNoKCk7XFxuICAgICAgc2VuZGluZy52YWx1ZSA9IHRydWVcXG5cXG4gICAgICBjb25zdCBjb3VudFRydWVWYWx1ZXMgPSBkYXRhQ2FuQmVTZW50QXJyYXkudmFsdWUucmVkdWNlKChjb3VudCwgY3VycmVudFZhbHVlKSA9PiB7XFxuICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSB0cnVlKSB7XFxuICAgICAgICAgIHJldHVybiBjb3VudCArIDE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gY291bnQ7XFxuICAgICAgICB9XFxuICAgICAgfSwgMCk7XFxuXFxuICAgICAgaWYgKGNvdW50VHJ1ZVZhbHVlcyA9PT0gNCkge1xcbiAgICAgICAgc2VuZERhdGEoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5sb2coJ0RhdGEgbm90IHNlbnQ6IHJlcXVpcmVkIGRhdGEgb2YgdGhlIGZvcm0gd2FzIG5vdCBwcm92aWRlZC4nKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IHNlbmREYXRhID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIGhhbmRsZVByZWZMYWJlbExhbmd1YWdlcygpO1xcbiAgICAgIGxldCBvbnRUeXBlSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtID0gJyc7XFxuICAgICAgY29uc3QgbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtID0gW107XFxuICAgICAgaWYgKGZvcm1EYXRhLnZvY2FidWxhcnkgPT09ICd5c28tcGFpa2F0Jykge1xcbiAgICAgICAgbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLnB1c2goJ3V1c2knKTtcXG4gICAgICAgIGxhYmVsc0luVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbS5wdXNoKCdNQUFOVElFVEVFTExJTkVOJyk7XFxuICAgICAgICBvbnRUeXBlSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtID0gJ0dFTyc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxhYmVsc0luVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbS5wdXNoKCd1dXNpJyk7XFxuICAgICAgICBvbnRUeXBlSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtID0gJ0NPTkNFUFQnO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBhbHRUZXJtcyA9IFtdO1xcbiAgICAgIGZvcm1EYXRhLmFsdExhYmVscy5mb3JFYWNoKChpdGVtKSA9PiAoaXRlbS52YWx1ZSAhPT0gJycgPyBhbHRUZXJtcy5wdXNoKGAgJHtpdGVtLnZhbHVlfWApIDogbnVsbCkpO1xcblxcbiAgICAgIGNvbnN0IGJyZExhYmxzID0gW107XFxuICAgICAgZm9ybURhdGEuYnJvYWRlckxhYmVscy5mb3JFYWNoKChpdGVtKSA9PlxcbiAgICAgICAgICBpdGVtLnZhbHVlICE9PSAnJyA/IGJyZExhYmxzLnB1c2goYCBbJHtpdGVtLnZhbHVlfV0oJHtpdGVtLnVyaX0pYCkgOiBudWxsXFxuICAgICAgKTtcXG5cXG4gICAgICBjb25zdCBncm91cHMgPSBbXTtcXG4gICAgICBmb3JtRGF0YS5ncm91cHMuc2VsZWN0ZWRHcm91cHMuZm9yRWFjaCgoaXRlbSkgPT5cXG4gICAgICAgICAgaXRlbS5wcmVmTGFiZWwgIT09ICcnID8gZ3JvdXBzLnB1c2goYCBbJHtpdGVtLnByZWZMYWJlbH1dKCR7aXRlbS51cml9KWApIDogbnVsbFxcbiAgICAgICk7XFxuXFxuICAgICAgY29uc3QgbnJyTGFibHMgPSBbXTtcXG4gICAgICBmb3JtRGF0YS5uYXJyb3dlckxhYmVscy5mb3JFYWNoKChpdGVtKSA9PlxcbiAgICAgICAgICBpdGVtLnZhbHVlICE9PSAnJyA/IG5yckxhYmxzLnB1c2goYCBbJHtpdGVtLnZhbHVlfV0oJHtpdGVtLnVyaX0pYCkgOiBudWxsXFxuICAgICAgKTtcXG5cXG4gICAgICBjb25zdCBybHRkTGFibHMgPSBbXTtcXG4gICAgICBmb3JtRGF0YS5yZWxhdGVkTGFiZWxzLmZvckVhY2goKGl0ZW0pID0+XFxuICAgICAgICAgIGl0ZW0udmFsdWUgIT09ICcnID8gcmx0ZExhYmxzLnB1c2goYCBbJHtpdGVtLnZhbHVlfV0oJHtpdGVtLnVyaX0pYCkgOiBudWxsXFxuICAgICAgKTtcXG5cXG4gICAgICBjb25zdCBleGN0TGFibHMgPSBbXTtcXG4gICAgICBmb3JtRGF0YS5leGFjdE1hdGNoZXMuZm9yRWFjaCgoaXRlbSkgPT5cXG4gICAgICAgICAgaXRlbS52YWx1ZSAhPT0gJycgPyBleGN0TGFibHMucHVzaChgIFske2l0ZW0udm9jYWJ9XSgke2FkZEhUVFBPckhUVFBTKGl0ZW0udmFsdWUpfSlgKSA6IG51bGxcXG4gICAgICApO1xcblxcbiAgICAgIGxldCBkYXRhID0gYFxcbioqS8Okc2l0dGVlbiB0eXlwcGkqKlxcblxcbiR7b250VHlwZUluVGFyZ2V0U3VnZ2VzdGlvblN5c3RlbX1cXG5cXG4qKkVoZG90ZXR0dSB0ZXJtaSBzdW9tZWtzaSoqXFxuXFxuJHtmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWV9XFxuXFxuKipFaGRvdGV0dHUgdGVybWkgcnVvdHNpa3NpKipcXG5cXG4ke2Zvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZX1cXG5cXG4qKkVoZG90ZXR0dSB0ZXJtaSBlbmdsYW5uaWtzaSoqXFxuXFxuJHtmb3JtRGF0YS5wcmVmTGFiZWwuZW59XFxuXFxuKipUYXJrb2l0dXN0YSB0w6RzbWVudMOkdsOkIHNlbGl0ZSoqXFxuXFxuJHtmb3JtRGF0YS5zY29wZU5vdGV9XFxuXFxuKipQZXJ1c3RlbHV0IGVoZG90dWtzZWxsZSoqXFxuXFxuJHtmb3JtRGF0YS5leHBsYW5hdGlvbn1cXG5cXG4qKkVoZG90ZXR0dSB5bMOka8Okc2l0ZSBZU09zc2EgKExUKSoqXFxuXFxuJHticmRMYWJsc31cXG5cXG4qKkVoZG90ZXR1dCB0ZW1hYXR0aXNldCByeWhtw6R0KipcXG5cXG4ke2dyb3Vwc31cXG5cXG4qKlZhaWh0b2VodG9pc2V0IHRlcm1pdCoqXFxuXFxuJHthbHRUZXJtc31cXG5cXG4qKkFsYWvDpHNpdHRlZXQgKFJUKSoqXFxuXFxuJHtucnJMYWJsc31cXG5cXG4qKkFzc29zaWF0aWl2aXNldCAoUlQpKipcXG5cXG4ke3JsdGRMYWJsc31cXG5cXG4qKlZhc3RhYXZhIGvDpHNpdGUgbXV1c3NhIHNhbmFzdG9zc2EqKlxcblxcbiR7ZXhjdExhYmxzfVxcblxcbioqQWluZWlzdG8gam9ua2Ega3V2YWlsdXNzYSBrw6RzaXRldHTDpCB0YXJ2aXRhYW4gKGVzaW0uIG5pbWVrZSB0YWkgVVJMKSoqXFxuXFxuJHtmb3JtRGF0YS5uZWVkZWRGb3J9XFxuXFxuKipFaGRvdHRhamFuIG9yZ2FuaXNhYXRpbyoqXFxuXFxuJHtmb3JtRGF0YS5mcm9tT3JnfVxcbmA7XFxuXFxuICAgICAgbGV0IGRhdGFCdW5kbGUgPSB7XFxuICAgICAgICAvLyB0aXRsZTogZm9ybURhdGEucHJlZkxhYmVsLnN2LnZhbHVlICE9PSAnJyA/IGZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSA6IGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSxcXG4gICAgICAgIHRpdGxlOiAgd2luZG93LmxhbmcgPT09ICdzdicgPyBmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWUgOiBmb3JtRGF0YS5wcmVmTGFiZWwuZmkudmFsdWUsXFxuICAgICAgICBib2R5OiBkYXRhLFxcbiAgICAgICAgc3RhdGU6ICdvcGVuJyxcXG4gICAgICAgIGxhYmVsczogbGFiZWxzSW5UYXJnZXRTdWdnZXN0aW9uU3lzdGVtLFxcbiAgICAgIH07XFxuICAgICAgY29uc3QgcGF5bG9hZCA9IGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShkYXRhQnVuZGxlKSk7XFxuICAgICAgLy8gY29uc29sZS5sb2coXFxcInBheWxvYWRcXFwiLCBwYXlsb2FkKVxcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XFxuICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxcbiAgICAgIH07XFxuICAgICAgY29uc3QgdXJsVG9QcnggPSByZXF1aXJlKCcuLi9wcnguanNvbicpO1xcbiAgICAgIGF3YWl0IGF4aW9zXFxuICAgICAgLy8gaHR0cHM6Ly9maW50by5maS9wbHVnaW5zL3N1Z2dlc3Rpb25zL2doX3ByeC5waHBcXG4gICAgICAvLyBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLzpvd25lci86cmVwb1xcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW50by1laGRvdHVzL1lTRVxcbiAgICAgICAgICAucG9zdChgJHt1cmxUb1ByeFswXS51cmx9P3BheWxvYWQ9JHtwYXlsb2FkfWAsIHt9LCB7IGhlYWRlcnMgfSlcXG4gICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1Jlc3BvbnNlOicsIHJlc3BvbnNlKVxcbiAgICAgICAgICAgIC8vIHRvZ2dsZVN1Y2Nlc3NNZXNzYWdlKGBodHRwczovL2dpdGh1Yi5jb20vRmludG8tZWhkb3R1cy9ZU0VgKTtcXG4gICAgICAgICAgICB0b2dnbGVTdWNjZXNzTWVzc2FnZShgJHtyZXNwb25zZS5kYXRhLnVybC5yZXBsYWNlKCcvcmVwb3MnLCAnJykucmVwbGFjZSgnYXBpLicsICcnKX1gKTtcXG4gICAgICAgICAgfSlcXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xcbiAgICAgICAgICAgIHRvZ2dsZUZhaWx1cmVNZXNzYWdlKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBjb25zdCB0b2dnbGVTdWNjZXNzTWVzc2FnZSA9IChyZXNwb25zZVVybCkgPT4ge1xcbiAgICAgIGlmIChyZXNwb25zZVVybCAmJiByZXNwb25zZVVybC5sZW5ndGggPiAwKSB7XFxuICAgICAgICBzdWdnZXN0aW9uVXJsLnZhbHVlID0gcmVzcG9uc2VVcmw7XFxuICAgICAgICBzaG93U3VjY2Vzc01lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBzaG93U3VjY2Vzc01lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICB9O1xcbiAgICBjb25zdCB0b2dnbGVGYWlsdXJlTWVzc2FnZSA9ICgpID0+IHtcXG4gICAgICBzaG93RmFpbHVyZU1lc3NhZ2UudmFsdWUgPSB0cnVlO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBoYW5kbGVQcmVmTGFiZWxMYW5ndWFnZXMgPSAoKSA9PiB7XFxuICAgICAgZm9ybURhdGEucHJlZkxhYmVsLmZpLnZhbHVlID0gZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnk7XFxuICAgICAgaWYgKHdpbmRvdy5sYW5nID09PSAnZmknIHx8IHdpbmRvdy5sYW5nID09PSAnZW4nKSB7IC8vIG11dXRvcyAyMDIzLTA5LTE4IGxpc8OkdHRpaW4gZW4gZWh0b1xcbiAgICAgICAgZm9ybURhdGEucHJlZkxhYmVsLmZpLnZhbHVlID0gZm9ybURhdGEucHJlZkxhYmVsLnByaW1hcnk7XFxuICAgICAgICBmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWUgPSBmb3JtRGF0YS5wcmVmTGFiZWwuc2Vjb25kYXJ5O1xcbiAgICAgIH0gZWxzZSBpZiAod2luZG93LmxhbmcgPT09ICdzdicpIHtcXG4gICAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSA9IGZvcm1EYXRhLnByZWZMYWJlbC5wcmltYXJ5O1xcbiAgICAgICAgZm9ybURhdGEucHJlZkxhYmVsLmZpLnZhbHVlID0gZm9ybURhdGEucHJlZkxhYmVsLnNlY29uZGFyeTtcXG4gICAgICB9XFxuICAgICAgLy8gZm9ybURhdGEucHJlZkxhYmVsLmZpLnZhbHVlID8gY29uc29sZS5sb2coXFxcImZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZVxcXCIsIGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSkgOiBjb25zb2xlLmxvZyhcXFwiZm9ybURhdGEucHJlZkxhYmVsLmZpLnZhbHVlIFhcXFwiKVxcbiAgICAgIC8vIGZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSA/IGNvbnNvbGUubG9nKFxcXCJmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWVcXFwiLCBmb3JtRGF0YS5wcmVmTGFiZWwuc3YudmFsdWUpIDogY29uc29sZS5sb2coXFxcImZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSBYXFxcIilcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgY2xvc2VEaWFsb2cgPSAoKSA9PiB7XFxuICAgICAgaXNPcGVuZWQudmFsdWUgPSAhaXNPcGVuZWQudmFsdWU7XFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLnZhbHVlID0gZmFsc2U7XFxuICAgICAgc2hvd0ZhaWx1cmVNZXNzYWdlLnZhbHVlID0gZmFsc2U7XFxuICAgICAgc3VnZ2VzdGlvblVybC52YWx1ZSA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLnZvY2FidWxhcnkgPSAneXNvJztcXG4gICAgICBmb3JtRGF0YS5jb25jZXB0VHlwZS52YWx1ZSA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5wcmltYXJ5ID0gJyc7XFxuICAgICAgZm9ybURhdGEucHJlZkxhYmVsLnNlY29uZGFyeSA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5maS52YWx1ZSA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5zdi52YWx1ZSA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLnByZWZMYWJlbC5lbiA9ICcnO1xcbiAgICAgIGZvcm1EYXRhLmFsdExhYmVscyA9IFt7IHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9XTtcXG4gICAgICBmb3JtRGF0YS5icm9hZGVyTGFiZWxzID0gW3sgdmFsdWU6ICcnLCB1cmk6ICcnLCBpc1RvdWNoZWQ6IGZhbHNlIH1dO1xcbiAgICAgIGZvcm1EYXRhLm5hcnJvd2VyTGFiZWxzID0gW3sgdmFsdWU6ICcnLCB1cmk6ICcnLCBpc1RvdWNoZWQ6IGZhbHNlIH1dO1xcbiAgICAgIGZvcm1EYXRhLnJlbGF0ZWRMYWJlbHMgPSBbeyB2YWx1ZTogJycsIHVyaTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV07XFxuICAgICAgZm9ybURhdGEuZ3JvdXBzLnNlbGVjdGVkR3JvdXBzID0gW107XFxuICAgICAgZm9ybURhdGEuZXhhY3RNYXRjaGVzID0gW3sgdm9jYWI6ICcnLCB2YWx1ZTogJycsIGlzVG91Y2hlZDogZmFsc2UgfV07XFxuICAgICAgZm9ybURhdGEuc2NvcGVOb3RlID0gJyc7XFxuICAgICAgZm9ybURhdGEuZXhwbGFuYXRpb24gPSAnJztcXG4gICAgICBmb3JtRGF0YS5uZWVkZWRGb3IgPSAnJztcXG4gICAgICBmb3JtRGF0YS5mcm9tT3JnID0gJyc7XFxuICAgICAgc2V0RHJvcERvd24oKTtcXG4gICAgICAvLyAkdi4kcmVzZXQoKTtcXG4gICAgICBnZXRHcm91cHMoKTtcXG4gICAgICBzZW5kaW5nLnZhbHVlID0gZmFsc2VcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgZ2V0VXJsID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIHBhZ2VVcmwudmFsdWUgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgZ2V0R3JvdXBzID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIGF3YWl0IGF4aW9zXFxuICAgICAgICAgIC5nZXQoYGh0dHBzOi8vYXBpLmZpbnRvLmZpL3Jlc3QvdjEvJHtmb3JtRGF0YS52b2NhYnVsYXJ5fS9ncm91cHNgLCB7XFxuICAgICAgICAgICAgcGFyYW1zOiB7XFxuICAgICAgICAgICAgICAvLyBsYW5nOiBwcm9wcy5sYW5nLFxcbiAgICAgICAgICAgICAgbGFuZzogd2luZG93LmxhbmcgPT09ICdlbicgPyAnZmknIDogd2luZG93LmxhbmdcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICB9KVxcbiAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IChmb3JtRGF0YS5ncm91cHMuYWxsR3JvdXBzID0gcmVzcG9uc2UuZGF0YS5ncm91cHMpKTtcXG4gICAgfTtcXG5cXG4gICAgLy8gTGlmZWN5Y2xlIGhvb2tzXFxuICAgIHdhdGNoRWZmZWN0KCgpID0+IHtcXG4gIC8qICAgIGlmIChwcm9wcy5sYW5nID09PSAnc3YnKSB7XFxuICAgICAgICAvLyBOb3RlOiAndGhpcycgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgc2V0dXAgZnVuY3Rpb24uXFxuICAgICAgICAvLyBJbnN0ZWFkLCB5b3UgY2FuIHVzZSAncHJvcHMnIGRpcmVjdGx5LlxcbiAgICAgIH0qL1xcbiAgICAgIHNldERyb3BEb3duKCk7XFxuICAgICAgZ2V0R3JvdXBzKCk7XFxuICAgIH0pO1xcblxcbiAgICBnZXRHcm91cHMoKTtcXG5cXG4gICAgLy8gUmV0dXJuIHRoZSB2YXJpYWJsZXMgYW5kIG1ldGhvZHMgeW91IHdhbnQgdG8gZXhwb3NlIHRvIHRoZSB0ZW1wbGF0ZVxcbiAgICByZXR1cm4ge1xcbiAgICAgIHBhZ2VVcmwsXFxuICAgICAgaXNPcGVuZWQsXFxuICAgICAgc2hvd1N1Y2Nlc3NNZXNzYWdlLFxcbiAgICAgIHNob3dGYWlsdXJlTWVzc2FnZSxcXG4gICAgICBzdWdnZXN0aW9uVXJsLFxcbiAgICAgIGZvcm1EYXRhLFxcbiAgICAgIGNvbmNlcHRUeXBlSXNTZWxlY3RlZCxcXG4gICAgICBwcmVmTGFiZWxPa2F5LFxcbiAgICAgIGV4cGxhbmF0aW9uT2theSxcXG4gICAgICBuZWVkZWRGb3JPa2F5LFxcbiAgICAgIHNldERyb3BEb3duLFxcbiAgICAgIGFkZEhUVFBPckhUVFBTLFxcbiAgICAgIHN1Ym1pdEZvcm0sXFxuICAgICAgc2VuZERhdGEsXFxuICAgICAgdG9nZ2xlU3VjY2Vzc01lc3NhZ2UsXFxuICAgICAgdG9nZ2xlRmFpbHVyZU1lc3NhZ2UsXFxuICAgICAgaGFuZGxlUHJlZkxhYmVsTGFuZ3VhZ2VzLFxcbiAgICAgIGNsb3NlRGlhbG9nLFxcbiAgICAgIGdldFVybCxcXG4gICAgICBnZXRHcm91cHMsXFxuICAgICAgZGF0YUNhbkJlU2VudEFycmF5LFxcbiAgICAgIHNlbmRpbmcsXFxuICAgICAgdGVzdGlcXG4gICAgfTtcXG4gIH0sXFxufSk7XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlPlxcbi5lcnJvciB7XFxuICBjb2xvcjogI2U4M2EzMDtcXG4gIHRleHQtaW5kZW50OiAycHg7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBtYXJnaW4tdG9wOiAtMTBweDtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcbjo6cGxhY2Vob2xkZXIge1xcbiAgY29sb3I6ICM1ZWE4Qjc7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG46LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gIGNvbG9yOiAjNWVhOEI3O1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuOjotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgY29sb3I6ICM1ZWE4Qjc7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8149\n");

/***/ }),

/***/ 3266:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nh5[data-v-8ddfc880] {\\n  font-weight: 500 !important;\\n  font-size: 15px;\\n  max-width: 60%;\\n}\\nstrong[data-v-8ddfc880] {\\n  font-weight: 600 !important;\\n}\\na[data-v-8ddfc880] {\\n  color: #00748f;\\n  font-weight: 500 !important;\\n}\\n.dialog-overlay[data-v-8ddfc880] {\\n  position: fixed;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  background-color: rgba(0, 0, 0, 0.5);\\n  text-align: center;\\n  z-index: 10000;\\n}\\n.dialog-modal[data-v-8ddfc880] {\\n  font-size: 14px;\\n  color: #474b4f;\\n  background-color: #ffffff;\\n  position: fixed;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  min-height: 60px;\\n  max-height: calc(100% - 80px);\\n  width: 650px;\\n  overflow-y: auto;\\n  z-index: 10001;\\n  padding: 0;\\n  border-top: 2px solid #000000;\\n}\\n.dialog-content[data-v-8ddfc880] {\\n  padding: 25px 30px 20px;\\n}\\n.dialog-close[data-v-8ddfc880] {\\n  position: absolute;\\n  top: 25px;\\n  right: 30px;\\n  background: rgba(255, 255, 255, 0.3);\\n}\\n@media (max-width: 850px) {\\n.dialog-modal[data-v-8ddfc880] {\\n    max-width: calc(100% - 100px);\\n    width: 80vw;\\n    min-width: 200px;\\n}\\n.dialog-content[data-v-8ddfc880] {\\n    padding: 40px 20px 25px;\\n}\\n.dialog-close[data-v-8ddfc880] {\\n    right: 20px;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/common/CenteredDialog.vue\"],\"names\":[],\"mappings\":\";AAmDA;EACE,2BAA2B;EAC3B,eAAe;EACf,cAAc;AAChB;AACA;EACE,2BAA2B;AAC7B;AACA;EACE,cAAc;EACd,2BAA2B;AAC7B;AACA;EACE,eAAe;EACf,WAAW;EACX,YAAY;EACZ,MAAM;EACN,OAAO;EACP,QAAQ;EACR,SAAS;EACT,oCAAoC;EACpC,kBAAkB;EAClB,cAAc;AAChB;AAEA;EACE,eAAe;EACf,cAAc;EACd,yBAAyB;EACzB,eAAe;EACf,QAAQ;EACR,SAAS;EACT,gCAAgC;EAChC,gBAAgB;EAChB,6BAA6B;EAC7B,YAAY;EACZ,gBAAgB;EAChB,cAAc;EACd,UAAU;EACV,6BAA6B;AAC/B;AAEA;EACE,uBAAuB;AACzB;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,oCAAoC;AACtC;AAEA;AACE;IACE,6BAA6B;IAC7B,WAAW;IACX,gBAAgB;AAClB;AACA;IACE,uBAAuB;AACzB;AAEA;IACE,WAAW;AACb;AACF\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"template\\\">\\n    <div class=\\\"dialog-overlay\\\"></div>\\n    <div class=\\\"dialog-modal\\\">\\n      <div class=\\\"dialog-content\\\">\\n        <div class=\\\"dialog-close\\\" @click=\\\"close\\\">\\n          <svg-icon icon-name=\\\"cross\\\"><icon-cross /></svg-icon>\\n        </div>\\n        <slot></slot>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\\nimport SvgIcon from '../icons/SvgIcon.vue';\\nimport IconCross from '../icons/IconCross.vue';\\n\\nexport default {\\n  components: {\\n    SvgIcon,\\n    IconCross\\n  },\\n  setup(_, { emit }) {\\n    const close = () => {\\n      emit('close');\\n    };\\n\\n    const handleEscKey = (e) => {\\n      if (e.keyCode === 27) {\\n        close();\\n      }\\n    };\\n\\n    onMounted(() => {\\n      document.addEventListener('keydown', handleEscKey);\\n    });\\n\\n    onBeforeUnmount(() => {\\n      document.removeEventListener('keydown', handleEscKey);\\n    });\\n\\n    return {\\n      close\\n    };\\n  }\\n};\\n</script>\\n\\n<style scoped>\\nh5 {\\n  font-weight: 500 !important;\\n  font-size: 15px;\\n  max-width: 60%;\\n}\\nstrong {\\n  font-weight: 600 !important;\\n}\\na {\\n  color: #00748f;\\n  font-weight: 500 !important;\\n}\\n.dialog-overlay {\\n  position: fixed;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  background-color: rgba(0, 0, 0, 0.5);\\n  text-align: center;\\n  z-index: 10000;\\n}\\n\\n.dialog-modal {\\n  font-size: 14px;\\n  color: #474b4f;\\n  background-color: #ffffff;\\n  position: fixed;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  min-height: 60px;\\n  max-height: calc(100% - 80px);\\n  width: 650px;\\n  overflow-y: auto;\\n  z-index: 10001;\\n  padding: 0;\\n  border-top: 2px solid #000000;\\n}\\n\\n.dialog-content {\\n  padding: 25px 30px 20px;\\n}\\n\\n.dialog-close {\\n  position: absolute;\\n  top: 25px;\\n  right: 30px;\\n  background: rgba(255, 255, 255, 0.3);\\n}\\n\\n@media (max-width: 850px) {\\n  .dialog-modal {\\n    max-width: calc(100% - 100px);\\n    width: 80vw;\\n    min-width: 200px;\\n  }\\n  .dialog-content {\\n    padding: 40px 20px 25px;\\n  }\\n\\n  .dialog-close {\\n    right: 20px;\\n  }\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI2Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxpRUFBaUUsZ0NBQWdDLG9CQUFvQixtQkFBbUIsR0FBRywyQkFBMkIsZ0NBQWdDLEdBQUcsc0JBQXNCLG1CQUFtQixnQ0FBZ0MsR0FBRyxvQ0FBb0Msb0JBQW9CLGdCQUFnQixpQkFBaUIsV0FBVyxZQUFZLGFBQWEsY0FBYyx5Q0FBeUMsdUJBQXVCLG1CQUFtQixHQUFHLGtDQUFrQyxvQkFBb0IsbUJBQW1CLDhCQUE4QixvQkFBb0IsYUFBYSxjQUFjLHFDQUFxQyxxQkFBcUIsa0NBQWtDLGlCQUFpQixxQkFBcUIsbUJBQW1CLGVBQWUsa0NBQWtDLEdBQUcsb0NBQW9DLDRCQUE0QixHQUFHLGtDQUFrQyx1QkFBdUIsY0FBYyxnQkFBZ0IseUNBQXlDLEdBQUcsNkJBQTZCLGtDQUFrQyxvQ0FBb0Msa0JBQWtCLHVCQUF1QixHQUFHLG9DQUFvQyw4QkFBOEIsR0FBRyxrQ0FBa0Msa0JBQWtCLEdBQUcsR0FBRyxTQUFTLHVHQUF1RyxNQUFNLFlBQVksV0FBVyxVQUFVLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLFdBQVcsWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLDBaQUEwWixrQ0FBa0MsV0FBVyw2Q0FBNkMsaURBQWlELG9CQUFvQixpQkFBaUIsa0NBQWtDLGdCQUFnQixNQUFNLEdBQUcsMkJBQTJCLHNCQUFzQixRQUFRLHFDQUFxQywrQkFBK0Isa0JBQWtCLFNBQVMsUUFBUSx5QkFBeUIsMkRBQTJELE9BQU8sRUFBRSwrQkFBK0IsOERBQThELE9BQU8sRUFBRSxnQkFBZ0IscUJBQXFCLEtBQUssSUFBSSxtQ0FBbUMsZ0NBQWdDLG9CQUFvQixtQkFBbUIsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLEtBQUssbUJBQW1CLGdDQUFnQyxHQUFHLG1CQUFtQixvQkFBb0IsZ0JBQWdCLGlCQUFpQixXQUFXLFlBQVksYUFBYSxjQUFjLHlDQUF5Qyx1QkFBdUIsbUJBQW1CLEdBQUcsbUJBQW1CLG9CQUFvQixtQkFBbUIsOEJBQThCLG9CQUFvQixhQUFhLGNBQWMscUNBQXFDLHFCQUFxQixrQ0FBa0MsaUJBQWlCLHFCQUFxQixtQkFBbUIsZUFBZSxrQ0FBa0MsR0FBRyxxQkFBcUIsNEJBQTRCLEdBQUcsbUJBQW1CLHVCQUF1QixjQUFjLGdCQUFnQix5Q0FBeUMsR0FBRywrQkFBK0IsbUJBQW1CLG9DQUFvQyxrQkFBa0IsdUJBQXVCLEtBQUsscUJBQXFCLDhCQUE4QixLQUFLLHFCQUFxQixrQkFBa0IsS0FBSyxHQUFHLCtCQUErQjtBQUNyb0k7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlPzZhNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG5oNVtkYXRhLXYtOGRkZmM4ODBdIHtcXG4gIGZvbnQtd2VpZ2h0OiA1MDAgIWltcG9ydGFudDtcXG4gIGZvbnQtc2l6ZTogMTVweDtcXG4gIG1heC13aWR0aDogNjAlO1xcbn1cXG5zdHJvbmdbZGF0YS12LThkZGZjODgwXSB7XFxuICBmb250LXdlaWdodDogNjAwICFpbXBvcnRhbnQ7XFxufVxcbmFbZGF0YS12LThkZGZjODgwXSB7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGZvbnQtd2VpZ2h0OiA1MDAgIWltcG9ydGFudDtcXG59XFxuLmRpYWxvZy1vdmVybGF5W2RhdGEtdi04ZGRmYzg4MF0ge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB6LWluZGV4OiAxMDAwMDtcXG59XFxuLmRpYWxvZy1tb2RhbFtkYXRhLXYtOGRkZmM4ODBdIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjNDc0YjRmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBtaW4taGVpZ2h0OiA2MHB4O1xcbiAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gODBweCk7XFxuICB3aWR0aDogNjUwcHg7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgei1pbmRleDogMTAwMDE7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyLXRvcDogMnB4IHNvbGlkICMwMDAwMDA7XFxufVxcbi5kaWFsb2ctY29udGVudFtkYXRhLXYtOGRkZmM4ODBdIHtcXG4gIHBhZGRpbmc6IDI1cHggMzBweCAyMHB4O1xcbn1cXG4uZGlhbG9nLWNsb3NlW2RhdGEtdi04ZGRmYzg4MF0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAyNXB4O1xcbiAgcmlnaHQ6IDMwcHg7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA4NTBweCkge1xcbi5kaWFsb2ctbW9kYWxbZGF0YS12LThkZGZjODgwXSB7XFxuICAgIG1heC13aWR0aDogY2FsYygxMDAlIC0gMTAwcHgpO1xcbiAgICB3aWR0aDogODB2dztcXG4gICAgbWluLXdpZHRoOiAyMDBweDtcXG59XFxuLmRpYWxvZy1jb250ZW50W2RhdGEtdi04ZGRmYzg4MF0ge1xcbiAgICBwYWRkaW5nOiA0MHB4IDIwcHggMjVweDtcXG59XFxuLmRpYWxvZy1jbG9zZVtkYXRhLXYtOGRkZmM4ODBdIHtcXG4gICAgcmlnaHQ6IDIwcHg7XFxufVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9jb21tb24vQ2VudGVyZWREaWFsb2cudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFtREE7RUFDRSwyQkFBMkI7RUFDM0IsZUFBZTtFQUNmLGNBQWM7QUFDaEI7QUFDQTtFQUNFLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0UsY0FBYztFQUNkLDJCQUEyQjtBQUM3QjtBQUNBO0VBQ0UsZUFBZTtFQUNmLFdBQVc7RUFDWCxZQUFZO0VBQ1osTUFBTTtFQUNOLE9BQU87RUFDUCxRQUFRO0VBQ1IsU0FBUztFQUNULG9DQUFvQztFQUNwQyxrQkFBa0I7RUFDbEIsY0FBYztBQUNoQjtBQUVBO0VBQ0UsZUFBZTtFQUNmLGNBQWM7RUFDZCx5QkFBeUI7RUFDekIsZUFBZTtFQUNmLFFBQVE7RUFDUixTQUFTO0VBQ1QsZ0NBQWdDO0VBQ2hDLGdCQUFnQjtFQUNoQiw2QkFBNkI7RUFDN0IsWUFBWTtFQUNaLGdCQUFnQjtFQUNoQixjQUFjO0VBQ2QsVUFBVTtFQUNWLDZCQUE2QjtBQUMvQjtBQUVBO0VBQ0UsdUJBQXVCO0FBQ3pCO0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsU0FBUztFQUNULFdBQVc7RUFDWCxvQ0FBb0M7QUFDdEM7QUFFQTtBQUNFO0lBQ0UsNkJBQTZCO0lBQzdCLFdBQVc7SUFDWCxnQkFBZ0I7QUFDbEI7QUFDQTtJQUNFLHVCQUF1QjtBQUN6QjtBQUVBO0lBQ0UsV0FBVztBQUNiO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwidGVtcGxhdGVcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkaWFsb2ctb3ZlcmxheVxcXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImRpYWxvZy1tb2RhbFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZGlhbG9nLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGlhbG9nLWNsb3NlXFxcIiBAY2xpY2s9XFxcImNsb3NlXFxcIj5cXG4gICAgICAgICAgPHN2Zy1pY29uIGljb24tbmFtZT1cXFwiY3Jvc3NcXFwiPjxpY29uLWNyb3NzIC8+PC9zdmctaWNvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHNsb3Q+PC9zbG90PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgeyByZWYsIG9uTW91bnRlZCwgb25CZWZvcmVVbm1vdW50IH0gZnJvbSAndnVlJztcXG5pbXBvcnQgU3ZnSWNvbiBmcm9tICcuLi9pY29ucy9TdmdJY29uLnZ1ZSc7XFxuaW1wb3J0IEljb25Dcm9zcyBmcm9tICcuLi9pY29ucy9JY29uQ3Jvc3MudnVlJztcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIFN2Z0ljb24sXFxuICAgIEljb25Dcm9zc1xcbiAgfSxcXG4gIHNldHVwKF8sIHsgZW1pdCB9KSB7XFxuICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xcbiAgICAgIGVtaXQoJ2Nsb3NlJyk7XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IGhhbmRsZUVzY0tleSA9IChlKSA9PiB7XFxuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcXG4gICAgICAgIGNsb3NlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVFc2NLZXkpO1xcbiAgICB9KTtcXG5cXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlRXNjS2V5KTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgY2xvc2VcXG4gICAgfTtcXG4gIH1cXG59O1xcbjwvc2NyaXB0PlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuaDUge1xcbiAgZm9udC13ZWlnaHQ6IDUwMCAhaW1wb3J0YW50O1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgbWF4LXdpZHRoOiA2MCU7XFxufVxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogNjAwICFpbXBvcnRhbnQ7XFxufVxcbmEge1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBmb250LXdlaWdodDogNTAwICFpbXBvcnRhbnQ7XFxufVxcbi5kaWFsb2ctb3ZlcmxheSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41KTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDEwMDAwO1xcbn1cXG5cXG4uZGlhbG9nLW1vZGFsIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjNDc0YjRmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBtaW4taGVpZ2h0OiA2MHB4O1xcbiAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gODBweCk7XFxuICB3aWR0aDogNjUwcHg7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgei1pbmRleDogMTAwMDE7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyLXRvcDogMnB4IHNvbGlkICMwMDAwMDA7XFxufVxcblxcbi5kaWFsb2ctY29udGVudCB7XFxuICBwYWRkaW5nOiAyNXB4IDMwcHggMjBweDtcXG59XFxuXFxuLmRpYWxvZy1jbG9zZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDI1cHg7XFxuICByaWdodDogMzBweDtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDg1MHB4KSB7XFxuICAuZGlhbG9nLW1vZGFsIHtcXG4gICAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSAxMDBweCk7XFxuICAgIHdpZHRoOiA4MHZ3O1xcbiAgICBtaW4td2lkdGg6IDIwMHB4O1xcbiAgfVxcbiAgLmRpYWxvZy1jb250ZW50IHtcXG4gICAgcGFkZGluZzogNDBweCAyMHB4IDI1cHg7XFxuICB9XFxuXFxuICAuZGlhbG9nLWNsb3NlIHtcXG4gICAgcmlnaHQ6IDIwcHg7XFxuICB9XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3266\n");

/***/ }),

/***/ 341:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nh2[data-v-bb99f552] {\\n  margin-top: 6px;\\n}\\np[data-v-bb99f552] {\\n  margin-top: 16px;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/common/FailureMessage.vue\"],\"names\":[],\"mappings\":\";AAeA;EACE,eAAe;AACjB;AAEA;EACE,gBAAgB;AAClB\",\"sourcesContent\":[\"<template>\\n<div>\\n  <h2>{{ $t('messages.failed.h2') }}</h2>\\n  <p>{{ $t('messages.failed.p_1a') }}</p>\\n  <p>{{ $t('messages.failed.p_1b') }}</p>\\n</div>\\n</template>\\n\\n<script>\\nexport default {\\n\\n}\\n</script>\\n\\n<style scoped>\\nh2 {\\n  margin-top: 6px;\\n}\\n\\np {\\n  margin-top: 16px;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQxLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDNEg7QUFDN0I7QUFDL0YsOEJBQThCLG1GQUEyQixDQUFDLHdHQUFxQztBQUMvRjtBQUNBLGlFQUFpRSxvQkFBb0IsR0FBRyxzQkFBc0IscUJBQXFCLEdBQUcsU0FBUyx1R0FBdUcsS0FBSyxVQUFVLE1BQU0sS0FBSyxZQUFZLHNEQUFzRCwyQkFBMkIsZUFBZSw2QkFBNkIsY0FBYyw2QkFBNkIsdURBQXVELEtBQUssbUNBQW1DLG9CQUFvQixHQUFHLE9BQU8scUJBQXFCLEdBQUcsK0JBQStCO0FBQ3huQjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWU/ODQzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcbmgyW2RhdGEtdi1iYjk5ZjU1Ml0ge1xcbiAgbWFyZ2luLXRvcDogNnB4O1xcbn1cXG5wW2RhdGEtdi1iYjk5ZjU1Ml0ge1xcbiAgbWFyZ2luLXRvcDogMTZweDtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL0ZhaWx1cmVNZXNzYWdlLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBZUE7RUFDRSxlQUFlO0FBQ2pCO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbjxkaXY+XFxuICA8aDI+e3sgJHQoJ21lc3NhZ2VzLmZhaWxlZC5oMicpIH19PC9oMj5cXG4gIDxwPnt7ICR0KCdtZXNzYWdlcy5mYWlsZWQucF8xYScpIH19PC9wPlxcbiAgPHA+e3sgJHQoJ21lc3NhZ2VzLmZhaWxlZC5wXzFiJykgfX08L3A+XFxuPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG5cXG59XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlIHNjb3BlZD5cXG5oMiB7XFxuICBtYXJnaW4tdG9wOiA2cHg7XFxufVxcblxcbnAge1xcbiAgbWFyZ2luLXRvcDogMTZweDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///341\n");

/***/ }),

/***/ 7847:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nh2[data-v-5ab5b3da] {\\n  margin-top: 6px;\\n}\\np[data-v-5ab5b3da] {\\n  margin-top: 16px;\\n}\\na[data-v-5ab5b3da] {\\n  color: #00748f;\\n  font-weight: 500;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/common/SuccessMessage.vue\"],\"names\":[],\"mappings\":\";AA0BA;EACE,eAAe;AACjB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,cAAc;EACd,gBAAgB;AAClB\",\"sourcesContent\":[\"<template>\\n<div>\\n  <h2>{{ $t('messages.success.h2') }}</h2>\\n  <p>{{ $t('messages.success.p_1') }}</p>\\n  <p v-if=\\\"!suggestionUrl || suggestionUrl.length === 0\\\">\\n    {{ $t('messages.success.p_2a') }}\\n    <a :href=\\\"url\\\">{{ $t('messages.success.p_2b') }}</a>.\\n  </p>\\n  <p v-if=\\\"suggestionUrl && suggestionUrl.length > 0\\\">\\n    {{ $t('messages.success.p_2a') }}\\n    <a target=\\\"_blank\\\" :href=\\\"suggestionUrl\\\">{{ $t('messages.success.p_2b') }}</a>.\\n  </p>\\n</div>\\n</template>\\n\\n<script>\\nexport default {\\n  props: {\\n    suggestionUrl: String,\\n    url: String\\n  }\\n\\n}\\n</script>\\n\\n<style scoped>\\nh2 {\\n  margin-top: 6px;\\n}\\n\\np {\\n  margin-top: 16px;\\n}\\n\\na {\\n  color: #00748f;\\n  font-weight: 500;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg0Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxpRUFBaUUsb0JBQW9CLEdBQUcsc0JBQXNCLHFCQUFxQixHQUFHLHNCQUFzQixtQkFBbUIscUJBQXFCLEdBQUcsU0FBUyx1R0FBdUcsTUFBTSxVQUFVLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksc0RBQXNELDRCQUE0QixlQUFlLDZCQUE2QiwwRUFBMEUsOEJBQThCLDBCQUEwQiw4QkFBOEIsZ0ZBQWdGLDhCQUE4QixzREFBc0QsOEJBQThCLGdFQUFnRSxZQUFZLGtEQUFrRCxLQUFLLG1DQUFtQyxvQkFBb0IsR0FBRyxPQUFPLHFCQUFxQixHQUFHLE9BQU8sbUJBQW1CLHFCQUFxQixHQUFHLCtCQUErQjtBQUM1b0M7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9jb21tb24vU3VjY2Vzc01lc3NhZ2UudnVlPzIxMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG5oMltkYXRhLXYtNWFiNWIzZGFdIHtcXG4gIG1hcmdpbi10b3A6IDZweDtcXG59XFxucFtkYXRhLXYtNWFiNWIzZGFdIHtcXG4gIG1hcmdpbi10b3A6IDE2cHg7XFxufVxcbmFbZGF0YS12LTVhYjViM2RhXSB7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9TdWNjZXNzTWVzc2FnZS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTBCQTtFQUNFLGVBQWU7QUFDakI7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsY0FBYztFQUNkLGdCQUFnQjtBQUNsQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuPGRpdj5cXG4gIDxoMj57eyAkdCgnbWVzc2FnZXMuc3VjY2Vzcy5oMicpIH19PC9oMj5cXG4gIDxwPnt7ICR0KCdtZXNzYWdlcy5zdWNjZXNzLnBfMScpIH19PC9wPlxcbiAgPHAgdi1pZj1cXFwiIXN1Z2dlc3Rpb25VcmwgfHwgc3VnZ2VzdGlvblVybC5sZW5ndGggPT09IDBcXFwiPlxcbiAgICB7eyAkdCgnbWVzc2FnZXMuc3VjY2Vzcy5wXzJhJykgfX1cXG4gICAgPGEgOmhyZWY9XFxcInVybFxcXCI+e3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MucF8yYicpIH19PC9hPi5cXG4gIDwvcD5cXG4gIDxwIHYtaWY9XFxcInN1Z2dlc3Rpb25VcmwgJiYgc3VnZ2VzdGlvblVybC5sZW5ndGggPiAwXFxcIj5cXG4gICAge3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MucF8yYScpIH19XFxuICAgIDxhIHRhcmdldD1cXFwiX2JsYW5rXFxcIiA6aHJlZj1cXFwic3VnZ2VzdGlvblVybFxcXCI+e3sgJHQoJ21lc3NhZ2VzLnN1Y2Nlc3MucF8yYicpIH19PC9hPi5cXG4gIDwvcD5cXG48L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgcHJvcHM6IHtcXG4gICAgc3VnZ2VzdGlvblVybDogU3RyaW5nLFxcbiAgICB1cmw6IFN0cmluZ1xcbiAgfVxcblxcbn1cXG48L3NjcmlwdD5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbmgyIHtcXG4gIG1hcmdpbi10b3A6IDZweDtcXG59XFxuXFxucCB7XFxuICBtYXJnaW4tdG9wOiAxNnB4O1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7847\n");

/***/ }),

/***/ 5265:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.input-container[data-v-eafbc960] {\\n  margin-bottom: 16px;\\n  width: 50%;\\n  position: relative;\\n}\\n.input-container label[data-v-eafbc960] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.select-button[data-v-eafbc960] {\\n  position: relative;\\n  display: block;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border: none;\\n  border-radius: 1px;\\n  font-size: 14px;\\n  outline: none;\\n  -webkit-appearance: none;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.select-button .select-content[data-v-eafbc960] {\\n  position: absolute;\\n  top: 55%;\\n  left: 14px;\\n  transform: perspective(1px) translateY(-50%);\\n  overflow: hidden;\\n  font-size: 13px;\\n  font-weight: 400;\\n  color: #00748f;\\n}\\n.select-button svg[data-v-eafbc960] {\\n  position: absolute;\\n  top: 60%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 16px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n.opened svg[data-v-eafbc960] {\\n  top: 25%;\\n  transform: scaleY(-1);\\n}\\n.drop-down-options[data-v-eafbc960] {\\n  position: absolute;\\n  top: 68px;\\n  left: 0;\\n  width: calc(100% - 2px);\\n  z-index: 4;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n.option[data-v-eafbc960] {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n.option[data-v-eafbc960]:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.option p[data-v-eafbc960] {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n.option svg[data-v-eafbc960] {\\n  height: 10px;\\n  margin-right: 5px;\\n  vertical-align: middle;\\n}\\n.selected[data-v-eafbc960] {\\n  font-weight: 500;\\n}\\n.hidden-checkmark[data-v-eafbc960] {\\n  opacity: 0;\\n}\\n.empty-options[data-v-eafbc960] {\\n  min-width: 250px;\\n}\\n@media (max-width: 700px) {\\n.input-container[data-v-eafbc960] {\\n    width: 100%;\\n}\\n.option[data-v-eafbc960] {\\n    padding: 12px 6px 11px;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/BasicDropDown.vue\"],\"names\":[],\"mappings\":\";AAsGA;EACE,mBAAmB;EACnB,UAAU;EACV,kBAAkB;AACpB;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,YAAY;EACZ,cAAc;EACd,yBAAyB;EACzB,YAAY;EACZ,kBAAkB;EAClB,eAAe;EACf,aAAa;EACb,wBAAwB;EACxB,eAAe;EACf,YAAY;AACd;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,4CAA4C;EAC5C,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,cAAc;AAChB;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,4CAA4C;EAC5C,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;AACtB;AAEA;EACE,QAAQ;EACR,qBAAqB;AACvB;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,uBAAuB;EACvB,UAAU;EACV,yBAAyB;EACzB,yBAAyB;EACzB,kBAAkB;EAClB,+DAA+D;EAC/D,4DAA4D;EAC5D,uDAAuD;AACzD;AAEA;EACE,sBAAsB;EACtB,gCAAgC;EAChC,cAAc;EACd,sBAAsB;AACxB;AAEA;EACE,yBAAyB;EACzB,cAAc;EACd,eAAe;EACf,YAAY;AACd;AAEA;EACE,qBAAqB;EACrB,SAAS;EACT,eAAe;EACf,gBAAgB;AAClB;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,sBAAsB;AACxB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,UAAU;AACZ;AAEA;EACE,gBAAgB;AAClB;AAEA;AACE;IACE,WAAW;AACb;AAEA;IACE,sBAAsB;AACxB;AACF\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"input-container\\\">\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <div\\n        @click=\\\"isOpened = !isOpened\\\"\\n        :class=\\\"[isOpened ? 'opened' : '', 'select-button']\\\">\\n      <div class=\\\"select-content\\\">\\n        <span v-if=\\\"!value\\\">{{ $t('new.conceptType.placeholder') }}</span>\\n        <span v-if=\\\"value && value.length > 0\\\" class=\\\"selected\\\">{{ value }}</span>\\n      </div>\\n      <svg-icon icon-name=\\\"triangle\\\"><icon-triangle /></svg-icon>\\n    </div>\\n    <div\\n        v-if=\\\"isOpened && options.length === 0\\\"\\n        class=\\\"drop-down-options empty-options\\\"\\n        v-on-click-away=\\\"closeDropDown\\\">\\n      <div class=\\\"option\\\" style=\\\"padding-left: 16px;\\\">\\n        <span>{{ noOptionsMessage }}</span>\\n      </div>\\n    </div>\\n    <div v-if=\\\"isOpened && options.length > 0\\\"\\n         class=\\\"drop-down-options\\\"\\n         v-on-click-away=\\\"closeDropDown\\\">\\n      <div v-for=\\\"(option, i) in options\\\"\\n           :key=\\\"option.id\\\"\\n           @click=\\\"selectOption(i)\\\"\\n           :class=\\\"[isSelected(i) ? 'selected' : '', 'option']\\\">\\n        <svg-icon\\n            :class=\\\"[isSelected(i) ? '' : 'hidden-checkmark']\\\"\\n            icon-name=\\\"check\\\"><icon-check />\\n        </svg-icon>\\n        <p>{{ $t(option.value) }}</p>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport {ref, onMounted, onBeforeUnmount, inject} from 'vue';\\nimport SvgIcon from '../icons/SvgIcon.vue';\\nimport IconTriangle from '../icons/IconTriangle.vue';\\nimport IconCheck from '../icons/IconCheck.vue';\\nimport { directive as onClickAway } from 'vue3-click-away';\\n\\nexport default {\\n  components: {\\n    SvgIcon,\\n    IconTriangle,\\n    IconCheck\\n  },\\n  directives: {\\n    onClickAway\\n  },\\n  props: {\\n    value: String,\\n    options: Array,\\n    label: Object\\n  },\\n  setup(props, context) {\\n    const $t = inject('$t');\\n    const selectedIndex = ref(-1);\\n    const isOpened = ref(false);\\n    const count = ref(0)\\n    const noOptionsMessage = context.attrs['onUpdate:noOptionsMessage'] || 'No options available';\\n    const selectOption = (index) => {\\n      selectedIndex.value = index;\\n      isOpened.value = false;\\n      context.emit('changeVocabulary', props.options[index].vocab);\\n      context.emit('select', $t(props.options[index].value)); // path\\n    };\\n\\n    const handleClick = () => {\\n      console.log('BEFORE: Clicked! isOpened:', isOpened.value);\\n      isOpened.value = !isOpened.value;\\n      console.log('AFTER: Clicked! isOpened:', isOpened.value);\\n    };\\n\\n    // const isSelected = (index) => selectedIndex.value === index;\\n    const isSelected = (index) => {\\n      return selectedIndex.value === index;\\n    };\\n\\n    const closeDropDown = () => {\\n      isOpened.value = false;\\n    };\\n\\n    return {\\n      isOpened,\\n      noOptionsMessage,\\n      count,\\n      selectOption,\\n      isSelected,\\n      closeDropDown,\\n      handleClick\\n    };\\n  }\\n};\\n</script>\\n\\n\\n\\n<style scoped>\\n.input-container {\\n  margin-bottom: 16px;\\n  width: 50%;\\n  position: relative;\\n}\\n\\n.input-container label {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.select-button {\\n  position: relative;\\n  display: block;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border: none;\\n  border-radius: 1px;\\n  font-size: 14px;\\n  outline: none;\\n  -webkit-appearance: none;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.select-button .select-content {\\n  position: absolute;\\n  top: 55%;\\n  left: 14px;\\n  transform: perspective(1px) translateY(-50%);\\n  overflow: hidden;\\n  font-size: 13px;\\n  font-weight: 400;\\n  color: #00748f;\\n}\\n\\n.select-button svg {\\n  position: absolute;\\n  top: 60%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 16px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n\\n.opened svg {\\n  top: 25%;\\n  transform: scaleY(-1);\\n}\\n\\n.drop-down-options {\\n  position: absolute;\\n  top: 68px;\\n  left: 0;\\n  width: calc(100% - 2px);\\n  z-index: 4;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n\\n.option {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n\\n.option:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.option p {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n\\n.option svg {\\n  height: 10px;\\n  margin-right: 5px;\\n  vertical-align: middle;\\n}\\n\\n.selected {\\n  font-weight: 500;\\n}\\n\\n.hidden-checkmark {\\n  opacity: 0;\\n}\\n\\n.empty-options {\\n  min-width: 250px;\\n}\\n\\n@media (max-width: 700px) {\\n  .input-container {\\n    width: 100%;\\n  }\\n\\n  .option {\\n    padding: 12px 6px 11px;\\n  }\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW9CLGlCQUFpQixHQUFHLG9DQUFvQyx1QkFBdUIsYUFBYSxlQUFlLGlEQUFpRCxxQkFBcUIsb0JBQW9CLHFCQUFxQixtQkFBbUIsR0FBRyx3QkFBd0IsdUJBQXVCLGFBQWEsZ0JBQWdCLGlEQUFpRCxpQkFBaUIsMkJBQTJCLHlCQUF5QixHQUFHLGlCQUFpQixhQUFhLDBCQUEwQixHQUFHLHdCQUF3Qix1QkFBdUIsY0FBYyxZQUFZLDRCQUE0QixlQUFlLDhCQUE4Qiw4QkFBOEIsdUJBQXVCLG9FQUFvRSxpRUFBaUUsNERBQTRELEdBQUcsYUFBYSwyQkFBMkIscUNBQXFDLG1CQUFtQiwyQkFBMkIsR0FBRyxtQkFBbUIsOEJBQThCLG1CQUFtQixvQkFBb0IsaUJBQWlCLEdBQUcsZUFBZSwwQkFBMEIsY0FBYyxvQkFBb0IscUJBQXFCLEdBQUcsaUJBQWlCLGlCQUFpQixzQkFBc0IsMkJBQTJCLEdBQUcsZUFBZSxxQkFBcUIsR0FBRyx1QkFBdUIsZUFBZSxHQUFHLG9CQUFvQixxQkFBcUIsR0FBRywrQkFBK0Isc0JBQXNCLGtCQUFrQixLQUFLLGVBQWUsNkJBQTZCLEtBQUssR0FBRywrQkFBK0I7QUFDbHlRO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9CYXNpY0Ryb3BEb3duLnZ1ZT84MjE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmlucHV0LWNvbnRhaW5lcltkYXRhLXYtZWFmYmM5NjBdIHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB3aWR0aDogNTAlO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uaW5wdXQtY29udGFpbmVyIGxhYmVsW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgY29sb3I6ICMxMTExMTE7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7XFxufVxcbi5zZWxlY3QtYnV0dG9uW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4uc2VsZWN0LWJ1dHRvbiAuc2VsZWN0LWNvbnRlbnRbZGF0YS12LWVhZmJjOTYwXSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDU1JTtcXG4gIGxlZnQ6IDE0cHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgY29sb3I6ICMwMDc0OGY7XFxufVxcbi5zZWxlY3QtYnV0dG9uIHN2Z1tkYXRhLXYtZWFmYmM5NjBdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNjAlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMTZweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcXG59XFxuLm9wZW5lZCBzdmdbZGF0YS12LWVhZmJjOTYwXSB7XFxuICB0b3A6IDI1JTtcXG4gIHRyYW5zZm9ybTogc2NhbGVZKC0xKTtcXG59XFxuLmRyb3AtZG93bi1vcHRpb25zW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA2OHB4O1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiBjYWxjKDEwMCUgLSAycHgpO1xcbiAgei1pbmRleDogNDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTFlMWUxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgLW1vei1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcXG59XFxuLm9wdGlvbltkYXRhLXYtZWFmYmM5NjBdIHtcXG4gIHBhZGRpbmc6IDEwcHggMTJweCA2cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVmNTtcXG4gIGNvbG9yOiAjNTU1NTU1O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLm9wdGlvbltkYXRhLXYtZWFmYmM5NjBdOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmM2ZiZmE7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG59XFxuLm9wdGlvbiBwW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuLm9wdGlvbiBzdmdbZGF0YS12LWVhZmJjOTYwXSB7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcbi5zZWxlY3RlZFtkYXRhLXYtZWFmYmM5NjBdIHtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcbi5oaWRkZW4tY2hlY2ttYXJrW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgb3BhY2l0eTogMDtcXG59XFxuLmVtcHR5LW9wdGlvbnNbZGF0YS12LWVhZmJjOTYwXSB7XFxuICBtaW4td2lkdGg6IDI1MHB4O1xcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcXG4uaW5wdXQtY29udGFpbmVyW2RhdGEtdi1lYWZiYzk2MF0ge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuLm9wdGlvbltkYXRhLXYtZWFmYmM5NjBdIHtcXG4gICAgcGFkZGluZzogMTJweCA2cHggMTFweDtcXG59XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jb21wb25lbnRzL2Zvcm0vQmFzaWNEcm9wRG93bi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNHQTtFQUNFLG1CQUFtQjtFQUNuQixVQUFVO0VBQ1Ysa0JBQWtCO0FBQ3BCO0FBRUE7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixjQUFjO0VBQ2Qsa0JBQWtCO0FBQ3BCO0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsY0FBYztFQUNkLFlBQVk7RUFDWixjQUFjO0VBQ2QseUJBQXlCO0VBQ3pCLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsZUFBZTtFQUNmLGFBQWE7RUFDYix3QkFBd0I7RUFDeEIsZUFBZTtFQUNmLFlBQVk7QUFDZDtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFFBQVE7RUFDUixVQUFVO0VBQ1YsNENBQTRDO0VBQzVDLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLGNBQWM7QUFDaEI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsV0FBVztFQUNYLDRDQUE0QztFQUM1QyxZQUFZO0VBQ1osc0JBQXNCO0VBQ3RCLG9CQUFvQjtBQUN0QjtBQUVBO0VBQ0UsUUFBUTtFQUNSLHFCQUFxQjtBQUN2QjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxPQUFPO0VBQ1AsdUJBQXVCO0VBQ3ZCLFVBQVU7RUFDVix5QkFBeUI7RUFDekIseUJBQXlCO0VBQ3pCLGtCQUFrQjtFQUNsQiwrREFBK0Q7RUFDL0QsNERBQTREO0VBQzVELHVEQUF1RDtBQUN6RDtBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLGdDQUFnQztFQUNoQyxjQUFjO0VBQ2Qsc0JBQXNCO0FBQ3hCO0FBRUE7RUFDRSx5QkFBeUI7RUFDekIsY0FBYztFQUNkLGVBQWU7RUFDZixZQUFZO0FBQ2Q7QUFFQTtFQUNFLHFCQUFxQjtFQUNyQixTQUFTO0VBQ1QsZUFBZTtFQUNmLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixzQkFBc0I7QUFDeEI7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsVUFBVTtBQUNaO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTtBQUNFO0lBQ0UsV0FBVztBQUNiO0FBRUE7SUFDRSxzQkFBc0I7QUFDeEI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1jb250YWluZXJcXFwiPlxcbiAgICA8bGFiZWwgOmZvcj1cXFwibGFiZWwuZm9yXFxcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cXG4gICAgPGRpdlxcbiAgICAgICAgQGNsaWNrPVxcXCJpc09wZW5lZCA9ICFpc09wZW5lZFxcXCJcXG4gICAgICAgIDpjbGFzcz1cXFwiW2lzT3BlbmVkID8gJ29wZW5lZCcgOiAnJywgJ3NlbGVjdC1idXR0b24nXVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2VsZWN0LWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPHNwYW4gdi1pZj1cXFwiIXZhbHVlXFxcIj57eyAkdCgnbmV3LmNvbmNlcHRUeXBlLnBsYWNlaG9sZGVyJykgfX08L3NwYW4+XFxuICAgICAgICA8c3BhbiB2LWlmPVxcXCJ2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwXFxcIiBjbGFzcz1cXFwic2VsZWN0ZWRcXFwiPnt7IHZhbHVlIH19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxzdmctaWNvbiBpY29uLW5hbWU9XFxcInRyaWFuZ2xlXFxcIj48aWNvbi10cmlhbmdsZSAvPjwvc3ZnLWljb24+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2XFxuICAgICAgICB2LWlmPVxcXCJpc09wZW5lZCAmJiBvcHRpb25zLmxlbmd0aCA9PT0gMFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJkcm9wLWRvd24tb3B0aW9ucyBlbXB0eS1vcHRpb25zXFxcIlxcbiAgICAgICAgdi1vbi1jbGljay1hd2F5PVxcXCJjbG9zZURyb3BEb3duXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJvcHRpb25cXFwiIHN0eWxlPVxcXCJwYWRkaW5nLWxlZnQ6IDE2cHg7XFxcIj5cXG4gICAgICAgIDxzcGFuPnt7IG5vT3B0aW9uc01lc3NhZ2UgfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IHYtaWY9XFxcImlzT3BlbmVkICYmIG9wdGlvbnMubGVuZ3RoID4gMFxcXCJcXG4gICAgICAgICBjbGFzcz1cXFwiZHJvcC1kb3duLW9wdGlvbnNcXFwiXFxuICAgICAgICAgdi1vbi1jbGljay1hd2F5PVxcXCJjbG9zZURyb3BEb3duXFxcIj5cXG4gICAgICA8ZGl2IHYtZm9yPVxcXCIob3B0aW9uLCBpKSBpbiBvcHRpb25zXFxcIlxcbiAgICAgICAgICAgOmtleT1cXFwib3B0aW9uLmlkXFxcIlxcbiAgICAgICAgICAgQGNsaWNrPVxcXCJzZWxlY3RPcHRpb24oaSlcXFwiXFxuICAgICAgICAgICA6Y2xhc3M9XFxcIltpc1NlbGVjdGVkKGkpID8gJ3NlbGVjdGVkJyA6ICcnLCAnb3B0aW9uJ11cXFwiPlxcbiAgICAgICAgPHN2Zy1pY29uXFxuICAgICAgICAgICAgOmNsYXNzPVxcXCJbaXNTZWxlY3RlZChpKSA/ICcnIDogJ2hpZGRlbi1jaGVja21hcmsnXVxcXCJcXG4gICAgICAgICAgICBpY29uLW5hbWU9XFxcImNoZWNrXFxcIj48aWNvbi1jaGVjayAvPlxcbiAgICAgICAgPC9zdmctaWNvbj5cXG4gICAgICAgIDxwPnt7ICR0KG9wdGlvbi52YWx1ZSkgfX08L3A+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCB7cmVmLCBvbk1vdW50ZWQsIG9uQmVmb3JlVW5tb3VudCwgaW5qZWN0fSBmcm9tICd2dWUnO1xcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL2ljb25zL1N2Z0ljb24udnVlJztcXG5pbXBvcnQgSWNvblRyaWFuZ2xlIGZyb20gJy4uL2ljb25zL0ljb25UcmlhbmdsZS52dWUnO1xcbmltcG9ydCBJY29uQ2hlY2sgZnJvbSAnLi4vaWNvbnMvSWNvbkNoZWNrLnZ1ZSc7XFxuaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2tBd2F5IH0gZnJvbSAndnVlMy1jbGljay1hd2F5JztcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIFN2Z0ljb24sXFxuICAgIEljb25UcmlhbmdsZSxcXG4gICAgSWNvbkNoZWNrXFxuICB9LFxcbiAgZGlyZWN0aXZlczoge1xcbiAgICBvbkNsaWNrQXdheVxcbiAgfSxcXG4gIHByb3BzOiB7XFxuICAgIHZhbHVlOiBTdHJpbmcsXFxuICAgIG9wdGlvbnM6IEFycmF5LFxcbiAgICBsYWJlbDogT2JqZWN0XFxuICB9LFxcbiAgc2V0dXAocHJvcHMsIGNvbnRleHQpIHtcXG4gICAgY29uc3QgJHQgPSBpbmplY3QoJyR0Jyk7XFxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSByZWYoLTEpO1xcbiAgICBjb25zdCBpc09wZW5lZCA9IHJlZihmYWxzZSk7XFxuICAgIGNvbnN0IGNvdW50ID0gcmVmKDApXFxuICAgIGNvbnN0IG5vT3B0aW9uc01lc3NhZ2UgPSBjb250ZXh0LmF0dHJzWydvblVwZGF0ZTpub09wdGlvbnNNZXNzYWdlJ10gfHwgJ05vIG9wdGlvbnMgYXZhaWxhYmxlJztcXG4gICAgY29uc3Qgc2VsZWN0T3B0aW9uID0gKGluZGV4KSA9PiB7XFxuICAgICAgc2VsZWN0ZWRJbmRleC52YWx1ZSA9IGluZGV4O1xcbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gZmFsc2U7XFxuICAgICAgY29udGV4dC5lbWl0KCdjaGFuZ2VWb2NhYnVsYXJ5JywgcHJvcHMub3B0aW9uc1tpbmRleF0udm9jYWIpO1xcbiAgICAgIGNvbnRleHQuZW1pdCgnc2VsZWN0JywgJHQocHJvcHMub3B0aW9uc1tpbmRleF0udmFsdWUpKTsgLy8gcGF0aFxcbiAgICB9O1xcblxcbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcXG4gICAgICBjb25zb2xlLmxvZygnQkVGT1JFOiBDbGlja2VkISBpc09wZW5lZDonLCBpc09wZW5lZC52YWx1ZSk7XFxuICAgICAgaXNPcGVuZWQudmFsdWUgPSAhaXNPcGVuZWQudmFsdWU7XFxuICAgICAgY29uc29sZS5sb2coJ0FGVEVSOiBDbGlja2VkISBpc09wZW5lZDonLCBpc09wZW5lZC52YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIC8vIGNvbnN0IGlzU2VsZWN0ZWQgPSAoaW5kZXgpID0+IHNlbGVjdGVkSW5kZXgudmFsdWUgPT09IGluZGV4O1xcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gKGluZGV4KSA9PiB7XFxuICAgICAgcmV0dXJuIHNlbGVjdGVkSW5kZXgudmFsdWUgPT09IGluZGV4O1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBjbG9zZURyb3BEb3duID0gKCkgPT4ge1xcbiAgICAgIGlzT3BlbmVkLnZhbHVlID0gZmFsc2U7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgaXNPcGVuZWQsXFxuICAgICAgbm9PcHRpb25zTWVzc2FnZSxcXG4gICAgICBjb3VudCxcXG4gICAgICBzZWxlY3RPcHRpb24sXFxuICAgICAgaXNTZWxlY3RlZCxcXG4gICAgICBjbG9zZURyb3BEb3duLFxcbiAgICAgIGhhbmRsZUNsaWNrXFxuICAgIH07XFxuICB9XFxufTtcXG48L3NjcmlwdD5cXG5cXG5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbi5pbnB1dC1jb250YWluZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHdpZHRoOiA1MCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5pbnB1dC1jb250YWluZXIgbGFiZWwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgY29sb3I6ICMxMTExMTE7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7XFxufVxcblxcbi5zZWxlY3QtYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG59XFxuXFxuLnNlbGVjdC1idXR0b24gLnNlbGVjdC1jb250ZW50IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTUlO1xcbiAgbGVmdDogMTRweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG59XFxuXFxuLnNlbGVjdC1idXR0b24gc3ZnIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNjAlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMTZweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcXG59XFxuXFxuLm9wZW5lZCBzdmcge1xcbiAgdG9wOiAyNSU7XFxuICB0cmFuc2Zvcm06IHNjYWxlWSgtMSk7XFxufVxcblxcbi5kcm9wLWRvd24tb3B0aW9ucyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDY4cHg7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IGNhbGMoMTAwJSAtIDJweCk7XFxuICB6LWluZGV4OiA0O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICBib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbn1cXG5cXG4ub3B0aW9uIHtcXG4gIHBhZGRpbmc6IDEwcHggMTJweCA2cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVmNTtcXG4gIGNvbG9yOiAjNTU1NTU1O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuLm9wdGlvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmYmZhO1xcbiAgY29sb3I6ICMxMTExMTE7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcblxcbi5vcHRpb24gcCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG5cXG4ub3B0aW9uIHN2ZyB7XFxuICBoZWlnaHQ6IDEwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5zZWxlY3RlZCB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG5cXG4uaGlkZGVuLWNoZWNrbWFyayB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uZW1wdHktb3B0aW9ucyB7XFxuICBtaW4td2lkdGg6IDI1MHB4O1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcXG4gIC5pbnB1dC1jb250YWluZXIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC5vcHRpb24ge1xcbiAgICBwYWRkaW5nOiAxMnB4IDZweCAxMXB4O1xcbiAgfVxcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5265\n");

/***/ }),

/***/ 6604:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.input-container[data-v-6c396249] {\\n  margin-bottom: 16px;\\n}\\n.input-container label[data-v-6c396249] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.input-container input[data-v-6c396249],\\n.input-container textarea[data-v-6c396249] {\\n  height: 40px;\\n  width: 100%;\\n  background-color: #eBf6f4;\\n  border: none;\\n  color: #00748f;\\n  padding-left: 10px;\\n  font-size: 14px;\\n  border-radius: 1px;\\n  outline: none;\\n  -webkit-appearance: none;\\n}\\n.input-container textarea[data-v-6c396249] {\\n  height: 70px;\\n  min-height: 70px;\\n  padding-top: 8px;\\n  padding-bottom: 8px;\\n  resize: vertical;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/BasicInput.vue\"],\"names\":[],\"mappings\":\";AA0CA;EACE,mBAAmB;AACrB;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;;EAEE,YAAY;EACZ,WAAW;EACX,yBAAyB;EACzB,YAAY;EACZ,cAAc;EACd,kBAAkB;EAClB,eAAe;EACf,kBAAkB;EAClB,aAAa;EACb,wBAAwB;AAC1B;AAEA;EACE,YAAY;EACZ,gBAAgB;EAChB,gBAAgB;EAChB,mBAAmB;EACnB,gBAAgB;AAClB\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"input-container\\\">\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <input\\n        v-if=\\\"!isTextArea\\\"\\n        :value=\\\"value\\\"\\n        @input=\\\"emitEvent('input:basic', $event.target.value)\\\"\\n        type=\\\"text\\\" />\\n    <textarea\\n        v-if=\\\"isTextArea\\\"\\n        :value=\\\"value\\\"\\n        @input=\\\"emitEvent('input:basic', $event.target.value)\\\"\\n        rows=\\\"3\\\">\\n    </textarea>\\n  </div>\\n</template>\\n\\n<script setup>\\nimport { defineProps, defineEmits, defineExpose } from 'vue';\\n\\nconst props = defineProps({\\n  value: String,\\n  label: {\\n    type: Object,\\n    required: true,\\n    default: () => ({ text: '', for: '' })\\n  },\\n  isTextArea: Boolean\\n});\\n\\nconst emitEvent = (eventName, payload) => {\\n  emit(eventName, payload);\\n};\\n\\nconst emit = defineEmits();\\n\\ndefineExpose({\\n  emitEvent,\\n});\\n</script>\\n\\n<style scoped>\\n.input-container {\\n  margin-bottom: 16px;\\n}\\n\\n.input-container label {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.input-container input,\\n.input-container textarea {\\n  height: 40px;\\n  width: 100%;\\n  background-color: #eBf6f4;\\n  border: none;\\n  color: #00748f;\\n  padding-left: 10px;\\n  font-size: 14px;\\n  border-radius: 1px;\\n  outline: none;\\n  -webkit-appearance: none;\\n}\\n\\n.input-container textarea {\\n  height: 70px;\\n  min-height: 70px;\\n  padding-top: 8px;\\n  padding-bottom: 8px;\\n  resize: vertical;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYwNC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSwrRUFBK0Usd0JBQXdCLEdBQUcsMkNBQTJDLG1CQUFtQixxQkFBcUIsb0JBQW9CLG1CQUFtQix1QkFBdUIsR0FBRyx3RkFBd0YsaUJBQWlCLGdCQUFnQiw4QkFBOEIsaUJBQWlCLG1CQUFtQix1QkFBdUIsb0JBQW9CLHVCQUF1QixrQkFBa0IsNkJBQTZCLEdBQUcsOENBQThDLGlCQUFpQixxQkFBcUIscUJBQXFCLHdCQUF3QixxQkFBcUIsR0FBRyxTQUFTLGlHQUFpRyxNQUFNLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLE1BQU0sVUFBVSxVQUFVLFlBQVksV0FBVyxVQUFVLFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLDBHQUEwRyxhQUFhLDBZQUEwWSx5Q0FBeUMsV0FBVywrQkFBK0IsOEJBQThCLGdFQUFnRSxtQkFBbUIsTUFBTSwyQkFBMkIsRUFBRSwrQ0FBK0MsNkJBQTZCLElBQUksK0JBQStCLGtCQUFrQixpQkFBaUIsRUFBRSxpREFBaUQsd0JBQXdCLEdBQUcsNEJBQTRCLG1CQUFtQixxQkFBcUIsb0JBQW9CLG1CQUFtQix1QkFBdUIsR0FBRyx3REFBd0QsaUJBQWlCLGdCQUFnQiw4QkFBOEIsaUJBQWlCLG1CQUFtQix1QkFBdUIsb0JBQW9CLHVCQUF1QixrQkFBa0IsNkJBQTZCLEdBQUcsK0JBQStCLGlCQUFpQixxQkFBcUIscUJBQXFCLHdCQUF3QixxQkFBcUIsR0FBRywrQkFBK0I7QUFDNWtGO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9CYXNpY0lucHV0LnZ1ZT9hOWNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmlucHV0LWNvbnRhaW5lcltkYXRhLXYtNmMzOTYyNDldIHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcbi5pbnB1dC1jb250YWluZXIgbGFiZWxbZGF0YS12LTZjMzk2MjQ5XSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuLmlucHV0LWNvbnRhaW5lciBpbnB1dFtkYXRhLXYtNmMzOTYyNDldLFxcbi5pbnB1dC1jb250YWluZXIgdGV4dGFyZWFbZGF0YS12LTZjMzk2MjQ5XSB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIHBhZGRpbmctbGVmdDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi5pbnB1dC1jb250YWluZXIgdGV4dGFyZWFbZGF0YS12LTZjMzk2MjQ5XSB7XFxuICBoZWlnaHQ6IDcwcHg7XFxuICBtaW4taGVpZ2h0OiA3MHB4O1xcbiAgcGFkZGluZy10b3A6IDhweDtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9mb3JtL0Jhc2ljSW5wdXQudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUEwQ0E7RUFDRSxtQkFBbUI7QUFDckI7QUFFQTtFQUNFLGNBQWM7RUFDZCxnQkFBZ0I7RUFDaEIsZUFBZTtFQUNmLGNBQWM7RUFDZCxrQkFBa0I7QUFDcEI7QUFFQTs7RUFFRSxZQUFZO0VBQ1osV0FBVztFQUNYLHlCQUF5QjtFQUN6QixZQUFZO0VBQ1osY0FBYztFQUNkLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2Ysa0JBQWtCO0VBQ2xCLGFBQWE7RUFDYix3QkFBd0I7QUFDMUI7QUFFQTtFQUNFLFlBQVk7RUFDWixnQkFBZ0I7RUFDaEIsZ0JBQWdCO0VBQ2hCLG1CQUFtQjtFQUNuQixnQkFBZ0I7QUFDbEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtY29udGFpbmVyXFxcIj5cXG4gICAgPGxhYmVsIDpmb3I9XFxcImxhYmVsLmZvclxcXCI+e3sgbGFiZWwudGV4dCB9fTwvbGFiZWw+XFxuICAgIDxpbnB1dFxcbiAgICAgICAgdi1pZj1cXFwiIWlzVGV4dEFyZWFcXFwiXFxuICAgICAgICA6dmFsdWU9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgQGlucHV0PVxcXCJlbWl0RXZlbnQoJ2lucHV0OmJhc2ljJywgJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiXFxuICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIiAvPlxcbiAgICA8dGV4dGFyZWFcXG4gICAgICAgIHYtaWY9XFxcImlzVGV4dEFyZWFcXFwiXFxuICAgICAgICA6dmFsdWU9XFxcInZhbHVlXFxcIlxcbiAgICAgICAgQGlucHV0PVxcXCJlbWl0RXZlbnQoJ2lucHV0OmJhc2ljJywgJGV2ZW50LnRhcmdldC52YWx1ZSlcXFwiXFxuICAgICAgICByb3dzPVxcXCIzXFxcIj5cXG4gICAgPC90ZXh0YXJlYT5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdCBzZXR1cD5cXG5pbXBvcnQgeyBkZWZpbmVQcm9wcywgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSB9IGZyb20gJ3Z1ZSc7XFxuXFxuY29uc3QgcHJvcHMgPSBkZWZpbmVQcm9wcyh7XFxuICB2YWx1ZTogU3RyaW5nLFxcbiAgbGFiZWw6IHtcXG4gICAgdHlwZTogT2JqZWN0LFxcbiAgICByZXF1aXJlZDogdHJ1ZSxcXG4gICAgZGVmYXVsdDogKCkgPT4gKHsgdGV4dDogJycsIGZvcjogJycgfSlcXG4gIH0sXFxuICBpc1RleHRBcmVhOiBCb29sZWFuXFxufSk7XFxuXFxuY29uc3QgZW1pdEV2ZW50ID0gKGV2ZW50TmFtZSwgcGF5bG9hZCkgPT4ge1xcbiAgZW1pdChldmVudE5hbWUsIHBheWxvYWQpO1xcbn07XFxuXFxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKCk7XFxuXFxuZGVmaW5lRXhwb3NlKHtcXG4gIGVtaXRFdmVudCxcXG59KTtcXG48L3NjcmlwdD5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbi5pbnB1dC1jb250YWluZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciBsYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciBpbnB1dCxcXG4uaW5wdXQtY29udGFpbmVyIHRleHRhcmVhIHtcXG4gIGhlaWdodDogNDBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgcGFkZGluZy1sZWZ0OiAxMHB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciB0ZXh0YXJlYSB7XFxuICBoZWlnaHQ6IDcwcHg7XFxuICBtaW4taGVpZ2h0OiA3MHB4O1xcbiAgcGFkZGluZy10b3A6IDhweDtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6604\n");

/***/ }),

/***/ 2150:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nlabel[data-v-7eae7b93] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.input-container[data-v-7eae7b93] {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n.chip-list[data-v-7eae7b93] {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n.chip-list .chip[data-v-7eae7b93] {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.chip-list .chip svg[data-v-7eae7b93] {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n.auto-complete[data-v-7eae7b93] {\\n  position: relative;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border-radius: 1px;\\n  font-size: 14px;\\n}\\n.auto-complete-input[data-v-7eae7b93] {\\n  position: absolute;\\n  top: 55%;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 100%;\\n  width: 100%;\\n  padding-left: 10px;\\n  overflow: hidden;\\n  font-size: 14px;\\n  font-weight: 400;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  border: none;\\n  outline: none;\\n  z-index: 1;\\n}\\n.auto-complete svg[data-v-7eae7b93] {\\n  position: absolute;\\n  top: 52%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 18px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n.drop-down-options[data-v-7eae7b93] {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n.option[data-v-7eae7b93] {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n.option[data-v-7eae7b93]:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.option p[data-v-7eae7b93] {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n.selected[data-v-7eae7b93] {\\n  font-weight: 500;\\n}\\n.empty-options[data-v-7eae7b93] {\\n  min-width: 250px;\\n}\\n@media (max-width: 700px) {\\n.input-container[data-v-7eae7b93], .drop-down-options[data-v-7eae7b93] {\\n    width: 100%;\\n}\\n.option[data-v-7eae7b93] {\\n    padding: 12px 6px 11px;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/SearchAutoComplete.vue\"],\"names\":[],\"mappings\":\";AA4JA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;EACE,WAAW;EACX,mBAAmB;EACnB,kBAAkB;AACpB;AAEA;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,2BAA2B,EAAE,eAAe;EAC5C,yBAAyB,EAAE,WAAW;EACtC,sBAAsB,EAAE,YAAY;EACpC,qBAAqB,EAAE,2BAA2B;EAClD,iBAAiB;AACnB;AAEA;EACE,qBAAqB;EACrB,yBAAyB;EACzB,cAAc;EACd,mBAAmB;EACnB,2BAA2B;EAC3B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd;AAEA;EACE,YAAY;EACZ,UAAU;EACV,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,4CAA4C;AAC9C;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,WAAW;EACX,YAAY;EACZ,cAAc;EACd,yBAAyB;EACzB,kBAAkB;EAClB,eAAe;AACjB;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,4CAA4C;EAC5C,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,yBAAyB;EACzB,cAAc;EACd,YAAY;EACZ,aAAa;EACb,UAAU;AACZ;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,4CAA4C;EAC5C,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;AACtB;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,WAAW;EACX,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,yBAAyB;EACzB,yBAAyB;EACzB,kBAAkB;EAClB,+DAA+D;EAC/D,4DAA4D;EAC5D,uDAAuD;AACzD;AAEA;EACE,sBAAsB;EACtB,gCAAgC;EAChC,cAAc;EACd,sBAAsB;AACxB;AAEA;EACE,yBAAyB;EACzB,cAAc;EACd,eAAe;EACf,YAAY;AACd;AAEA;EACE,qBAAqB;EACrB,SAAS;EACT,eAAe;EACf,gBAAgB;AAClB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,gBAAgB;AAClB;AAEA;AACE;IACE,WAAW;AACb;AAEA;IACE,sBAAsB;AACxB;AACF\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <div v-if=\\\"selectedOptions && selectedOptions.length > 0\\\" class=\\\"chip-list\\\">\\n      <div v-for=\\\"option in selectedOptions\\\" @click=\\\"removeLabelSelection(option)\\\" :key=\\\"option.id\\\" class=\\\"chip\\\">\\n        <span>{{ option.value }}</span>\\n        <svg-icon icon-name=\\\"cross\\\"><icon-cross /></svg-icon>\\n      </div>\\n    </div>\\n    <div class=\\\"input-container\\\">\\n      <div class=\\\"auto-complete\\\">\\n        <input\\n            v-model.trim=\\\"searchString\\\"\\n            class=\\\"auto-complete-input\\\"\\n            type=\\\"text\\\"\\n        />\\n        <div @click=\\\"clearInput\\\" class=\\\"clear-input\\\">\\n          <svg-icon v-if=\\\"searchString.length > 0\\\" icon-name=\\\"cross\\\">\\n            <icon-cross />\\n          </svg-icon>\\n        </div>\\n      </div>\\n      <div v-if=\\\"isOpened && options.length > 0\\\" class=\\\"drop-down-options\\\" v-on-clickaway=\\\"closeDropDown\\\">\\n        <div v-for=\\\"option in options\\\" :key=\\\"option.id\\\" @click=\\\"addLabelSelection(option)\\\" class=\\\"option\\\">\\n          <p>{{ option.prefLabel }}</p>\\n        </div>\\n      </div>\\n      <div v-if=\\\"options.length == 0 && isOpened\\\" class=\\\"drop-down-options empty-options\\\" v-on-clickaway=\\\"closeDropDown\\\">\\n        <div class=\\\"option\\\" style=\\\"padding-left: 16px;\\\">\\n          <span>{{ noOptionsMessage }}</span>\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport SvgIcon from '../icons/SvgIcon.vue';\\nimport IconCross from '../icons/IconCross.vue';\\nimport IconCheck from '../icons/IconCheck.vue';\\nimport { directive as onClickaway } from 'vue3-click-away';\\nimport axios from 'axios';\\nimport debounce from 'lodash/debounce';\\nimport {ref, watch, onMounted, defineEmits, inject} from 'vue';\\n\\nexport default {\\n  components: {\\n    SvgIcon,\\n    IconCross,\\n    IconCheck,\\n  },\\n  directives: {\\n    onClickaway: onClickaway,\\n  },\\n  props: {\\n    values: Array,\\n    vocabulary: String,\\n    language: String,\\n    label: Object,\\n    hasUniqueValue: Boolean,\\n  },\\n  setup(props, context) {\\n    const $t = inject('$t');\\n    const isOpened = ref(false);\\n    const noOptionsMessage = $t('new.common.none'); // Provide the translation key\\n    const options = ref([]);\\n    const searchString = ref('');\\n    const selectedOptions = ref([]);\\n\\n    const searchLabel = debounce(() => {\\n      if (searchString.value.length >= 3) {\\n        fetchResults(checkCapitalization(searchString.value));\\n      } else {\\n        isOpened.value = false;\\n        options.value = [];\\n      }\\n    }, 200);\\n\\n    const fetchResults = async (inputValue) => {\\n      try {\\n        const response = await axios.get('https://api.finto.fi/rest/v1/search', {\\n          params: {\\n            vocab: props.vocabulary,\\n            lang: props.language,\\n            query: inputValue + '*',\\n          },\\n        });\\n        options.value = response.data.results;\\n        isOpened.value = true;\\n      } catch (error) {\\n        console.error(error);\\n      }\\n    };\\n\\n    const checkCapitalization = (inputValue) => {\\n      if (inputValue && props.vocabulary === 'new.common.places') {\\n        return inputValue.charAt(0).toUpperCase() + inputValue.substring(1);\\n      }\\n      return inputValue;\\n    };\\n\\n    const addLabelSelection = (option) => {\\n      isOpened.value = false;\\n      const o = {\\n        value: option.prefLabel,\\n        uri: option.uri,\\n      };\\n      if (props.hasUniqueValue) {\\n        selectedOptions.value = [];\\n      }\\n      if (!selectedOptions.value.some((item) => item.value === o.value)) {\\n        selectedOptions.value.push(o);\\n      }\\n      searchString.value = '';\\n      context.emit('update:selectedOptions', selectedOptions.value);\\n    };\\n\\n    const removeLabelSelection = (option) => {\\n      const index = selectedOptions.value.findIndex((item) => item.uri === option.uri);\\n      if (index >= 0) {\\n        selectedOptions.value.splice(index, 1);\\n      }\\n      context.emit('update:selectedOptions', selectedOptions.value); // Emit the event\\n    };\\n\\n    const closeDropDown = () => {\\n      isOpened.value = false;\\n    };\\n\\n    const clearInput = () => {\\n      searchString.value = '';\\n    };\\n\\n    watch(searchString, searchLabel);\\n\\n    onMounted(() => {\\n      // Initialize data or perform actions after initial render\\n    });\\n\\n    return {\\n      isOpened,\\n      noOptionsMessage,\\n      options,\\n      searchString,\\n      selectedOptions,\\n      addLabelSelection,\\n      removeLabelSelection,\\n      closeDropDown,\\n      clearInput,\\n    };\\n  },\\n};\\n</script>\\n\\n\\n<style scoped>\\nlabel {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.input-container {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n\\n.chip-list {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n\\n.chip-list .chip {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.chip-list .chip svg {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n\\n.auto-complete {\\n  position: relative;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border-radius: 1px;\\n  font-size: 14px;\\n}\\n\\n.auto-complete-input {\\n  position: absolute;\\n  top: 55%;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 100%;\\n  width: 100%;\\n  padding-left: 10px;\\n  overflow: hidden;\\n  font-size: 14px;\\n  font-weight: 400;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  border: none;\\n  outline: none;\\n  z-index: 1;\\n}\\n\\n.auto-complete svg {\\n  position: absolute;\\n  top: 52%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 18px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n\\n.drop-down-options {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n\\n.option {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n\\n.option:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.option p {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n\\n.selected {\\n  font-weight: 500;\\n}\\n\\n.empty-options {\\n  min-width: 250px;\\n}\\n\\n@media (max-width: 700px) {\\n  .input-container, .drop-down-options {\\n    width: 100%;\\n  }\\n\\n  .option {\\n    padding: 12px 6px 11px;\\n  }\\n}\\n</style>\\n\\n\\n\\n\\n\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WSxnQkFBZ0Isc0JBQXNCLHVCQUF1QixlQUFlLDhCQUE4Qiw4QkFBOEIsdUJBQXVCLG9FQUFvRSxpRUFBaUUsNERBQTRELEdBQUcsYUFBYSwyQkFBMkIscUNBQXFDLG1CQUFtQiwyQkFBMkIsR0FBRyxtQkFBbUIsOEJBQThCLG1CQUFtQixvQkFBb0IsaUJBQWlCLEdBQUcsZUFBZSwwQkFBMEIsY0FBYyxvQkFBb0IscUJBQXFCLEdBQUcsZUFBZSxxQkFBcUIsR0FBRyxvQkFBb0IscUJBQXFCLEdBQUcsK0JBQStCLDBDQUEwQyxrQkFBa0IsS0FBSyxlQUFlLDZCQUE2QixLQUFLLEdBQUcseUNBQXlDO0FBQ3AxVztBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT83OWMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxubGFiZWxbZGF0YS12LTdlYWU3YjkzXSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuLmlucHV0LWNvbnRhaW5lcltkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmNoaXAtbGlzdFtkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIG1hcmdpbjogMTZweCAwIDhweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC8qIGlPUyBTYWZhcmkgKi9cXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLyogRmlyZWZveCAqL1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAvKiBJbnRlcm5ldCBFeHBsb3Jlci9FZGdlICovXFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLmNoaXAtbGlzdCAuY2hpcFtkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwNmE3OTg7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG4gIG1hcmdpbjogMCA4cHggOHB4IDA7XFxuICBwYWRkaW5nOiAxMHB4IDMycHggN3B4IDEycHg7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4uY2hpcC1saXN0IC5jaGlwIHN2Z1tkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIGhlaWdodDogMTZweDtcXG4gIHotaW5kZXg6IDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiA4cHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLmF1dG8tY29tcGxldGVbZGF0YS12LTdlYWU3YjkzXSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4uYXV0by1jb21wbGV0ZS1pbnB1dFtkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTUlO1xcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmctbGVmdDogMTBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIHotaW5kZXg6IDE7XFxufVxcbi5hdXRvLWNvbXBsZXRlIHN2Z1tkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTIlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMThweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcXG59XFxuLmRyb3AtZG93bi1vcHRpb25zW2RhdGEtdi03ZWFlN2I5M10ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0MnB4O1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LWhlaWdodDogMjAwcHg7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB6LWluZGV4OiAyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICBib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi03ZWFlN2I5M10ge1xcbiAgcGFkZGluZzogMTBweCAxMnB4IDZweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZjVmNWY1O1xcbiAgY29sb3I6ICM1NTU1NTU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi03ZWFlN2I5M106aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZmJmYTtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4ub3B0aW9uIHBbZGF0YS12LTdlYWU3YjkzXSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG4uc2VsZWN0ZWRbZGF0YS12LTdlYWU3YjkzXSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG4uZW1wdHktb3B0aW9uc1tkYXRhLXYtN2VhZTdiOTNdIHtcXG4gIG1pbi13aWR0aDogMjUwcHg7XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbi5pbnB1dC1jb250YWluZXJbZGF0YS12LTdlYWU3YjkzXSwgLmRyb3AtZG93bi1vcHRpb25zW2RhdGEtdi03ZWFlN2I5M10ge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuLm9wdGlvbltkYXRhLXYtN2VhZTdiOTNdIHtcXG4gICAgcGFkZGluZzogMTJweCA2cHggMTFweDtcXG59XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBNEpBO0VBQ0UsY0FBYztFQUNkLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsY0FBYztFQUNkLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0UsV0FBVztFQUNYLG1CQUFtQjtFQUNuQixrQkFBa0I7QUFDcEI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLDJCQUEyQixFQUFFLGVBQWU7RUFDNUMseUJBQXlCLEVBQUUsV0FBVztFQUN0QyxzQkFBc0IsRUFBRSxZQUFZO0VBQ3BDLHFCQUFxQixFQUFFLDJCQUEyQjtFQUNsRCxpQkFBaUI7QUFDbkI7QUFFQTtFQUNFLHFCQUFxQjtFQUNyQix5QkFBeUI7RUFDekIsY0FBYztFQUNkLG1CQUFtQjtFQUNuQiwyQkFBMkI7RUFDM0IsbUJBQW1CO0VBQ25CLGtCQUFrQjtFQUNsQixlQUFlO0VBQ2YsWUFBWTtBQUNkO0FBRUE7RUFDRSxZQUFZO0VBQ1osVUFBVTtFQUNWLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsVUFBVTtFQUNWLDRDQUE0QztBQUM5QztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGNBQWM7RUFDZCxXQUFXO0VBQ1gsWUFBWTtFQUNaLGNBQWM7RUFDZCx5QkFBeUI7RUFDekIsa0JBQWtCO0VBQ2xCLGVBQWU7QUFDakI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsNENBQTRDO0VBQzVDLFlBQVk7RUFDWixXQUFXO0VBQ1gsa0JBQWtCO0VBQ2xCLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLHlCQUF5QjtFQUN6QixjQUFjO0VBQ2QsWUFBWTtFQUNaLGFBQWE7RUFDYixVQUFVO0FBQ1o7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsV0FBVztFQUNYLDRDQUE0QztFQUM1QyxZQUFZO0VBQ1osc0JBQXNCO0VBQ3RCLG9CQUFvQjtBQUN0QjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxPQUFPO0VBQ1AsV0FBVztFQUNYLGlCQUFpQjtFQUNqQixrQkFBa0I7RUFDbEIsVUFBVTtFQUNWLHlCQUF5QjtFQUN6Qix5QkFBeUI7RUFDekIsa0JBQWtCO0VBQ2xCLCtEQUErRDtFQUMvRCw0REFBNEQ7RUFDNUQsdURBQXVEO0FBQ3pEO0FBRUE7RUFDRSxzQkFBc0I7RUFDdEIsZ0NBQWdDO0VBQ2hDLGNBQWM7RUFDZCxzQkFBc0I7QUFDeEI7QUFFQTtFQUNFLHlCQUF5QjtFQUN6QixjQUFjO0VBQ2QsZUFBZTtFQUNmLFlBQVk7QUFDZDtBQUVBO0VBQ0UscUJBQXFCO0VBQ3JCLFNBQVM7RUFDVCxlQUFlO0VBQ2YsZ0JBQWdCO0FBQ2xCO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0FBQ0U7SUFDRSxXQUFXO0FBQ2I7QUFFQTtJQUNFLHNCQUFzQjtBQUN4QjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXY+XFxuICAgIDxsYWJlbCA6Zm9yPVxcXCJsYWJlbC5mb3JcXFwiPnt7IGxhYmVsLnRleHQgfX08L2xhYmVsPlxcbiAgICA8ZGl2IHYtaWY9XFxcInNlbGVjdGVkT3B0aW9ucyAmJiBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoID4gMFxcXCIgY2xhc3M9XFxcImNoaXAtbGlzdFxcXCI+XFxuICAgICAgPGRpdiB2LWZvcj1cXFwib3B0aW9uIGluIHNlbGVjdGVkT3B0aW9uc1xcXCIgQGNsaWNrPVxcXCJyZW1vdmVMYWJlbFNlbGVjdGlvbihvcHRpb24pXFxcIiA6a2V5PVxcXCJvcHRpb24uaWRcXFwiIGNsYXNzPVxcXCJjaGlwXFxcIj5cXG4gICAgICAgIDxzcGFuPnt7IG9wdGlvbi52YWx1ZSB9fTwvc3Bhbj5cXG4gICAgICAgIDxzdmctaWNvbiBpY29uLW5hbWU9XFxcImNyb3NzXFxcIj48aWNvbi1jcm9zcyAvPjwvc3ZnLWljb24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1jb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImF1dG8tY29tcGxldGVcXFwiPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgdi1tb2RlbC50cmltPVxcXCJzZWFyY2hTdHJpbmdcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImF1dG8tY29tcGxldGUtaW5wdXRcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IEBjbGljaz1cXFwiY2xlYXJJbnB1dFxcXCIgY2xhc3M9XFxcImNsZWFyLWlucHV0XFxcIj5cXG4gICAgICAgICAgPHN2Zy1pY29uIHYtaWY9XFxcInNlYXJjaFN0cmluZy5sZW5ndGggPiAwXFxcIiBpY29uLW5hbWU9XFxcImNyb3NzXFxcIj5cXG4gICAgICAgICAgICA8aWNvbi1jcm9zcyAvPlxcbiAgICAgICAgICA8L3N2Zy1pY29uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiB2LWlmPVxcXCJpc09wZW5lZCAmJiBvcHRpb25zLmxlbmd0aCA+IDBcXFwiIGNsYXNzPVxcXCJkcm9wLWRvd24tb3B0aW9uc1xcXCIgdi1vbi1jbGlja2F3YXk9XFxcImNsb3NlRHJvcERvd25cXFwiPlxcbiAgICAgICAgPGRpdiB2LWZvcj1cXFwib3B0aW9uIGluIG9wdGlvbnNcXFwiIDprZXk9XFxcIm9wdGlvbi5pZFxcXCIgQGNsaWNrPVxcXCJhZGRMYWJlbFNlbGVjdGlvbihvcHRpb24pXFxcIiBjbGFzcz1cXFwib3B0aW9uXFxcIj5cXG4gICAgICAgICAgPHA+e3sgb3B0aW9uLnByZWZMYWJlbCB9fTwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgdi1pZj1cXFwib3B0aW9ucy5sZW5ndGggPT0gMCAmJiBpc09wZW5lZFxcXCIgY2xhc3M9XFxcImRyb3AtZG93bi1vcHRpb25zIGVtcHR5LW9wdGlvbnNcXFwiIHYtb24tY2xpY2thd2F5PVxcXCJjbG9zZURyb3BEb3duXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm9wdGlvblxcXCIgc3R5bGU9XFxcInBhZGRpbmctbGVmdDogMTZweDtcXFwiPlxcbiAgICAgICAgICA8c3Bhbj57eyBub09wdGlvbnNNZXNzYWdlIH19PC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL2ljb25zL1N2Z0ljb24udnVlJztcXG5pbXBvcnQgSWNvbkNyb3NzIGZyb20gJy4uL2ljb25zL0ljb25Dcm9zcy52dWUnO1xcbmltcG9ydCBJY29uQ2hlY2sgZnJvbSAnLi4vaWNvbnMvSWNvbkNoZWNrLnZ1ZSc7XFxuaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2thd2F5IH0gZnJvbSAndnVlMy1jbGljay1hd2F5JztcXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xcbmltcG9ydCB7cmVmLCB3YXRjaCwgb25Nb3VudGVkLCBkZWZpbmVFbWl0cywgaW5qZWN0fSBmcm9tICd2dWUnO1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIGNvbXBvbmVudHM6IHtcXG4gICAgU3ZnSWNvbixcXG4gICAgSWNvbkNyb3NzLFxcbiAgICBJY29uQ2hlY2ssXFxuICB9LFxcbiAgZGlyZWN0aXZlczoge1xcbiAgICBvbkNsaWNrYXdheTogb25DbGlja2F3YXksXFxuICB9LFxcbiAgcHJvcHM6IHtcXG4gICAgdmFsdWVzOiBBcnJheSxcXG4gICAgdm9jYWJ1bGFyeTogU3RyaW5nLFxcbiAgICBsYW5ndWFnZTogU3RyaW5nLFxcbiAgICBsYWJlbDogT2JqZWN0LFxcbiAgICBoYXNVbmlxdWVWYWx1ZTogQm9vbGVhbixcXG4gIH0sXFxuICBzZXR1cChwcm9wcywgY29udGV4dCkge1xcbiAgICBjb25zdCAkdCA9IGluamVjdCgnJHQnKTtcXG4gICAgY29uc3QgaXNPcGVuZWQgPSByZWYoZmFsc2UpO1xcbiAgICBjb25zdCBub09wdGlvbnNNZXNzYWdlID0gJHQoJ25ldy5jb21tb24ubm9uZScpOyAvLyBQcm92aWRlIHRoZSB0cmFuc2xhdGlvbiBrZXlcXG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlZihbXSk7XFxuICAgIGNvbnN0IHNlYXJjaFN0cmluZyA9IHJlZignJyk7XFxuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IHJlZihbXSk7XFxuXFxuICAgIGNvbnN0IHNlYXJjaExhYmVsID0gZGVib3VuY2UoKCkgPT4ge1xcbiAgICAgIGlmIChzZWFyY2hTdHJpbmcudmFsdWUubGVuZ3RoID49IDMpIHtcXG4gICAgICAgIGZldGNoUmVzdWx0cyhjaGVja0NhcGl0YWxpemF0aW9uKHNlYXJjaFN0cmluZy52YWx1ZSkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpc09wZW5lZC52YWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtdO1xcbiAgICAgIH1cXG4gICAgfSwgMjAwKTtcXG5cXG4gICAgY29uc3QgZmV0Y2hSZXN1bHRzID0gYXN5bmMgKGlucHV0VmFsdWUpID0+IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoJ2h0dHBzOi8vYXBpLmZpbnRvLmZpL3Jlc3QvdjEvc2VhcmNoJywge1xcbiAgICAgICAgICBwYXJhbXM6IHtcXG4gICAgICAgICAgICB2b2NhYjogcHJvcHMudm9jYWJ1bGFyeSxcXG4gICAgICAgICAgICBsYW5nOiBwcm9wcy5sYW5ndWFnZSxcXG4gICAgICAgICAgICBxdWVyeTogaW5wdXRWYWx1ZSArICcqJyxcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0cztcXG4gICAgICAgIGlzT3BlbmVkLnZhbHVlID0gdHJ1ZTtcXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBjb25zdCBjaGVja0NhcGl0YWxpemF0aW9uID0gKGlucHV0VmFsdWUpID0+IHtcXG4gICAgICBpZiAoaW5wdXRWYWx1ZSAmJiBwcm9wcy52b2NhYnVsYXJ5ID09PSAnbmV3LmNvbW1vbi5wbGFjZXMnKSB7XFxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlucHV0VmFsdWUuc3Vic3RyaW5nKDEpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgYWRkTGFiZWxTZWxlY3Rpb24gPSAob3B0aW9uKSA9PiB7XFxuICAgICAgaXNPcGVuZWQudmFsdWUgPSBmYWxzZTtcXG4gICAgICBjb25zdCBvID0ge1xcbiAgICAgICAgdmFsdWU6IG9wdGlvbi5wcmVmTGFiZWwsXFxuICAgICAgICB1cmk6IG9wdGlvbi51cmksXFxuICAgICAgfTtcXG4gICAgICBpZiAocHJvcHMuaGFzVW5pcXVlVmFsdWUpIHtcXG4gICAgICAgIHNlbGVjdGVkT3B0aW9ucy52YWx1ZSA9IFtdO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIXNlbGVjdGVkT3B0aW9ucy52YWx1ZS5zb21lKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSBvLnZhbHVlKSkge1xcbiAgICAgICAgc2VsZWN0ZWRPcHRpb25zLnZhbHVlLnB1c2gobyk7XFxuICAgICAgfVxcbiAgICAgIHNlYXJjaFN0cmluZy52YWx1ZSA9ICcnO1xcbiAgICAgIGNvbnRleHQuZW1pdCgndXBkYXRlOnNlbGVjdGVkT3B0aW9ucycsIHNlbGVjdGVkT3B0aW9ucy52YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IHJlbW92ZUxhYmVsU2VsZWN0aW9uID0gKG9wdGlvbikgPT4ge1xcbiAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0ZWRPcHRpb25zLnZhbHVlLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS51cmkgPT09IG9wdGlvbi51cmkpO1xcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxuICAgICAgICBzZWxlY3RlZE9wdGlvbnMudmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICB9XFxuICAgICAgY29udGV4dC5lbWl0KCd1cGRhdGU6c2VsZWN0ZWRPcHRpb25zJywgc2VsZWN0ZWRPcHRpb25zLnZhbHVlKTsgLy8gRW1pdCB0aGUgZXZlbnRcXG4gICAgfTtcXG5cXG4gICAgY29uc3QgY2xvc2VEcm9wRG93biA9ICgpID0+IHtcXG4gICAgICBpc09wZW5lZC52YWx1ZSA9IGZhbHNlO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBjbGVhcklucHV0ID0gKCkgPT4ge1xcbiAgICAgIHNlYXJjaFN0cmluZy52YWx1ZSA9ICcnO1xcbiAgICB9O1xcblxcbiAgICB3YXRjaChzZWFyY2hTdHJpbmcsIHNlYXJjaExhYmVsKTtcXG5cXG4gICAgb25Nb3VudGVkKCgpID0+IHtcXG4gICAgICAvLyBJbml0aWFsaXplIGRhdGEgb3IgcGVyZm9ybSBhY3Rpb25zIGFmdGVyIGluaXRpYWwgcmVuZGVyXFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGlzT3BlbmVkLFxcbiAgICAgIG5vT3B0aW9uc01lc3NhZ2UsXFxuICAgICAgb3B0aW9ucyxcXG4gICAgICBzZWFyY2hTdHJpbmcsXFxuICAgICAgc2VsZWN0ZWRPcHRpb25zLFxcbiAgICAgIGFkZExhYmVsU2VsZWN0aW9uLFxcbiAgICAgIHJlbW92ZUxhYmVsU2VsZWN0aW9uLFxcbiAgICAgIGNsb3NlRHJvcERvd24sXFxuICAgICAgY2xlYXJJbnB1dCxcXG4gICAgfTtcXG4gIH0sXFxufTtcXG48L3NjcmlwdD5cXG5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbmxhYmVsIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4uaW5wdXQtY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLmNoaXAtbGlzdCB7XFxuICBtYXJnaW46IDE2cHggMCA4cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5jaGlwLWxpc3QgLmNoaXAge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzA2YTc5ODtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgbWFyZ2luOiAwIDhweCA4cHggMDtcXG4gIHBhZGRpbmc6IDEwcHggMzJweCA3cHggMTJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcblxcbi5jaGlwLWxpc3QgLmNoaXAgc3ZnIHtcXG4gIGhlaWdodDogMTZweDtcXG4gIHotaW5kZXg6IDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiA4cHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuXFxuLmF1dG8tY29tcGxldGUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogNDBweDtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcXG4gIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLmF1dG8tY29tcGxldGUtaW5wdXQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1NSU7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1sZWZ0OiAxMHB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBib3JkZXI6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgei1pbmRleDogMTtcXG59XFxuXFxuLmF1dG8tY29tcGxldGUgc3ZnIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTIlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMThweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcXG59XFxuXFxuLmRyb3AtZG93bi1vcHRpb25zIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNDJweDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgei1pbmRleDogMjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTFlMWUxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgLW1vei1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcXG59XFxuXFxuLm9wdGlvbiB7XFxuICBwYWRkaW5nOiAxMHB4IDEycHggNnB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1ZjU7XFxuICBjb2xvcjogIzU1NTU1NTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcblxcbi5vcHRpb246aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZmJmYTtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG5cXG4ub3B0aW9uIHAge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuXFxuLnNlbGVjdGVkIHtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbi5lbXB0eS1vcHRpb25zIHtcXG4gIG1pbi13aWR0aDogMjUwcHg7XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbiAgLmlucHV0LWNvbnRhaW5lciwgLmRyb3AtZG93bi1vcHRpb25zIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuXFxuICAub3B0aW9uIHtcXG4gICAgcGFkZGluZzogMTJweCA2cHggMTFweDtcXG4gIH1cXG59XFxuPC9zdHlsZT5cXG5cXG5cXG5cXG5cXG5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2150\n");

/***/ }),

/***/ 4225:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\na[data-v-e062b0ac], a[data-v-e062b0ac]:hover, a[data-v-e062b0ac]:active, a[data-v-e062b0ac]:visited {\\n  color: #00748f;\\n}\\nlabel[data-v-e062b0ac] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.input-container[data-v-e062b0ac] {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n.chip-list[data-v-e062b0ac] {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n.chip-list .chip[data-v-e062b0ac] {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.chip-list .chip svg[data-v-e062b0ac] {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n.auto-complete[data-v-e062b0ac] {\\n  position: relative;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border-radius: 1px;\\n  font-size: 14px;\\n}\\n.auto-complete-input[data-v-e062b0ac] {\\n  position: absolute;\\n  top: 53.5%;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 100%;\\n  width: 100%;\\n  padding-left: 10px;\\n  overflow: hidden;\\n  font-size: 14px;\\n  font-weight: 400;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  border: none;\\n  outline: none;\\n}\\n.auto-complete svg[data-v-e062b0ac] {\\n  position: absolute;\\n  top: 52%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 18px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n.drop-down-options[data-v-e062b0ac] {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n.option[data-v-e062b0ac] {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n.option[data-v-e062b0ac]:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.option p[data-v-e062b0ac] {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n.selected[data-v-e062b0ac] {\\n  font-weight: 500;\\n}\\n.empty-options[data-v-e062b0ac] {\\n  min-width: 250px;\\n}\\n@media (max-width: 700px) {\\n.input-container[data-v-e062b0ac], .drop-down-options[data-v-e062b0ac] {\\n    width: 100%;\\n}\\n.option[data-v-e062b0ac] {\\n    padding: 12px 6px 11px;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/SearchInput.vue\"],\"names\":[],\"mappings\":\";AAqIA;EACE,cAAc;AAChB;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;EACE,WAAW;EACX,mBAAmB;EACnB,kBAAkB;AACpB;AAEA;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,2BAA2B,EAAE,eAAe;EAC5C,yBAAyB,EAAE,WAAW;EACtC,sBAAsB,EAAE,YAAY;EACpC,qBAAqB,EAAE,2BAA2B;EAClD,iBAAiB;AACnB;AAEA;EACE,qBAAqB;EACrB,yBAAyB;EACzB,cAAc;EACd,mBAAmB;EACnB,2BAA2B;EAC3B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd;AAEA;EACE,YAAY;EACZ,UAAU;EACV,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,4CAA4C;AAC9C;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,WAAW;EACX,YAAY;EACZ,cAAc;EACd,yBAAyB;EACzB,kBAAkB;EAClB,eAAe;AACjB;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,4CAA4C;EAC5C,YAAY;EACZ,WAAW;EACX,kBAAkB;EAClB,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,yBAAyB;EACzB,cAAc;EACd,YAAY;EACZ,aAAa;AACf;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,4CAA4C;EAC5C,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;AACtB;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,WAAW;EACX,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,yBAAyB;EACzB,yBAAyB;EACzB,kBAAkB;EAClB,+DAA+D;EAC/D,4DAA4D;EAC5D,uDAAuD;AACzD;AAEA;EACE,sBAAsB;EACtB,gCAAgC;EAChC,cAAc;EACd,sBAAsB;AACxB;AAEA;EACE,yBAAyB;EACzB,cAAc;EACd,eAAe;EACf,YAAY;AACd;AAEA;EACE,qBAAqB;EACrB,SAAS;EACT,eAAe;EACf,gBAAgB;AAClB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,gBAAgB;AAClB;AAEA;AACE;IACE,WAAW;AACb;AAEA;IACE,sBAAsB;AACxB;AACF\",\"sourcesContent\":[\"<template>\\n<div>\\n  <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n  <div v-if=\\\"searchResult\\n    && searchResult.uri.length > 0\\n    && searchString.toLowerCase() === searchResult.prefLabel.toLowerCase()\\\">\\n      <div v-if=\\\"searchResult.vocab === 'yse'\\\">\\n        <p>\\n          {{ $t('new.common.ifyse1') }}\\n          <strong><a target=\\\"_blank\\\" :href=\\\"searchResult.uri\\\">{{ searchResult.lang === language ? searchResult.prefLabel : ''}}</a></strong>\\n          {{ $t('new.common.ifyse2') }}\\n        </p>\\n      </div>\\n    <div v-if=\\\"searchResult.vocab === 'yso'\\\">\\n      <p>\\n        {{ $t('new.common.ifyso') }}\\n        <strong><a target=\\\"_blank\\\" :href=\\\"searchResult.uri\\\">{{ searchResult.lang === language ? searchResult.prefLabel : ''}}</a></strong>\\n      </p>\\n    </div>\\n    <div v-if=\\\"searchResult.vocab === 'yso-paikat'\\\">\\n      <p>\\n        {{ $t('new.common.ifysopaikat') }}\\n        <strong><a target=\\\"_blank\\\" :href=\\\"searchResult.uri\\\">{{ searchResult.lang === language ? searchResult.prefLabel : ''}}</a></strong>\\n      </p>\\n    </div>\\n  </div>\\n  <div class=\\\"input-container\\\">\\n    <div class=\\\"auto-complete\\\">\\n      <input\\n        v-model.trim=\\\"searchString\\\"\\n        class=\\\"auto-complete-input\\\"\\n        type=\\\"text\\\" />\\n      <div @click=\\\"searchString = ''\\\" class=\\\"clear-input\\\">\\n        <svg-icon\\n          v-if=\\\"searchString.length > 0\\\"\\n          icon-name=\\\"cross\\\">\\n          <icon-cross />\\n        </svg-icon>\\n      </div>\\n    </div>\\n  </div>\\n</div>\\n</template>\\n\\n<script>\\nimport { defineComponent, ref, reactive, watchEffect, inject, watch } from 'vue';\\nimport SvgIcon from '../icons/SvgIcon.vue';\\nimport IconCross from '../icons/IconCross.vue';\\nimport IconCheck from '../icons/IconCheck.vue';\\n// import { directive as onClickaway } from 'vue-clickaway';\\n// import { onClickaway } from \\\"vue3-click-away\\\";\\nimport axios from 'axios';\\nimport debounce from 'lodash/debounce';\\n\\nexport default {\\n  components: {\\n    SvgIcon,\\n    IconCross,\\n    IconCheck\\n  },\\n  props: {\\n    values: Array,\\n    vocabulary: String,\\n    label: Object,\\n    // vocabulary: String,\\n    language: String,\\n    conceptType: String\\n  },\\n\\n  setup (props, context) {\\n\\n    const $t = inject('$t');\\n\\n    let searchString = ref('')\\n    let searchResult = ref(null)\\n\\n    watch(searchString, () => {\\n      searchLabel();\\n    });\\n\\n    const searchLabel = debounce(function() {\\n      if (searchString.value.length >= 2) {\\n        handleResult(checkCapitalization(searchString.value));\\n      } else {\\n        context.emit('input', searchString.value);\\n      }\\n    }, 1500)\\n    const handleResult = async (inputValue) => {\\n      const vocs = [\\\"yso-paikat\\\", \\\"yso\\\", \\\"yse\\\"];\\n      for (var i = 0; i < vocs.length; i++) {\\n        const response = await axios({\\n          method: 'get',\\n          url: 'https://api.finto.fi/rest/v1/search',\\n          params: {\\n            vocab: vocs[i],\\n            lang: props.language,\\n            query: inputValue\\n          }\\n        }).catch(error => console.log(error));\\n        // For the future: this is assigned only if the term is found and is null otherwise\\n        searchResult.value = response.data.results[0]\\n        context.emit('input', searchString.value);\\n        if (searchResult.value) {\\n          context.emit('input', '');\\n          break;\\n        }\\n      }\\n    }\\n\\n    const capitalizeFirstLetter = (string) => {\\n      return string.charAt(0).toUpperCase() + string.slice(1);\\n    }\\n\\n    const checkCapitalization = (inputValue) => {\\n      if (inputValue && props.vocabulary === $t('new.common.places')) {\\n        return inputValue.charAt(0).toUpperCase() + inputValue.substr(1);\\n      }\\n      return inputValue;\\n    }\\n\\n    return {\\n      searchLabel,\\n      searchString ,\\n      searchResult,\\n      capitalizeFirstLetter,\\n      checkCapitalization,\\n      handleResult\\n    }\\n  }\\n};\\n</script>\\n\\n<style scoped>\\na, a:hover, a:active, a:visited {\\n  color: #00748f;\\n}\\n\\nlabel {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.input-container {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n\\n.chip-list {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n\\n.chip-list .chip {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.chip-list .chip svg {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n\\n.auto-complete {\\n  position: relative;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border-radius: 1px;\\n  font-size: 14px;\\n}\\n\\n.auto-complete-input {\\n  position: absolute;\\n  top: 53.5%;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 100%;\\n  width: 100%;\\n  padding-left: 10px;\\n  overflow: hidden;\\n  font-size: 14px;\\n  font-weight: 400;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  border: none;\\n  outline: none;\\n}\\n\\n.auto-complete svg {\\n  position: absolute;\\n  top: 52%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 18px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n\\n.drop-down-options {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n\\n.option {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n\\n.option:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.option p {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n\\n.selected {\\n  font-weight: 500;\\n}\\n\\n.empty-options {\\n  min-width: 250px;\\n}\\n\\n@media (max-width: 700px) {\\n  .input-container, .drop-down-options {\\n    width: 100%;\\n  }\\n\\n  .option {\\n    padding: 12px 6px 11px;\\n  }\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIyNS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxpSkFBaUosbUJBQW1CLEdBQUcsMEJBQTBCLG1CQUFtQixxQkFBcUIsb0JBQW9CLG1CQUFtQix1QkFBdUIsR0FBRyxxQ0FBcUMsZ0JBQWdCLHdCQUF3Qix1QkFBdUIsR0FBRywrQkFBK0IsdUJBQXVCLG9CQUFvQixxQkFBcUIsaUNBQWlDLCtDQUErQyx3Q0FBd0Msd0NBQXdDLGtEQUFrRCxHQUFHLHFDQUFxQywwQkFBMEIsOEJBQThCLG1CQUFtQix3QkFBd0IsZ0NBQWdDLHdCQUF3Qix1QkFBdUIsb0JBQW9CLGlCQUFpQixHQUFHLHlDQUF5QyxpQkFBaUIsZUFBZSx1QkFBdUIsYUFBYSxlQUFlLGlEQUFpRCxHQUFHLG1DQUFtQyx1QkFBdUIsbUJBQW1CLGdCQUFnQixpQkFBaUIsbUJBQW1CLDhCQUE4Qix1QkFBdUIsb0JBQW9CLEdBQUcseUNBQXlDLHVCQUF1QixlQUFlLGlEQUFpRCxpQkFBaUIsZ0JBQWdCLHVCQUF1QixxQkFBcUIsb0JBQW9CLHFCQUFxQiw4QkFBOEIsbUJBQW1CLGlCQUFpQixrQkFBa0IsR0FBRyx1Q0FBdUMsdUJBQXVCLGFBQWEsZ0JBQWdCLGlEQUFpRCxpQkFBaUIsMkJBQTJCLHlCQUF5QixHQUFHLHVDQUF1Qyx1QkFBdUIsY0FBYyxZQUFZLGdCQUFnQixzQkFBc0IsdUJBQXVCLGVBQWUsOEJBQThCLDhCQUE4Qix1QkFBdUIsb0VBQW9FLGlFQUFpRSw0REFBNEQsR0FBRyw0QkFBNEIsMkJBQTJCLHFDQUFxQyxtQkFBbUIsMkJBQTJCLEdBQUcsa0NBQWtDLDhCQUE4QixtQkFBbUIsb0JBQW9CLGlCQUFpQixHQUFHLDhCQUE4QiwwQkFBMEIsY0FBYyxvQkFBb0IscUJBQXFCLEdBQUcsOEJBQThCLHFCQUFxQixHQUFHLG1DQUFtQyxxQkFBcUIsR0FBRyw2QkFBNkIsMEVBQTBFLGtCQUFrQixHQUFHLDRCQUE0Qiw2QkFBNkIsR0FBRyxHQUFHLFNBQVMsa0dBQWtHLE1BQU0sVUFBVSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksdUJBQXVCLHVCQUF1Qix1QkFBdUIseUJBQXlCLGFBQWEsTUFBTSxLQUFLLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLE1BQU0sS0FBSyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxhQUFhLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksTUFBTSwyRUFBMkUsYUFBYSxzT0FBc08sMEJBQTBCLHVFQUF1RSw4REFBOEQsNEJBQTRCLDBCQUEwQixxR0FBcUcseUJBQXlCLHFFQUFxRSw4REFBOEQscUhBQXFILCtCQUErQixxRUFBcUUsOERBQThELHlnQkFBeWdCLDZEQUE2RCxXQUFXLDZDQUE2QyxpREFBaUQsaURBQWlELGNBQWMsMkJBQTJCLHFCQUFxQixjQUFjLGNBQWMseUJBQXlCLDRCQUE0Qix5Q0FBeUMsb0JBQW9CLGlCQUFpQixrREFBa0QsYUFBYSxrSkFBa0osK0JBQStCLGdDQUFnQyx1R0FBdUcsc0JBQXNCLE9BQU8sRUFBRSxpREFBaUQsNkNBQTZDLGdFQUFnRSxVQUFVLE1BQU0sb0RBQW9ELFNBQVMsT0FBTyx5REFBeUQsd0RBQXdELHdCQUF3QixpQkFBaUIsTUFBTSx3Q0FBd0Msc0dBQXNHLDRHQUE0RyxXQUFXLHFDQUFxQyx3TUFBd00sbUNBQW1DLHNDQUFzQyxrQkFBa0IsV0FBVyxTQUFTLE9BQU8sbURBQW1ELGdFQUFnRSxPQUFPLHFEQUFxRCx5RUFBeUUsMkVBQTJFLFNBQVMsMEJBQTBCLE9BQU8sZ0JBQWdCLG9KQUFvSixLQUFLLElBQUksZ0VBQWdFLG1CQUFtQixHQUFHLFdBQVcsbUJBQW1CLHFCQUFxQixvQkFBb0IsbUJBQW1CLHVCQUF1QixHQUFHLHNCQUFzQixnQkFBZ0Isd0JBQXdCLHVCQUF1QixHQUFHLGdCQUFnQix1QkFBdUIsb0JBQW9CLHFCQUFxQixpQ0FBaUMsK0NBQStDLHdDQUF3Qyx3Q0FBd0Msa0RBQWtELEdBQUcsc0JBQXNCLDBCQUEwQiw4QkFBOEIsbUJBQW1CLHdCQUF3QixnQ0FBZ0Msd0JBQXdCLHVCQUF1QixvQkFBb0IsaUJBQWlCLEdBQUcsMEJBQTBCLGlCQUFpQixlQUFlLHVCQUF1QixhQUFhLGVBQWUsaURBQWlELEdBQUcsb0JBQW9CLHVCQUF1QixtQkFBbUIsZ0JBQWdCLGlCQUFpQixtQkFBbUIsOEJBQThCLHVCQUF1QixvQkFBb0IsR0FBRywwQkFBMEIsdUJBQXVCLGVBQWUsaURBQWlELGlCQUFpQixnQkFBZ0IsdUJBQXVCLHFCQUFxQixvQkFBb0IscUJBQXFCLDhCQUE4QixtQkFBbUIsaUJBQWlCLGtCQUFrQixHQUFHLHdCQUF3Qix1QkFBdUIsYUFBYSxnQkFBZ0IsaURBQWlELGlCQUFpQiwyQkFBMkIseUJBQXlCLEdBQUcsd0JBQXdCLHVCQUF1QixjQUFjLFlBQVksZ0JBQWdCLHNCQUFzQix1QkFBdUIsZUFBZSw4QkFBOEIsOEJBQThCLHVCQUF1QixvRUFBb0UsaUVBQWlFLDREQUE0RCxHQUFHLGFBQWEsMkJBQTJCLHFDQUFxQyxtQkFBbUIsMkJBQTJCLEdBQUcsbUJBQW1CLDhCQUE4QixtQkFBbUIsb0JBQW9CLGlCQUFpQixHQUFHLGVBQWUsMEJBQTBCLGNBQWMsb0JBQW9CLHFCQUFxQixHQUFHLGVBQWUscUJBQXFCLEdBQUcsb0JBQW9CLHFCQUFxQixHQUFHLCtCQUErQiwwQ0FBMEMsa0JBQWtCLEtBQUssZUFBZSw2QkFBNkIsS0FBSyxHQUFHLCtCQUErQjtBQUNwMFY7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9mb3JtL1NlYXJjaElucHV0LnZ1ZT80ZmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuYVtkYXRhLXYtZTA2MmIwYWNdLCBhW2RhdGEtdi1lMDYyYjBhY106aG92ZXIsIGFbZGF0YS12LWUwNjJiMGFjXTphY3RpdmUsIGFbZGF0YS12LWUwNjJiMGFjXTp2aXNpdGVkIHtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbn1cXG5sYWJlbFtkYXRhLXYtZTA2MmIwYWNdIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG4uaW5wdXQtY29udGFpbmVyW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uY2hpcC1saXN0W2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgbWFyZ2luOiAxNnB4IDAgOHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG4uY2hpcC1saXN0IC5jaGlwW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzA2YTc5ODtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgbWFyZ2luOiAwIDhweCA4cHggMDtcXG4gIHBhZGRpbmc6IDEwcHggMzJweCA3cHggMTJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcbi5jaGlwLWxpc3QgLmNoaXAgc3ZnW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgei1pbmRleDogNDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgcmlnaHQ6IDhweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbn1cXG4uYXV0by1jb21wbGV0ZVtkYXRhLXYtZTA2MmIwYWNdIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5hdXRvLWNvbXBsZXRlLWlucHV0W2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1My41JTtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5hdXRvLWNvbXBsZXRlIHN2Z1tkYXRhLXYtZTA2MmIwYWNdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTIlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMThweDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgMCAtNHB4IDZweDtcXG59XFxuLmRyb3AtZG93bi1vcHRpb25zW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0MnB4O1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LWhlaWdodDogMjAwcHg7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB6LWluZGV4OiAyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICBib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgcGFkZGluZzogMTBweCAxMnB4IDZweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZjVmNWY1O1xcbiAgY29sb3I6ICM1NTU1NTU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi1lMDYyYjBhY106aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZmJmYTtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4ub3B0aW9uIHBbZGF0YS12LWUwNjJiMGFjXSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG4uc2VsZWN0ZWRbZGF0YS12LWUwNjJiMGFjXSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG4uZW1wdHktb3B0aW9uc1tkYXRhLXYtZTA2MmIwYWNdIHtcXG4gIG1pbi13aWR0aDogMjUwcHg7XFxufVxcbkBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbi5pbnB1dC1jb250YWluZXJbZGF0YS12LWUwNjJiMGFjXSwgLmRyb3AtZG93bi1vcHRpb25zW2RhdGEtdi1lMDYyYjBhY10ge1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuLm9wdGlvbltkYXRhLXYtZTA2MmIwYWNdIHtcXG4gICAgcGFkZGluZzogMTJweCA2cHggMTFweDtcXG59XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoSW5wdXQudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFxSUE7RUFDRSxjQUFjO0FBQ2hCO0FBRUE7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixjQUFjO0VBQ2Qsa0JBQWtCO0FBQ3BCO0FBRUE7RUFDRSxXQUFXO0VBQ1gsbUJBQW1CO0VBQ25CLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsMkJBQTJCLEVBQUUsZUFBZTtFQUM1Qyx5QkFBeUIsRUFBRSxXQUFXO0VBQ3RDLHNCQUFzQixFQUFFLFlBQVk7RUFDcEMscUJBQXFCLEVBQUUsMkJBQTJCO0VBQ2xELGlCQUFpQjtBQUNuQjtBQUVBO0VBQ0UscUJBQXFCO0VBQ3JCLHlCQUF5QjtFQUN6QixjQUFjO0VBQ2QsbUJBQW1CO0VBQ25CLDJCQUEyQjtFQUMzQixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixZQUFZO0FBQ2Q7QUFFQTtFQUNFLFlBQVk7RUFDWixVQUFVO0VBQ1Ysa0JBQWtCO0VBQ2xCLFFBQVE7RUFDUixVQUFVO0VBQ1YsNENBQTRDO0FBQzlDO0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsY0FBYztFQUNkLFdBQVc7RUFDWCxZQUFZO0VBQ1osY0FBYztFQUNkLHlCQUF5QjtFQUN6QixrQkFBa0I7RUFDbEIsZUFBZTtBQUNqQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFVBQVU7RUFDViw0Q0FBNEM7RUFDNUMsWUFBWTtFQUNaLFdBQVc7RUFDWCxrQkFBa0I7RUFDbEIsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIseUJBQXlCO0VBQ3pCLGNBQWM7RUFDZCxZQUFZO0VBQ1osYUFBYTtBQUNmO0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsUUFBUTtFQUNSLFdBQVc7RUFDWCw0Q0FBNEM7RUFDNUMsWUFBWTtFQUNaLHNCQUFzQjtFQUN0QixvQkFBb0I7QUFDdEI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixTQUFTO0VBQ1QsT0FBTztFQUNQLFdBQVc7RUFDWCxpQkFBaUI7RUFDakIsa0JBQWtCO0VBQ2xCLFVBQVU7RUFDVix5QkFBeUI7RUFDekIseUJBQXlCO0VBQ3pCLGtCQUFrQjtFQUNsQiwrREFBK0Q7RUFDL0QsNERBQTREO0VBQzVELHVEQUF1RDtBQUN6RDtBQUVBO0VBQ0Usc0JBQXNCO0VBQ3RCLGdDQUFnQztFQUNoQyxjQUFjO0VBQ2Qsc0JBQXNCO0FBQ3hCO0FBRUE7RUFDRSx5QkFBeUI7RUFDekIsY0FBYztFQUNkLGVBQWU7RUFDZixZQUFZO0FBQ2Q7QUFFQTtFQUNFLHFCQUFxQjtFQUNyQixTQUFTO0VBQ1QsZUFBZTtFQUNmLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsZ0JBQWdCO0FBQ2xCO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTtBQUNFO0lBQ0UsV0FBVztBQUNiO0FBRUE7SUFDRSxzQkFBc0I7QUFDeEI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuPGRpdj5cXG4gIDxsYWJlbCA6Zm9yPVxcXCJsYWJlbC5mb3JcXFwiPnt7IGxhYmVsLnRleHQgfX08L2xhYmVsPlxcbiAgPGRpdiB2LWlmPVxcXCJzZWFyY2hSZXN1bHRcXG4gICAgJiYgc2VhcmNoUmVzdWx0LnVyaS5sZW5ndGggPiAwXFxuICAgICYmIHNlYXJjaFN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBzZWFyY2hSZXN1bHQucHJlZkxhYmVsLnRvTG93ZXJDYXNlKClcXFwiPlxcbiAgICAgIDxkaXYgdi1pZj1cXFwic2VhcmNoUmVzdWx0LnZvY2FiID09PSAneXNlJ1xcXCI+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAge3sgJHQoJ25ldy5jb21tb24uaWZ5c2UxJykgfX1cXG4gICAgICAgICAgPHN0cm9uZz48YSB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgOmhyZWY9XFxcInNlYXJjaFJlc3VsdC51cmlcXFwiPnt7IHNlYXJjaFJlc3VsdC5sYW5nID09PSBsYW5ndWFnZSA/IHNlYXJjaFJlc3VsdC5wcmVmTGFiZWwgOiAnJ319PC9hPjwvc3Ryb25nPlxcbiAgICAgICAgICB7eyAkdCgnbmV3LmNvbW1vbi5pZnlzZTInKSB9fVxcbiAgICAgICAgPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8ZGl2IHYtaWY9XFxcInNlYXJjaFJlc3VsdC52b2NhYiA9PT0gJ3lzbydcXFwiPlxcbiAgICAgIDxwPlxcbiAgICAgICAge3sgJHQoJ25ldy5jb21tb24uaWZ5c28nKSB9fVxcbiAgICAgICAgPHN0cm9uZz48YSB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgOmhyZWY9XFxcInNlYXJjaFJlc3VsdC51cmlcXFwiPnt7IHNlYXJjaFJlc3VsdC5sYW5nID09PSBsYW5ndWFnZSA/IHNlYXJjaFJlc3VsdC5wcmVmTGFiZWwgOiAnJ319PC9hPjwvc3Ryb25nPlxcbiAgICAgIDwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgdi1pZj1cXFwic2VhcmNoUmVzdWx0LnZvY2FiID09PSAneXNvLXBhaWthdCdcXFwiPlxcbiAgICAgIDxwPlxcbiAgICAgICAge3sgJHQoJ25ldy5jb21tb24uaWZ5c29wYWlrYXQnKSB9fVxcbiAgICAgICAgPHN0cm9uZz48YSB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgOmhyZWY9XFxcInNlYXJjaFJlc3VsdC51cmlcXFwiPnt7IHNlYXJjaFJlc3VsdC5sYW5nID09PSBsYW5ndWFnZSA/IHNlYXJjaFJlc3VsdC5wcmVmTGFiZWwgOiAnJ319PC9hPjwvc3Ryb25nPlxcbiAgICAgIDwvcD5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImlucHV0LWNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImF1dG8tY29tcGxldGVcXFwiPlxcbiAgICAgIDxpbnB1dFxcbiAgICAgICAgdi1tb2RlbC50cmltPVxcXCJzZWFyY2hTdHJpbmdcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiYXV0by1jb21wbGV0ZS1pbnB1dFxcXCJcXG4gICAgICAgIHR5cGU9XFxcInRleHRcXFwiIC8+XFxuICAgICAgPGRpdiBAY2xpY2s9XFxcInNlYXJjaFN0cmluZyA9ICcnXFxcIiBjbGFzcz1cXFwiY2xlYXItaW5wdXRcXFwiPlxcbiAgICAgICAgPHN2Zy1pY29uXFxuICAgICAgICAgIHYtaWY9XFxcInNlYXJjaFN0cmluZy5sZW5ndGggPiAwXFxcIlxcbiAgICAgICAgICBpY29uLW5hbWU9XFxcImNyb3NzXFxcIj5cXG4gICAgICAgICAgPGljb24tY3Jvc3MgLz5cXG4gICAgICAgIDwvc3ZnLWljb24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCB7IGRlZmluZUNvbXBvbmVudCwgcmVmLCByZWFjdGl2ZSwgd2F0Y2hFZmZlY3QsIGluamVjdCwgd2F0Y2ggfSBmcm9tICd2dWUnO1xcbmltcG9ydCBTdmdJY29uIGZyb20gJy4uL2ljb25zL1N2Z0ljb24udnVlJztcXG5pbXBvcnQgSWNvbkNyb3NzIGZyb20gJy4uL2ljb25zL0ljb25Dcm9zcy52dWUnO1xcbmltcG9ydCBJY29uQ2hlY2sgZnJvbSAnLi4vaWNvbnMvSWNvbkNoZWNrLnZ1ZSc7XFxuLy8gaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2thd2F5IH0gZnJvbSAndnVlLWNsaWNrYXdheSc7XFxuLy8gaW1wb3J0IHsgb25DbGlja2F3YXkgfSBmcm9tIFxcXCJ2dWUzLWNsaWNrLWF3YXlcXFwiO1xcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgY29tcG9uZW50czoge1xcbiAgICBTdmdJY29uLFxcbiAgICBJY29uQ3Jvc3MsXFxuICAgIEljb25DaGVja1xcbiAgfSxcXG4gIHByb3BzOiB7XFxuICAgIHZhbHVlczogQXJyYXksXFxuICAgIHZvY2FidWxhcnk6IFN0cmluZyxcXG4gICAgbGFiZWw6IE9iamVjdCxcXG4gICAgLy8gdm9jYWJ1bGFyeTogU3RyaW5nLFxcbiAgICBsYW5ndWFnZTogU3RyaW5nLFxcbiAgICBjb25jZXB0VHlwZTogU3RyaW5nXFxuICB9LFxcblxcbiAgc2V0dXAgKHByb3BzLCBjb250ZXh0KSB7XFxuXFxuICAgIGNvbnN0ICR0ID0gaW5qZWN0KCckdCcpO1xcblxcbiAgICBsZXQgc2VhcmNoU3RyaW5nID0gcmVmKCcnKVxcbiAgICBsZXQgc2VhcmNoUmVzdWx0ID0gcmVmKG51bGwpXFxuXFxuICAgIHdhdGNoKHNlYXJjaFN0cmluZywgKCkgPT4ge1xcbiAgICAgIHNlYXJjaExhYmVsKCk7XFxuICAgIH0pO1xcblxcbiAgICBjb25zdCBzZWFyY2hMYWJlbCA9IGRlYm91bmNlKGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmIChzZWFyY2hTdHJpbmcudmFsdWUubGVuZ3RoID49IDIpIHtcXG4gICAgICAgIGhhbmRsZVJlc3VsdChjaGVja0NhcGl0YWxpemF0aW9uKHNlYXJjaFN0cmluZy52YWx1ZSkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb250ZXh0LmVtaXQoJ2lucHV0Jywgc2VhcmNoU3RyaW5nLnZhbHVlKTtcXG4gICAgICB9XFxuICAgIH0sIDE1MDApXFxuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IGFzeW5jIChpbnB1dFZhbHVlKSA9PiB7XFxuICAgICAgY29uc3Qgdm9jcyA9IFtcXFwieXNvLXBhaWthdFxcXCIsIFxcXCJ5c29cXFwiLCBcXFwieXNlXFxcIl07XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2b2NzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zKHtcXG4gICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcXG4gICAgICAgICAgdXJsOiAnaHR0cHM6Ly9hcGkuZmludG8uZmkvcmVzdC92MS9zZWFyY2gnLFxcbiAgICAgICAgICBwYXJhbXM6IHtcXG4gICAgICAgICAgICB2b2NhYjogdm9jc1tpXSxcXG4gICAgICAgICAgICBsYW5nOiBwcm9wcy5sYW5ndWFnZSxcXG4gICAgICAgICAgICBxdWVyeTogaW5wdXRWYWx1ZVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBjb25zb2xlLmxvZyhlcnJvcikpO1xcbiAgICAgICAgLy8gRm9yIHRoZSBmdXR1cmU6IHRoaXMgaXMgYXNzaWduZWQgb25seSBpZiB0aGUgdGVybSBpcyBmb3VuZCBhbmQgaXMgbnVsbCBvdGhlcndpc2VcXG4gICAgICAgIHNlYXJjaFJlc3VsdC52YWx1ZSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0c1swXVxcbiAgICAgICAgY29udGV4dC5lbWl0KCdpbnB1dCcsIHNlYXJjaFN0cmluZy52YWx1ZSk7XFxuICAgICAgICBpZiAoc2VhcmNoUmVzdWx0LnZhbHVlKSB7XFxuICAgICAgICAgIGNvbnRleHQuZW1pdCgnaW5wdXQnLCAnJyk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSAoc3RyaW5nKSA9PiB7XFxuICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBjaGVja0NhcGl0YWxpemF0aW9uID0gKGlucHV0VmFsdWUpID0+IHtcXG4gICAgICBpZiAoaW5wdXRWYWx1ZSAmJiBwcm9wcy52b2NhYnVsYXJ5ID09PSAkdCgnbmV3LmNvbW1vbi5wbGFjZXMnKSkge1xcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpbnB1dFZhbHVlLnN1YnN0cigxKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBzZWFyY2hMYWJlbCxcXG4gICAgICBzZWFyY2hTdHJpbmcgLFxcbiAgICAgIHNlYXJjaFJlc3VsdCxcXG4gICAgICBjYXBpdGFsaXplRmlyc3RMZXR0ZXIsXFxuICAgICAgY2hlY2tDYXBpdGFsaXphdGlvbixcXG4gICAgICBoYW5kbGVSZXN1bHRcXG4gICAgfVxcbiAgfVxcbn07XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlIHNjb3BlZD5cXG5hLCBhOmhvdmVyLCBhOmFjdGl2ZSwgYTp2aXNpdGVkIHtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbn1cXG5cXG5sYWJlbCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5jaGlwLWxpc3Qge1xcbiAgbWFyZ2luOiAxNnB4IDAgOHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4uY2hpcC1saXN0IC5jaGlwIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwNmE3OTg7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG4gIG1hcmdpbjogMCA4cHggOHB4IDA7XFxuICBwYWRkaW5nOiAxMHB4IDMycHggN3B4IDEycHg7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG5cXG4uY2hpcC1saXN0IC5jaGlwIHN2ZyB7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICB6LWluZGV4OiA0O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICByaWdodDogOHB4O1xcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XFxufVxcblxcbi5hdXRvLWNvbXBsZXRlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi5hdXRvLWNvbXBsZXRlLWlucHV0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTMuNSU7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1sZWZ0OiAxMHB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBib3JkZXI6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4uYXV0by1jb21wbGV0ZSBzdmcge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MiU7XFxuICByaWdodDogMTBweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIG1hcmdpbjogMCAwIC00cHggNnB4O1xcbn1cXG5cXG4uZHJvcC1kb3duLW9wdGlvbnMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA0MnB4O1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LWhlaWdodDogMjAwcHg7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB6LWluZGV4OiAyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlMWUxZTE7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICAtbW96LWJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxuICBib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbn1cXG5cXG4ub3B0aW9uIHtcXG4gIHBhZGRpbmc6IDEwcHggMTJweCA2cHg7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVmNTtcXG4gIGNvbG9yOiAjNTU1NTU1O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuXFxuLm9wdGlvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmYmZhO1xcbiAgY29sb3I6ICMxMTExMTE7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcblxcbi5vcHRpb24gcCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG5cXG4uc2VsZWN0ZWQge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuXFxuLmVtcHR5LW9wdGlvbnMge1xcbiAgbWluLXdpZHRoOiAyNTBweDtcXG59XFxuXFxuQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XFxuICAuaW5wdXQtY29udGFpbmVyLCAuZHJvcC1kb3duLW9wdGlvbnMge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC5vcHRpb24ge1xcbiAgICBwYWRkaW5nOiAxMnB4IDZweCAxMXB4O1xcbiAgfVxcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4225\n");

/***/ }),

/***/ 7816:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nlabel[data-v-e34bb30e] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.input-container[data-v-e34bb30e] {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n.chip-list[data-v-e34bb30e] {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n.chip-list .chip[data-v-e34bb30e] {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.chip-list .chip svg[data-v-e34bb30e] {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n.select-button[data-v-e34bb30e] {\\n  position: relative;\\n  display: block;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border: none;\\n  border-radius: 1px;\\n  font-size: 14px;\\n  outline: none;\\n  -webkit-appearance: none;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.select-button .select-content[data-v-e34bb30e] {\\n  position: absolute;\\n  top: 55%;\\n  left: 14px;\\n  transform: perspective(1px) translateY(-50%);\\n  overflow: hidden;\\n  font-size: 13px;\\n  font-weight: 400;\\n  color: #00748f;\\n}\\n.select-button svg[data-v-e34bb30e] {\\n  position: absolute;\\n  top: 60%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 16px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n.opened svg[data-v-e34bb30e] {\\n  top: 25%;\\n  transform: scaleY(-1);\\n}\\n.drop-down-options[data-v-e34bb30e] {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n.option[data-v-e34bb30e] {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  font-size: 13px;\\n  font-weight: 500;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n.option[data-v-e34bb30e]:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n.option p[data-v-e34bb30e] {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n.selected[data-v-e34bb30e] {\\n  font-weight: 500;\\n}\\n.hidden-checkmark[data-v-e34bb30e] {\\n  opacity: 0;\\n}\\n.empty-options[data-v-e34bb30e] {\\n  min-width: 250px;\\n}\\n@media (max-width: 700px) {\\n.input-container[data-v-e34bb30e], .drop-down-options[data-v-e34bb30e] {\\n    width: 100%;\\n}\\n.option[data-v-e34bb30e] {\\n    padding: 12px 6px 11px;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/SelectWithChips.vue\"],\"names\":[],\"mappings\":\";AAiHA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;EACE,WAAW;EACX,mBAAmB;EACnB,kBAAkB;AACpB;AAEA;EACE,kBAAkB;EAClB,eAAe;EACf,gBAAgB;EAChB,2BAA2B,EAAE,eAAe;EAC5C,yBAAyB,EAAE,WAAW;EACtC,sBAAsB,EAAE,YAAY;EACpC,qBAAqB,EAAE,2BAA2B;EAClD,iBAAiB;AACnB;AAEA;EACE,qBAAqB;EACrB,yBAAyB;EACzB,cAAc;EACd,mBAAmB;EACnB,2BAA2B;EAC3B,mBAAmB;EACnB,kBAAkB;EAClB,eAAe;EACf,YAAY;AACd;AAEA;EACE,YAAY;EACZ,UAAU;EACV,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,4CAA4C;AAC9C;AAEA;EACE,kBAAkB;EAClB,cAAc;EACd,YAAY;EACZ,cAAc;EACd,yBAAyB;EACzB,YAAY;EACZ,kBAAkB;EAClB,eAAe;EACf,aAAa;EACb,wBAAwB;EACxB,eAAe;EACf,YAAY;AACd;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,UAAU;EACV,4CAA4C;EAC5C,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,cAAc;AAChB;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,WAAW;EACX,4CAA4C;EAC5C,YAAY;EACZ,sBAAsB;EACtB,oBAAoB;AACtB;AAEA;EACE,QAAQ;EACR,qBAAqB;AACvB;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,WAAW;EACX,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,yBAAyB;EACzB,yBAAyB;EACzB,kBAAkB;EAClB,+DAA+D;EAC/D,4DAA4D;EAC5D,uDAAuD;AACzD;AAEA;EACE,sBAAsB;EACtB,gCAAgC;EAChC,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,sBAAsB;AACxB;AAEA;EACE,yBAAyB;EACzB,cAAc;EACd,eAAe;EACf,YAAY;AACd;AAEA;EACE,qBAAqB;EACrB,SAAS;EACT,eAAe;EACf,gBAAgB;AAClB;AAEA;EACE,gBAAgB;AAClB;AAEA;EACE,UAAU;AACZ;AAEA;EACE,gBAAgB;AAClB;AAEA;AACE;IACE,WAAW;AACb;AAEA;IACE,sBAAsB;AACxB;AACF\",\"sourcesContent\":[\"<template>\\n  <div>\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <div v-if=\\\"selectedOptions && selectedOptions.length > 0\\\" class=\\\"chip-list\\\">\\n      <div v-for=\\\"option in selectedOptions\\\" @click=\\\"removeOption(option)\\\" :key=\\\"option.id\\\" class=\\\"chip\\\">\\n        <span>{{ option.prefLabel }}</span>\\n        <svg-icon icon-name=\\\"cross\\\"><icon-cross /></svg-icon>\\n      </div>\\n    </div>\\n    <div class=\\\"input-container\\\">\\n      <div\\n          @click=\\\"isOpened = !isOpened\\\"\\n          :class=\\\"[isOpened ? 'opened' : '', 'select-button']\\\">\\n        <div class=\\\"select-content\\\">\\n          <span v-if=\\\"value && value.length > 0\\\" class=\\\"selected\\\">{{ value }}</span>\\n        </div>\\n        <svg-icon icon-name=\\\"triangle\\\"><icon-triangle /></svg-icon>\\n      </div>\\n      <div\\n          v-if=\\\"isOpened && selectableOptions.length === 0\\\" class=\\\"drop-down-options empty-options\\\" v-on-clickaway=\\\"closeDropDown\\\">\\n        <div class=\\\"option\\\" style=\\\"padding-left: 16px;\\\">\\n          <span>{{ noOptionsMessage }}</span>\\n        </div>\\n      </div>\\n      <div v-if=\\\"isOpened && selectableOptions.length > 0\\\" class=\\\"drop-down-options\\\" v-on-clickaway=\\\"closeDropDown\\\">\\n        <div v-for=\\\"option in selectableOptions\\\"\\n             :key=\\\"option.id\\\"\\n             @click=\\\"selectOption(option)\\\"\\n             class=\\\"option\\\">\\n          <p>{{ option.prefLabel }}</p>\\n        </div>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport SvgIcon from '../icons/SvgIcon.vue';\\nimport IconTriangle from '../icons/IconTriangle.vue';\\nimport IconCross from '../icons/IconCross.vue';\\nimport IconCheck from '../icons/IconCheck.vue';\\nimport { directive as onClickaway } from 'vue3-click-away'; // almost working\\nimport { ref, onMounted, inject } from 'vue';\\n\\nexport default {\\n  components: {\\n    SvgIcon,\\n    IconTriangle,\\n    IconCross,\\n    IconCheck\\n  },\\n  directives: {\\n    onClickaway: onClickaway,\\n  },\\n  props: {\\n    value: String,\\n    options: Array,\\n    label: Object\\n  },\\n\\n  setup (props, context) {\\n    const $t = inject('$t')\\n    const isOpened = ref(false);\\n    const noOptionsMessage = ref($t('new.groups.none'))\\n    let selectableOptions = ref([])\\n    let selectedOptions = ref([])\\n\\n    onMounted(() => { selectableOptions.value = props.options })\\n\\n    const selectOption = option => {\\n      selectedOptions.value.push(option);\\n      // if (selectableOptions && selectableOptions.length > 0) {\\n      if (selectableOptions) {\\n        selectableOptions.value.splice(findOptionIndex(option, selectableOptions.value), 1);\\n      }\\n      isOpened.value = false;\\n      context.emit('select', selectedOptions);\\n    }\\n\\n\\n    const removeOption = (option) => {\\n      const index = selectedOptions.value.findIndex((item) => item.id === option.id);\\n      if (index !== -1) {\\n        selectableOptions.value.push(selectedOptions.value[index]);\\n        selectedOptions.value.splice(index, 1);\\n      }\\n      context.emit('select', selectedOptions);\\n    };\\n\\n\\n    const findOptionIndex = (option, optionList) => {\\n      return optionList.indexOf(option);\\n    }\\n\\n    const closeDropDown = () => {\\n      isOpened.value = false;\\n    }\\n\\n    return {\\n      isOpened,\\n      noOptionsMessage,\\n      selectableOptions,\\n      selectedOptions,\\n      // onClickAwayDirective,\\n      selectOption,\\n      removeOption,\\n      closeDropDown\\n    }\\n  }\\n};\\n</script>\\n\\n<style scoped>\\nlabel {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.input-container {\\n  width: 100%;\\n  margin-bottom: 16px;\\n  position: relative;\\n}\\n\\n.chip-list {\\n  margin: 16px 0 8px;\\n  font-size: 12px;\\n  font-weight: 500;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n}\\n\\n.chip-list .chip {\\n  display: inline-block;\\n  background-color: #06a798;\\n  color: #ffffff;\\n  margin: 0 8px 8px 0;\\n  padding: 10px 32px 7px 12px;\\n  border-radius: 20px;\\n  position: relative;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.chip-list .chip svg {\\n  height: 16px;\\n  z-index: 4;\\n  position: absolute;\\n  top: 50%;\\n  right: 8px;\\n  transform: perspective(1px) translateY(-50%);\\n}\\n\\n.select-button {\\n  position: relative;\\n  display: block;\\n  height: 40px;\\n  color: #00748f;\\n  background-color: #eBf6f4;\\n  border: none;\\n  border-radius: 1px;\\n  font-size: 14px;\\n  outline: none;\\n  -webkit-appearance: none;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.select-button .select-content {\\n  position: absolute;\\n  top: 55%;\\n  left: 14px;\\n  transform: perspective(1px) translateY(-50%);\\n  overflow: hidden;\\n  font-size: 13px;\\n  font-weight: 400;\\n  color: #00748f;\\n}\\n\\n.select-button svg {\\n  position: absolute;\\n  top: 60%;\\n  right: 10px;\\n  transform: perspective(1px) translateY(-50%);\\n  height: 16px;\\n  vertical-align: middle;\\n  margin: 0 0 -4px 6px;\\n}\\n\\n.opened svg {\\n  top: 25%;\\n  transform: scaleY(-1);\\n}\\n\\n.drop-down-options {\\n  position: absolute;\\n  top: 42px;\\n  left: 0;\\n  width: 100%;\\n  max-height: 200px;\\n  overflow-y: scroll;\\n  z-index: 2;\\n  background-color: #ffffff;\\n  border: 1px solid #e1e1e1;\\n  border-radius: 2px;\\n  -webkit-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  -moz-box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n  box-shadow: 6px 8px 17px -6px rgba(200, 200, 200, 0.35);\\n}\\n\\n.option {\\n  padding: 10px 12px 6px;\\n  border-bottom: 1px solid #f5f5f5;\\n  font-size: 13px;\\n  font-weight: 500;\\n  color: #555555;\\n  vertical-align: middle;\\n}\\n\\n.option:hover {\\n  background-color: #f3fbfa;\\n  color: #111111;\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\\n.option p {\\n  display: inline-block;\\n  margin: 0;\\n  font-size: 13px;\\n  font-weight: 400;\\n}\\n\\n.selected {\\n  font-weight: 500;\\n}\\n\\n.hidden-checkmark {\\n  opacity: 0;\\n}\\n\\n.empty-options {\\n  min-width: 250px;\\n}\\n\\n@media (max-width: 700px) {\\n  .input-container, .drop-down-options {\\n    width: 100%;\\n  }\\n\\n  .option {\\n    padding: 12px 6px 11px;\\n  }\\n}\\n</style>\\n\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFpQixHQUFHLGVBQWUsMEJBQTBCLGNBQWMsb0JBQW9CLHFCQUFxQixHQUFHLGVBQWUscUJBQXFCLEdBQUcsdUJBQXVCLGVBQWUsR0FBRyxvQkFBb0IscUJBQXFCLEdBQUcsK0JBQStCLDBDQUEwQyxrQkFBa0IsS0FBSyxlQUFlLDZCQUE2QixLQUFLLEdBQUcsaUNBQWlDO0FBQ3orVTtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0V2l0aENoaXBzLnZ1ZT9lM2ExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxubGFiZWxbZGF0YS12LWUzNGJiMzBlXSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuLmlucHV0LWNvbnRhaW5lcltkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmNoaXAtbGlzdFtkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIG1hcmdpbjogMTZweCAwIDhweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC8qIGlPUyBTYWZhcmkgKi9cXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFNhZmFyaSAqL1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgLyogRmlyZWZveCAqL1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAvKiBJbnRlcm5ldCBFeHBsb3Jlci9FZGdlICovXFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLmNoaXAtbGlzdCAuY2hpcFtkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwNmE3OTg7XFxuICBjb2xvcjogI2ZmZmZmZjtcXG4gIG1hcmdpbjogMCA4cHggOHB4IDA7XFxuICBwYWRkaW5nOiAxMHB4IDMycHggN3B4IDEycHg7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4uY2hpcC1saXN0IC5jaGlwIHN2Z1tkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIGhlaWdodDogMTZweDtcXG4gIHotaW5kZXg6IDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiA4cHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuLnNlbGVjdC1idXR0b25bZGF0YS12LWUzNGJiMzBlXSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogNDBweDtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcbi5zZWxlY3QtYnV0dG9uIC5zZWxlY3QtY29udGVudFtkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTUlO1xcbiAgbGVmdDogMTRweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG59XFxuLnNlbGVjdC1idXR0b24gc3ZnW2RhdGEtdi1lMzRiYjMwZV0ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA2MCU7XFxuICByaWdodDogMTBweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIG1hcmdpbjogMCAwIC00cHggNnB4O1xcbn1cXG4ub3BlbmVkIHN2Z1tkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIHRvcDogMjUlO1xcbiAgdHJhbnNmb3JtOiBzY2FsZVkoLTEpO1xcbn1cXG4uZHJvcC1kb3duLW9wdGlvbnNbZGF0YS12LWUzNGJiMzBlXSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDQycHg7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAyMDBweDtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG4gIHotaW5kZXg6IDI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2UxZTFlMTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcXG4gIC1tb3otYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcXG4gIGJveC1zaGFkb3c6IDZweCA4cHggMTdweCAtNnB4IHJnYmEoMjAwLCAyMDAsIDIwMCwgMC4zNSk7XFxufVxcbi5vcHRpb25bZGF0YS12LWUzNGJiMzBlXSB7XFxuICBwYWRkaW5nOiAxMHB4IDEycHggNnB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1ZjU7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6ICM1NTU1NTU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi1lMzRiYjMwZV06aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZmJmYTtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG4ub3B0aW9uIHBbZGF0YS12LWUzNGJiMzBlXSB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG4uc2VsZWN0ZWRbZGF0YS12LWUzNGJiMzBlXSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG4uaGlkZGVuLWNoZWNrbWFya1tkYXRhLXYtZTM0YmIzMGVdIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi5lbXB0eS1vcHRpb25zW2RhdGEtdi1lMzRiYjMwZV0ge1xcbiAgbWluLXdpZHRoOiAyNTBweDtcXG59XFxuQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XFxuLmlucHV0LWNvbnRhaW5lcltkYXRhLXYtZTM0YmIzMGVdLCAuZHJvcC1kb3duLW9wdGlvbnNbZGF0YS12LWUzNGJiMzBlXSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG4ub3B0aW9uW2RhdGEtdi1lMzRiYjMwZV0ge1xcbiAgICBwYWRkaW5nOiAxMnB4IDZweCAxMXB4O1xcbn1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9TZWxlY3RXaXRoQ2hpcHMudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFpSEE7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0VBQ2hCLGVBQWU7RUFDZixjQUFjO0VBQ2Qsa0JBQWtCO0FBQ3BCO0FBRUE7RUFDRSxXQUFXO0VBQ1gsbUJBQW1CO0VBQ25CLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsMkJBQTJCLEVBQUUsZUFBZTtFQUM1Qyx5QkFBeUIsRUFBRSxXQUFXO0VBQ3RDLHNCQUFzQixFQUFFLFlBQVk7RUFDcEMscUJBQXFCLEVBQUUsMkJBQTJCO0VBQ2xELGlCQUFpQjtBQUNuQjtBQUVBO0VBQ0UscUJBQXFCO0VBQ3JCLHlCQUF5QjtFQUN6QixjQUFjO0VBQ2QsbUJBQW1CO0VBQ25CLDJCQUEyQjtFQUMzQixtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGVBQWU7RUFDZixZQUFZO0FBQ2Q7QUFFQTtFQUNFLFlBQVk7RUFDWixVQUFVO0VBQ1Ysa0JBQWtCO0VBQ2xCLFFBQVE7RUFDUixVQUFVO0VBQ1YsNENBQTRDO0FBQzlDO0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsY0FBYztFQUNkLFlBQVk7RUFDWixjQUFjO0VBQ2QseUJBQXlCO0VBQ3pCLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsZUFBZTtFQUNmLGFBQWE7RUFDYix3QkFBd0I7RUFDeEIsZUFBZTtFQUNmLFlBQVk7QUFDZDtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFFBQVE7RUFDUixVQUFVO0VBQ1YsNENBQTRDO0VBQzVDLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsZ0JBQWdCO0VBQ2hCLGNBQWM7QUFDaEI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixRQUFRO0VBQ1IsV0FBVztFQUNYLDRDQUE0QztFQUM1QyxZQUFZO0VBQ1osc0JBQXNCO0VBQ3RCLG9CQUFvQjtBQUN0QjtBQUVBO0VBQ0UsUUFBUTtFQUNSLHFCQUFxQjtBQUN2QjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxPQUFPO0VBQ1AsV0FBVztFQUNYLGlCQUFpQjtFQUNqQixrQkFBa0I7RUFDbEIsVUFBVTtFQUNWLHlCQUF5QjtFQUN6Qix5QkFBeUI7RUFDekIsa0JBQWtCO0VBQ2xCLCtEQUErRDtFQUMvRCw0REFBNEQ7RUFDNUQsdURBQXVEO0FBQ3pEO0FBRUE7RUFDRSxzQkFBc0I7RUFDdEIsZ0NBQWdDO0VBQ2hDLGVBQWU7RUFDZixnQkFBZ0I7RUFDaEIsY0FBYztFQUNkLHNCQUFzQjtBQUN4QjtBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLGNBQWM7RUFDZCxlQUFlO0VBQ2YsWUFBWTtBQUNkO0FBRUE7RUFDRSxxQkFBcUI7RUFDckIsU0FBUztFQUNULGVBQWU7RUFDZixnQkFBZ0I7QUFDbEI7QUFFQTtFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsVUFBVTtBQUNaO0FBRUE7RUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTtBQUNFO0lBQ0UsV0FBVztBQUNiO0FBRUE7SUFDRSxzQkFBc0I7QUFDeEI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgICA8bGFiZWwgOmZvcj1cXFwibGFiZWwuZm9yXFxcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cXG4gICAgPGRpdiB2LWlmPVxcXCJzZWxlY3RlZE9wdGlvbnMgJiYgc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA+IDBcXFwiIGNsYXNzPVxcXCJjaGlwLWxpc3RcXFwiPlxcbiAgICAgIDxkaXYgdi1mb3I9XFxcIm9wdGlvbiBpbiBzZWxlY3RlZE9wdGlvbnNcXFwiIEBjbGljaz1cXFwicmVtb3ZlT3B0aW9uKG9wdGlvbilcXFwiIDprZXk9XFxcIm9wdGlvbi5pZFxcXCIgY2xhc3M9XFxcImNoaXBcXFwiPlxcbiAgICAgICAgPHNwYW4+e3sgb3B0aW9uLnByZWZMYWJlbCB9fTwvc3Bhbj5cXG4gICAgICAgIDxzdmctaWNvbiBpY29uLW5hbWU9XFxcImNyb3NzXFxcIj48aWNvbi1jcm9zcyAvPjwvc3ZnLWljb24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dC1jb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXZcXG4gICAgICAgICAgQGNsaWNrPVxcXCJpc09wZW5lZCA9ICFpc09wZW5lZFxcXCJcXG4gICAgICAgICAgOmNsYXNzPVxcXCJbaXNPcGVuZWQgPyAnb3BlbmVkJyA6ICcnLCAnc2VsZWN0LWJ1dHRvbiddXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNlbGVjdC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgPHNwYW4gdi1pZj1cXFwidmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMFxcXCIgY2xhc3M9XFxcInNlbGVjdGVkXFxcIj57eyB2YWx1ZSB9fTwvc3Bhbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPHN2Zy1pY29uIGljb24tbmFtZT1cXFwidHJpYW5nbGVcXFwiPjxpY29uLXRyaWFuZ2xlIC8+PC9zdmctaWNvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2XFxuICAgICAgICAgIHYtaWY9XFxcImlzT3BlbmVkICYmIHNlbGVjdGFibGVPcHRpb25zLmxlbmd0aCA9PT0gMFxcXCIgY2xhc3M9XFxcImRyb3AtZG93bi1vcHRpb25zIGVtcHR5LW9wdGlvbnNcXFwiIHYtb24tY2xpY2thd2F5PVxcXCJjbG9zZURyb3BEb3duXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm9wdGlvblxcXCIgc3R5bGU9XFxcInBhZGRpbmctbGVmdDogMTZweDtcXFwiPlxcbiAgICAgICAgICA8c3Bhbj57eyBub09wdGlvbnNNZXNzYWdlIH19PC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiB2LWlmPVxcXCJpc09wZW5lZCAmJiBzZWxlY3RhYmxlT3B0aW9ucy5sZW5ndGggPiAwXFxcIiBjbGFzcz1cXFwiZHJvcC1kb3duLW9wdGlvbnNcXFwiIHYtb24tY2xpY2thd2F5PVxcXCJjbG9zZURyb3BEb3duXFxcIj5cXG4gICAgICAgIDxkaXYgdi1mb3I9XFxcIm9wdGlvbiBpbiBzZWxlY3RhYmxlT3B0aW9uc1xcXCJcXG4gICAgICAgICAgICAgOmtleT1cXFwib3B0aW9uLmlkXFxcIlxcbiAgICAgICAgICAgICBAY2xpY2s9XFxcInNlbGVjdE9wdGlvbihvcHRpb24pXFxcIlxcbiAgICAgICAgICAgICBjbGFzcz1cXFwib3B0aW9uXFxcIj5cXG4gICAgICAgICAgPHA+e3sgb3B0aW9uLnByZWZMYWJlbCB9fTwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgU3ZnSWNvbiBmcm9tICcuLi9pY29ucy9TdmdJY29uLnZ1ZSc7XFxuaW1wb3J0IEljb25UcmlhbmdsZSBmcm9tICcuLi9pY29ucy9JY29uVHJpYW5nbGUudnVlJztcXG5pbXBvcnQgSWNvbkNyb3NzIGZyb20gJy4uL2ljb25zL0ljb25Dcm9zcy52dWUnO1xcbmltcG9ydCBJY29uQ2hlY2sgZnJvbSAnLi4vaWNvbnMvSWNvbkNoZWNrLnZ1ZSc7XFxuaW1wb3J0IHsgZGlyZWN0aXZlIGFzIG9uQ2xpY2thd2F5IH0gZnJvbSAndnVlMy1jbGljay1hd2F5JzsgLy8gYWxtb3N0IHdvcmtpbmdcXG5pbXBvcnQgeyByZWYsIG9uTW91bnRlZCwgaW5qZWN0IH0gZnJvbSAndnVlJztcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIFN2Z0ljb24sXFxuICAgIEljb25UcmlhbmdsZSxcXG4gICAgSWNvbkNyb3NzLFxcbiAgICBJY29uQ2hlY2tcXG4gIH0sXFxuICBkaXJlY3RpdmVzOiB7XFxuICAgIG9uQ2xpY2thd2F5OiBvbkNsaWNrYXdheSxcXG4gIH0sXFxuICBwcm9wczoge1xcbiAgICB2YWx1ZTogU3RyaW5nLFxcbiAgICBvcHRpb25zOiBBcnJheSxcXG4gICAgbGFiZWw6IE9iamVjdFxcbiAgfSxcXG5cXG4gIHNldHVwIChwcm9wcywgY29udGV4dCkge1xcbiAgICBjb25zdCAkdCA9IGluamVjdCgnJHQnKVxcbiAgICBjb25zdCBpc09wZW5lZCA9IHJlZihmYWxzZSk7XFxuICAgIGNvbnN0IG5vT3B0aW9uc01lc3NhZ2UgPSByZWYoJHQoJ25ldy5ncm91cHMubm9uZScpKVxcbiAgICBsZXQgc2VsZWN0YWJsZU9wdGlvbnMgPSByZWYoW10pXFxuICAgIGxldCBzZWxlY3RlZE9wdGlvbnMgPSByZWYoW10pXFxuXFxuICAgIG9uTW91bnRlZCgoKSA9PiB7IHNlbGVjdGFibGVPcHRpb25zLnZhbHVlID0gcHJvcHMub3B0aW9ucyB9KVxcblxcbiAgICBjb25zdCBzZWxlY3RPcHRpb24gPSBvcHRpb24gPT4ge1xcbiAgICAgIHNlbGVjdGVkT3B0aW9ucy52YWx1ZS5wdXNoKG9wdGlvbik7XFxuICAgICAgLy8gaWYgKHNlbGVjdGFibGVPcHRpb25zICYmIHNlbGVjdGFibGVPcHRpb25zLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAoc2VsZWN0YWJsZU9wdGlvbnMpIHtcXG4gICAgICAgIHNlbGVjdGFibGVPcHRpb25zLnZhbHVlLnNwbGljZShmaW5kT3B0aW9uSW5kZXgob3B0aW9uLCBzZWxlY3RhYmxlT3B0aW9ucy52YWx1ZSksIDEpO1xcbiAgICAgIH1cXG4gICAgICBpc09wZW5lZC52YWx1ZSA9IGZhbHNlO1xcbiAgICAgIGNvbnRleHQuZW1pdCgnc2VsZWN0Jywgc2VsZWN0ZWRPcHRpb25zKTtcXG4gICAgfVxcblxcblxcbiAgICBjb25zdCByZW1vdmVPcHRpb24gPSAob3B0aW9uKSA9PiB7XFxuICAgICAgY29uc3QgaW5kZXggPSBzZWxlY3RlZE9wdGlvbnMudmFsdWUuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtLmlkID09PSBvcHRpb24uaWQpO1xcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcXG4gICAgICAgIHNlbGVjdGFibGVPcHRpb25zLnZhbHVlLnB1c2goc2VsZWN0ZWRPcHRpb25zLnZhbHVlW2luZGV4XSk7XFxuICAgICAgICBzZWxlY3RlZE9wdGlvbnMudmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICB9XFxuICAgICAgY29udGV4dC5lbWl0KCdzZWxlY3QnLCBzZWxlY3RlZE9wdGlvbnMpO1xcbiAgICB9O1xcblxcblxcbiAgICBjb25zdCBmaW5kT3B0aW9uSW5kZXggPSAob3B0aW9uLCBvcHRpb25MaXN0KSA9PiB7XFxuICAgICAgcmV0dXJuIG9wdGlvbkxpc3QuaW5kZXhPZihvcHRpb24pO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGNsb3NlRHJvcERvd24gPSAoKSA9PiB7XFxuICAgICAgaXNPcGVuZWQudmFsdWUgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGlzT3BlbmVkLFxcbiAgICAgIG5vT3B0aW9uc01lc3NhZ2UsXFxuICAgICAgc2VsZWN0YWJsZU9wdGlvbnMsXFxuICAgICAgc2VsZWN0ZWRPcHRpb25zLFxcbiAgICAgIC8vIG9uQ2xpY2tBd2F5RGlyZWN0aXZlLFxcbiAgICAgIHNlbGVjdE9wdGlvbixcXG4gICAgICByZW1vdmVPcHRpb24sXFxuICAgICAgY2xvc2VEcm9wRG93blxcbiAgICB9XFxuICB9XFxufTtcXG48L3NjcmlwdD5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbmxhYmVsIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4uaW5wdXQtY29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLmNoaXAtbGlzdCB7XFxuICBtYXJnaW46IDE2cHggMCA4cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5jaGlwLWxpc3QgLmNoaXAge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzA2YTc5ODtcXG4gIGNvbG9yOiAjZmZmZmZmO1xcbiAgbWFyZ2luOiAwIDhweCA4cHggMDtcXG4gIHBhZGRpbmc6IDEwcHggMzJweCA3cHggMTJweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjdXJzb3I6IGhhbmQ7XFxufVxcblxcbi5jaGlwLWxpc3QgLmNoaXAgc3ZnIHtcXG4gIGhlaWdodDogMTZweDtcXG4gIHotaW5kZXg6IDQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiA4cHg7XFxuICB0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDFweCkgdHJhbnNsYXRlWSgtNTAlKTtcXG59XFxuXFxuLnNlbGVjdC1idXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG5cXG4uc2VsZWN0LWJ1dHRvbiAuc2VsZWN0LWNvbnRlbnQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1NSU7XFxuICBsZWZ0OiAxNHB4O1xcbiAgdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxcHgpIHRyYW5zbGF0ZVkoLTUwJSk7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIGNvbG9yOiAjMDA3NDhmO1xcbn1cXG5cXG4uc2VsZWN0LWJ1dHRvbiBzdmcge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA2MCU7XFxuICByaWdodDogMTBweDtcXG4gIHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMXB4KSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgaGVpZ2h0OiAxNnB4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIG1hcmdpbjogMCAwIC00cHggNnB4O1xcbn1cXG5cXG4ub3BlbmVkIHN2ZyB7XFxuICB0b3A6IDI1JTtcXG4gIHRyYW5zZm9ybTogc2NhbGVZKC0xKTtcXG59XFxuXFxuLmRyb3AtZG93bi1vcHRpb25zIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNDJweDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC1oZWlnaHQ6IDIwMHB4O1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgei1pbmRleDogMjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmZmZmY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTFlMWUxO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgLW1vei1ib3gtc2hhZG93OiA2cHggOHB4IDE3cHggLTZweCByZ2JhKDIwMCwgMjAwLCAyMDAsIDAuMzUpO1xcbiAgYm94LXNoYWRvdzogNnB4IDhweCAxN3B4IC02cHggcmdiYSgyMDAsIDIwMCwgMjAwLCAwLjM1KTtcXG59XFxuXFxuLm9wdGlvbiB7XFxuICBwYWRkaW5nOiAxMHB4IDEycHggNnB4O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1ZjU7XFxuICBmb250LXNpemU6IDEzcHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6ICM1NTU1NTU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4ub3B0aW9uOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmM2ZiZmE7XFxuICBjb2xvcjogIzExMTExMTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG59XFxuXFxuLm9wdGlvbiBwIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxufVxcblxcbi5zZWxlY3RlZCB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG5cXG4uaGlkZGVuLWNoZWNrbWFyayB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4uZW1wdHktb3B0aW9ucyB7XFxuICBtaW4td2lkdGg6IDI1MHB4O1xcbn1cXG5cXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcXG4gIC5pbnB1dC1jb250YWluZXIsIC5kcm9wLWRvd24tb3B0aW9ucyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLm9wdGlvbiB7XFxuICAgIHBhZGRpbmc6IDEycHggNnB4IDExcHg7XFxuICB9XFxufVxcbjwvc3R5bGU+XFxuXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7816\n");

/***/ }),

/***/ 267:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.inputs-container[data-v-3f1c254f] {\\n    margin-bottom: 16px;\\n}\\n.inputs-container label[data-v-3f1c254f] {\\n    display: block;\\n    font-weight: 500;\\n    font-size: 13px;\\n    color: #111111;\\n    margin-bottom: 8px;\\n}\\n.input-pair[data-v-3f1c254f] {\\n    margin-bottom: 8px;\\n    margin-top: 8px;\\n}\\n.input-pair[data-v-3f1c254f]:first-of-type {\\n    margin-top: 0;\\n}\\n.input-pair input[data-v-3f1c254f] {\\n    display: inline-block;\\n    height: 40px;\\n    width: 48%;\\n    border: none;\\n    border-radius: 1px;\\n    background-color: #eBf6f4;\\n    color: #00748f;\\n    font-size: 14px;\\n    padding-left: 10px;\\n    outline: none;\\n    -webkit-appearance: none;\\n}\\n.input-pair input[data-v-3f1c254f]:last-of-type {\\n    margin-left: 3%;\\n}\\n@media (max-width: 700px) {\\n.input-pair[data-v-3f1c254f] {\\n      margin-top: 16px;\\n}\\n.input-pair input[data-v-3f1c254f],\\n    .input-pair input[data-v-3f1c254f]:last-of-type {\\n      display: block;\\n      margin: 8px 0 0;\\n      width: 100%;\\n}\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/TheExactMatchesInput.vue\"],\"names\":[],\"mappings\":\";AAwDE;IACE,mBAAmB;AACrB;AAEA;IACE,cAAc;IACd,gBAAgB;IAChB,eAAe;IACf,cAAc;IACd,kBAAkB;AACpB;AAEA;IACE,kBAAkB;IAClB,eAAe;AACjB;AAEA;IACE,aAAa;AACf;AAEA;IACE,qBAAqB;IACrB,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,kBAAkB;IAClB,yBAAyB;IACzB,cAAc;IACd,eAAe;IACf,kBAAkB;IAClB,aAAa;IACb,wBAAwB;AAC1B;AAEA;IACE,eAAe;AACjB;AAEA;AACE;MACE,gBAAgB;AAClB;AAEA;;MAEE,cAAc;MACd,eAAe;MACf,WAAW;AACb;AACF\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"inputs-container\\\">\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <div v-if=\\\"values && values.length > 0\\\">\\n      <div v-for=\\\"(item, i) in values\\\" :key=\\\"item.id\\\" class=\\\"input-pair\\\">\\n        <input\\n            :value=\\\"item.vocab\\\"\\n            @input=\\\"handleVocabInput($event.target.value, i)\\\"\\n            :placeholder=\\\"$t('new.exactMatches.vocab')\\\"\\n            type=\\\"text\\\" />\\n        <input\\n            :value=\\\"item.value\\\"\\n            @input=\\\"handleValueInput($event.target.value, i)\\\"\\n            :placeholder=\\\"$t('new.exactMatches.uri')\\\"\\n            type=\\\"text\\\" />\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<script setup>\\nimport { defineProps, defineEmits } from 'vue';\\n\\nconst props = defineProps({\\n  values: Array,\\n  label: {\\n    text: String,\\n    for: String\\n  }\\n});\\n\\nconst emit = defineEmits();\\n\\nconst handleVocabInput = (inputVocab, index) => {\\n  const updatedValues = [...props.values];\\n  if (!props.values[index].isTouched) {\\n    updatedValues.push({ vocab: '', value: '', isTouched: false });\\n  }\\n  updatedValues[index].vocab = inputVocab;\\n  updatedValues[index].isTouched = true;\\n  emit('inputexm', updatedValues);\\n};\\n\\nconst handleValueInput = (inputValue, index) => {\\n  const updatedValues = [...props.values];\\n  if (!props.values[index].isTouched) {\\n    updatedValues.push({ vocab: '', value: '', isTouched: false });\\n  }\\n  updatedValues[index].value = inputValue;\\n  updatedValues[index].isTouched = true;\\n  emit('inputexm', updatedValues);\\n};\\n</script>\\n\\n\\n<style scoped>\\n  .inputs-container {\\n    margin-bottom: 16px;\\n  }\\n\\n  .inputs-container label {\\n    display: block;\\n    font-weight: 500;\\n    font-size: 13px;\\n    color: #111111;\\n    margin-bottom: 8px;\\n  }\\n\\n  .input-pair {\\n    margin-bottom: 8px;\\n    margin-top: 8px;\\n  }\\n\\n  .input-pair:first-of-type {\\n    margin-top: 0;\\n  }\\n\\n  .input-pair input {\\n    display: inline-block;\\n    height: 40px;\\n    width: 48%;\\n    border: none;\\n    border-radius: 1px;\\n    background-color: #eBf6f4;\\n    color: #00748f;\\n    font-size: 14px;\\n    padding-left: 10px;\\n    outline: none;\\n    -webkit-appearance: none;\\n  }\\n\\n  .input-pair input:last-of-type {\\n    margin-left: 3%;\\n  }\\n\\n  @media (max-width: 700px) {\\n    .input-pair {\\n      margin-top: 16px;\\n    }\\n\\n    .input-pair input,\\n    .input-pair input:last-of-type {\\n      display: block;\\n      margin: 8px 0 0;\\n      width: 100%;\\n    }\\n  }\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDNEg7QUFDN0I7QUFDL0YsOEJBQThCLG1GQUEyQixDQUFDLHdHQUFxQztBQUMvRjtBQUNBLGdGQUFnRiwwQkFBMEIsR0FBRyw0Q0FBNEMscUJBQXFCLHVCQUF1QixzQkFBc0IscUJBQXFCLHlCQUF5QixHQUFHLGdDQUFnQyx5QkFBeUIsc0JBQXNCLEdBQUcsOENBQThDLG9CQUFvQixHQUFHLHNDQUFzQyw0QkFBNEIsbUJBQW1CLGlCQUFpQixtQkFBbUIseUJBQXlCLGdDQUFnQyxxQkFBcUIsc0JBQXNCLHlCQUF5QixvQkFBb0IsK0JBQStCLEdBQUcsbURBQW1ELHNCQUFzQixHQUFHLDZCQUE2QixnQ0FBZ0MseUJBQXlCLEdBQUcsNEZBQTRGLHVCQUF1Qix3QkFBd0Isb0JBQW9CLEdBQUcsR0FBRyxTQUFTLDJHQUEyRyxNQUFNLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFVBQVUsWUFBWSxXQUFXLFlBQVksTUFBTSxLQUFLLFVBQVUsTUFBTSxLQUFLLEtBQUssWUFBWSxNQUFNLE1BQU0sVUFBVSxVQUFVLFVBQVUsS0FBSywwR0FBMEcsYUFBYSwrbUJBQSttQiwyQkFBMkIsV0FBVywrQkFBK0IsOEJBQThCLHlDQUF5QyxHQUFHLEVBQUUsK0JBQStCLHFEQUFxRCw0Q0FBNEMseUNBQXlDLDJCQUEyQix3Q0FBd0MsRUFBRSxLQUFLLDRDQUE0QywwQ0FBMEMsb0NBQW9DLElBQUkscURBQXFELDRDQUE0Qyx5Q0FBeUMsMkJBQTJCLHdDQUF3QyxFQUFFLEtBQUssNENBQTRDLDBDQUEwQyxvQ0FBb0MsSUFBSSxzREFBc0QsMEJBQTBCLEtBQUssK0JBQStCLHFCQUFxQix1QkFBdUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsS0FBSyxtQkFBbUIseUJBQXlCLHNCQUFzQixLQUFLLGlDQUFpQyxvQkFBb0IsS0FBSyx5QkFBeUIsNEJBQTRCLG1CQUFtQixpQkFBaUIsbUJBQW1CLHlCQUF5QixnQ0FBZ0MscUJBQXFCLHNCQUFzQix5QkFBeUIsb0JBQW9CLCtCQUErQixLQUFLLHNDQUFzQyxzQkFBc0IsS0FBSyxpQ0FBaUMsbUJBQW1CLHlCQUF5QixPQUFPLGdFQUFnRSx1QkFBdUIsd0JBQXdCLG9CQUFvQixPQUFPLEtBQUssK0JBQStCO0FBQ3RnSTtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vVGhlRXhhY3RNYXRjaGVzSW5wdXQudnVlPzUyM2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uaW5wdXRzLWNvbnRhaW5lcltkYXRhLXYtM2YxYzI1NGZdIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG59XFxuLmlucHV0cy1jb250YWluZXIgbGFiZWxbZGF0YS12LTNmMWMyNTRmXSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBmb250LXNpemU6IDEzcHg7XFxuICAgIGNvbG9yOiAjMTExMTExO1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxufVxcbi5pbnB1dC1wYWlyW2RhdGEtdi0zZjFjMjU0Zl0ge1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgIG1hcmdpbi10b3A6IDhweDtcXG59XFxuLmlucHV0LXBhaXJbZGF0YS12LTNmMWMyNTRmXTpmaXJzdC1vZi10eXBlIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG59XFxuLmlucHV0LXBhaXIgaW5wdXRbZGF0YS12LTNmMWMyNTRmXSB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgaGVpZ2h0OiA0MHB4O1xcbiAgICB3aWR0aDogNDglO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VCZjZmNDtcXG4gICAgY29sb3I6ICMwMDc0OGY7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi5pbnB1dC1wYWlyIGlucHV0W2RhdGEtdi0zZjFjMjU0Zl06bGFzdC1vZi10eXBlIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMlO1xcbn1cXG5AbWVkaWEgKG1heC13aWR0aDogNzAwcHgpIHtcXG4uaW5wdXQtcGFpcltkYXRhLXYtM2YxYzI1NGZdIHtcXG4gICAgICBtYXJnaW4tdG9wOiAxNnB4O1xcbn1cXG4uaW5wdXQtcGFpciBpbnB1dFtkYXRhLXYtM2YxYzI1NGZdLFxcbiAgICAuaW5wdXQtcGFpciBpbnB1dFtkYXRhLXYtM2YxYzI1NGZdOmxhc3Qtb2YtdHlwZSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgbWFyZ2luOiA4cHggMCAwO1xcbiAgICAgIHdpZHRoOiAxMDAlO1xcbn1cXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9UaGVFeGFjdE1hdGNoZXNJbnB1dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXdERTtJQUNFLG1CQUFtQjtBQUNyQjtBQUVBO0lBQ0UsY0FBYztJQUNkLGdCQUFnQjtJQUNoQixlQUFlO0lBQ2YsY0FBYztJQUNkLGtCQUFrQjtBQUNwQjtBQUVBO0lBQ0Usa0JBQWtCO0lBQ2xCLGVBQWU7QUFDakI7QUFFQTtJQUNFLGFBQWE7QUFDZjtBQUVBO0lBQ0UscUJBQXFCO0lBQ3JCLFlBQVk7SUFDWixVQUFVO0lBQ1YsWUFBWTtJQUNaLGtCQUFrQjtJQUNsQix5QkFBeUI7SUFDekIsY0FBYztJQUNkLGVBQWU7SUFDZixrQkFBa0I7SUFDbEIsYUFBYTtJQUNiLHdCQUF3QjtBQUMxQjtBQUVBO0lBQ0UsZUFBZTtBQUNqQjtBQUVBO0FBQ0U7TUFDRSxnQkFBZ0I7QUFDbEI7QUFFQTs7TUFFRSxjQUFjO01BQ2QsZUFBZTtNQUNmLFdBQVc7QUFDYjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXYgY2xhc3M9XFxcImlucHV0cy1jb250YWluZXJcXFwiPlxcbiAgICA8bGFiZWwgOmZvcj1cXFwibGFiZWwuZm9yXFxcIj57eyBsYWJlbC50ZXh0IH19PC9sYWJlbD5cXG4gICAgPGRpdiB2LWlmPVxcXCJ2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA+IDBcXFwiPlxcbiAgICAgIDxkaXYgdi1mb3I9XFxcIihpdGVtLCBpKSBpbiB2YWx1ZXNcXFwiIDprZXk9XFxcIml0ZW0uaWRcXFwiIGNsYXNzPVxcXCJpbnB1dC1wYWlyXFxcIj5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICAgIDp2YWx1ZT1cXFwiaXRlbS52b2NhYlxcXCJcXG4gICAgICAgICAgICBAaW5wdXQ9XFxcImhhbmRsZVZvY2FiSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSwgaSlcXFwiXFxuICAgICAgICAgICAgOnBsYWNlaG9sZGVyPVxcXCIkdCgnbmV3LmV4YWN0TWF0Y2hlcy52b2NhYicpXFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiIC8+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICA6dmFsdWU9XFxcIml0ZW0udmFsdWVcXFwiXFxuICAgICAgICAgICAgQGlucHV0PVxcXCJoYW5kbGVWYWx1ZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUsIGkpXFxcIlxcbiAgICAgICAgICAgIDpwbGFjZWhvbGRlcj1cXFwiJHQoJ25ldy5leGFjdE1hdGNoZXMudXJpJylcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCIgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQgc2V0dXA+XFxuaW1wb3J0IHsgZGVmaW5lUHJvcHMsIGRlZmluZUVtaXRzIH0gZnJvbSAndnVlJztcXG5cXG5jb25zdCBwcm9wcyA9IGRlZmluZVByb3BzKHtcXG4gIHZhbHVlczogQXJyYXksXFxuICBsYWJlbDoge1xcbiAgICB0ZXh0OiBTdHJpbmcsXFxuICAgIGZvcjogU3RyaW5nXFxuICB9XFxufSk7XFxuXFxuY29uc3QgZW1pdCA9IGRlZmluZUVtaXRzKCk7XFxuXFxuY29uc3QgaGFuZGxlVm9jYWJJbnB1dCA9IChpbnB1dFZvY2FiLCBpbmRleCkgPT4ge1xcbiAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IFsuLi5wcm9wcy52YWx1ZXNdO1xcbiAgaWYgKCFwcm9wcy52YWx1ZXNbaW5kZXhdLmlzVG91Y2hlZCkge1xcbiAgICB1cGRhdGVkVmFsdWVzLnB1c2goeyB2b2NhYjogJycsIHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9KTtcXG4gIH1cXG4gIHVwZGF0ZWRWYWx1ZXNbaW5kZXhdLnZvY2FiID0gaW5wdXRWb2NhYjtcXG4gIHVwZGF0ZWRWYWx1ZXNbaW5kZXhdLmlzVG91Y2hlZCA9IHRydWU7XFxuICBlbWl0KCdpbnB1dGV4bScsIHVwZGF0ZWRWYWx1ZXMpO1xcbn07XFxuXFxuY29uc3QgaGFuZGxlVmFsdWVJbnB1dCA9IChpbnB1dFZhbHVlLCBpbmRleCkgPT4ge1xcbiAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IFsuLi5wcm9wcy52YWx1ZXNdO1xcbiAgaWYgKCFwcm9wcy52YWx1ZXNbaW5kZXhdLmlzVG91Y2hlZCkge1xcbiAgICB1cGRhdGVkVmFsdWVzLnB1c2goeyB2b2NhYjogJycsIHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9KTtcXG4gIH1cXG4gIHVwZGF0ZWRWYWx1ZXNbaW5kZXhdLnZhbHVlID0gaW5wdXRWYWx1ZTtcXG4gIHVwZGF0ZWRWYWx1ZXNbaW5kZXhdLmlzVG91Y2hlZCA9IHRydWU7XFxuICBlbWl0KCdpbnB1dGV4bScsIHVwZGF0ZWRWYWx1ZXMpO1xcbn07XFxuPC9zY3JpcHQ+XFxuXFxuXFxuPHN0eWxlIHNjb3BlZD5cXG4gIC5pbnB1dHMtY29udGFpbmVyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIH1cXG5cXG4gIC5pbnB1dHMtY29udGFpbmVyIGxhYmVsIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgY29sb3I6ICMxMTExMTE7XFxuICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gIH1cXG5cXG4gIC5pbnB1dC1wYWlyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICBtYXJnaW4tdG9wOiA4cHg7XFxuICB9XFxuXFxuICAuaW5wdXQtcGFpcjpmaXJzdC1vZi10eXBlIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5pbnB1dC1wYWlyIGlucHV0IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIHdpZHRoOiA0OCU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMXB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgICBjb2xvcjogIzAwNzQ4ZjtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG5cXG4gIC5pbnB1dC1wYWlyIGlucHV0Omxhc3Qtb2YtdHlwZSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzJTtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbiAgICAuaW5wdXQtcGFpciB7XFxuICAgICAgbWFyZ2luLXRvcDogMTZweDtcXG4gICAgfVxcblxcbiAgICAuaW5wdXQtcGFpciBpbnB1dCxcXG4gICAgLmlucHV0LXBhaXIgaW5wdXQ6bGFzdC1vZi10eXBlIHtcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICBtYXJnaW46IDhweCAwIDA7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgIH1cXG4gIH1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///267\n");

/***/ }),

/***/ 7787:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.input-container[data-v-438acc87] {\\n  margin-bottom: 16px;\\n}\\n.input-container label[data-v-438acc87] {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n.inputs[data-v-438acc87] {\\n  margin-top: 8px;\\n}\\n.inputs[data-v-438acc87]:first-of-type {\\n  margin-top: 0;\\n}\\n.inputs input[data-v-438acc87] {\\n  height: 40px;\\n  width: 100%;\\n  border: none;\\n  border-radius: 1px;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  font-size: 14px;\\n  padding-left: 10px;\\n  outline: none;\\n  -webkit-appearance: none;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/form/TheMultipleBasicInput.vue\"],\"names\":[],\"mappings\":\";AAqCA;EACE,mBAAmB;AACrB;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,eAAe;EACf,cAAc;EACd,kBAAkB;AACpB;AAEA;EACE,eAAe;AACjB;AAEA;EACE,aAAa;AACf;AAEA;EACE,YAAY;EACZ,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,yBAAyB;EACzB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,aAAa;EACb,wBAAwB;AAC1B\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"input-container\\\">\\n    <label :for=\\\"label.for\\\">{{ label.text }}</label>\\n    <div v-for=\\\"(item, i) in values\\\" :key=\\\"item.id\\\" class=\\\"inputs\\\">\\n      <input\\n          v-model=\\\"item.value\\\"\\n          @input=\\\"handleInput($event.target.value, i)\\\"\\n          type=\\\"text\\\" />\\n    </div>\\n  </div>\\n</template>\\n\\n<script>\\nimport { ref } from 'vue';\\n\\nexport default {\\n  props: {\\n    values: Array,\\n    label: {\\n      text: String,\\n      for: String\\n    }\\n  },\\n  setup(props, { emit }) {\\n    const handleInput = (inputValue, index) => {\\n      if (index === props.values.length - 1 && inputValue !== '') {\\n        props.values.push({ value: '', isTouched: false });\\n      }\\n      emit('update:values', [...props.values]);\\n    };\\n\\n    return { handleInput };\\n  }\\n}\\n</script>\\n\\n<style scoped>\\n.input-container {\\n  margin-bottom: 16px;\\n}\\n\\n.input-container label {\\n  display: block;\\n  font-weight: 500;\\n  font-size: 13px;\\n  color: #111111;\\n  margin-bottom: 8px;\\n}\\n\\n.inputs {\\n  margin-top: 8px;\\n}\\n\\n.inputs:first-of-type {\\n  margin-top: 0;\\n}\\n\\n.inputs input {\\n  height: 40px;\\n  width: 100%;\\n  border: none;\\n  border-radius: 1px;\\n  background-color: #eBf6f4;\\n  color: #00748f;\\n  font-size: 14px;\\n  padding-left: 10px;\\n  outline: none;\\n  -webkit-appearance: none;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSwrRUFBK0Usd0JBQXdCLEdBQUcsMkNBQTJDLG1CQUFtQixxQkFBcUIsb0JBQW9CLG1CQUFtQix1QkFBdUIsR0FBRyw0QkFBNEIsb0JBQW9CLEdBQUcsMENBQTBDLGtCQUFrQixHQUFHLGtDQUFrQyxpQkFBaUIsZ0JBQWdCLGlCQUFpQix1QkFBdUIsOEJBQThCLG1CQUFtQixvQkFBb0IsdUJBQXVCLGtCQUFrQiw2QkFBNkIsR0FBRyxTQUFTLDRHQUE0RyxNQUFNLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSwwR0FBMEcsYUFBYSxtUkFBbVIsTUFBTSxXQUFXLG9CQUFvQixZQUFZLGtDQUFrQywrQ0FBK0MsS0FBSyxvQkFBb0IsTUFBTSxHQUFHLGtEQUFrRCxxRUFBcUUsOEJBQThCLDZCQUE2QixFQUFFLFNBQVMsaURBQWlELFFBQVEsaUJBQWlCLGNBQWMsS0FBSyxHQUFHLGlEQUFpRCx3QkFBd0IsR0FBRyw0QkFBNEIsbUJBQW1CLHFCQUFxQixvQkFBb0IsbUJBQW1CLHVCQUF1QixHQUFHLGFBQWEsb0JBQW9CLEdBQUcsMkJBQTJCLGtCQUFrQixHQUFHLG1CQUFtQixpQkFBaUIsZ0JBQWdCLGlCQUFpQix1QkFBdUIsOEJBQThCLG1CQUFtQixvQkFBb0IsdUJBQXVCLGtCQUFrQiw2QkFBNkIsR0FBRywrQkFBK0I7QUFDOTBFO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vc3JjL2NvbXBvbmVudHMvZm9ybS9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP2UyODciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uaW5wdXQtY29udGFpbmVyW2RhdGEtdi00MzhhY2M4N10ge1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG59XFxuLmlucHV0LWNvbnRhaW5lciBsYWJlbFtkYXRhLXYtNDM4YWNjODddIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGZvbnQtc2l6ZTogMTNweDtcXG4gIGNvbG9yOiAjMTExMTExO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG4uaW5wdXRzW2RhdGEtdi00MzhhY2M4N10ge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbn1cXG4uaW5wdXRzW2RhdGEtdi00MzhhY2M4N106Zmlyc3Qtb2YtdHlwZSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbn1cXG4uaW5wdXRzIGlucHV0W2RhdGEtdi00MzhhY2M4N10ge1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAxcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZUJmNmY0O1xcbiAgY29sb3I6ICMwMDc0OGY7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9mb3JtL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXFDQTtFQUNFLG1CQUFtQjtBQUNyQjtBQUVBO0VBQ0UsY0FBYztFQUNkLGdCQUFnQjtFQUNoQixlQUFlO0VBQ2YsY0FBYztFQUNkLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0UsZUFBZTtBQUNqQjtBQUVBO0VBQ0UsYUFBYTtBQUNmO0FBRUE7RUFDRSxZQUFZO0VBQ1osV0FBVztFQUNYLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIseUJBQXlCO0VBQ3pCLGNBQWM7RUFDZCxlQUFlO0VBQ2Ysa0JBQWtCO0VBQ2xCLGFBQWE7RUFDYix3QkFBd0I7QUFDMUJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwiaW5wdXQtY29udGFpbmVyXFxcIj5cXG4gICAgPGxhYmVsIDpmb3I9XFxcImxhYmVsLmZvclxcXCI+e3sgbGFiZWwudGV4dCB9fTwvbGFiZWw+XFxuICAgIDxkaXYgdi1mb3I9XFxcIihpdGVtLCBpKSBpbiB2YWx1ZXNcXFwiIDprZXk9XFxcIml0ZW0uaWRcXFwiIGNsYXNzPVxcXCJpbnB1dHNcXFwiPlxcbiAgICAgIDxpbnB1dFxcbiAgICAgICAgICB2LW1vZGVsPVxcXCJpdGVtLnZhbHVlXFxcIlxcbiAgICAgICAgICBAaW5wdXQ9XFxcImhhbmRsZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUsIGkpXFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIiAvPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgeyByZWYgfSBmcm9tICd2dWUnO1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIHByb3BzOiB7XFxuICAgIHZhbHVlczogQXJyYXksXFxuICAgIGxhYmVsOiB7XFxuICAgICAgdGV4dDogU3RyaW5nLFxcbiAgICAgIGZvcjogU3RyaW5nXFxuICAgIH1cXG4gIH0sXFxuICBzZXR1cChwcm9wcywgeyBlbWl0IH0pIHtcXG4gICAgY29uc3QgaGFuZGxlSW5wdXQgPSAoaW5wdXRWYWx1ZSwgaW5kZXgpID0+IHtcXG4gICAgICBpZiAoaW5kZXggPT09IHByb3BzLnZhbHVlcy5sZW5ndGggLSAxICYmIGlucHV0VmFsdWUgIT09ICcnKSB7XFxuICAgICAgICBwcm9wcy52YWx1ZXMucHVzaCh7IHZhbHVlOiAnJywgaXNUb3VjaGVkOiBmYWxzZSB9KTtcXG4gICAgICB9XFxuICAgICAgZW1pdCgndXBkYXRlOnZhbHVlcycsIFsuLi5wcm9wcy52YWx1ZXNdKTtcXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHsgaGFuZGxlSW5wdXQgfTtcXG4gIH1cXG59XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlIHNjb3BlZD5cXG4uaW5wdXQtY29udGFpbmVyIHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcblxcbi5pbnB1dC1jb250YWluZXIgbGFiZWwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgY29sb3I6ICMxMTExMTE7XFxuICBtYXJnaW4tYm90dG9tOiA4cHg7XFxufVxcblxcbi5pbnB1dHMge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbn1cXG5cXG4uaW5wdXRzOmZpcnN0LW9mLXR5cGUge1xcbiAgbWFyZ2luLXRvcDogMDtcXG59XFxuXFxuLmlucHV0cyBpbnB1dCB7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDFweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlQmY2ZjQ7XFxuICBjb2xvcjogIzAwNzQ4ZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIHBhZGRpbmctbGVmdDogMTBweDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7787\n");

/***/ }),

/***/ 4486:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4015);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\nsvg[data-v-2fda14c1]:hover {\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/components/icons/SvgIcon.vue\"],\"names\":[],\"mappings\":\";AAuCA;EACE,eAAe;EACf,YAAY;AACd\",\"sourcesContent\":[\"<template>\\n  <svg\\n    :width=\\\"width\\\"\\n    :height=\\\"height\\\"\\n    viewBox=\\\"0 0 24 24\\\"\\n    :aria-labelledby=\\\"iconName\\\"\\n    role=\\\"presentation\\\"\\n    stroke=\\\"currentColor\\\">\\n    <title :id=\\\"iconName\\\" lang=\\\"en\\\">{{iconName}} icon</title>\\n    <g :fill=\\\"iconColor\\\">\\n      <slot />\\n    </g>\\n  </svg>\\n</template>\\n\\n<script>\\nexport default {\\n  props: {\\n    iconName: {\\n      type: String,\\n      default: ''\\n    },\\n    width: {\\n      type: [Number, String],\\n      default: 24\\n    },\\n    height: {\\n      type: [Number, String],\\n      default: 24\\n    },\\n    iconColor: {\\n      type: String,\\n      default: 'currentColor'\\n    }\\n  }\\n};\\n</script>\\n\\n<style scoped>\\nsvg:hover {\\n  cursor: pointer;\\n  cursor: hand;\\n}\\n</style>\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ4Ni5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzRIO0FBQzdCO0FBQy9GLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSx3RUFBd0Usb0JBQW9CLGlCQUFpQixHQUFHLFNBQVMsK0ZBQStGLE1BQU0sVUFBVSxVQUFVLDRQQUE0UCxXQUFXLHdIQUF3SCxZQUFZLGlCQUFpQiwrQ0FBK0MsZUFBZSx5REFBeUQsZ0JBQWdCLHlEQUF5RCxtQkFBbUIsMkRBQTJELEtBQUssSUFBSSwwQ0FBMEMsb0JBQW9CLGlCQUFpQixHQUFHLCtCQUErQjtBQUN0aEM7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9zcmMvY29tcG9uZW50cy9pY29ucy9TdmdJY29uLnZ1ZT80NjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuc3ZnW2RhdGEtdi0yZmRhMTRjMV06aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiBoYW5kO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvY29tcG9uZW50cy9pY29ucy9TdmdJY29uLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBdUNBO0VBQ0UsZUFBZTtFQUNmLFlBQVk7QUFDZFwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8c3ZnXFxuICAgIDp3aWR0aD1cXFwid2lkdGhcXFwiXFxuICAgIDpoZWlnaHQ9XFxcImhlaWdodFxcXCJcXG4gICAgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgICA6YXJpYS1sYWJlbGxlZGJ5PVxcXCJpY29uTmFtZVxcXCJcXG4gICAgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIlxcbiAgICBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCI+XFxuICAgIDx0aXRsZSA6aWQ9XFxcImljb25OYW1lXFxcIiBsYW5nPVxcXCJlblxcXCI+e3tpY29uTmFtZX19IGljb248L3RpdGxlPlxcbiAgICA8ZyA6ZmlsbD1cXFwiaWNvbkNvbG9yXFxcIj5cXG4gICAgICA8c2xvdCAvPlxcbiAgICA8L2c+XFxuICA8L3N2Zz5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgcHJvcHM6IHtcXG4gICAgaWNvbk5hbWU6IHtcXG4gICAgICB0eXBlOiBTdHJpbmcsXFxuICAgICAgZGVmYXVsdDogJydcXG4gICAgfSxcXG4gICAgd2lkdGg6IHtcXG4gICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxcbiAgICAgIGRlZmF1bHQ6IDI0XFxuICAgIH0sXFxuICAgIGhlaWdodDoge1xcbiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXFxuICAgICAgZGVmYXVsdDogMjRcXG4gICAgfSxcXG4gICAgaWNvbkNvbG9yOiB7XFxuICAgICAgdHlwZTogU3RyaW5nLFxcbiAgICAgIGRlZmF1bHQ6ICdjdXJyZW50Q29sb3InXFxuICAgIH1cXG4gIH1cXG59O1xcbjwvc2NyaXB0PlxcblxcbjxzdHlsZSBzY29wZWQ+XFxuc3ZnOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGN1cnNvcjogaGFuZDtcXG59XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4486\n");

/***/ }),

/***/ 3645:
/***/ (function(module) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIscUJBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3645\n");

/***/ }),

/***/ 4015:
/***/ (function(module) {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAxNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0M7O0FBRWxDLDhCQUE4Qjs7QUFFOUIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHlDQUF5Qyw4RkFBOEYsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRXZlLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanM/NzVlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4015\n");

/***/ }),

/***/ 2705:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var root = __webpack_require__(5639);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUzs7QUFFNUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanM/OWU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2705\n");

/***/ }),

/***/ 4239:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Symbol = __webpack_require__(2705),\n    getRawTag = __webpack_require__(9607),\n    objectToString = __webpack_require__(2333);\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFjO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLElBQW1COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcz8zNzI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4239\n");

/***/ }),

/***/ 7561:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var trimmedEndIndex = __webpack_require__(7990);\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFvQjs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUcmltLmpzPzhkNzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRyaW1tZWRFbmRJbmRleCA9IHJlcXVpcmUoJy4vX3RyaW1tZWRFbmRJbmRleCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRyaW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7561\n");

/***/ }),

/***/ 1957:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHdCQUF3QixxQkFBTSxnQkFBZ0IscUJBQU0sSUFBSSxxQkFBTSxzQkFBc0IscUJBQU07O0FBRTFGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanM/NTg1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1957\n");

/***/ }),

/***/ 9607:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Symbol = __webpack_require__(2705);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanM/MDBmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9607\n");

/***/ }),

/***/ 2333:
/***/ (function(module) {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcz8yOWYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2333\n");

/***/ }),

/***/ 5639:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var freeGlobal = __webpack_require__(1957);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcz8yYjNlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5639\n");

/***/ }),

/***/ 7990:
/***/ (function(module) {

eval("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzPzRjZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7990\n");

/***/ }),

/***/ 3279:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var isObject = __webpack_require__(3218),\n    now = __webpack_require__(7771),\n    toNumber = __webpack_require__(4841);\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI3OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBWTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsSUFBTztBQUN6QixlQUFlLG1CQUFPLENBQUMsSUFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzP2IwNDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3279\n");

/***/ }),

/***/ 3218:
/***/ (function(module) {

eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcz8xYThjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3218\n");

/***/ }),

/***/ 7005:
/***/ (function(module) {

eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcz8xMzEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7005\n");

/***/ }),

/***/ 3448:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var baseGetTag = __webpack_require__(4239),\n    isObjectLike = __webpack_require__(7005);\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLElBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzP2ZmZDYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3448\n");

/***/ }),

/***/ 7771:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var root = __webpack_require__(5639);\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc3MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzPzQwOGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7771\n");

/***/ }),

/***/ 4841:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var baseTrim = __webpack_require__(7561),\n    isObject = __webpack_require__(3218),\n    isSymbol = __webpack_require__(3448);\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsSUFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanM/YjRiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZVRyaW0gPSByZXF1aXJlKCcuL19iYXNlVHJpbScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4841\n");

/***/ }),

/***/ 3744:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.Z = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0NC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw2QkFBNkMsRUFBRSxhQUFhLENBQUM7QUFDN0Q7QUFDQTtBQUNBLFNBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtY3VzdG9tZWxlbWVudC1idW5kbGVyLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9leHBvcnRIZWxwZXIuanM/YjlhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3744\n");

/***/ }),

/***/ 2254:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(1899);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"17b996ef\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI1NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUF3UDtBQUM5UTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQThFO0FBQ3hGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL0VkaXRTdWdnZXN0aW9uLnZ1ZT9kYmNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0VkaXRTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTMyZDMxZTVhJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjE3Yjk5NmVmXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0VkaXRTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTMyZDMxZTVhJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vRWRpdFN1Z2dlc3Rpb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzJkMzFlNWEmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG4gICAgIGlmKG5ld0NvbnRlbnQuX19lc01vZHVsZSkgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuZGVmYXVsdDtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2254\n");

/***/ }),

/***/ 3675:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9278);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"6b0372ae\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUF1UDtBQUM3UTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQThFO0FBQ3hGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL05ld1N1Z2dlc3Rpb24udnVlP2E4MGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vTmV3U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zOTI4ODcyMSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI2YjAzNzJhZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9OZXdTdWdnZXN0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM5Mjg4NzIxJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vTmV3U3VnZ2VzdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zOTI4ODcyMSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3675\n");

/***/ }),

/***/ 4722:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(8533);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"46762d1a\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFpUDtBQUN2UTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQThFO0FBQ3hGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlPzk4NWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wZTViZDdhNSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI0Njc2MmQxYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTBlNWJkN2E1Jmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wZTViZDdhNSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4722\n");

/***/ }),

/***/ 6839:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(3602);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"bb53fb6e\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUE2UDtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQThFO0FBQ3hGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL1N1Z2dlc3RDaGFuZ2VCdXR0b24udnVlP2FlMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD0wZTViZDdhNSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJiYjUzZmI2ZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0Q2hhbmdlQnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0xJmlkPTBlNWJkN2E1JnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdENoYW5nZUJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD0wZTViZDdhNSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6839\n");

/***/ }),

/***/ 2249:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(8149);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"21b1a15e\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUE4TztBQUNwUTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQThFO0FBQ3hGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL1N1Z2dlc3ROZXdCdXR0b24udnVlP2FkMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdE5ld0J1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xNTA3MjdhZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIyMWIxYTE1ZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWdnZXN0TmV3QnV0dG9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTE1MDcyN2FlJmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3VnZ2VzdE5ld0J1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xNTA3MjdhZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2249\n");

/***/ }),

/***/ 3867:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(3266);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"3377bee1\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFpUTtBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9DZW50ZXJlZERpYWxvZy52dWU/ZGQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9DZW50ZXJlZERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD04ZGRmYzg4MCZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIzMzc3YmVlMVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9DZW50ZXJlZERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD04ZGRmYzg4MCZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0NlbnRlcmVkRGlhbG9nLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPThkZGZjODgwJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3867\n");

/***/ }),

/***/ 8565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(341);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"d52c5b1c\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU2NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxHQUFpUTtBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9GYWlsdXJlTWVzc2FnZS52dWU/NTZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9GYWlsdXJlTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1iYjk5ZjU1MiZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJkNTJjNWIxY1wiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9GYWlsdXJlTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1iYjk5ZjU1MiZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0ZhaWx1cmVNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWJiOTlmNTUyJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8565\n");

/***/ }),

/***/ 8130:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7847);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"8920f41a\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEzMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFpUTtBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9TdWNjZXNzTWVzc2FnZS52dWU/ODAxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01YWI1YjNkYSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI4OTIwZjQxYVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01YWI1YjNkYSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1N1Y2Nlc3NNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTVhYjViM2RhJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8130\n");

/***/ }),

/***/ 1199:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(5265);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"0c07b1af\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFnUTtBQUN0UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vQmFzaWNEcm9wRG93bi52dWU/Nzg3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWVhZmJjOTYwJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjBjMDdiMWFmXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0Jhc2ljRHJvcERvd24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZWFmYmM5NjAmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0Ryb3BEb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWVhZmJjOTYwJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1199\n");

/***/ }),

/***/ 7173:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(6604);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"24ffe2be\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE3My5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUE2UDtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vQmFzaWNJbnB1dC52dWU/YzkwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0lucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZjMzk2MjQ5JnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuaWYoY29udGVudC5fX2VzTW9kdWxlKSBjb250ZW50ID0gY29udGVudC5kZWZhdWx0O1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjI0ZmZlMmJlXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL0Jhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NmMzOTYyNDkmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9CYXNpY0lucHV0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZjMzk2MjQ5JnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIpO1xuICAgICBpZihuZXdDb250ZW50Ll9fZXNNb2R1bGUpIG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LmRlZmF1bHQ7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7173\n");

/***/ }),

/***/ 8618:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(2150);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"367c1a24\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFxUTtBQUMzUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoQXV0b0NvbXBsZXRlLnZ1ZT80NTJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlYXJjaEF1dG9Db21wbGV0ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03ZWFlN2I5MyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIzNjdjMWEyNFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWFyY2hBdXRvQ29tcGxldGUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2VhZTdiOTMmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWFyY2hBdXRvQ29tcGxldGUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2VhZTdiOTMmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG4gICAgIGlmKG5ld0NvbnRlbnQuX19lc01vZHVsZSkgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuZGVmYXVsdDtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8618\n");

/***/ }),

/***/ 2305:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4225);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"3a7e77f4\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUE4UDtBQUNwUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VhcmNoSW5wdXQudnVlP2E4NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU2VhcmNoSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTA2MmIwYWMmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiM2E3ZTc3ZjRcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU2VhcmNoSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTA2MmIwYWMmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWFyY2hJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1lMDYyYjBhYyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2305\n");

/***/ }),

/***/ 7344:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7816);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"6120c521\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM0NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFrUTtBQUN4UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vU2VsZWN0V2l0aENoaXBzLnZ1ZT9hZDUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1NlbGVjdFdpdGhDaGlwcy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1lMzRiYjMwZSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI2MTIwYzUyMVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTM0YmIzMGUmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TZWxlY3RXaXRoQ2hpcHMudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZTM0YmIzMGUmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG4gICAgIGlmKG5ld0NvbnRlbnQuX19lc01vZHVsZSkgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuZGVmYXVsdDtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7344\n");

/***/ }),

/***/ 4753:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(267);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"4f655e07\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc1My5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxHQUF1UTtBQUM3UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vVGhlRXhhY3RNYXRjaGVzSW5wdXQudnVlP2U2ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vVGhlRXhhY3RNYXRjaGVzSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9M2YxYzI1NGYmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG5pZihjb250ZW50Ll9fZXNNb2R1bGUpIGNvbnRlbnQgPSBjb250ZW50LmRlZmF1bHQ7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNGY2NTVlMDdcIiwgY29udGVudCwgZmFsc2UsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vVGhlRXhhY3RNYXRjaGVzSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9M2YxYzI1NGYmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVFeGFjdE1hdGNoZXNJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zZjFjMjU0ZiZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4753\n");

/***/ }),

/***/ 2982:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7787);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"e200bce8\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUF3UTtBQUM5UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2Zvcm0vVGhlTXVsdGlwbGVCYXNpY0lucHV0LnZ1ZT81OTNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLnVzZVswXSEuL1RoZU11bHRpcGxlQmFzaWNJbnB1dC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD00MzhhY2M4NyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJlMjAwYmNlOFwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDM4YWNjODcmc2NvcGVkPXRydWUmbGFuZz1jc3NcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9UaGVNdWx0aXBsZUJhc2ljSW5wdXQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDM4YWNjODcmc2NvcGVkPXRydWUmbGFuZz1jc3NcIik7XG4gICAgIGlmKG5ld0NvbnRlbnQuX19lc01vZHVsZSkgbmV3Q29udGVudCA9IG5ld0NvbnRlbnQuZGVmYXVsdDtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2982\n");

/***/ }),

/***/ 4549:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4486);\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(5346)/* [\"default\"] */ .Z)\nvar update = add(\"cf7408ce\", content, false, {});\n// Hot Module Replacement\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU0OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUEwUDtBQUNoUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQWlGO0FBQzNGLCtDQUErQztBQUMvQztBQUNBLEdBQUcsS0FBVSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL3NyYy9jb21wb25lbnRzL2ljb25zL1N2Z0ljb24udnVlPzJlMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3ZnSWNvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yZmRhMTRjMSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbmlmKGNvbnRlbnQuX19lc01vZHVsZSkgY29udGVudCA9IGNvbnRlbnQuZGVmYXVsdDtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJjZjc0MDhjZVwiLCBjb250ZW50LCBmYWxzZSwge30pO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMF0hLi9TdmdJY29uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTJmZGExNGMxJnNjb3BlZD10cnVlJmxhbmc9Y3NzXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzBdIS4vU3ZnSWNvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yZmRhMTRjMSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcbiAgICAgaWYobmV3Q29udGVudC5fX2VzTW9kdWxlKSBuZXdDb250ZW50ID0gbmV3Q29udGVudC5kZWZhdWx0O1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4549\n");

/***/ }),

/***/ 5346:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Z: function() { return /* binding */ addStylesClient; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n;// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzliYmMiLCJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanM/NDk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5346\n");

/***/ }),

/***/ 8620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n__webpack_unused_export__ = Vuelidate;\n__webpack_unused_export__ = __webpack_unused_export__ = void 0;\n__webpack_unused_export__ = ({\n  enumerable: true,\n  get: function get() {\n    return _params.withParams;\n  }\n});\n\nvar _vval = __webpack_require__(2584);\n\nvar _params = __webpack_require__(8413);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar NIL = function NIL() {\n  return null;\n};\n\nvar buildFromKeys = function buildFromKeys(keys, fn, keyFn) {\n  return keys.reduce(function (build, key) {\n    build[keyFn ? keyFn(key) : key] = fn(key);\n    return build;\n  }, {});\n};\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\nfunction isObject(val) {\n  return val !== null && (_typeof(val) === 'object' || isFunction(val));\n}\n\nfunction isPromise(object) {\n  return isObject(object) && isFunction(object.then);\n}\n\nvar getPath = function getPath(ctx, obj, path, fallback) {\n  if (typeof path === 'function') {\n    return path.call(ctx, obj, fallback);\n  }\n\n  path = Array.isArray(path) ? path : path.split('.');\n\n  for (var i = 0; i < path.length; i++) {\n    if (obj && _typeof(obj) === 'object') {\n      obj = obj[path[i]];\n    } else {\n      return fallback;\n    }\n  }\n\n  return typeof obj === 'undefined' ? fallback : obj;\n};\n\nvar __isVuelidateAsyncVm = '__isVuelidateAsyncVm';\n\nfunction makePendingAsyncVm(Vue, promise) {\n  var asyncVm = new Vue({\n    data: {\n      p: true,\n      v: false\n    }\n  });\n  promise.then(function (value) {\n    asyncVm.p = false;\n    asyncVm.v = value;\n  }, function (error) {\n    asyncVm.p = false;\n    asyncVm.v = false;\n    throw error;\n  });\n  asyncVm[__isVuelidateAsyncVm] = true;\n  return asyncVm;\n}\n\nvar validationGetters = {\n  $invalid: function $invalid() {\n    var _this = this;\n\n    var proxy = this.proxy;\n    return this.nestedKeys.some(function (nested) {\n      return _this.refProxy(nested).$invalid;\n    }) || this.ruleKeys.some(function (rule) {\n      return !proxy[rule];\n    });\n  },\n  $dirty: function $dirty() {\n    var _this2 = this;\n\n    if (this.dirty) {\n      return true;\n    }\n\n    if (this.nestedKeys.length === 0) {\n      return false;\n    }\n\n    return this.nestedKeys.every(function (key) {\n      return _this2.refProxy(key).$dirty;\n    });\n  },\n  $anyDirty: function $anyDirty() {\n    var _this3 = this;\n\n    if (this.dirty) {\n      return true;\n    }\n\n    if (this.nestedKeys.length === 0) {\n      return false;\n    }\n\n    return this.nestedKeys.some(function (key) {\n      return _this3.refProxy(key).$anyDirty;\n    });\n  },\n  $error: function $error() {\n    return this.$dirty && !this.$pending && this.$invalid;\n  },\n  $anyError: function $anyError() {\n    var _this4 = this;\n\n    if (this.$error) return true;\n    return this.nestedKeys.some(function (key) {\n      return _this4.refProxy(key).$anyError;\n    });\n  },\n  $pending: function $pending() {\n    var _this5 = this;\n\n    return this.ruleKeys.some(function (key) {\n      return _this5.getRef(key).$pending;\n    }) || this.nestedKeys.some(function (key) {\n      return _this5.refProxy(key).$pending;\n    });\n  },\n  $params: function $params() {\n    var _this6 = this;\n\n    var vals = this.validations;\n    return _objectSpread(_objectSpread({}, buildFromKeys(this.nestedKeys, function (key) {\n      return vals[key] && vals[key].$params || null;\n    })), buildFromKeys(this.ruleKeys, function (key) {\n      return _this6.getRef(key).$params;\n    }));\n  }\n};\n\nfunction setDirtyRecursive(newState) {\n  this.dirty = newState;\n  var proxy = this.proxy;\n  var method = newState ? '$touch' : '$reset';\n  this.nestedKeys.forEach(function (key) {\n    proxy[key][method]();\n  });\n}\n\nvar validationMethods = {\n  $touch: function $touch() {\n    setDirtyRecursive.call(this, true);\n  },\n  $reset: function $reset() {\n    setDirtyRecursive.call(this, false);\n  },\n  $flattenParams: function $flattenParams() {\n    var proxy = this.proxy;\n    var params = [];\n\n    for (var key in this.$params) {\n      if (this.isNested(key)) {\n        var childParams = proxy[key].$flattenParams();\n\n        for (var j = 0; j < childParams.length; j++) {\n          childParams[j].path.unshift(key);\n        }\n\n        params = params.concat(childParams);\n      } else {\n        params.push({\n          path: [],\n          name: key,\n          params: this.$params[key]\n        });\n      }\n    }\n\n    return params;\n  }\n};\nvar getterNames = Object.keys(validationGetters);\nvar methodNames = Object.keys(validationMethods);\nvar _cachedComponent = null;\n\nvar getComponent = function getComponent(Vue) {\n  if (_cachedComponent) {\n    return _cachedComponent;\n  }\n\n  var VBase = Vue.extend({\n    computed: {\n      refs: function refs() {\n        var oldVval = this._vval;\n        this._vval = this.children;\n        (0, _vval.patchChildren)(oldVval, this._vval);\n        var refs = {};\n\n        this._vval.forEach(function (c) {\n          refs[c.key] = c.vm;\n        });\n\n        return refs;\n      }\n    },\n    beforeCreate: function beforeCreate() {\n      this._vval = null;\n    },\n    beforeDestroy: function beforeDestroy() {\n      if (this._vval) {\n        (0, _vval.patchChildren)(this._vval);\n        this._vval = null;\n      }\n    },\n    methods: {\n      getModel: function getModel() {\n        return this.lazyModel ? this.lazyModel(this.prop) : this.model;\n      },\n      getModelKey: function getModelKey(key) {\n        var model = this.getModel();\n\n        if (model) {\n          return model[key];\n        }\n      },\n      hasIter: function hasIter() {\n        return false;\n      }\n    }\n  });\n  var ValidationRule = VBase.extend({\n    data: function data() {\n      return {\n        rule: null,\n        lazyModel: null,\n        model: null,\n        lazyParentModel: null,\n        rootModel: null\n      };\n    },\n    methods: {\n      runRule: function runRule(parent) {\n        var model = this.getModel();\n        (0, _params.pushParams)();\n        var rawOutput = this.rule.call(this.rootModel, model, parent);\n        var output = isPromise(rawOutput) ? makePendingAsyncVm(Vue, rawOutput) : rawOutput;\n        var rawParams = (0, _params.popParams)();\n        var params = rawParams && rawParams.$sub ? rawParams.$sub.length > 1 ? rawParams : rawParams.$sub[0] : null;\n        return {\n          output: output,\n          params: params\n        };\n      }\n    },\n    computed: {\n      run: function run() {\n        var _this7 = this;\n\n        var parent = this.lazyParentModel();\n\n        var isArrayDependant = Array.isArray(parent) && parent.__ob__;\n\n        if (isArrayDependant) {\n          var arrayDep = parent.__ob__.dep;\n          arrayDep.depend();\n          var target = arrayDep.constructor.target;\n\n          if (!this._indirectWatcher) {\n            var Watcher = target.constructor;\n            this._indirectWatcher = new Watcher(this, function () {\n              return _this7.runRule(parent);\n            }, null, {\n              lazy: true\n            });\n          }\n\n          var model = this.getModel();\n\n          if (!this._indirectWatcher.dirty && this._lastModel === model) {\n            this._indirectWatcher.depend();\n\n            return target.value;\n          }\n\n          this._lastModel = model;\n\n          this._indirectWatcher.evaluate();\n\n          this._indirectWatcher.depend();\n        } else if (this._indirectWatcher) {\n          this._indirectWatcher.teardown();\n\n          this._indirectWatcher = null;\n        }\n\n        return this._indirectWatcher ? this._indirectWatcher.value : this.runRule(parent);\n      },\n      $params: function $params() {\n        return this.run.params;\n      },\n      proxy: function proxy() {\n        var output = this.run.output;\n\n        if (output[__isVuelidateAsyncVm]) {\n          return !!output.v;\n        }\n\n        return !!output;\n      },\n      $pending: function $pending() {\n        var output = this.run.output;\n\n        if (output[__isVuelidateAsyncVm]) {\n          return output.p;\n        }\n\n        return false;\n      }\n    },\n    destroyed: function destroyed() {\n      if (this._indirectWatcher) {\n        this._indirectWatcher.teardown();\n\n        this._indirectWatcher = null;\n      }\n    }\n  });\n  var Validation = VBase.extend({\n    data: function data() {\n      return {\n        dirty: false,\n        validations: null,\n        lazyModel: null,\n        model: null,\n        prop: null,\n        lazyParentModel: null,\n        rootModel: null\n      };\n    },\n    methods: _objectSpread(_objectSpread({}, validationMethods), {}, {\n      refProxy: function refProxy(key) {\n        return this.getRef(key).proxy;\n      },\n      getRef: function getRef(key) {\n        return this.refs[key];\n      },\n      isNested: function isNested(key) {\n        return typeof this.validations[key] !== 'function';\n      }\n    }),\n    computed: _objectSpread(_objectSpread({}, validationGetters), {}, {\n      nestedKeys: function nestedKeys() {\n        return this.keys.filter(this.isNested);\n      },\n      ruleKeys: function ruleKeys() {\n        var _this8 = this;\n\n        return this.keys.filter(function (k) {\n          return !_this8.isNested(k);\n        });\n      },\n      keys: function keys() {\n        return Object.keys(this.validations).filter(function (k) {\n          return k !== '$params';\n        });\n      },\n      proxy: function proxy() {\n        var _this9 = this;\n\n        var keyDefs = buildFromKeys(this.keys, function (key) {\n          return {\n            enumerable: true,\n            configurable: true,\n            get: function get() {\n              return _this9.refProxy(key);\n            }\n          };\n        });\n        var getterDefs = buildFromKeys(getterNames, function (key) {\n          return {\n            enumerable: true,\n            configurable: true,\n            get: function get() {\n              return _this9[key];\n            }\n          };\n        });\n        var methodDefs = buildFromKeys(methodNames, function (key) {\n          return {\n            enumerable: false,\n            configurable: true,\n            get: function get() {\n              return _this9[key];\n            }\n          };\n        });\n        var iterDefs = this.hasIter() ? {\n          $iter: {\n            enumerable: true,\n            value: Object.defineProperties({}, _objectSpread({}, keyDefs))\n          }\n        } : {};\n        return Object.defineProperties({}, _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, keyDefs), iterDefs), {}, {\n          $model: {\n            enumerable: true,\n            get: function get() {\n              var parent = _this9.lazyParentModel();\n\n              if (parent != null) {\n                return parent[_this9.prop];\n              } else {\n                return null;\n              }\n            },\n            set: function set(value) {\n              var parent = _this9.lazyParentModel();\n\n              if (parent != null) {\n                parent[_this9.prop] = value;\n\n                _this9.$touch();\n              }\n            }\n          }\n        }, getterDefs), methodDefs));\n      },\n      children: function children() {\n        var _this10 = this;\n\n        return [].concat(_toConsumableArray(this.nestedKeys.map(function (key) {\n          return renderNested(_this10, key);\n        })), _toConsumableArray(this.ruleKeys.map(function (key) {\n          return renderRule(_this10, key);\n        }))).filter(Boolean);\n      }\n    })\n  });\n  var GroupValidation = Validation.extend({\n    methods: {\n      isNested: function isNested(key) {\n        return typeof this.validations[key]() !== 'undefined';\n      },\n      getRef: function getRef(key) {\n        var vm = this;\n        return {\n          get proxy() {\n            return vm.validations[key]() || false;\n          }\n\n        };\n      }\n    }\n  });\n  var EachValidation = Validation.extend({\n    computed: {\n      keys: function keys() {\n        var model = this.getModel();\n\n        if (isObject(model)) {\n          return Object.keys(model);\n        } else {\n          return [];\n        }\n      },\n      tracker: function tracker() {\n        var _this11 = this;\n\n        var trackBy = this.validations.$trackBy;\n        return trackBy ? function (key) {\n          return \"\".concat(getPath(_this11.rootModel, _this11.getModelKey(key), trackBy));\n        } : function (x) {\n          return \"\".concat(x);\n        };\n      },\n      getModelLazy: function getModelLazy() {\n        var _this12 = this;\n\n        return function () {\n          return _this12.getModel();\n        };\n      },\n      children: function children() {\n        var _this13 = this;\n\n        var def = this.validations;\n        var model = this.getModel();\n\n        var validations = _objectSpread({}, def);\n\n        delete validations['$trackBy'];\n        var usedTracks = {};\n        return this.keys.map(function (key) {\n          var track = _this13.tracker(key);\n\n          if (usedTracks.hasOwnProperty(track)) {\n            return null;\n          }\n\n          usedTracks[track] = true;\n          return (0, _vval.h)(Validation, track, {\n            validations: validations,\n            prop: key,\n            lazyParentModel: _this13.getModelLazy,\n            model: model[key],\n            rootModel: _this13.rootModel\n          });\n        }).filter(Boolean);\n      }\n    },\n    methods: {\n      isNested: function isNested() {\n        return true;\n      },\n      getRef: function getRef(key) {\n        return this.refs[this.tracker(key)];\n      },\n      hasIter: function hasIter() {\n        return true;\n      }\n    }\n  });\n\n  var renderNested = function renderNested(vm, key) {\n    if (key === '$each') {\n      return (0, _vval.h)(EachValidation, key, {\n        validations: vm.validations[key],\n        lazyParentModel: vm.lazyParentModel,\n        prop: key,\n        lazyModel: vm.getModel,\n        rootModel: vm.rootModel\n      });\n    }\n\n    var validations = vm.validations[key];\n\n    if (Array.isArray(validations)) {\n      var root = vm.rootModel;\n      var refVals = buildFromKeys(validations, function (path) {\n        return function () {\n          return getPath(root, root.$v, path);\n        };\n      }, function (v) {\n        return Array.isArray(v) ? v.join('.') : v;\n      });\n      return (0, _vval.h)(GroupValidation, key, {\n        validations: refVals,\n        lazyParentModel: NIL,\n        prop: key,\n        lazyModel: NIL,\n        rootModel: root\n      });\n    }\n\n    return (0, _vval.h)(Validation, key, {\n      validations: validations,\n      lazyParentModel: vm.getModel,\n      prop: key,\n      lazyModel: vm.getModelKey,\n      rootModel: vm.rootModel\n    });\n  };\n\n  var renderRule = function renderRule(vm, key) {\n    return (0, _vval.h)(ValidationRule, key, {\n      rule: vm.validations[key],\n      lazyParentModel: vm.lazyParentModel,\n      lazyModel: vm.getModel,\n      rootModel: vm.rootModel\n    });\n  };\n\n  _cachedComponent = {\n    VBase: VBase,\n    Validation: Validation\n  };\n  return _cachedComponent;\n};\n\nvar _cachedVue = null;\n\nfunction getVue(rootVm) {\n  if (_cachedVue) return _cachedVue;\n  var Vue = rootVm.constructor;\n\n  while (Vue.super) {\n    Vue = Vue.super;\n  }\n\n  _cachedVue = Vue;\n  return Vue;\n}\n\nvar validateModel = function validateModel(model, validations) {\n  var Vue = getVue(model);\n\n  var _getComponent = getComponent(Vue),\n      Validation = _getComponent.Validation,\n      VBase = _getComponent.VBase;\n\n  var root = new VBase({\n    computed: {\n      children: function children() {\n        var vals = typeof validations === 'function' ? validations.call(model) : validations;\n        return [(0, _vval.h)(Validation, '$v', {\n          validations: vals,\n          lazyParentModel: NIL,\n          prop: '$v',\n          model: model,\n          rootModel: model\n        })];\n      }\n    }\n  });\n  return root;\n};\n\nvar validationMixin = {\n  data: function data() {\n    var vals = this.$options.validations;\n\n    if (vals) {\n      this._vuelidate = validateModel(this, vals);\n    }\n\n    return {};\n  },\n  beforeCreate: function beforeCreate() {\n    var options = this.$options;\n    var vals = options.validations;\n    if (!vals) return;\n    if (!options.computed) options.computed = {};\n    if (options.computed.$v) return;\n\n    options.computed.$v = function () {\n      return this._vuelidate ? this._vuelidate.refs.$v.proxy : null;\n    };\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this._vuelidate) {\n      this._vuelidate.$destroy();\n\n      this._vuelidate = null;\n    }\n  }\n};\n__webpack_unused_export__ = validationMixin;\n\nfunction Vuelidate(Vue) {\n  Vue.mixin(validationMixin);\n}\n\nvar _default = Vuelidate;\n__webpack_unused_export__ = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYyMC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsNkJBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxDQUFDO0FBQ0YseUJBQWlCO0FBQ2pCLHlCQUF1QixHQUFHLHlCQUFlO0FBQ3pDLDZCQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQzs7QUFFRixZQUFZLG1CQUFPLENBQUMsSUFBUTs7QUFFNUIsY0FBYyxtQkFBTyxDQUFDLElBQVU7O0FBRWhDLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1Msa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFM1UsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx1REFBdUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLGlEQUFpRCxtRkFBbUYsT0FBTzs7QUFFdGdCLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTSx3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFD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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvdnVlbGlkYXRlL2xpYi9pbmRleC5qcz8xZGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WdWVsaWRhdGUgPSBWdWVsaWRhdGU7XG5leHBvcnRzLnZhbGlkYXRpb25NaXhpbiA9IGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpdGhQYXJhbXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcmFtcy53aXRoUGFyYW1zO1xuICB9XG59KTtcblxudmFyIF92dmFsID0gcmVxdWlyZShcIi4vdnZhbFwiKTtcblxudmFyIF9wYXJhbXMgPSByZXF1aXJlKFwiLi9wYXJhbXNcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBOSUwgPSBmdW5jdGlvbiBOSUwoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGJ1aWxkRnJvbUtleXMgPSBmdW5jdGlvbiBidWlsZEZyb21LZXlzKGtleXMsIGZuLCBrZXlGbikge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGJ1aWxkLCBrZXkpIHtcbiAgICBidWlsZFtrZXlGbiA/IGtleUZuKGtleSkgOiBrZXldID0gZm4oa2V5KTtcbiAgICByZXR1cm4gYnVpbGQ7XG4gIH0sIHt9KTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyB8fCBpc0Z1bmN0aW9uKHZhbCkpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIGlzRnVuY3Rpb24ob2JqZWN0LnRoZW4pO1xufVxuXG52YXIgZ2V0UGF0aCA9IGZ1bmN0aW9uIGdldFBhdGgoY3R4LCBvYmosIHBhdGgsIGZhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYXRoLmNhbGwoY3R4LCBvYmosIGZhbGxiYWNrKTtcbiAgfVxuXG4gIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqICYmIF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/IGZhbGxiYWNrIDogb2JqO1xufTtcblxudmFyIF9faXNWdWVsaWRhdGVBc3luY1ZtID0gJ19faXNWdWVsaWRhdGVBc3luY1ZtJztcblxuZnVuY3Rpb24gbWFrZVBlbmRpbmdBc3luY1ZtKFZ1ZSwgcHJvbWlzZSkge1xuICB2YXIgYXN5bmNWbSA9IG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgIHA6IHRydWUsXG4gICAgICB2OiBmYWxzZVxuICAgIH1cbiAgfSk7XG4gIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc3luY1ZtLnAgPSBmYWxzZTtcbiAgICBhc3luY1ZtLnYgPSB2YWx1ZTtcbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgYXN5bmNWbS5wID0gZmFsc2U7XG4gICAgYXN5bmNWbS52ID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBhc3luY1ZtW19faXNWdWVsaWRhdGVBc3luY1ZtXSA9IHRydWU7XG4gIHJldHVybiBhc3luY1ZtO1xufVxuXG52YXIgdmFsaWRhdGlvbkdldHRlcnMgPSB7XG4gICRpbnZhbGlkOiBmdW5jdGlvbiAkaW52YWxpZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByb3h5ID0gdGhpcy5wcm94eTtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWRLZXlzLnNvbWUoZnVuY3Rpb24gKG5lc3RlZCkge1xuICAgICAgcmV0dXJuIF90aGlzLnJlZlByb3h5KG5lc3RlZCkuJGludmFsaWQ7XG4gICAgfSkgfHwgdGhpcy5ydWxlS2V5cy5zb21lKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICByZXR1cm4gIXByb3h5W3J1bGVdO1xuICAgIH0pO1xuICB9LFxuICAkZGlydHk6IGZ1bmN0aW9uICRkaXJ0eSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZXN0ZWRLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5lc3RlZEtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIF90aGlzMi5yZWZQcm94eShrZXkpLiRkaXJ0eTtcbiAgICB9KTtcbiAgfSxcbiAgJGFueURpcnR5OiBmdW5jdGlvbiAkYW55RGlydHkoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVzdGVkS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uZXN0ZWRLZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIF90aGlzMy5yZWZQcm94eShrZXkpLiRhbnlEaXJ0eTtcbiAgICB9KTtcbiAgfSxcbiAgJGVycm9yOiBmdW5jdGlvbiAkZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGRpcnR5ICYmICF0aGlzLiRwZW5kaW5nICYmIHRoaXMuJGludmFsaWQ7XG4gIH0sXG4gICRhbnlFcnJvcjogZnVuY3Rpb24gJGFueUVycm9yKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuJGVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWRLZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIF90aGlzNC5yZWZQcm94eShrZXkpLiRhbnlFcnJvcjtcbiAgICB9KTtcbiAgfSxcbiAgJHBlbmRpbmc6IGZ1bmN0aW9uICRwZW5kaW5nKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMucnVsZUtleXMuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXM1LmdldFJlZihrZXkpLiRwZW5kaW5nO1xuICAgIH0pIHx8IHRoaXMubmVzdGVkS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBfdGhpczUucmVmUHJveHkoa2V5KS4kcGVuZGluZztcbiAgICB9KTtcbiAgfSxcbiAgJHBhcmFtczogZnVuY3Rpb24gJHBhcmFtcygpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciB2YWxzID0gdGhpcy52YWxpZGF0aW9ucztcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBidWlsZEZyb21LZXlzKHRoaXMubmVzdGVkS2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHNba2V5XSAmJiB2YWxzW2tleV0uJHBhcmFtcyB8fCBudWxsO1xuICAgIH0pKSwgYnVpbGRGcm9tS2V5cyh0aGlzLnJ1bGVLZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXM2LmdldFJlZihrZXkpLiRwYXJhbXM7XG4gICAgfSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzZXREaXJ0eVJlY3Vyc2l2ZShuZXdTdGF0ZSkge1xuICB0aGlzLmRpcnR5ID0gbmV3U3RhdGU7XG4gIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gIHZhciBtZXRob2QgPSBuZXdTdGF0ZSA/ICckdG91Y2gnIDogJyRyZXNldCc7XG4gIHRoaXMubmVzdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBwcm94eVtrZXldW21ldGhvZF0oKTtcbiAgfSk7XG59XG5cbnZhciB2YWxpZGF0aW9uTWV0aG9kcyA9IHtcbiAgJHRvdWNoOiBmdW5jdGlvbiAkdG91Y2goKSB7XG4gICAgc2V0RGlydHlSZWN1cnNpdmUuY2FsbCh0aGlzLCB0cnVlKTtcbiAgfSxcbiAgJHJlc2V0OiBmdW5jdGlvbiAkcmVzZXQoKSB7XG4gICAgc2V0RGlydHlSZWN1cnNpdmUuY2FsbCh0aGlzLCBmYWxzZSk7XG4gIH0sXG4gICRmbGF0dGVuUGFyYW1zOiBmdW5jdGlvbiAkZmxhdHRlblBhcmFtcygpIHtcbiAgICB2YXIgcHJveHkgPSB0aGlzLnByb3h5O1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLiRwYXJhbXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTmVzdGVkKGtleSkpIHtcbiAgICAgICAgdmFyIGNoaWxkUGFyYW1zID0gcHJveHlba2V5XS4kZmxhdHRlblBhcmFtcygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRQYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjaGlsZFBhcmFtc1tqXS5wYXRoLnVuc2hpZnQoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5jb25jYXQoY2hpbGRQYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICBwYXJhbXM6IHRoaXMuJHBhcmFtc1trZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG52YXIgZ2V0dGVyTmFtZXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9uR2V0dGVycyk7XG52YXIgbWV0aG9kTmFtZXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9uTWV0aG9kcyk7XG52YXIgX2NhY2hlZENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBnZXRDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRDb21wb25lbnQoVnVlKSB7XG4gIGlmIChfY2FjaGVkQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIF9jYWNoZWRDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgVkJhc2UgPSBWdWUuZXh0ZW5kKHtcbiAgICBjb21wdXRlZDoge1xuICAgICAgcmVmczogZnVuY3Rpb24gcmVmcygpIHtcbiAgICAgICAgdmFyIG9sZFZ2YWwgPSB0aGlzLl92dmFsO1xuICAgICAgICB0aGlzLl92dmFsID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgKDAsIF92dmFsLnBhdGNoQ2hpbGRyZW4pKG9sZFZ2YWwsIHRoaXMuX3Z2YWwpO1xuICAgICAgICB2YXIgcmVmcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3Z2YWwuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJlZnNbYy5rZXldID0gYy52bTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlZnM7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgIHRoaXMuX3Z2YWwgPSBudWxsO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLl92dmFsKSB7XG4gICAgICAgICgwLCBfdnZhbC5wYXRjaENoaWxkcmVuKSh0aGlzLl92dmFsKTtcbiAgICAgICAgdGhpcy5fdnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBnZXRNb2RlbDogZnVuY3Rpb24gZ2V0TW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhenlNb2RlbCA/IHRoaXMubGF6eU1vZGVsKHRoaXMucHJvcCkgOiB0aGlzLm1vZGVsO1xuICAgICAgfSxcbiAgICAgIGdldE1vZGVsS2V5OiBmdW5jdGlvbiBnZXRNb2RlbEtleShrZXkpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuXG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgIHJldHVybiBtb2RlbFtrZXldO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzSXRlcjogZnVuY3Rpb24gaGFzSXRlcigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBWYWxpZGF0aW9uUnVsZSA9IFZCYXNlLmV4dGVuZCh7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJ1bGU6IG51bGwsXG4gICAgICAgIGxhenlNb2RlbDogbnVsbCxcbiAgICAgICAgbW9kZWw6IG51bGwsXG4gICAgICAgIGxhenlQYXJlbnRNb2RlbDogbnVsbCxcbiAgICAgICAgcm9vdE1vZGVsOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcnVuUnVsZTogZnVuY3Rpb24gcnVuUnVsZShwYXJlbnQpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuICAgICAgICAoMCwgX3BhcmFtcy5wdXNoUGFyYW1zKSgpO1xuICAgICAgICB2YXIgcmF3T3V0cHV0ID0gdGhpcy5ydWxlLmNhbGwodGhpcy5yb290TW9kZWwsIG1vZGVsLCBwYXJlbnQpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gaXNQcm9taXNlKHJhd091dHB1dCkgPyBtYWtlUGVuZGluZ0FzeW5jVm0oVnVlLCByYXdPdXRwdXQpIDogcmF3T3V0cHV0O1xuICAgICAgICB2YXIgcmF3UGFyYW1zID0gKDAsIF9wYXJhbXMucG9wUGFyYW1zKSgpO1xuICAgICAgICB2YXIgcGFyYW1zID0gcmF3UGFyYW1zICYmIHJhd1BhcmFtcy4kc3ViID8gcmF3UGFyYW1zLiRzdWIubGVuZ3RoID4gMSA/IHJhd1BhcmFtcyA6IHJhd1BhcmFtcy4kc3ViWzBdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHJ1bjogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5sYXp5UGFyZW50TW9kZWwoKTtcblxuICAgICAgICB2YXIgaXNBcnJheURlcGVuZGFudCA9IEFycmF5LmlzQXJyYXkocGFyZW50KSAmJiBwYXJlbnQuX19vYl9fO1xuXG4gICAgICAgIGlmIChpc0FycmF5RGVwZW5kYW50KSB7XG4gICAgICAgICAgdmFyIGFycmF5RGVwID0gcGFyZW50Ll9fb2JfXy5kZXA7XG4gICAgICAgICAgYXJyYXlEZXAuZGVwZW5kKCk7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGFycmF5RGVwLmNvbnN0cnVjdG9yLnRhcmdldDtcblxuICAgICAgICAgIGlmICghdGhpcy5faW5kaXJlY3RXYXRjaGVyKSB7XG4gICAgICAgICAgICB2YXIgV2F0Y2hlciA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHRoaXMuX2luZGlyZWN0V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNy5ydW5SdWxlKHBhcmVudCk7XG4gICAgICAgICAgICB9LCBudWxsLCB7XG4gICAgICAgICAgICAgIGxhenk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwoKTtcblxuICAgICAgICAgIGlmICghdGhpcy5faW5kaXJlY3RXYXRjaGVyLmRpcnR5ICYmIHRoaXMuX2xhc3RNb2RlbCA9PT0gbW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGlyZWN0V2F0Y2hlci5kZXBlbmQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9sYXN0TW9kZWwgPSBtb2RlbDtcblxuICAgICAgICAgIHRoaXMuX2luZGlyZWN0V2F0Y2hlci5ldmFsdWF0ZSgpO1xuXG4gICAgICAgICAgdGhpcy5faW5kaXJlY3RXYXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2luZGlyZWN0V2F0Y2hlcikge1xuICAgICAgICAgIHRoaXMuX2luZGlyZWN0V2F0Y2hlci50ZWFyZG93bigpO1xuXG4gICAgICAgICAgdGhpcy5faW5kaXJlY3RXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRpcmVjdFdhdGNoZXIgPyB0aGlzLl9pbmRpcmVjdFdhdGNoZXIudmFsdWUgOiB0aGlzLnJ1blJ1bGUocGFyZW50KTtcbiAgICAgIH0sXG4gICAgICAkcGFyYW1zOiBmdW5jdGlvbiAkcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW4ucGFyYW1zO1xuICAgICAgfSxcbiAgICAgIHByb3h5OiBmdW5jdGlvbiBwcm94eSgpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMucnVuLm91dHB1dDtcblxuICAgICAgICBpZiAob3V0cHV0W19faXNWdWVsaWRhdGVBc3luY1ZtXSkge1xuICAgICAgICAgIHJldHVybiAhIW91dHB1dC52O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhb3V0cHV0O1xuICAgICAgfSxcbiAgICAgICRwZW5kaW5nOiBmdW5jdGlvbiAkcGVuZGluZygpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMucnVuLm91dHB1dDtcblxuICAgICAgICBpZiAob3V0cHV0W19faXNWdWVsaWRhdGVBc3luY1ZtXSkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXQucDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgICAgaWYgKHRoaXMuX2luZGlyZWN0V2F0Y2hlcikge1xuICAgICAgICB0aGlzLl9pbmRpcmVjdFdhdGNoZXIudGVhcmRvd24oKTtcblxuICAgICAgICB0aGlzLl9pbmRpcmVjdFdhdGNoZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHZhciBWYWxpZGF0aW9uID0gVkJhc2UuZXh0ZW5kKHtcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlydHk6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW9uczogbnVsbCxcbiAgICAgICAgbGF6eU1vZGVsOiBudWxsLFxuICAgICAgICBtb2RlbDogbnVsbCxcbiAgICAgICAgcHJvcDogbnVsbCxcbiAgICAgICAgbGF6eVBhcmVudE1vZGVsOiBudWxsLFxuICAgICAgICByb290TW9kZWw6IG51bGxcbiAgICAgIH07XG4gICAgfSxcbiAgICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbGlkYXRpb25NZXRob2RzKSwge30sIHtcbiAgICAgIHJlZlByb3h5OiBmdW5jdGlvbiByZWZQcm94eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmKGtleSkucHJveHk7XG4gICAgICB9LFxuICAgICAgZ2V0UmVmOiBmdW5jdGlvbiBnZXRSZWYoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNba2V5XTtcbiAgICAgIH0sXG4gICAgICBpc05lc3RlZDogZnVuY3Rpb24gaXNOZXN0ZWQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy52YWxpZGF0aW9uc1trZXldICE9PSAnZnVuY3Rpb24nO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGNvbXB1dGVkOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHZhbGlkYXRpb25HZXR0ZXJzKSwge30sIHtcbiAgICAgIG5lc3RlZEtleXM6IGZ1bmN0aW9uIG5lc3RlZEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuZmlsdGVyKHRoaXMuaXNOZXN0ZWQpO1xuICAgICAgfSxcbiAgICAgIHJ1bGVLZXlzOiBmdW5jdGlvbiBydWxlS2V5cygpIHtcbiAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gIV90aGlzOC5pc05lc3RlZChrKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsaWRhdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBrICE9PSAnJHBhcmFtcyc7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByb3h5OiBmdW5jdGlvbiBwcm94eSgpIHtcbiAgICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGtleURlZnMgPSBidWlsZEZyb21LZXlzKHRoaXMua2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczkucmVmUHJveHkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGdldHRlckRlZnMgPSBidWlsZEZyb21LZXlzKGdldHRlck5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWV0aG9kRGVmcyA9IGJ1aWxkRnJvbUtleXMobWV0aG9kTmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXRlckRlZnMgPSB0aGlzLmhhc0l0ZXIoKSA/IHtcbiAgICAgICAgICAkaXRlcjoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgX29iamVjdFNwcmVhZCh7fSwga2V5RGVmcykpXG4gICAgICAgICAgfVxuICAgICAgICB9IDoge307XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwga2V5RGVmcyksIGl0ZXJEZWZzKSwge30sIHtcbiAgICAgICAgICAkbW9kZWw6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IF90aGlzOS5sYXp5UGFyZW50TW9kZWwoKTtcblxuICAgICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50W190aGlzOS5wcm9wXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBfdGhpczkubGF6eVBhcmVudE1vZGVsKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50W190aGlzOS5wcm9wXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgX3RoaXM5LiR0b3VjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBnZXR0ZXJEZWZzKSwgbWV0aG9kRGVmcykpO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubmVzdGVkS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJOZXN0ZWQoX3RoaXMxMCwga2V5KTtcbiAgICAgICAgfSkpLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5ydWxlS2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJSdWxlKF90aGlzMTAsIGtleSk7XG4gICAgICAgIH0pKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgfVxuICAgIH0pXG4gIH0pO1xuICB2YXIgR3JvdXBWYWxpZGF0aW9uID0gVmFsaWRhdGlvbi5leHRlbmQoe1xuICAgIG1ldGhvZHM6IHtcbiAgICAgIGlzTmVzdGVkOiBmdW5jdGlvbiBpc05lc3RlZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbGlkYXRpb25zW2tleV0oKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9LFxuICAgICAgZ2V0UmVmOiBmdW5jdGlvbiBnZXRSZWYoa2V5KSB7XG4gICAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZ2V0IHByb3h5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHZtLnZhbGlkYXRpb25zW2tleV0oKSB8fCBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB2YXIgRWFjaFZhbGlkYXRpb24gPSBWYWxpZGF0aW9uLmV4dGVuZCh7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwoKTtcblxuICAgICAgICBpZiAoaXNPYmplY3QobW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmFja2VyOiBmdW5jdGlvbiB0cmFja2VyKCkge1xuICAgICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHRyYWNrQnkgPSB0aGlzLnZhbGlkYXRpb25zLiR0cmFja0J5O1xuICAgICAgICByZXR1cm4gdHJhY2tCeSA/IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZ2V0UGF0aChfdGhpczExLnJvb3RNb2RlbCwgX3RoaXMxMS5nZXRNb2RlbEtleShrZXkpLCB0cmFja0J5KSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh4KTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRNb2RlbExhenk6IGZ1bmN0aW9uIGdldE1vZGVsTGF6eSgpIHtcbiAgICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTIuZ2V0TW9kZWwoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgICB2YXIgZGVmID0gdGhpcy52YWxpZGF0aW9ucztcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRNb2RlbCgpO1xuXG4gICAgICAgIHZhciB2YWxpZGF0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZik7XG5cbiAgICAgICAgZGVsZXRlIHZhbGlkYXRpb25zWyckdHJhY2tCeSddO1xuICAgICAgICB2YXIgdXNlZFRyYWNrcyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHRyYWNrID0gX3RoaXMxMy50cmFja2VyKGtleSk7XG5cbiAgICAgICAgICBpZiAodXNlZFRyYWNrcy5oYXNPd25Qcm9wZXJ0eSh0cmFjaykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVzZWRUcmFja3NbdHJhY2tdID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gKDAsIF92dmFsLmgpKFZhbGlkYXRpb24sIHRyYWNrLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uczogdmFsaWRhdGlvbnMsXG4gICAgICAgICAgICBwcm9wOiBrZXksXG4gICAgICAgICAgICBsYXp5UGFyZW50TW9kZWw6IF90aGlzMTMuZ2V0TW9kZWxMYXp5LFxuICAgICAgICAgICAgbW9kZWw6IG1vZGVsW2tleV0sXG4gICAgICAgICAgICByb290TW9kZWw6IF90aGlzMTMucm9vdE1vZGVsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGlzTmVzdGVkOiBmdW5jdGlvbiBpc05lc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgZ2V0UmVmOiBmdW5jdGlvbiBnZXRSZWYoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNbdGhpcy50cmFja2VyKGtleSldO1xuICAgICAgfSxcbiAgICAgIGhhc0l0ZXI6IGZ1bmN0aW9uIGhhc0l0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlbmRlck5lc3RlZCA9IGZ1bmN0aW9uIHJlbmRlck5lc3RlZCh2bSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gJyRlYWNoJykge1xuICAgICAgcmV0dXJuICgwLCBfdnZhbC5oKShFYWNoVmFsaWRhdGlvbiwga2V5LCB7XG4gICAgICAgIHZhbGlkYXRpb25zOiB2bS52YWxpZGF0aW9uc1trZXldLFxuICAgICAgICBsYXp5UGFyZW50TW9kZWw6IHZtLmxhenlQYXJlbnRNb2RlbCxcbiAgICAgICAgcHJvcDoga2V5LFxuICAgICAgICBsYXp5TW9kZWw6IHZtLmdldE1vZGVsLFxuICAgICAgICByb290TW9kZWw6IHZtLnJvb3RNb2RlbFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkYXRpb25zID0gdm0udmFsaWRhdGlvbnNba2V5XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRpb25zKSkge1xuICAgICAgdmFyIHJvb3QgPSB2bS5yb290TW9kZWw7XG4gICAgICB2YXIgcmVmVmFscyA9IGJ1aWxkRnJvbUtleXModmFsaWRhdGlvbnMsIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFBhdGgocm9vdCwgcm9vdC4kdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9LCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHYuam9pbignLicpIDogdjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgwLCBfdnZhbC5oKShHcm91cFZhbGlkYXRpb24sIGtleSwge1xuICAgICAgICB2YWxpZGF0aW9uczogcmVmVmFscyxcbiAgICAgICAgbGF6eVBhcmVudE1vZGVsOiBOSUwsXG4gICAgICAgIHByb3A6IGtleSxcbiAgICAgICAgbGF6eU1vZGVsOiBOSUwsXG4gICAgICAgIHJvb3RNb2RlbDogcm9vdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfdnZhbC5oKShWYWxpZGF0aW9uLCBrZXksIHtcbiAgICAgIHZhbGlkYXRpb25zOiB2YWxpZGF0aW9ucyxcbiAgICAgIGxhenlQYXJlbnRNb2RlbDogdm0uZ2V0TW9kZWwsXG4gICAgICBwcm9wOiBrZXksXG4gICAgICBsYXp5TW9kZWw6IHZtLmdldE1vZGVsS2V5LFxuICAgICAgcm9vdE1vZGVsOiB2bS5yb290TW9kZWxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVuZGVyUnVsZSA9IGZ1bmN0aW9uIHJlbmRlclJ1bGUodm0sIGtleSkge1xuICAgIHJldHVybiAoMCwgX3Z2YWwuaCkoVmFsaWRhdGlvblJ1bGUsIGtleSwge1xuICAgICAgcnVsZTogdm0udmFsaWRhdGlvbnNba2V5XSxcbiAgICAgIGxhenlQYXJlbnRNb2RlbDogdm0ubGF6eVBhcmVudE1vZGVsLFxuICAgICAgbGF6eU1vZGVsOiB2bS5nZXRNb2RlbCxcbiAgICAgIHJvb3RNb2RlbDogdm0ucm9vdE1vZGVsXG4gICAgfSk7XG4gIH07XG5cbiAgX2NhY2hlZENvbXBvbmVudCA9IHtcbiAgICBWQmFzZTogVkJhc2UsXG4gICAgVmFsaWRhdGlvbjogVmFsaWRhdGlvblxuICB9O1xuICByZXR1cm4gX2NhY2hlZENvbXBvbmVudDtcbn07XG5cbnZhciBfY2FjaGVkVnVlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0VnVlKHJvb3RWbSkge1xuICBpZiAoX2NhY2hlZFZ1ZSkgcmV0dXJuIF9jYWNoZWRWdWU7XG4gIHZhciBWdWUgPSByb290Vm0uY29uc3RydWN0b3I7XG5cbiAgd2hpbGUgKFZ1ZS5zdXBlcikge1xuICAgIFZ1ZSA9IFZ1ZS5zdXBlcjtcbiAgfVxuXG4gIF9jYWNoZWRWdWUgPSBWdWU7XG4gIHJldHVybiBWdWU7XG59XG5cbnZhciB2YWxpZGF0ZU1vZGVsID0gZnVuY3Rpb24gdmFsaWRhdGVNb2RlbChtb2RlbCwgdmFsaWRhdGlvbnMpIHtcbiAgdmFyIFZ1ZSA9IGdldFZ1ZShtb2RlbCk7XG5cbiAgdmFyIF9nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQoVnVlKSxcbiAgICAgIFZhbGlkYXRpb24gPSBfZ2V0Q29tcG9uZW50LlZhbGlkYXRpb24sXG4gICAgICBWQmFzZSA9IF9nZXRDb21wb25lbnQuVkJhc2U7XG5cbiAgdmFyIHJvb3QgPSBuZXcgVkJhc2Uoe1xuICAgIGNvbXB1dGVkOiB7XG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgICAgIHZhciB2YWxzID0gdHlwZW9mIHZhbGlkYXRpb25zID09PSAnZnVuY3Rpb24nID8gdmFsaWRhdGlvbnMuY2FsbChtb2RlbCkgOiB2YWxpZGF0aW9ucztcbiAgICAgICAgcmV0dXJuIFsoMCwgX3Z2YWwuaCkoVmFsaWRhdGlvbiwgJyR2Jywge1xuICAgICAgICAgIHZhbGlkYXRpb25zOiB2YWxzLFxuICAgICAgICAgIGxhenlQYXJlbnRNb2RlbDogTklMLFxuICAgICAgICAgIHByb3A6ICckdicsXG4gICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgIHJvb3RNb2RlbDogbW9kZWxcbiAgICAgICAgfSldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290O1xufTtcblxudmFyIHZhbGlkYXRpb25NaXhpbiA9IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICB2YXIgdmFscyA9IHRoaXMuJG9wdGlvbnMudmFsaWRhdGlvbnM7XG5cbiAgICBpZiAodmFscykge1xuICAgICAgdGhpcy5fdnVlbGlkYXRlID0gdmFsaWRhdGVNb2RlbCh0aGlzLCB2YWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICB2YXIgdmFscyA9IG9wdGlvbnMudmFsaWRhdGlvbnM7XG4gICAgaWYgKCF2YWxzKSByZXR1cm47XG4gICAgaWYgKCFvcHRpb25zLmNvbXB1dGVkKSBvcHRpb25zLmNvbXB1dGVkID0ge307XG4gICAgaWYgKG9wdGlvbnMuY29tcHV0ZWQuJHYpIHJldHVybjtcblxuICAgIG9wdGlvbnMuY29tcHV0ZWQuJHYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdnVlbGlkYXRlID8gdGhpcy5fdnVlbGlkYXRlLnJlZnMuJHYucHJveHkgOiBudWxsO1xuICAgIH07XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3Z1ZWxpZGF0ZSkge1xuICAgICAgdGhpcy5fdnVlbGlkYXRlLiRkZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuX3Z1ZWxpZGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0cy52YWxpZGF0aW9uTWl4aW4gPSB2YWxpZGF0aW9uTWl4aW47XG5cbmZ1bmN0aW9uIFZ1ZWxpZGF0ZShWdWUpIHtcbiAgVnVlLm1peGluKHZhbGlkYXRpb25NaXhpbik7XG59XG5cbnZhciBfZGVmYXVsdCA9IFZ1ZWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8620\n");

/***/ }),

/***/ 8413:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._setTarget = void 0;\nexports.popParams = popParams;\nexports.pushParams = pushParams;\nexports.target = void 0;\nexports.withParams = withParams;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar stack = [];\nvar target = null;\nexports.target = target;\n\nvar _setTarget = function _setTarget(x) {\n  exports.target = target = x;\n};\n\nexports._setTarget = _setTarget;\n\nfunction pushParams() {\n  if (target !== null) {\n    stack.push(target);\n  }\n\n  exports.target = target = {};\n}\n\nfunction popParams() {\n  var lastTarget = target;\n  var newTarget = exports.target = target = stack.pop() || null;\n\n  if (newTarget) {\n    if (!Array.isArray(newTarget.$sub)) {\n      newTarget.$sub = [];\n    }\n\n    newTarget.$sub.push(lastTarget);\n  }\n\n  return lastTarget;\n}\n\nfunction addParams(params) {\n  if (_typeof(params) === 'object' && !Array.isArray(params)) {\n    exports.target = target = _objectSpread(_objectSpread({}, target), params);\n  } else {\n    throw new Error('params must be an object');\n  }\n}\n\nfunction withParamsDirect(params, validator) {\n  return withParamsClosure(function (add) {\n    return function () {\n      add(params);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return validator.apply(this, args);\n    };\n  });\n}\n\nfunction withParamsClosure(closure) {\n  var validator = closure(addParams);\n  return function () {\n    pushParams();\n\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return validator.apply(this, args);\n    } finally {\n      popParams();\n    }\n  };\n}\n\nfunction withParams(paramsOrClosure, maybeValidator) {\n  if (_typeof(paramsOrClosure) === 'object' && maybeValidator !== undefined) {\n    return withParamsDirect(paramsOrClosure, maybeValidator);\n  }\n\n  return withParamsClosure(paramsOrClosure);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Qsa0JBQWtCOztBQUVsQiwyQ0FBMkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTNVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsdURBQXVELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxpREFBaUQsbUZBQW1GLE9BQU87O0FBRXRnQiw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE0sd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0EsRUFBRSxjQUFjO0FBQ2hCOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxjQUFjO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGNBQWMsMENBQTBDO0FBQzVELElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlLWN1c3RvbWVsZW1lbnQtYnVuZGxlci8uL25vZGVfbW9kdWxlcy92dWVsaWRhdGUvbGliL3BhcmFtcy5qcz8wMjM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fc2V0VGFyZ2V0ID0gdm9pZCAwO1xuZXhwb3J0cy5wb3BQYXJhbXMgPSBwb3BQYXJhbXM7XG5leHBvcnRzLnB1c2hQYXJhbXMgPSBwdXNoUGFyYW1zO1xuZXhwb3J0cy50YXJnZXQgPSB2b2lkIDA7XG5leHBvcnRzLndpdGhQYXJhbXMgPSB3aXRoUGFyYW1zO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIHN0YWNrID0gW107XG52YXIgdGFyZ2V0ID0gbnVsbDtcbmV4cG9ydHMudGFyZ2V0ID0gdGFyZ2V0O1xuXG52YXIgX3NldFRhcmdldCA9IGZ1bmN0aW9uIF9zZXRUYXJnZXQoeCkge1xuICBleHBvcnRzLnRhcmdldCA9IHRhcmdldCA9IHg7XG59O1xuXG5leHBvcnRzLl9zZXRUYXJnZXQgPSBfc2V0VGFyZ2V0O1xuXG5mdW5jdGlvbiBwdXNoUGFyYW1zKCkge1xuICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgc3RhY2sucHVzaCh0YXJnZXQpO1xuICB9XG5cbiAgZXhwb3J0cy50YXJnZXQgPSB0YXJnZXQgPSB7fTtcbn1cblxuZnVuY3Rpb24gcG9wUGFyYW1zKCkge1xuICB2YXIgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgdmFyIG5ld1RhcmdldCA9IGV4cG9ydHMudGFyZ2V0ID0gdGFyZ2V0ID0gc3RhY2sucG9wKCkgfHwgbnVsbDtcblxuICBpZiAobmV3VGFyZ2V0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld1RhcmdldC4kc3ViKSkge1xuICAgICAgbmV3VGFyZ2V0LiRzdWIgPSBbXTtcbiAgICB9XG5cbiAgICBuZXdUYXJnZXQuJHN1Yi5wdXNoKGxhc3RUYXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RUYXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGFkZFBhcmFtcyhwYXJhbXMpIHtcbiAgaWYgKF90eXBlb2YocGFyYW1zKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIGV4cG9ydHMudGFyZ2V0ID0gdGFyZ2V0ID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0YXJnZXQpLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2l0aFBhcmFtc0RpcmVjdChwYXJhbXMsIHZhbGlkYXRvcikge1xuICByZXR1cm4gd2l0aFBhcmFtc0Nsb3N1cmUoZnVuY3Rpb24gKGFkZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBhZGQocGFyYW1zKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWxpZGF0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhQYXJhbXNDbG9zdXJlKGNsb3N1cmUpIHtcbiAgdmFyIHZhbGlkYXRvciA9IGNsb3N1cmUoYWRkUGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBwdXNoUGFyYW1zKCk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkYXRvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcG9wUGFyYW1zKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB3aXRoUGFyYW1zKHBhcmFtc09yQ2xvc3VyZSwgbWF5YmVWYWxpZGF0b3IpIHtcbiAgaWYgKF90eXBlb2YocGFyYW1zT3JDbG9zdXJlKSA9PT0gJ29iamVjdCcgJiYgbWF5YmVWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB3aXRoUGFyYW1zRGlyZWN0KHBhcmFtc09yQ2xvc3VyZSwgbWF5YmVWYWxpZGF0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHdpdGhQYXJhbXNDbG9zdXJlKHBhcmFtc09yQ2xvc3VyZSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8413\n");

/***/ }),

/***/ 2584:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.h = h;\nexports.patchChildren = patchChildren;\n\nfunction isUndef(v) {\n  return v === null || v === undefined;\n}\n\nfunction isDef(v) {\n  return v !== null && v !== undefined;\n}\n\nfunction sameVval(oldVval, vval) {\n  return vval.tag === oldVval.tag && vval.key === oldVval.key;\n}\n\nfunction createVm(vval) {\n  var Vm = vval.tag;\n  vval.vm = new Vm({\n    data: vval.args\n  });\n}\n\nfunction updateVval(vval) {\n  var keys = Object.keys(vval.args);\n\n  for (var i = 0; i < keys.length; i++) {\n    keys.forEach(function (k) {\n      vval.vm[k] = vval.args[k];\n    });\n  }\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n\n  return map;\n}\n\nfunction updateChildren(oldCh, newCh) {\n  var oldStartIdx = 0;\n  var newStartIdx = 0;\n  var oldEndIdx = oldCh.length - 1;\n  var oldStartVval = oldCh[0];\n  var oldEndVval = oldCh[oldEndIdx];\n  var newEndIdx = newCh.length - 1;\n  var newStartVval = newCh[0];\n  var newEndVval = newCh[newEndIdx];\n  var oldKeyToIdx, idxInOld, elmToMove;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    if (isUndef(oldStartVval)) {\n      oldStartVval = oldCh[++oldStartIdx];\n    } else if (isUndef(oldEndVval)) {\n      oldEndVval = oldCh[--oldEndIdx];\n    } else if (sameVval(oldStartVval, newStartVval)) {\n      patchVval(oldStartVval, newStartVval);\n      oldStartVval = oldCh[++oldStartIdx];\n      newStartVval = newCh[++newStartIdx];\n    } else if (sameVval(oldEndVval, newEndVval)) {\n      patchVval(oldEndVval, newEndVval);\n      oldEndVval = oldCh[--oldEndIdx];\n      newEndVval = newCh[--newEndIdx];\n    } else if (sameVval(oldStartVval, newEndVval)) {\n      patchVval(oldStartVval, newEndVval);\n      oldStartVval = oldCh[++oldStartIdx];\n      newEndVval = newCh[--newEndIdx];\n    } else if (sameVval(oldEndVval, newStartVval)) {\n      patchVval(oldEndVval, newStartVval);\n      oldEndVval = oldCh[--oldEndIdx];\n      newStartVval = newCh[++newStartIdx];\n    } else {\n      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n      idxInOld = isDef(newStartVval.key) ? oldKeyToIdx[newStartVval.key] : null;\n\n      if (isUndef(idxInOld)) {\n        createVm(newStartVval);\n        newStartVval = newCh[++newStartIdx];\n      } else {\n        elmToMove = oldCh[idxInOld];\n\n        if (sameVval(elmToMove, newStartVval)) {\n          patchVval(elmToMove, newStartVval);\n          oldCh[idxInOld] = undefined;\n          newStartVval = newCh[++newStartIdx];\n        } else {\n          createVm(newStartVval);\n          newStartVval = newCh[++newStartIdx];\n        }\n      }\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    addVvals(newCh, newStartIdx, newEndIdx);\n  } else if (newStartIdx > newEndIdx) {\n    removeVvals(oldCh, oldStartIdx, oldEndIdx);\n  }\n}\n\nfunction addVvals(vvals, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    createVm(vvals[startIdx]);\n  }\n}\n\nfunction removeVvals(vvals, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    var ch = vvals[startIdx];\n\n    if (isDef(ch)) {\n      ch.vm.$destroy();\n      ch.vm = null;\n    }\n  }\n}\n\nfunction patchVval(oldVval, vval) {\n  if (oldVval === vval) {\n    return;\n  }\n\n  vval.vm = oldVval.vm;\n  updateVval(vval);\n}\n\nfunction patchChildren(oldCh, ch) {\n  if (isDef(oldCh) && isDef(ch)) {\n    if (oldCh !== ch) updateChildren(oldCh, ch);\n  } else if (isDef(ch)) {\n    addVvals(ch, 0, ch.length - 1);\n  } else if (isDef(oldCh)) {\n    removeVvals(oldCh, 0, oldCh.length - 1);\n  }\n}\n\nfunction h(tag, key, args) {\n  return {\n    tag: tag,\n    key: key,\n    args: args\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU4NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixTQUFTO0FBQ1QscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZS1jdXN0b21lbGVtZW50LWJ1bmRsZXIvLi9ub2RlX21vZHVsZXMvdnVlbGlkYXRlL2xpYi92dmFsLmpzP2ZiZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmggPSBoO1xuZXhwb3J0cy5wYXRjaENoaWxkcmVuID0gcGF0Y2hDaGlsZHJlbjtcblxuZnVuY3Rpb24gaXNVbmRlZih2KSB7XG4gIHJldHVybiB2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNEZWYodikge1xuICByZXR1cm4gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNhbWVWdmFsKG9sZFZ2YWwsIHZ2YWwpIHtcbiAgcmV0dXJuIHZ2YWwudGFnID09PSBvbGRWdmFsLnRhZyAmJiB2dmFsLmtleSA9PT0gb2xkVnZhbC5rZXk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZtKHZ2YWwpIHtcbiAgdmFyIFZtID0gdnZhbC50YWc7XG4gIHZ2YWwudm0gPSBuZXcgVm0oe1xuICAgIGRhdGE6IHZ2YWwuYXJnc1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVnZhbCh2dmFsKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModnZhbC5hcmdzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHZ2YWwudm1ba10gPSB2dmFsLmFyZ3Nba107XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuXG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihvbGRDaCwgbmV3Q2gpIHtcbiAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gIHZhciBvbGRTdGFydFZ2YWwgPSBvbGRDaFswXTtcbiAgdmFyIG9sZEVuZFZ2YWwgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgdmFyIG5ld1N0YXJ0VnZhbCA9IG5ld0NoWzBdO1xuICB2YXIgbmV3RW5kVnZhbCA9IG5ld0NoW25ld0VuZElkeF07XG4gIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZTtcblxuICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0VnZhbCkpIHtcbiAgICAgIG9sZFN0YXJ0VnZhbCA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWdmFsKSkge1xuICAgICAgb2xkRW5kVnZhbCA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICB9IGVsc2UgaWYgKHNhbWVWdmFsKG9sZFN0YXJ0VnZhbCwgbmV3U3RhcnRWdmFsKSkge1xuICAgICAgcGF0Y2hWdmFsKG9sZFN0YXJ0VnZhbCwgbmV3U3RhcnRWdmFsKTtcbiAgICAgIG9sZFN0YXJ0VnZhbCA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgbmV3U3RhcnRWdmFsID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgfSBlbHNlIGlmIChzYW1lVnZhbChvbGRFbmRWdmFsLCBuZXdFbmRWdmFsKSkge1xuICAgICAgcGF0Y2hWdmFsKG9sZEVuZFZ2YWwsIG5ld0VuZFZ2YWwpO1xuICAgICAgb2xkRW5kVnZhbCA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIG5ld0VuZFZ2YWwgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgfSBlbHNlIGlmIChzYW1lVnZhbChvbGRTdGFydFZ2YWwsIG5ld0VuZFZ2YWwpKSB7XG4gICAgICBwYXRjaFZ2YWwob2xkU3RhcnRWdmFsLCBuZXdFbmRWdmFsKTtcbiAgICAgIG9sZFN0YXJ0VnZhbCA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgbmV3RW5kVnZhbCA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICB9IGVsc2UgaWYgKHNhbWVWdmFsKG9sZEVuZFZ2YWwsIG5ld1N0YXJ0VnZhbCkpIHtcbiAgICAgIHBhdGNoVnZhbChvbGRFbmRWdmFsLCBuZXdTdGFydFZ2YWwpO1xuICAgICAgb2xkRW5kVnZhbCA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIG5ld1N0YXJ0VnZhbCA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZ2YWwua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0VnZhbC5rZXldIDogbnVsbDtcblxuICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7XG4gICAgICAgIGNyZWF0ZVZtKG5ld1N0YXJ0VnZhbCk7XG4gICAgICAgIG5ld1N0YXJ0VnZhbCA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuXG4gICAgICAgIGlmIChzYW1lVnZhbChlbG1Ub01vdmUsIG5ld1N0YXJ0VnZhbCkpIHtcbiAgICAgICAgICBwYXRjaFZ2YWwoZWxtVG9Nb3ZlLCBuZXdTdGFydFZ2YWwpO1xuICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXdTdGFydFZ2YWwgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjcmVhdGVWbShuZXdTdGFydFZ2YWwpO1xuICAgICAgICAgIG5ld1N0YXJ0VnZhbCA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgYWRkVnZhbHMobmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgpO1xuICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgcmVtb3ZlVnZhbHMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFZ2YWxzKHZ2YWxzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICBjcmVhdGVWbSh2dmFsc1tzdGFydElkeF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVZ2YWxzKHZ2YWxzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICB2YXIgY2ggPSB2dmFsc1tzdGFydElkeF07XG5cbiAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICBjaC52bS4kZGVzdHJveSgpO1xuICAgICAgY2gudm0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaFZ2YWwob2xkVnZhbCwgdnZhbCkge1xuICBpZiAob2xkVnZhbCA9PT0gdnZhbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZ2YWwudm0gPSBvbGRWdmFsLnZtO1xuICB1cGRhdGVWdmFsKHZ2YWwpO1xufVxuXG5mdW5jdGlvbiBwYXRjaENoaWxkcmVuKG9sZENoLCBjaCkge1xuICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKG9sZENoLCBjaCk7XG4gIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgYWRkVnZhbHMoY2gsIDAsIGNoLmxlbmd0aCAtIDEpO1xuICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgIHJlbW92ZVZ2YWxzKG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoKHRhZywga2V5LCBhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAga2V5OiBrZXksXG4gICAgYXJnczogYXJnc1xuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2584\n");

/***/ }),

/***/ 8593:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ }),

/***/ 6:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"new":{"button":"Ehdota uutta käsitettä tähän sanastoon","header":"Ehdota uutta käsitettä YSOon","header-geo":"Ehdota uutta käsitettä YSO-paikkoihin","p1":"","p2":"Sanastossa jo oleviin käsitteisiin voit ehdottaa muutoksia käsitesivulta","conceptType":{"label":"Tyyppi: *","for":"ehdotuksen tyyppi","placeholder":"Valitse ehdotuksen tyyppi","none":"Ehdotustyyppejä ei valittavissa","error":"Valitse ehdotukselle tyyppi."},"prefLabel":{"error":"Päätermiksi tarvitaan uniikki termi.","fi":{"label":"Päätermi/asiasana: *","for":"ehdotettava termi suomeksi"},"sv":{"label":"Termi ruotsiksi:","for":"ehdotettava termi ruotsiksi"},"en":{"label":"Termi englanniksi:","for":"ehdotettava termi englanniksi"}},"altLabels":{"label":"Vaihtoehtoiset termit ja ilmaisut:","for":"muut vastaavat käsitteet ehdotetulle termille"},"broaderLabels":{"label":"Yläkäsite YSOssa (LT):","for":"yläkäsitteet ehdotetulle termille"},"narrowerLabels":{"label":"Alakäsitteet (ST):","for":"alakäsitteet ehdotetulle termille"},"relatedLabels":{"label":"Assosiatiiviset (RT):","for":"liittyvät käsitteet ehdotetulle termille"},"groups":{"label":"YSA/YSO temaattinen ryhmä:","for":"ehdotettuun termiin liittyvät ryhmät","none":"Ei enempää ryhmiä valittavissa.","placeholder":"Valitse ryhmä(t) listalta"},"exactMatches":{"label":"Vastaava käsite muussa sanastossa:","for":"vastaavat käsitteet muissa sanastoissa","vocab":"Sanasto (LCSH, Wikipedia tai vastaava)","uri":"URI tai termi"},"scopeNote":{"label":"Tarkoitusta täsmentävä selite:","for":"tarkoitusta täsmentävä selite"},"explanation":{"label":"Perustelut ehdotukselle: *","for":"perustelut ehdotetulle termille","error":"Tämä on pakollinen tieto."},"neededFor":{"label":"Minkä aineiston kuvailussa tarvitsit käsitettä? Julkaisun nimi, ISBN tai URL: *","for":"mihin ehdotettua termiä tarvitaan","error":"Tämä on pakollinen tieto."},"fromOrg":{"label":"Ehdottajan organisaatio:","for":"mitä organisaatiota ehdottaja edustaa"},"common":{"none":"Termejä ei löydy hakusanalla","exists1":"Ehdottamasi termi ","exists2":" löytyy jo YSOsta, YSO-paikoista tai sanastoehdotuksista","places":"yso-paikat","concept":"Yleiskäsite","geo":"Maantieteellinen paikka","ifyso":"Termi löytyy jo YSOsta:","ifysopaikat":"Termi löytyy jo YSO-paikoista:","ifyse1":"Termistä on jo olemassa käsite-ehdotus:","ifyse2":". Kommentoi tai kannata ehdotusta sen tiedoista löytyvän kotisivulinkin kautta"},"submit":"Lähetä käsite-ehdotus"},"edit":{"button":"Ehdota muutosta käsitteeseen","header":"Ehdota muutosta käsitteeseen","paragraph":"Kuka tahansa YSOn käyttäjä saa ehdottaa muutoksia sanastoon.","description":{"label":"Ehdotettu muutos: *","for":"perustelut ehdotetulle muutokselle","error":"Tämä on pakollinen tieto."},"reason":{"label":"Perustelut ehdotukselle: *","for":"miksi muutosta tarvitaan","error":"Tämä on pakollinen tieto."},"fromOrg":{"label":"Ehdottajan organisaatio:","for":"mitä organisaatiota ehdottaja edustaa"},"submit":"Lähetä muutosehdotus"},"messages":{"success":{"h2":"Ehdotus lähetetty onnistuneesti","p_1":"Ehdotuksesi siirtyy nyt YSO-kokouksen käsiteltäväksi.","p_2a":"Voit seurata ehdotuksesi käsittelyn etenemistä","p_2b":"täällä"},"failed":{"h2":"Ehdotuksen lähettäminen ei onnistunut","p_1a":"Ehdotustasi ei valitettavasti pystytty vastaanottamaan.","p_1b":"Voit kokeilla ehdotuksen täyttämistä uudestaan tai ottaa yhteyttä Finton ylläpitäjiin Tietoja-välilehden kautta."}}}');

/***/ }),

/***/ 4360:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"new":{"button":"Ehdota uutta käsitettä tähän sanastoon","header":"Ehdota uutta käsitettä YSOon","header-geo":"Ehdota uutta käsitettä YSO-paikkoihin","p1":"","p2":"Sanastossa jo oleviin käsitteisiin voit ehdottaa muutoksia käsitesivulta","conceptType":{"label":"Tyyppi: *","for":"ehdotuksen tyyppi","placeholder":"Valitse ehdotuksen tyyppi","none":"Ehdotustyyppejä ei valittavissa","error":"Valitse ehdotukselle tyyppi."},"prefLabel":{"error":"Päätermiksi tarvitaan uniikki termi.","fi":{"label":"Päätermi/asiasana: *","for":"ehdotettava termi suomeksi"},"sv":{"label":"Termi ruotsiksi:","for":"ehdotettava termi ruotsiksi"},"en":{"label":"Termi englanniksi:","for":"ehdotettava termi englanniksi"}},"altLabels":{"label":"Vaihtoehtoiset termit ja ilmaisut:","for":"muut vastaavat käsitteet ehdotetulle termille"},"broaderLabels":{"label":"Yläkäsite YSOssa (LT):","for":"yläkäsitteet ehdotetulle termille"},"narrowerLabels":{"label":"Alakäsitteet (ST):","for":"alakäsitteet ehdotetulle termille"},"relatedLabels":{"label":"Assosiatiiviset (RT):","for":"liittyvät käsitteet ehdotetulle termille"},"groups":{"label":"YSA/YSO temaattinen ryhmä:","for":"ehdotettuun termiin liittyvät ryhmät","none":"Ei enempää ryhmiä valittavissa.","placeholder":"Valitse ryhmä(t) listalta"},"exactMatches":{"label":"Vastaava käsite muussa sanastossa:","for":"vastaavat käsitteet muissa sanastoissa","vocab":"Sanasto (LCSH, Wikipedia tai vastaava)","uri":"URI tai termi"},"scopeNote":{"label":"Tarkoitusta täsmentävä selite:","for":"tarkoitusta täsmentävä selite"},"explanation":{"label":"Perustelut ehdotukselle: *","for":"perustelut ehdotetulle termille","error":"Tämä on pakollinen tieto."},"neededFor":{"label":"Minkä aineiston kuvailussa tarvitsit käsitettä? Julkaisun nimi, ISBN tai URL: *","for":"mihin ehdotettua termiä tarvitaan","error":"Tämä on pakollinen tieto."},"fromOrg":{"label":"Ehdottajan organisaatio:","for":"mitä organisaatiota ehdottaja edustaa"},"common":{"none":"Termejä ei löydy hakusanalla","exists1":"Ehdottamasi termi ","exists2":" löytyy jo YSOsta, YSO-paikoista tai sanastoehdotuksista","places":"yso-paikat","concept":"Yleiskäsite","geo":"Maantieteellinen paikka","ifyso":"Termi löytyy jo YSOsta:","ifysopaikat":"Termi löytyy jo YSO-paikoista:","ifyse1":"Termistä on jo olemassa käsite-ehdotus:","ifyse2":". Kommentoi tai kannata ehdotusta sen tiedoista löytyvän kotisivulinkin kautta"},"submit":"Lähetä käsite-ehdotus"},"edit":{"button":"Ehdota muutosta käsitteeseen","header":"Ehdota muutosta käsitteeseen","paragraph":"Kuka tahansa YSOn käyttäjä saa ehdottaa muutoksia sanastoon.","description":{"label":"Ehdotettu muutos: *","for":"perustelut ehdotetulle muutokselle","error":"Tämä on pakollinen tieto."},"reason":{"label":"Perustelut ehdotukselle: *","for":"miksi muutosta tarvitaan","error":"Tämä on pakollinen tieto."},"fromOrg":{"label":"Ehdottajan organisaatio:","for":"mitä organisaatiota ehdottaja edustaa"},"submit":"Lähetä muutosehdotus"},"messages":{"success":{"h2":"Ehdotus lähetetty onnistuneesti","p_1":"Ehdotuksesi siirtyy nyt YSO-kokouksen käsiteltäväksi.","p_2a":"Voit seurata ehdotuksesi käsittelyn etenemistä","p_2b":"täällä"},"failed":{"h2":"Ehdotuksen lähettäminen ei onnistunut","p_1a":"Ehdotustasi ei valitettavasti pystytty vastaanottamaan.","p_1b":"Voit kokeilla ehdotuksen täyttämistä uudestaan tai ottaa yhteyttä Finton ylläpitäjiin Tietoja-välilehden kautta."}}}');

/***/ }),

/***/ 2220:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"new":{"button":"Föreslå ett nytt begrepp till denna vokabulär","header":"Föreslå ett nytt begrepp till ALLFO","header-geo":"Föreslå ett nytt begrepp till ALLFO-orter","p1":"","p2":"Du kan föreslå ändringar av begrepp som redan finns i vokabulären via begreppens egna sidor.","conceptType":{"label":"Typ: *","for":"typ av begrepp","placeholder":"Välj typ av begrepp","none":"Begreppstyper kan inte väljas","error":"Välj typ av begrepp."},"prefLabel":{"error":"Huvudtermen måste vara en unik term.","fi":{"label":"Term på finska","for":"den föreslagna termen på finska"},"sv":{"label":"Term/ämnesord på svenska: *","for":"den föreslagna termen på svenska"},"en":{"label":"Term på engelska:","for":"den föreslagna termen på engelska"}},"altLabels":{"label":"Alternativa termer och uttryck:","for":"andra motsvarande termer"},"broaderLabels":{"label":"Överordnade begrepp i ALLFO:","for":"överordnade begrepp till den föreslagna termen"},"narrowerLabels":{"label":"Underordnade begrepp:","for":"underordnade begrepp till den föreslagna termen"},"relatedLabels":{"label":"Relaterade begrepp:","for":"relaterade begrepp till den föreslagna termen"},"groups":{"label":"Tematisk grupp i ALLFO:","for":"tematiska grupper för den föreslagna termen","none":"Inga fler grupper kan väljas","placeholder":"Välj grupp(er) ur listan"},"exactMatches":{"label":"Motsvarande begrepp i annan vokabulär:","for":"motsvarande begrepp i andra vokabulärer","vocab":"Vokabulär (LCSH, Wikipedia, etc.)","uri":"URI eller term"},"scopeNote":{"label":"Förklaring som preciserar betydelsen:","for":"förklaring som preciserar betydelsen"},"explanation":{"label":"Motiveringar till förslaget: *","for":"motiveringar till den föreslagna termen","error":"Detta är obligatorisk information."},"neededFor":{"label":"För vilket materials beskrivning behöver du begreppet (t.ex. titel eller URL): *","for":"för vilket material behövs termen","error":"Detta är obligatorisk information."},"fromOrg":{"label":"Förslagsställarens organisation:","for":"vilken organisation reDu kan försöka fylla i formuläret igen eller så kan du kontakta Finto-administratörer via informationen på sidan \\"Om\\".presenterar förslagsställaren"},"common":{"none":"Termer hittades inte med sökordet","exists1":"Termen ","exists2":" finns redan i ALLFO, ALLFO orter eller YSE","places":"allfo-orter","concept":"Allmänt begrepp","geo":"Geografisk plats","ifyso":"Termen finns redan i ALLFO:","ifysopaikat":"Termen finns redan i ALLFO-orter :","ifyse1":"Termen har redan föreslagits:","ifyse2":". Kommentera eller understöd förslaget via länken till förslagets hemsida."},"submit":"Skicka förslaget"},"edit":{"button":"Föreslå en ändring av begreppet","header":"Föreslå en ändring av begreppet","paragraph":"Vem som helst som använder ALLFO kan föreslå ändringar till vokabulären.","description":{"label":"Förslag till ändring: *","for":"förslag till ändring","error":"Detta är obligatorisk information."},"reason":{"label":"Motiveringar till förslaget: *","for":"varför behövs ändringen","error":"Detta är obligatorisk information."},"fromOrg":{"label":"Förslagsställarens organisation:","for":"vilken organisation representerar förslagsställaren"},"submit":"Skicka förslaget"},"messages":{"success":{"h2":"Förslaget skickades","p_1":"Ditt förslag vidarebefordras till YSO-mötet.","p_2a":"Du kan följa hur behandlingen av ditt förslag framskrider","p_2b":"här"},"failed":{"h2":"Förslaget kunde inte skickas","p_1a":"Ditt förslag kunde tyvärr inte tas emot.","p_1b":"Du kan försöka fylla i formuläret igen eller så kan du kontakta Finto-servicens administratörer via responssidan."}}}');

/***/ }),

/***/ 3421:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('[{"url":"https://finto.fi/plugins/suggestions/gh_prx.php"}]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__(5800);
/******/ 	
/******/ })()
;